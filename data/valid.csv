id,function,location,description
198034,"   t42_parse_sfnts( T42_Face    face,
                    T42_Loader  loader )
   {
     T42_Parser  parser = &loader->parser;
     FT_Memory   memory = parser->root.memory;
     FT_Byte*    cur;
      FT_Byte*    limit  = parser->root.limit;
      FT_Error    error;
      FT_Int      num_tables = 0;
    FT_ULong    count, ttf_size = 0;
     FT_ULong    count;
  
      FT_Long     n, string_size, old_string_size, real_size;
      FT_Byte*    string_buf = NULL;
     FT_Bool     allocated  = 0;
 
     T42_Load_Status  status;
 
 
      
      
      
      
      
      
      
      
      
      
      
      
      
 
     T1_Skip_Spaces( parser );
 
     if ( parser->root.cursor >= limit || *parser->root.cursor++ != '[' )
     {
       FT_ERROR(( ""t42_parse_sfnts: can't find begin of sfnts vector\n"" ));
       error = FT_THROW( Invalid_File_Format );
       goto Fail;
     }
 
     T1_Skip_Spaces( parser );
     status          = BEFORE_START;
     string_size     = 0;
     old_string_size = 0;
     count           = 0;
 
     while ( parser->root.cursor < limit )
     {
       cur = parser->root.cursor;
 
       if ( *cur == ']' )
       {
         parser->root.cursor++;
         goto Exit;
       }
 
       else if ( *cur == '<' )
       {
         T1_Skip_PS_Token( parser );
         if ( parser->root.error )
           goto Exit;
 
          
         string_size = (FT_Long)( ( parser->root.cursor - cur - 2 + 1 ) / 2 );
         if ( FT_REALLOC( string_buf, old_string_size, string_size ) )
           goto Fail;
 
         allocated = 1;
 
         parser->root.cursor = cur;
         (void)T1_ToBytes( parser, string_buf, string_size, &real_size, 1 );
         old_string_size = string_size;
         string_size = real_size;
       }
 
       else if ( ft_isdigit( *cur ) )
       {
         if ( allocated )
         {
           FT_ERROR(( ""t42_parse_sfnts: ""
                      ""can't handle mixed binary and hex strings\n"" ));
           error = FT_THROW( Invalid_File_Format );
           goto Fail;
         }
 
         string_size = T1_ToInt( parser );
         if ( string_size < 0 )
         {
           FT_ERROR(( ""t42_parse_sfnts: invalid string size\n"" ));
           error = FT_THROW( Invalid_File_Format );
           goto Fail;
         }
 
         T1_Skip_PS_Token( parser );              
         if ( parser->root.error )
           return;
 
         string_buf = parser->root.cursor + 1;    
  
          if ( limit - parser->root.cursor < string_size )
          {
          FT_ERROR(( ""t42_parse_sfnts: too many binary data\n"" ));
           FT_ERROR(( ""t42_parse_sfnts: too much binary data\n"" ));
            error = FT_THROW( Invalid_File_Format );
            goto Fail;
          }
         else
           parser->root.cursor += string_size + 1;
       }
 
       if ( !string_buf )
       {
         FT_ERROR(( ""t42_parse_sfnts: invalid data in sfnts array\n"" ));
         error = FT_THROW( Invalid_File_Format );
         goto Fail;
       }
 
        
        
       if ( ( string_size & 1 ) && string_buf[string_size - 1] == 0 )
         string_size--;
 
       if ( !string_size )
       {
         FT_ERROR(( ""t42_parse_sfnts: invalid string\n"" ));
         error = FT_THROW( Invalid_File_Format );
         goto Fail;
       }
 
       for ( n = 0; n < string_size; n++ )
       {
         switch ( status )
         {
         case BEFORE_START:
            
           if ( count < 12 )
           {
             face->ttf_data[count++] = string_buf[n];
             continue;
            }
            else
            {
            num_tables = 16 * face->ttf_data[4] + face->ttf_data[5];
            status     = BEFORE_TABLE_DIR;
            ttf_size   = 12 + 16 * num_tables;
             num_tables     = 16 * face->ttf_data[4] + face->ttf_data[5];
             status         = BEFORE_TABLE_DIR;
             face->ttf_size = 12 + 16 * num_tables;
  
            if ( FT_REALLOC( face->ttf_data, 12, ttf_size ) )
             if ( FT_REALLOC( face->ttf_data, 12, face->ttf_size ) )
                goto Fail;
            }
             
  
          case BEFORE_TABLE_DIR:
             
          if ( count < ttf_size )
           if ( count < face->ttf_size )
            {
              face->ttf_data[count++] = string_buf[n];
              continue;
           }
           else
           {
             int       i;
             FT_ULong  len;
 
 
             for ( i = 0; i < num_tables; i++ )
             {
               FT_Byte*  p = face->ttf_data + 12 + 16 * i + 12;
 
 
                len = FT_PEEK_ULONG( p );
  
                 
              ttf_size += ( len + 3 ) & ~3;
               face->ttf_size += ( len + 3 ) & ~3;
              }
  
            status         = OTHER_TABLES;
            face->ttf_size = ttf_size;
             status = OTHER_TABLES;
  
               
              if ( FT_REALLOC( face->ttf_data, 12 + 16 * num_tables,
                             ttf_size + 1 ) )
                              face->ttf_size + 1 ) )
                goto Fail;
            }
             
  
          case OTHER_TABLES:
             
          if ( count >= ttf_size )
           if ( count >= face->ttf_size )
            {
            FT_ERROR(( ""t42_parse_sfnts: too many binary data\n"" ));
             FT_ERROR(( ""t42_parse_sfnts: too much binary data\n"" ));
              error = FT_THROW( Invalid_File_Format );
              goto Fail;
            }
           }
           face->ttf_data[count++] = string_buf[n];
         }
       }
 
       T1_Skip_Spaces( parser );
     }","[11, 105, 148, 149, 150, 153, 161, 181, 186, 191, 199, 202, 10, 104, 145, 146, 147, 152, 160, 180, 184, 185, 190, 198, 201]","type42/t42parse.c in FreeType before 2.5.4 does not consider that scanning can be incomplete without triggering an error, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted Type42 font."
208056," void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,
  impeg2d_video_decode_op_t *ps_op)
 {
 
     UWORD32 u4_bits_read;
  dec_state_t *ps_dec;
 
     ps_dec = (dec_state_t *)pv_dec;
     ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;
 
     impeg2d_bit_stream_init(&(ps_dec->s_bit_stream),ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer,
         ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes);
 
  {
  {
             IMPEG2D_ERROR_CODES_T e_error;
             e_error = impeg2d_process_video_header(ps_dec);
  if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
  {
                 ps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;
 
                 u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);
 
                 ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;
  if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)
  {
                     ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;
  }
 
                  if(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)
                      ps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;
  
                 if (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)
                 {
                     ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;
                     ps_dec->u2_header_done = 0;
  
                     ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;
                     ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;
                 }
                  impeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);
                  return;
              }
  }
         ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;
         ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;
 
         ps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;
         ps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;
 
         u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);
         ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;
  if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)
  {
             ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;
  }
         ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;
   
         ps_dec->u2_header_done = 1;
 
  }
 }","[33, 34, 35, 36, 38, 39, 40]","A remote code execution vulnerability in libmpeg2 in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35219737."
8165,"TPM2B_PROOF_Marshal(TPM2B_PROOF *source, BYTE **buffer, INT32 *size)
{
UINT16 written = 0;
written += TPM2B_Marshal(&source->b, buffer, size);
return written;
}",[4],A flaw was found in libtpms. The flaw can be triggered by specially-crafted TPM 2 command packets containing illegal values and may lead to an out-of-bounds access when the volatile state of the TPM 2 is marshalled/written or unmarshalled/read. The highest threat from this vulnerability is to system availability.
201169," static void send(node_t *node, node_t *child, byte *fout) {
 static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {
  	if (node->parent) {
		send(node->parent, node, fout);
 		send(node->parent, node, fout, maxoffset);
  	}
  	if (child) {
 		if (bloc >= maxoffset) {
 			bloc = maxoffset + 1;
 			return;
 		}
  		if (node->right == child) {
  			add_bit(1, fout);
  		} else {
 			add_bit(0, fout);
 		}
 	}
  }","[2, 5, 8, 9, 10, 11, 4]",Buffer overflow in ioquake3 before 2017-08-02 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted packet.
202087," long video_ioctl2(struct file *file,
	       unsigned int cmd, unsigned long arg)
 long
 video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
 	       v4l2_kioctl func)
  {
  	char	sbuf[128];
  	void    *mbuf = NULL;
 	void	*parg = (void *)arg;
 	long	err  = -EINVAL;
 	bool	has_array_args;
 	size_t  array_size = 0;
 	void __user *user_ptr = NULL;
 	void	**kernel_ptr = NULL;
 
 	 
 	if (_IOC_DIR(cmd) != _IOC_NONE) {
 		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
 			parg = sbuf;
 		} else {
 			 
 			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
 			if (NULL == mbuf)
 				return -ENOMEM;
 			parg = mbuf;
 		}
 
 		err = -EFAULT;
 		if (_IOC_DIR(cmd) & _IOC_WRITE) {
 			unsigned long n = cmd_input_size(cmd);
 
 			if (copy_from_user(parg, (void __user *)arg, n))
 				goto out;
 
 			 
 			if (n < _IOC_SIZE(cmd))
 				memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);
 		} else {
 			 
 			memset(parg, 0, _IOC_SIZE(cmd));
 		}
 	}
 
 	err = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);
 	if (err < 0)
 		goto out;
 	has_array_args = err;
 
 	if (has_array_args) {
 		 
 		mbuf = kmalloc(array_size, GFP_KERNEL);
 		err = -ENOMEM;
 		if (NULL == mbuf)
 			goto out_array_args;
 		err = -EFAULT;
 		if (copy_from_user(mbuf, user_ptr, array_size))
 			goto out_array_args;
 		*kernel_ptr = mbuf;
  	}
  
  	 
	err = __video_do_ioctl(file, cmd, parg);
 	err = func(file, cmd, parg);
  	if (err == -ENOIOCTLCMD)
  		err = -EINVAL;
  
 	if (has_array_args) {
 		*kernel_ptr = user_ptr;
 		if (copy_to_user(user_ptr, mbuf, array_size))
 			err = -EFAULT;
 		goto out_array_args;
 	}
 	if (err < 0)
 		goto out;
 
 out_array_args:
 	 
 	switch (_IOC_DIR(cmd)) {
 	case _IOC_READ:
 	case (_IOC_WRITE | _IOC_READ):
 		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
 			err = -EFAULT;
 		break;
 	}
 
 out:
  	kfree(mbuf);
  	return err;
  }","[3, 4, 5, 63, 2, 62]","The video_usercopy function in drivers/media/video/v4l2-ioctl.c in the Linux kernel before 2.6.39 relies on the count value of a v4l2_ext_controls data structure to determine a kmalloc size, which might allow local users to cause a denial of service (memory consumption) via a large value."
199643," static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
 					    struct pluto_crypto_req *r,
 					    err_t ugh)
 {
 	struct dh_continuation *dh = (struct dh_continuation *)pcrc;
 	struct msg_digest *md = dh->md;
 	struct state *const st = md->st;
 	stf_status e;
 
 	DBG(DBG_CONTROLMORE,
 	    DBG_log(""ikev2 parent inI2outR2: calculating g^{xy}, sending R2""));
 
 	if (st == NULL) {
 		loglog(RC_LOG_SERIOUS,
 		       ""%s: Request was disconnected from state"",
 		       __FUNCTION__);
 		if (dh->md)
 			release_md(dh->md);
 		return;
 	}
 
 	 
 	passert(ugh == NULL);
 	passert(cur_state == NULL);
 	passert(st != NULL);
 
 	passert(st->st_suspended_md == dh->md);
 	set_suspended(st, NULL);  
 
 	set_cur_state(st);
 
 	st->st_calculating = FALSE;
 
 	e = ikev2_parent_inI2outR2_tail(pcrc, r);
 	if ( e > STF_FAIL) {
 		 
 		int v2_notify_num = e - STF_FAIL;
 		DBG_log(
 			""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s"",
 			enum_name(&ikev2_notify_names, v2_notify_num));
 	} else if ( e != STF_OK) {
 		DBG_log(""ikev2_parent_inI2outR2_tail returned %s"",
 			enum_name(&stfstatus_name, e));
 	}
 
 	if (dh->md != NULL) {
 		complete_v2_state_transition(&dh->md, e);
 		if (dh->md)
  			release_md(dh->md);
  	}
  	reset_globals();
	passert(GLOBALS_ARE_RESET());
  }",[52],The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.
207980," status_t MPEG4Source::fragmentedRead(
  MediaBuffer **out, const ReadOptions *options) {
 
     ALOGV(""MPEG4Source::fragmentedRead"");
 
     CHECK(mStarted);
 
  *out = NULL;
 
  int64_t targetSampleTimeUs = -1;
 
  int64_t seekTimeUs;
  ReadOptions::SeekMode mode;
  if (options && options->getSeekTo(&seekTimeUs, &mode)) {
 
  int numSidxEntries = mSegments.size();
  if (numSidxEntries != 0) {
  int64_t totalTime = 0;
  off64_t totalOffset = mFirstMoofOffset;
  for (int i = 0; i < numSidxEntries; i++) {
  const SidxEntry *se = &mSegments[i];
  if (totalTime + se->mDurationUs > seekTimeUs) {
  if ((mode == ReadOptions::SEEK_NEXT_SYNC) ||
  (mode == ReadOptions::SEEK_CLOSEST_SYNC &&
  (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {
                         totalTime += se->mDurationUs;
                         totalOffset += se->mSize;
  }
  break;
  }
                 totalTime += se->mDurationUs;
                 totalOffset += se->mSize;
  }
         mCurrentMoofOffset = totalOffset;
         mCurrentSamples.clear();
         mCurrentSampleIndex = 0;
         parseChunk(&totalOffset);
         mCurrentTime = totalTime * mTimescale / 1000000ll;
  }
 
  if (mBuffer != NULL) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  }
 
  off64_t offset = 0;
  size_t size;
  uint32_t cts = 0;
  bool isSyncSample = false;
  bool newBuffer = false;
  if (mBuffer == NULL) {
         newBuffer = true;
 
  if (mCurrentSampleIndex >= mCurrentSamples.size()) {
  Sample lastSample = mCurrentSamples[mCurrentSamples.size() - 1];
  off64_t nextMoof = mNextMoofOffset;  
             mCurrentMoofOffset = nextMoof;
             mCurrentSamples.clear();
             mCurrentSampleIndex = 0;
             parseChunk(&nextMoof);
  if (mCurrentSampleIndex >= mCurrentSamples.size()) {
  return ERROR_END_OF_STREAM;
  }
  }
 
  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];
         offset = smpl->offset;
         size = smpl->size;
         cts = mCurrentTime;
         mCurrentTime += smpl->duration;
         isSyncSample = (mCurrentSampleIndex == 0);  
 
  status_t err = mGroup->acquire_buffer(&mBuffer);
 
  if (err != OK) {
             CHECK(mBuffer == NULL);
             ALOGV(""acquire_buffer returned %d"", err);
  return err;
  }
  if (size > mBuffer->size()) {
             ALOGE(""buffer too small: %zu > %zu"", size, mBuffer->size());
  return ERROR_BUFFER_TOO_SMALL;
  }
  }
 
  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];
  const sp<MetaData> bufmeta = mBuffer->meta_data();
     bufmeta->clear();
  if (smpl->encryptedsizes.size()) {
         bufmeta->setData(kKeyPlainSizes, 0,
                 smpl->clearsizes.array(), smpl->clearsizes.size() * 4);
         bufmeta->setData(kKeyEncryptedSizes, 0,
                 smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);
         bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16);  
         bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);
         bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);
         bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);
  }
 
  if (!mIsAVC || mWantsNALFragments) {
  if (newBuffer) {
  if (!isInRange((size_t)0u, mBuffer->size(), size)) {
                 mBuffer->release();
                 mBuffer = NULL;
 
                 ALOGE(""fragmentedRead ERROR_MALFORMED size %zu"", size);
  return ERROR_MALFORMED;
  }
 
  ssize_t num_bytes_read =
                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);
 
  if (num_bytes_read < (ssize_t)size) {
                 mBuffer->release();
                 mBuffer = NULL;
 
                 ALOGE(""i/o error"");
  return ERROR_IO;
  }
 
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
             mBuffer->meta_data()->setInt64(
                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
                 mBuffer->meta_data()->setInt64(
                         kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
  }
 
  if (!mIsAVC) {
  *out = mBuffer;
             mBuffer = NULL;
 
  return OK;
  }
 
 
         CHECK(mBuffer->range_length() >= mNALLengthSize);
 
  const uint8_t *src =
  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
 
  size_t nal_size = parseNALSize(src);
  if (mNALLengthSize > SIZE_MAX - nal_size) {
             ALOGE(""b/24441553, b/24445122"");
  }
 
  if (mBuffer->range_length() - mNALLengthSize < nal_size) {
             ALOGE(""incomplete NAL unit."");
 
             mBuffer->release();
             mBuffer = NULL;
 
  return ERROR_MALFORMED;
  }
 
  MediaBuffer *clone = mBuffer->clone();
         CHECK(clone != NULL);
         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);
 
         CHECK(mBuffer != NULL);
         mBuffer->set_range(
                 mBuffer->range_offset() + mNALLengthSize + nal_size,
                 mBuffer->range_length() - mNALLengthSize - nal_size);
 
  if (mBuffer->range_length() == 0) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  *out = clone;
 
  return OK;
  } else {
         ALOGV(""whole NAL"");
  ssize_t num_bytes_read = 0;
  int32_t drm = 0;
  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
  void *data = NULL;
  bool isMalFormed = false;
  if (usesDRM) {
  if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) {
                 isMalFormed = true;
  } else {
                 data = mBuffer->data();
  }
  } else {
  int32_t max_size;
  if (mFormat == NULL
  || !mFormat->findInt32(kKeyMaxInputSize, &max_size)
  || !isInRange((size_t)0u, (size_t)max_size, size)) {
                 isMalFormed = true;
  } else {
                 data = mSrcBuffer;
  }
  }
 
  if (isMalFormed || data == NULL) {
             ALOGE(""isMalFormed size %zu"", size);
  if (mBuffer != NULL) {
                 mBuffer->release();
                 mBuffer = NULL;
  }
  return ERROR_MALFORMED;
  }
         num_bytes_read = mDataSource->readAt(offset, data, size);
 
  if (num_bytes_read < (ssize_t)size) {
             mBuffer->release();
             mBuffer = NULL;
 
             ALOGE(""i/o error"");
  return ERROR_IO;
  }
 
  if (usesDRM) {
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
 
  } else {
  uint8_t *dstData = (uint8_t *)mBuffer->data();
  size_t srcOffset = 0;
  size_t dstOffset = 0;
 
  while (srcOffset < size) {
                 isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);
  size_t nalLength = 0;
  if (!isMalFormed) {
                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                     srcOffset += mNALLengthSize;
                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength)
  || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u)
  || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength);
  }
 
  if (isMalFormed) {
                     ALOGE(""Video is malformed; nalLength %zu"", nalLength);
                     mBuffer->release();
                     mBuffer = NULL;
  return ERROR_MALFORMED;
  }
 
  if (nalLength == 0) {
 
                      continue;
                  }
  
                CHECK(dstOffset + 4 <= mBuffer->size());
                 if (dstOffset > SIZE_MAX - 4 ||
                         dstOffset + 4 > SIZE_MAX - nalLength ||
                         dstOffset + 4 + nalLength > mBuffer->size()) {
                     ALOGE(""b/26365349 : %zu %zu"", dstOffset, mBuffer->size());
                     android_errorWriteLog(0x534e4554, ""26365349"");
                     mBuffer->release();
                     mBuffer = NULL;
                     return ERROR_MALFORMED;
                 }
  
                  dstData[dstOffset++] = 0;
                  dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 1;
                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);
                 srcOffset += nalLength;
                 dstOffset += nalLength;
  }
             CHECK_EQ(srcOffset, size);
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, dstOffset);
  }
 
         mBuffer->meta_data()->setInt64(
                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
             mBuffer->meta_data()->setInt64(
                     kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
 
  *out = mBuffer;
         mBuffer = NULL;
 
  return OK;
  }
 }","[259, 260, 261, 262, 263, 264, 265, 266, 267, 258]","The MPEG4Source::fragmentedRead function in MPEG4Extractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26365349."
201446,"  static int install_process_keyring(void)
  {
 	struct cred *new;
 	int ret;
 
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
 
  	ret = install_process_keyring_to_cred(new);
  	if (ret < 0) {
  		abort_creds(new);
		return ret != -EEXIST ? ret : 0;
 		return ret;
  	}
  
  	return commit_creds(new);
  }","[14, 13]",The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.
205623,"  void Document::detach(const AttachContext& context)
  {
      TRACE_EVENT0(""blink"", ""Document::detach"");
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
      if (!isActive())
          return;
  
     FrameNavigationDisabler navigationDisabler(*m_frame);
     HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
     ScriptForbiddenScope forbidScript;
     view()->dispose();
     m_markers->prepareForDestruction();
     if (LocalDOMWindow* window = this->domWindow())
         window->willDetachDocumentFromFrame();
 
     m_lifecycle.advanceTo(DocumentLifecycle::Stopping);
 
     if (page())
         page()->documentDetached(this);
     InspectorInstrumentation::documentDetached(this);
 
     if (m_frame->loader().client()->sharedWorkerRepositoryClient())
         m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);
 
     stopActiveDOMObjects();
 
     if (m_scriptedAnimationController)
         m_scriptedAnimationController->clearDocumentPointer();
     m_scriptedAnimationController.clear();
 
     m_scriptedIdleTaskController.clear();
 
     if (svgExtensions())
         accessSVGExtensions().pauseAnimations();
 
     if (m_domWindow)
         m_domWindow->clearEventQueue();
 
     if (m_layoutView)
         m_layoutView->setIsInWindow(false);
 
     if (registrationContext())
         registrationContext()->documentWasDetached();
 
     m_hoverNode = nullptr;
     m_activeHoverElement = nullptr;
     m_autofocusElement = nullptr;
 
     if (m_focusedElement.get()) {
         RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
         m_focusedElement = nullptr;
         if (frameHost())
             frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
     }
 
     if (this == &axObjectCacheOwner())
         clearAXObjectCache();
 
     m_layoutView = nullptr;
     ContainerNode::detach(context);
 
     if (this != &axObjectCacheOwner()) {
         if (AXObjectCache* cache = existingAXObjectCache()) {
             for (Node& node : NodeTraversal::descendantsOf(*this)) {
                 cache->remove(&node);
             }
         }
     }
 
     styleEngine().didDetach();
 
     frameHost()->eventHandlerRegistry().documentDetached(*this);
 
     m_frame->inputMethodController().documentDetached();
 
     if (!loader())
         m_fetcher->clearContext();
     if (m_importsController)
         HTMLImportsController::removeFrom(*this);
 
     m_timers.setTimerTaskRunner(
         Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());
 
     m_frame = nullptr;
 
     if (m_mediaQueryMatcher)
         m_mediaQueryMatcher->documentDetached();
 
     DocumentLifecycleNotifier::notifyDocumentWasDetached();
     m_lifecycle.advanceTo(DocumentLifecycle::Stopped);
 
     DocumentLifecycleNotifier::notifyContextDestroyed();
     ExecutionContext::notifyContextDestroyed();
 }","[5, 4]","The DOM implementation in Google Chrome before 47.0.2526.73 allows remote attackers to bypass the Same Origin Policy via unspecified vectors, a different vulnerability than CVE-2015-6770."
201848," int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,
 			int cpu_id)
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
 	unsigned long nr_pages;
 	int cpu, err = 0;
 
 	 
 	if (!buffer)
 		return size;
 
 	 
 	if (cpu_id != RING_BUFFER_ALL_CPUS &&
  	    !cpumask_test_cpu(cpu_id, buffer->cpumask))
  		return size;
  
	size = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
	size *= BUF_PAGE_SIZE;
 	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
  
  	 
	if (size < BUF_PAGE_SIZE * 2)
		size = BUF_PAGE_SIZE * 2;
 	if (nr_pages < 2)
 		nr_pages = 2;
  
	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
 	size = nr_pages * BUF_PAGE_SIZE;
  
  	 
 	if (atomic_read(&buffer->resize_disabled))
 		return -EBUSY;
 
 	 
 	mutex_lock(&buffer->mutex);
 
 	if (cpu_id == RING_BUFFER_ALL_CPUS) {
 		 
 		for_each_buffer_cpu(buffer, cpu) {
 			cpu_buffer = buffer->buffers[cpu];
 
 			cpu_buffer->nr_pages_to_update = nr_pages -
 							cpu_buffer->nr_pages;
 			 
 			if (cpu_buffer->nr_pages_to_update <= 0)
 				continue;
 			 
 			INIT_LIST_HEAD(&cpu_buffer->new_pages);
 			if (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,
 						&cpu_buffer->new_pages, cpu)) {
 				 
 				err = -ENOMEM;
 				goto out_err;
 			}
 		}
 
 		get_online_cpus();
 		 
 		for_each_buffer_cpu(buffer, cpu) {
 			cpu_buffer = buffer->buffers[cpu];
 			if (!cpu_buffer->nr_pages_to_update)
 				continue;
 
 			 
 			if (!cpu_online(cpu)) {
 				rb_update_pages(cpu_buffer);
 				cpu_buffer->nr_pages_to_update = 0;
 			} else {
 				schedule_work_on(cpu,
 						&cpu_buffer->update_pages_work);
 			}
 		}
 
 		 
 		for_each_buffer_cpu(buffer, cpu) {
 			cpu_buffer = buffer->buffers[cpu];
 			if (!cpu_buffer->nr_pages_to_update)
 				continue;
 
 			if (cpu_online(cpu))
 				wait_for_completion(&cpu_buffer->update_done);
 			cpu_buffer->nr_pages_to_update = 0;
 		}
 
 		put_online_cpus();
 	} else {
 		 
 		if (!cpumask_test_cpu(cpu_id, buffer->cpumask))
 			goto out;
 
 		cpu_buffer = buffer->buffers[cpu_id];
 
 		if (nr_pages == cpu_buffer->nr_pages)
 			goto out;
 
 		cpu_buffer->nr_pages_to_update = nr_pages -
 						cpu_buffer->nr_pages;
 
 		INIT_LIST_HEAD(&cpu_buffer->new_pages);
 		if (cpu_buffer->nr_pages_to_update > 0 &&
 			__rb_allocate_pages(cpu_buffer->nr_pages_to_update,
 					    &cpu_buffer->new_pages, cpu_id)) {
 			err = -ENOMEM;
 			goto out_err;
 		}
 
 		get_online_cpus();
 
 		 
 		if (!cpu_online(cpu_id))
 			rb_update_pages(cpu_buffer);
 		else {
 			schedule_work_on(cpu_id,
 					 &cpu_buffer->update_pages_work);
 			wait_for_completion(&cpu_buffer->update_done);
 		}
 
 		cpu_buffer->nr_pages_to_update = 0;
 		put_online_cpus();
 	}
 
  out:
 	 
 	if (atomic_read(&buffer->record_disabled)) {
 		atomic_inc(&buffer->record_disabled);
 		 
 		synchronize_sched();
 		for_each_buffer_cpu(buffer, cpu) {
 			cpu_buffer = buffer->buffers[cpu];
 			rb_check_pages(cpu_buffer);
 		}
 		atomic_dec(&buffer->record_disabled);
 	}
 
 	mutex_unlock(&buffer->mutex);
 	return size;
 
  out_err:
 	for_each_buffer_cpu(buffer, cpu) {
 		struct buffer_page *bpage, *tmp;
 
 		cpu_buffer = buffer->buffers[cpu];
 		cpu_buffer->nr_pages_to_update = 0;
 
 		if (list_empty(&cpu_buffer->new_pages))
 			continue;
 
 		list_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,
 					list) {
 			list_del_init(&bpage->list);
 			free_buffer_page(bpage);
 		}
 	}
 	mutex_unlock(&buffer->mutex);
 	return err;
 }","[19, 24, 25, 28, 17, 18, 22, 23, 27]","The ring_buffer_resize function in kernel/trace/ring_buffer.c in the profiling subsystem in the Linux kernel before 4.6.1 mishandles certain integer calculations, which allows local users to gain privileges by writing to the /sys/kernel/debug/tracing/buffer_size_kb file."
197884," network_init ()
 {
 #ifdef HAVE_GNUTLS
     char *ca_path, *ca_path2;
 
     gnutls_global_init ();
     gnutls_certificate_allocate_credentials (&gnutls_xcred);
     
     ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));
     if (ca_path)
     {
         ca_path2 = string_replace (ca_path, ""%h"", weechat_home);
         if (ca_path2)
         {
             gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,
                                                     GNUTLS_X509_FMT_PEM);
             free (ca_path2);
          }
          free (ca_path);
      }
     gnutls_certificate_set_verify_function (gnutls_xcred,
                                             &hook_connect_gnutls_verify_certificates);
      gnutls_certificate_client_set_retrieve_function (gnutls_xcred,
                                                       &hook_connect_gnutls_set_certificates);
      network_init_ok = 1;
     gcry_check_version (GCRYPT_VERSION);
     gcry_control (GCRYCTL_DISABLE_SECMEM, 0);
     gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
 #endif
 }","[21, 22]","Wee Enhanced Environment for Chat (aka WeeChat) 0.3.4 and earlier does not properly verify that the server hostname matches the domain name of the subject of an X.509 certificate, which allows man-in-the-middle attackers to spoof an SSL chat server via an arbitrary certificate, related to incorrect use of the GnuTLS API."
200787," static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 			   struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
 	struct netlink_sock *nlk = nlk_sk(sk);
 	struct sockaddr_nl *addr = msg->msg_name;
 	u32 dst_pid;
 	u32 dst_group;
 	struct sk_buff *skb;
 	int err;
 	struct scm_cookie scm;
 
 	if (msg->msg_flags&MSG_OOB)
 		return -EOPNOTSUPP;
 
 	if (NULL == siocb->scm)
 		siocb->scm = &scm;
 
 	err = scm_send(sock, msg, siocb->scm, true);
 	if (err < 0)
 		return err;
 
 	if (msg->msg_namelen) {
 		err = -EINVAL;
 		if (addr->nl_family != AF_NETLINK)
 			goto out;
  		dst_pid = addr->nl_pid;
  		dst_group = ffs(addr->nl_groups);
  		err =  -EPERM;
		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
 		if ((dst_group || dst_pid) &&
 		    !netlink_capable(sock, NL_NONROOT_SEND))
  			goto out;
  	} else {
  		dst_pid = nlk->dst_pid;
 		dst_group = nlk->dst_group;
 	}
 
 	if (!nlk->pid) {
 		err = netlink_autobind(sock);
 		if (err)
 			goto out;
 	}
 
 	err = -EMSGSIZE;
 	if (len > sk->sk_sndbuf - 32)
 		goto out;
 	err = -ENOBUFS;
 	skb = alloc_skb(len, GFP_KERNEL);
 	if (skb == NULL)
 		goto out;
 
 	NETLINK_CB(skb).pid	= nlk->pid;
 	NETLINK_CB(skb).dst_group = dst_group;
 	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));
 
 	err = -EFAULT;
 	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
 		kfree_skb(skb);
 		goto out;
 	}
 
 	err = security_netlink_send(sk, skb);
 	if (err) {
 		kfree_skb(skb);
 		goto out;
 	}
 
 	if (dst_group) {
 		atomic_inc(&skb->users);
 		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
 	}
 	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);
 
 out:
 	scm_destroy(siocb->scm);
 	return err;
 }","[32, 33, 31]","The netlink_sendmsg function in net/netlink/af_netlink.c in the Linux kernel before 3.5.5 does not validate the dst_pid field, which allows local users to have an unspecified impact by spoofing Netlink messages."
199661," int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 		size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct atm_vcc *vcc;
  	struct sk_buff *skb;
  	int copied, error = -EINVAL;
  
	msg->msg_namelen = 0;
  	if (sock->state != SS_CONNECTED)
  		return -ENOTCONN;
  
 	 
 	if (flags & ~(MSG_DONTWAIT | MSG_PEEK))
 		return -EOPNOTSUPP;
 
 	vcc = ATM_SD(sock);
 	if (test_bit(ATM_VF_RELEASED, &vcc->flags) ||
 	    test_bit(ATM_VF_CLOSE, &vcc->flags) ||
 	    !test_bit(ATM_VF_READY, &vcc->flags))
 		return 0;
 
 	skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);
 	if (!skb)
 		return error;
 
 	copied = skb->len;
 	if (copied > size) {
 		copied = size;
 		msg->msg_flags |= MSG_TRUNC;
 	}
 
 	error = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 	if (error)
 		return error;
 	sock_recv_ts_and_drops(msg, sk, skb);
 
 	if (!(flags & MSG_PEEK)) {
 		pr_debug(""%d -= %d\n"", atomic_read(&sk->sk_rmem_alloc),
 			 skb->truesize);
 		atm_return(vcc, skb->truesize);
 	}
 
 	skb_free_datagram(sk, skb);
 	return copied;
 }",[9],"The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
198863," int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)
 {
 	struct nfs_server *server = NFS_SERVER(state->inode);
 	struct nfs4_closedata *calldata;
 	struct nfs4_state_owner *sp = state->owner;
 	struct rpc_task *task;
 	struct rpc_message msg = {
 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],
 		.rpc_cred = state->owner->so_cred,
 	};
 	struct rpc_task_setup task_setup_data = {
 		.rpc_client = server->client,
 		.rpc_message = &msg,
 		.callback_ops = &nfs4_close_ops,
 		.workqueue = nfsiod_workqueue,
 		.flags = RPC_TASK_ASYNC,
 	};
 	int status = -ENOMEM;
 
 	calldata = kmalloc(sizeof(*calldata), GFP_KERNEL);
 	if (calldata == NULL)
 		goto out;
 	calldata->inode = state->inode;
 	calldata->state = state;
 	calldata->arg.fh = NFS_FH(state->inode);
 	calldata->arg.stateid = &state->open_stateid;
 	 
  	calldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);
  	if (calldata->arg.seqid == NULL)
  		goto out_free_calldata;
	calldata->arg.open_flags = 0;
 	calldata->arg.fmode = 0;
  	calldata->arg.bitmask = server->attr_bitmask;
  	calldata->res.fattr = &calldata->fattr;
  	calldata->res.seqid = calldata->arg.seqid;
 	calldata->res.server = server;
 	calldata->path.mnt = mntget(path->mnt);
 	calldata->path.dentry = dget(path->dentry);
 
 	msg.rpc_argp = &calldata->arg,
 	msg.rpc_resp = &calldata->res,
 	task_setup_data.callback_data = calldata;
 	task = rpc_run_task(&task_setup_data);
 	if (IS_ERR(task))
 		return PTR_ERR(task);
 	status = 0;
 	if (wait)
 		status = rpc_wait_for_completion_task(task);
 	rpc_put_task(task);
 	return status;
 out_free_calldata:
 	kfree(calldata);
 out:
 	nfs4_put_open_state(state);
 	nfs4_put_state_owner(sp);
  	return status;
  }","[32, 31]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
207961,"  status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     return BasicClient::dump(fd, args);
 }
 
 status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
      String8 result;
      result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
              mCameraId,
             getRemoteCallback()->asBinder().get(),
             mClientPid);
     result.append(""  State: "");
 
     mFrameProcessor->dump(fd, args);
 
  return dumpDevice(fd, args);
 }","[2, 3, 4, 5]","libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403."
206657," void WebGL2RenderingContextBase::texSubImage3D(GLenum target,
                                                GLint level,
                                                GLint xoffset,
                                                GLint yoffset,
                                                GLint zoffset,
                                                GLsizei width,
                                                GLsizei height,
                                                GLsizei depth,
                                                GLenum format,
                                                GLenum type,
                                                GLintptr offset) {
   if (isContextLost())
     return;
   if (!ValidateTexture3DBinding(""texSubImage3D"", target))
     return;
   if (!bound_pixel_unpack_buffer_) {
     SynthesizeGLError(GL_INVALID_OPERATION, ""texSubImage3D"",
                        ""no bound PIXEL_UNPACK_BUFFER"");
      return;
    }
   if (unpack_flip_y_ || unpack_premultiply_alpha_) {
     SynthesizeGLError(
         GL_INVALID_OPERATION, ""texSubImage3D"",
         ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
     return;
   }
    if (!ValidateTexFunc(""texSubImage3D"", kTexSubImage, kSourceUnpackBuffer,
                         target, level, 0, width, height, depth, 0, format, type,
                         xoffset, yoffset, zoffset))
     return;
   if (!ValidateValueFitNonNegInt32(""texSubImage3D"", ""offset"", offset))
     return;
 
   ContextGL()->TexSubImage3D(target, level, xoffset, yoffset, zoffset, width,
                              height, depth, format, type,
                              reinterpret_cast<const void*>(offset));
 }","[21, 22, 23, 24, 25, 26]",Heap buffer overflow in WebGL in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
202590," static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,
                                           const unsigned char *end )
 {
     int ret = 0;
     size_t n;
 
     if( ssl->conf->f_psk == NULL &&
         ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
           ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""got no pre-shared key"" ) );
         return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
     }
 
       
    if( *p + 2 > end )
     if( end - *p < 2 )
      {
          MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad client key exchange message"" ) );
          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
     }
 
      n = ( (*p)[0] << 8 ) | (*p)[1];
      *p += 2;
  
    if( n < 1 || n > 65535 || *p + n > end )
     if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )
      {
          MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad client key exchange message"" ) );
          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
     }
 
     if( ssl->conf->f_psk != NULL )
     {
         if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )
             ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
     }
     else
     {
          
         if( n != ssl->conf->psk_identity_len ||
             mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )
         {
             ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
         }
     }
 
     if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )
     {
         MBEDTLS_SSL_DEBUG_BUF( 3, ""Unknown PSK identity"", *p, n );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                         MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );
         return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );
     }
 
     *p += n;
 
     return( 0 );
 }","[17, 27, 16, 26]","In ARM mbed TLS before 2.7.0, there is a bounds-check bypass through an integer overflow in PSK identity parsing in the ssl_parse_client_psk_identity() function in library/ssl_srv.c."
199448," int mk_request_error(int http_status, struct client_session *cs,
                      struct session_request *sr) {
     int ret, fd;
     mk_ptr_t message, *page = 0;
     struct error_page *entry;
     struct mk_list *head;
     struct file_info finfo;
 
     mk_header_set_http_status(sr, http_status);
 
      
     if (http_status != MK_CLIENT_LENGTH_REQUIRED &&
         http_status != MK_CLIENT_BAD_REQUEST &&
         http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE) {
 
          
         mk_list_foreach(head, &sr->host_conf->error_pages) {
             entry = mk_list_entry(head, struct error_page, _head);
             if (entry->status != http_status) {
                 continue;
             }
 
              
             ret = mk_file_get_info(entry->real_path, &finfo);
             if (ret == -1) {
                 break;
             }
 
              
             fd = open(entry->real_path, config->open_flags);
             if (fd == -1) {
                  break;
              }
  
            sr->fd_file = fd;
             sr->fd_file   = fd;
             sr->fd_is_fdt = MK_FALSE;
              sr->bytes_to_send = finfo.size;
              sr->headers.content_length = finfo.size;
              sr->headers.real_length    = finfo.size;
 
             memcpy(&sr->file_info, &finfo, sizeof(struct file_info));
 
             mk_header_send(cs->socket, cs, sr);
             return mk_http_send_file(cs, sr);
         }
     }
 
     mk_ptr_reset(&message);
 
     switch (http_status) {
     case MK_CLIENT_BAD_REQUEST:
         page = mk_request_set_default_page(""Bad Request"",
                                            sr->uri,
                                            sr->host_conf->host_signature);
         break;
 
     case MK_CLIENT_FORBIDDEN:
         page = mk_request_set_default_page(""Forbidden"",
                                            sr->uri,
                                            sr->host_conf->host_signature);
         break;
 
     case MK_CLIENT_NOT_FOUND:
         mk_string_build(&message.data, &message.len,
                         ""The requested URL was not found on this server."");
         page = mk_request_set_default_page(""Not Found"",
                                            message,
                                            sr->host_conf->host_signature);
         mk_ptr_free(&message);
         break;
 
     case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE:
         mk_string_build(&message.data, &message.len,
                         ""The request entity is too large."");
         page = mk_request_set_default_page(""Entity too large"",
                                            message,
                                            sr->host_conf->host_signature);
         mk_ptr_free(&message);
         break;
 
     case MK_CLIENT_METHOD_NOT_ALLOWED:
         page = mk_request_set_default_page(""Method Not Allowed"",
                                            sr->uri,
                                            sr->host_conf->host_signature);
         break;
 
     case MK_CLIENT_REQUEST_TIMEOUT:
     case MK_CLIENT_LENGTH_REQUIRED:
         break;
 
     case MK_SERVER_NOT_IMPLEMENTED:
         page = mk_request_set_default_page(""Method Not Implemented"",
                                            sr->uri,
                                            sr->host_conf->host_signature);
         break;
 
     case MK_SERVER_INTERNAL_ERROR:
         page = mk_request_set_default_page(""Internal Server Error"",
                                            sr->uri,
                                            sr->host_conf->host_signature);
         break;
 
     case MK_SERVER_HTTP_VERSION_UNSUP:
         mk_ptr_reset(&message);
         page = mk_request_set_default_page(""HTTP Version Not Supported"",
                                            message,
                                            sr->host_conf->host_signature);
         break;
     }
 
     if (page) {
         sr->headers.content_length = page->len;
     }
 
     sr->headers.location = NULL;
     sr->headers.cgi = SH_NOCGI;
     sr->headers.pconnections_left = 0;
     sr->headers.last_modified = -1;
 
     if (!page) {
         mk_ptr_reset(&sr->headers.content_type);
     }
     else {
         mk_ptr_set(&sr->headers.content_type, ""text/html\r\n"");
     }
 
     mk_header_send(cs->socket, cs, sr);
 
     if (page) {
         if (sr->method != MK_HTTP_METHOD_HEAD)
             mk_socket_send(cs->socket, page->data, page->len);
 
         mk_ptr_free(page);
         mk_mem_free(page);
     }
 
      
     mk_server_cork_flag(cs->socket, TCP_CORK_OFF);
     return EXIT_ERROR;
 }","[36, 37, 35]","Monkey HTTP Server before 1.5.3, when the File Descriptor Table (FDT) is enabled and custom error messages are set, allows remote attackers to cause a denial of service (file descriptor consumption) via an HTTP request that triggers an error message."
463,"void initServerConfig() {
server.port = REDIS_SERVERPORT;
server.bindaddr = NULL;
server.unixsocket = NULL;
server.ipfd = -1;
server.sofd = -1;
server.dbnum = REDIS_DEFAULT_DBNUM;
server.verbosity = REDIS_VERBOSE;
server.maxidletime = REDIS_MAXIDLETIME;
server.saveparams = NULL;
server.loading = 0;
server.logfile = NULL;
server.syslog_enabled = 0;
server.syslog_ident = zstrdup(""redis"");
server.syslog_facility = LOG_LOCAL0;
server.glueoutputbuf = 1;
server.daemonize = 0;
server.appendonly = 0;
server.appendfsync = APPENDFSYNC_EVERYSEC;
server.no_appendfsync_on_rewrite = 0;
server.lastfsync = time(NULL);
server.appendfd = -1;
server.appendseldb = -1;
server.pidfile = zstrdup(""/var/run/redis.pid"");
server.dbfilename = zstrdup(""dump.rdb"");
server.appendfilename = zstrdup(""appendonly.aof"");
server.requirepass = NULL;
server.rdbcompression = 1;
server.activerehashing = 1;
server.maxclients = 0;
server.bpop_blocked_clients = 0;
server.maxmemory = 0;
server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;
server.maxmemory_samples = 3;
server.vm_enabled = 0;
server.vm_swap_file = zstrdup(""/tmp/redis-%p.vm"");
server.vm_page_size = 256;
server.vm_pages = 1024*1024*100;
server.vm_max_memory = 1024LL*1024*1024*1;
server.vm_max_threads = 4;
server.vm_blocked_clients = 0;
server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES;
server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE;
server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;
server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;
server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;
server.shutdown_asap = 0;

updateLRUClock();
resetServerSaveParams();

appendServerSaveParams(60*60,1);
appendServerSaveParams(300,100);
appendServerSaveParams(60,10000);

server.isslave = 0;
server.masterauth = NULL;
server.masterhost = NULL;
server.masterport = 6379;
server.master = NULL;
server.replstate = REDIS_REPL_NONE;
server.repl_serve_stale_data = 1;


R_Zero = 0.0;
R_PosInf = 1.0/R_Zero;
R_NegInf = -1.0/R_Zero;
R_Nan = R_Zero/R_Zero;




server.commands = dictCreate(&commandTableDictType,NULL);
populateCommandTable();
server.delCommand = lookupCommandByCString(""del"");
server.multiCommand = lookupCommandByCString(""multi"");
}","[35, 36, 37, 38, 39, 40, 41]",Insecure temporary file vulnerability in Redis before 2.6 related to /tmp/redis-%p.vm.
207880," long Cluster::ParseSimpleBlock(long long block_size, long long& pos,
  long& len) {
  const long long block_start = pos;
  const long long block_stop = pos + block_size;
 
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  long long total, avail;
 
  long status = pReader->Length(&total, &avail);
 
  if (status < 0)  
  return status;
 
   assert((total < 0) || (avail <= total));
 
 
  if ((pos + 1) > avail) {
     len = 1;
  return E_BUFFER_NOT_FULL;
  }
 
  long long result = GetUIntLength(pReader, pos, len);
 
  if (result < 0)  
  return static_cast<long>(result);
 
  if (result > 0)  
  return E_BUFFER_NOT_FULL;
 
  if ((pos + len) > block_stop)
  return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > avail)
  return E_BUFFER_NOT_FULL;
 
  const long long track = ReadUInt(pReader, pos, len);
 
  if (track < 0)  
  return static_cast<long>(track);
 
 
    if (track == 0)
      return E_FILE_FORMAT_INVALID;
  
#if 0
    const Tracks* const pTracks = m_pSegment->GetTracks();
    assert(pTracks);
    const long tn = static_cast<long>(track);
    const Track* const pTrack = pTracks->GetTrackByNumber(tn);
    if (pTrack == NULL)
        return E_FILE_FORMAT_INVALID;
#endif
    pos += len;   
  
    if ((pos + 2) > block_stop)
  return E_FILE_FORMAT_INVALID;
 
  if ((pos + 2) > avail) {
     len = 2;
  return E_BUFFER_NOT_FULL;
  }
 
   pos += 2;  
 
  if ((pos + 1) > block_stop)
  return E_FILE_FORMAT_INVALID;
 
  if ((pos + 1) > avail) {
     len = 1;
  return E_BUFFER_NOT_FULL;
  }
 
  unsigned char flags;
 
   status = pReader->Read(pos, 1, &flags);
 
  if (status < 0) {  
     len = 1;
  return status;
  }
 
  ++pos;  
   assert(pos <= avail);
 
  if (pos >= block_stop)
  return E_FILE_FORMAT_INVALID;
 
  const int lacing = int(flags & 0x06) >> 1;
 
  if ((lacing != 0) && (block_stop > avail)) {
     len = static_cast<long>(block_stop - pos);
  return E_BUFFER_NOT_FULL;
  }
 
   status = CreateBlock(0x23,  
                        block_start, block_size,
  0);  
 
  if (status != 0)
  return status;
 
   m_pos = block_stop;
 
  return 0;  
 }","[46, 47, 48, 49, 50, 51, 52, 53]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
198752," static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
 			       struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
 	struct sock *other = NULL;
 	int err, size;
 	struct sk_buff *skb;
 	int sent = 0;
 	struct scm_cookie tmp_scm;
 	bool fds_sent = false;
 	int max_level;
 
  	if (NULL == siocb->scm)
  		siocb->scm = &tmp_scm;
  	wait_for_unix_gc();
	err = scm_send(sock, msg, siocb->scm);
 	err = scm_send(sock, msg, siocb->scm, false);
  	if (err < 0)
  		return err;
  
 	err = -EOPNOTSUPP;
 	if (msg->msg_flags&MSG_OOB)
 		goto out_err;
 
 	if (msg->msg_namelen) {
 		err = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;
 		goto out_err;
 	} else {
 		err = -ENOTCONN;
 		other = unix_peer(sk);
 		if (!other)
 			goto out_err;
 	}
 
 	if (sk->sk_shutdown & SEND_SHUTDOWN)
 		goto pipe_err;
 
 	while (sent < len) {
 		 
 
 		size = len-sent;
 
 		 
 		if (size > ((sk->sk_sndbuf >> 1) - 64))
 			size = (sk->sk_sndbuf >> 1) - 64;
 
 		if (size > SKB_MAX_ALLOC)
 			size = SKB_MAX_ALLOC;
 
 		 
 
 		skb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,
 					  &err);
 
 		if (skb == NULL)
 			goto out_err;
 
 		 
 		size = min_t(int, size, skb_tailroom(skb));
 
 
 		 
 		err = unix_scm_to_skb(siocb->scm, skb, !fds_sent);
 		if (err < 0) {
 			kfree_skb(skb);
 			goto out_err;
 		}
 		max_level = err + 1;
 		fds_sent = true;
 
 		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
 		if (err) {
 			kfree_skb(skb);
 			goto out_err;
 		}
 
 		unix_state_lock(other);
 
 		if (sock_flag(other, SOCK_DEAD) ||
 		    (other->sk_shutdown & RCV_SHUTDOWN))
 			goto pipe_err_free;
 
 		maybe_add_creds(skb, sock, other);
 		skb_queue_tail(&other->sk_receive_queue, skb);
 		if (max_level > unix_sk(other)->recursion_level)
 			unix_sk(other)->recursion_level = max_level;
 		unix_state_unlock(other);
 		other->sk_data_ready(other, size);
 		sent += size;
 	}
 
 	scm_destroy(siocb->scm);
 	siocb->scm = NULL;
 
 	return sent;
 
 pipe_err_free:
 	unix_state_unlock(other);
 	kfree_skb(skb);
 pipe_err:
 	if (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))
 		send_sig(SIGPIPE, current, 0);
 	err = -EPIPE;
 out_err:
 	scm_destroy(siocb->scm);
 	siocb->scm = NULL;
 	return sent ? : err;
 }","[18, 17]","The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager."
207716,"  set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,
    PNG_CONST char *name)
     const char *name)
  {
      
    pm->state = modifier_start;
    pm->bit_depth = 0;
    pm->colour_type = 255;
 
    pm->pending_len = 0;
    pm->pending_chunk = 0;
    pm->flush = 0;
    pm->buffer_count = 0;
    pm->buffer_position = 0;
 
  return set_store_for_read(&pm->this, ppi, id, name);
 }","[3, 2]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
206079," bool GLSurfaceEGLSurfaceControl::ScheduleOverlayPlane(
     int z_order,
     gfx::OverlayTransform transform,
     GLImage* image,
     const gfx::Rect& bounds_rect,
     const gfx::RectF& crop_rect,
     bool enable_blend,
     std::unique_ptr<gfx::GpuFence> gpu_fence) {
   if (!pending_transaction_)
     pending_transaction_.emplace();
 
   bool uninitialized = false;
   if (pending_surfaces_count_ == surface_list_.size()) {
     uninitialized = true;
     surface_list_.emplace_back(*root_surface_);
   }
   pending_surfaces_count_++;
   auto& surface_state = surface_list_.at(pending_surfaces_count_ - 1);
 
   if (uninitialized || surface_state.z_order != z_order) {
     surface_state.z_order = z_order;
     pending_transaction_->SetZOrder(*surface_state.surface, z_order);
   }
 
   AHardwareBuffer* hardware_buffer = nullptr;
   base::ScopedFD fence_fd;
   auto scoped_hardware_buffer = image->GetAHardwareBuffer();
   if (scoped_hardware_buffer) {
     hardware_buffer = scoped_hardware_buffer->buffer();
     fence_fd = scoped_hardware_buffer->TakeFence();
 
     auto* a_surface = surface_state.surface->surface();
     DCHECK_EQ(pending_frame_resources_.count(a_surface), 0u);
 
     auto& resource_ref = pending_frame_resources_[a_surface];
     resource_ref.surface = surface_state.surface;
      resource_ref.scoped_buffer = std::move(scoped_hardware_buffer);
    }
  
  if (uninitialized || surface_state.hardware_buffer != hardware_buffer) {
   surface_state.buffer_updated_in_pending_transaction =
       uninitialized || surface_state.hardware_buffer != hardware_buffer;
   if (surface_state.buffer_updated_in_pending_transaction) {
      surface_state.hardware_buffer = hardware_buffer;
  
      if (!fence_fd.is_valid() && gpu_fence && surface_state.hardware_buffer) {
       auto fence_handle =
           gfx::CloneHandleForIPC(gpu_fence->GetGpuFenceHandle());
       DCHECK(!fence_handle.is_null());
       fence_fd = base::ScopedFD(fence_handle.native_fd.fd);
     }
 
     pending_transaction_->SetBuffer(*surface_state.surface,
                                     surface_state.hardware_buffer,
                                     std::move(fence_fd));
   }
 
   if (hardware_buffer) {
     gfx::Rect dst = bounds_rect;
 
     gfx::Size buffer_size = GetBufferSize(hardware_buffer);
     gfx::RectF scaled_rect =
         gfx::RectF(crop_rect.x() * buffer_size.width(),
                    crop_rect.y() * buffer_size.height(),
                    crop_rect.width() * buffer_size.width(),
                    crop_rect.height() * buffer_size.height());
     gfx::Rect src = gfx::ToEnclosedRect(scaled_rect);
 
     if (uninitialized || surface_state.src != src || surface_state.dst != dst ||
         surface_state.transform != transform) {
       surface_state.src = src;
       surface_state.dst = dst;
       surface_state.transform = transform;
       pending_transaction_->SetGeometry(*surface_state.surface, src, dst,
                                         transform);
     }
   }
 
   bool opaque = !enable_blend;
   if (uninitialized || surface_state.opaque != opaque) {
     surface_state.opaque = opaque;
     pending_transaction_->SetOpaque(*surface_state.surface, opaque);
   }
 
   return true;
 }","[41, 42, 43, 40]",Multiple unspecified vulnerabilities in Google Chrome before 52.0.2743.82 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
207275," void CredentialManagerImpl::OnProvisionalSaveComplete() {
   DCHECK(form_manager_);
   DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage());
   const autofill::PasswordForm& form = form_manager_->pending_credentials();
 
   if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {
     form_manager_->Save();
     return;
   }
 
   if (!form.federation_origin.unique()) {
     for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) {
       if (match->username_value == form.username_value &&
           match->federation_origin.IsSameOriginWith(form.federation_origin)) {
         form_manager_->Update(*match);
         return;
       }
     }
   } else if (!form_manager_->IsNewLogin()) {
    form_manager_->Update(*form_manager_->preferred_match());
     auto best_match = form_manager_->best_matches().find(form.username_value);
      
      
     DCHECK(best_match != form_manager_->best_matches().end());
     form_manager_->Update(*best_match->second);
      return;
    }
  
   client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false);
 }","[21, 22, 23, 24, 25, 20]",Insufficient validation in V8 in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
200795," static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
 	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
 	u16 scid, flags, result;
 	struct sock *sk;
 
 	scid   = __le16_to_cpu(rsp->scid);
 	flags  = __le16_to_cpu(rsp->flags);
 	result = __le16_to_cpu(rsp->result);
 
 	BT_DBG(""scid 0x%4.4x flags 0x%2.2x result 0x%2.2x"",
 			scid, flags, result);
 
 	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
 	if (!sk)
 		return 0;
 
 	switch (result) {
 	case L2CAP_CONF_SUCCESS:
  		break;
  
  	case L2CAP_CONF_UNACCEPT:
		if (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {
			char req[128];
 		if (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
 			int len = cmd->len - sizeof(*rsp);
 			char req[64];
 
 			 
			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
						l2cap_build_conf_req(sk, req), req);
			goto done;
 			result = L2CAP_CONF_SUCCESS;
 			len = l2cap_parse_conf_rsp(sk, rsp->data,
 							len, req, &result);
 			if (len < 0) {
 				struct l2cap_disconn_req req;
 				req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
 				req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 				l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					L2CAP_DISCONN_REQ, sizeof(req), &req);
 				goto done;
 			}
 
 			l2cap_send_cmd(conn, l2cap_get_ident(conn),
 						L2CAP_CONF_REQ, len, req);
 			l2cap_pi(sk)->num_conf_req++;
 			if (result != L2CAP_CONF_SUCCESS)
 				goto done;
 			break;
  		}
  
  	default:
 		sk->sk_state = BT_DISCONN;
 		sk->sk_err = ECONNRESET;
 		l2cap_sock_set_timer(sk, HZ * 5);
 		{
 			struct l2cap_disconn_req req;
 			req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
 			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					L2CAP_DISCONN_REQ, sizeof(req), &req);
 		}
 		goto done;
 	}
 
 	if (flags & 0x01)
 		goto done;
 
 	l2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;
 
 	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {
 		sk->sk_state = BT_CONNECTED;
 		l2cap_chan_ready(sk);
 	}
 
 done:
 	bh_unlock_sock(sk);
 	return 0;
 }","[25, 26, 27, 28, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 24, 30, 31, 32]","The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space."
206539," void SerializedScriptValue::transferArrayBuffers(v8::Isolate* isolate, const ArrayBufferArray& arrayBuffers, ExceptionState& exceptionState)
 {
     if (!arrayBuffers.size())
         return;
 
     for (size_t i = 0; i < arrayBuffers.size(); ++i) {
         if (arrayBuffers[i]->isNeutered()) {
             exceptionState.throwDOMException(DataCloneError, ""ArrayBuffer at index "" + String::number(i) + "" is already neutered."");
             return;
         }
     }
 
     OwnPtr<ArrayBufferContentsArray> contents = adoptPtr(new ArrayBufferContentsArray(arrayBuffers.size()));
 
     HeapHashSet<Member<DOMArrayBufferBase>> visited;
     for (size_t i = 0; i < arrayBuffers.size(); ++i) {
         if (visited.contains(arrayBuffers[i]))
             continue;
         visited.add(arrayBuffers[i]);
 
         if (arrayBuffers[i]->isShared()) {
             bool result = arrayBuffers[i]->shareContentsWith(contents->at(i));
             if (!result) {
                 exceptionState.throwDOMException(DataCloneError, ""SharedArrayBuffer at index "" + String::number(i) + "" could not be transferred."");
                 return;
             }
         } else {
             Vector<v8::Local<v8::ArrayBuffer>, 4> bufferHandles;
             v8::HandleScope handleScope(isolate);
             acculumateArrayBuffersForAllWorlds(isolate, static_cast<DOMArrayBuffer*>(arrayBuffers[i].get()), bufferHandles);
             bool isNeuterable = true;
             for (size_t j = 0; j < bufferHandles.size(); ++j)
                 isNeuterable &= bufferHandles[j]->IsNeuterable();
  
              DOMArrayBufferBase* toTransfer = arrayBuffers[i];
              if (!isNeuterable)
                toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer());
                 toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer()->data(), arrayBuffers[i]->buffer()->byteLength());
              bool result = toTransfer->transfer(contents->at(i));
              if (!result) {
                  exceptionState.throwDOMException(DataCloneError, ""ArrayBuffer at index "" + String::number(i) + "" could not be transferred."");
                 return;
             }
 
             if (isNeuterable)
                 for (size_t j = 0; j < bufferHandles.size(); ++j)
                     bufferHandles[j]->Neuter();
         }
 
     }
     m_arrayBufferContentsArray = contents.release();
 }","[38, 37]","The SerializedScriptValue::transferArrayBuffers function in WebKit/Source/bindings/core/v8/SerializedScriptValue.cpp in the V8 bindings in Blink, as used in Google Chrome before 50.0.2661.94, mishandles certain array-buffer data structures, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site."
9253,"int nfc_dev_up(struct nfc_dev *dev)
{
int rc = 0;

pr_debug(""dev_name=%s\n"", dev_name(&dev->dev));

device_lock(&dev->dev);

if (!device_is_registered(&dev->dev)) {
rc = -ENODEV;
goto error;
}

if (dev->rfkill && rfkill_blocked(dev->rfkill)) {
rc = -ERFKILL;
goto error;
}

if (dev->fw_download_in_progress) {
rc = -EBUSY;
goto error;
}

if (dev->dev_up) {
rc = -EALREADY;
goto error;
}

if (dev->ops->dev_up)
rc = dev->ops->dev_up(dev);

if (!rc)
dev->dev_up = true;


if (dev->ops->discover_se && dev->ops->discover_se(dev))
pr_err(""SE discovery failed\n"");

error:
device_unlock(&dev->dev);
return rc;
}",[9],A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.
198552," sysapi_translate_arch( const char *machine, const char *)
 {
 	char tmp[64];
 	char *tmparch;
 
 #if defined(AIX)
 	 
 	struct utsname buf;
 
 	if( uname(&buf) < 0 ) {
 		return NULL;
 	}
 
 	return( get_aix_arch( &buf ) );
 
 #elif defined(HPUX)
 
 	return( get_hpux_arch( ) );
 #else
 
 	if( !strcmp(machine, ""alpha"") ) {
 		sprintf( tmp, ""ALPHA"" );
 	}
 	else if( !strcmp(machine, ""i86pc"") ) {
 		sprintf( tmp, ""INTEL"" );
 	}
 	else if( !strcmp(machine, ""i686"") ) {
 		sprintf( tmp, ""INTEL"" );
 	}
 	else if( !strcmp(machine, ""i586"") ) {
 		sprintf( tmp, ""INTEL"" );
 	}
 	else if( !strcmp(machine, ""i486"") ) {
 		sprintf( tmp, ""INTEL"" );
 	}
 	else if( !strcmp(machine, ""i386"") ) {  
 #if defined(Darwin)
 		 
 		int ret;
 		char val[32];
 		size_t len = sizeof(val);
 
 		 
 		sprintf( tmp, ""INTEL"" );
 		ret = sysctlbyname(""kern.osrelease"", &val, &len, NULL, 0);
 		if (ret == 0 && strncmp(val, ""10."", 3) == 0) {
 			 
 			sprintf( tmp, ""X86_64"" );
 		}
 #else
 		sprintf( tmp, ""INTEL"" );
 #endif
 	}
 	else if( !strcmp(machine, ""ia64"") ) {
 		sprintf( tmp, ""IA64"" );
 	}
 	else if( !strcmp(machine, ""x86_64"") ) {
 		sprintf( tmp, ""X86_64"" );
 	}
 	else if( !strcmp(machine, ""amd64"") ) {
 		sprintf( tmp, ""X86_64"" );
 	}
 	else if( !strcmp(machine, ""sun4u"") ) {
 		sprintf( tmp, ""SUN4u"" );
 	}
 	else if( !strcmp(machine, ""sun4m"") ) {
 		sprintf( tmp, ""SUN4x"" );
 	}
 	else if( !strcmp(machine, ""sun4c"") ) {
 		sprintf( tmp, ""SUN4x"" );
 	}
 	else if( !strcmp(machine, ""sparc"") ) {  
 		sprintf( tmp, ""SUN4x"" );
 	}
 	else if( !strcmp(machine, ""Power Macintosh"") ) {  
 		sprintf( tmp, ""PPC"" );
 	}
 	else if( !strcmp(machine, ""ppc"") ) {
 		sprintf( tmp, ""PPC"" );
 	}
 	else if( !strcmp(machine, ""ppc32"") ) {
 		sprintf( tmp, ""PPC"" );
 	}
 	else if( !strcmp(machine, ""ppc64"") ) {
 		sprintf( tmp, ""PPC64"" );
         }
         else {
               sprintf( tmp, machine );
                sprintf( tmp, ""%s"", machine );
         }
  
         tmparch = strdup( tmp );
 	if( !tmparch ) {
 		EXCEPT( ""Out of memory!"" );
 	}
 	return( tmparch );
 #endif  
 }","[89, 88]","Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors."
201587,"  tiffcp(TIFF* in, TIFF* out)
  {
	uint16 bitspersample, samplesperpixel = 1;
 	uint16 bitspersample = 1, samplesperpixel = 1;
  	uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;
  	copyFunc cf;
  	uint32 width, length;
 	struct cpTag* p;
 
 	CopyField(TIFFTAG_IMAGEWIDTH, width);
 	CopyField(TIFFTAG_IMAGELENGTH, length);
 	CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);
 	CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
 	if (compression != (uint16)-1)
 		TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
 	else
 		CopyField(TIFFTAG_COMPRESSION, compression);
 	TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);
 	TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);
 	if (input_compression == COMPRESSION_JPEG) {
 		 
 		TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
 	} else if (input_photometric == PHOTOMETRIC_YCBCR) {
 		 
 		uint16 subsamplinghor,subsamplingver;
 
 		TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
 				      &subsamplinghor, &subsamplingver);
 		if (subsamplinghor!=1 || subsamplingver!=1) {
 			fprintf(stderr, ""tiffcp: %s: Can't copy/convert subsampled image.\n"",
 				TIFFFileName(in));
 			return FALSE;
 		}
 	}
 	if (compression == COMPRESSION_JPEG) {
 		if (input_photometric == PHOTOMETRIC_RGB &&
 		    jpegcolormode == JPEGCOLORMODE_RGB)
 		  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
 		else
 		  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
 	}
 	else if (compression == COMPRESSION_SGILOG
 	    || compression == COMPRESSION_SGILOG24)
 		TIFFSetField(out, TIFFTAG_PHOTOMETRIC,
 		    samplesperpixel == 1 ?
 		    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
 	else if (input_compression == COMPRESSION_JPEG &&
 			 samplesperpixel == 3 ) {
 		 
 		TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
 	}
 	else
 		CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);
 	if (fillorder != 0)
 		TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
 	else
 		CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
 	 
 	TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
 	switch (orientation) {
 		case ORIENTATION_BOTRIGHT:
 		case ORIENTATION_RIGHTBOT:	 
 			TIFFWarning(TIFFFileName(in), ""using bottom-left orientation"");
 			orientation = ORIENTATION_BOTLEFT;
 		 
 		case ORIENTATION_LEFTBOT:	 
 		case ORIENTATION_BOTLEFT:
 			break;
 		case ORIENTATION_TOPRIGHT:
 		case ORIENTATION_RIGHTTOP:	 
 		default:
 			TIFFWarning(TIFFFileName(in), ""using top-left orientation"");
 			orientation = ORIENTATION_TOPLEFT;
 		 
 		case ORIENTATION_LEFTTOP:	 
 		case ORIENTATION_TOPLEFT:
 			break;
 	}
 	TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);
 	 
 	if (outtiled == -1)
 		outtiled = TIFFIsTiled(in);
 	if (outtiled) {
 		 
 		if (tilewidth == (uint32) -1)
 			TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
 		if (tilelength == (uint32) -1)
 			TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);
 		TIFFDefaultTileSize(out, &tilewidth, &tilelength);
 		TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
 		TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
 	} else {
 		 
 		if (rowsperstrip == (uint32) 0) {
 			if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,
 			    &rowsperstrip)) {
 				rowsperstrip =
 				    TIFFDefaultStripSize(out, rowsperstrip);
 			}
 			if (rowsperstrip > length && rowsperstrip != (uint32)-1)
 				rowsperstrip = length;
 		}
 		else if (rowsperstrip == (uint32) -1)
 			rowsperstrip = length;
 		TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
 	}
 	if (config != (uint16) -1)
 		TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
 	else
 		CopyField(TIFFTAG_PLANARCONFIG, config);
 	if (samplesperpixel <= 4)
 		CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
 	CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);
  
 	switch (compression) {
 		case COMPRESSION_JPEG:
 			TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
 			TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
 			break;
 		case COMPRESSION_JBIG:
 			CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
 			CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);
 			break;
 		case COMPRESSION_LZW:
 		case COMPRESSION_ADOBE_DEFLATE:
 		case COMPRESSION_DEFLATE:
                 case COMPRESSION_LZMA:
 			if (predictor != (uint16)-1)
 				TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
 			else
 				CopyField(TIFFTAG_PREDICTOR, predictor);
 			if (preset != -1) {
                                 if (compression == COMPRESSION_ADOBE_DEFLATE
                                          || compression == COMPRESSION_DEFLATE)
                                         TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);
 				else if (compression == COMPRESSION_LZMA)
 					TIFFSetField(out, TIFFTAG_LZMAPRESET, preset);
                         }
 			break;
 		case COMPRESSION_CCITTFAX3:
 		case COMPRESSION_CCITTFAX4:
 			if (compression == COMPRESSION_CCITTFAX3) {
 				if (g3opts != (uint32) -1)
 					TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,
 					    g3opts);
 				else
 					CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
 			} else
 				CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
 			break;
 	}
 	{
 		uint32 len32;
 		void** data;
 		if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
 			TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
 	}
 	{
 		uint16 ninks;
 		const char* inknames;
 		if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
 			TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
 			if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
 				int inknameslen = strlen(inknames) + 1;
 				const char* cp = inknames;
 				while (ninks > 1) {
 					cp = strchr(cp, '\0');
                                         cp++;
                                         inknameslen += (strlen(cp) + 1);
 					ninks--;
 				}
 				TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
 			}
 		}
 	}
 	{
 		unsigned short pg0, pg1;
 
 		if (pageInSeq == 1) {
 			if (pageNum < 0)   {
 				if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))
 					TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
 			} else
 				TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
 
 		} else {
 			if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
 				if (pageNum < 0)  
 					TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
 				else
 					TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
 			}
 		}
 	}
 
 	for (p = tags; p < &tags[NTAGS]; p++)
 		CopyTag(p->tag, p->count, p->type);
 
 	cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);
 	return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);
 }","[4, 3]",LibTIFF version 4.0.7 is vulnerable to a heap buffer overflow in the tools/tiffcp resulting in DoS or code execution via a crafted BitsPerSample value.
208080," int Equalizer_getParameter(EffectContext *pContext,
  void *pParam,
  uint32_t *pValueSize,
  void *pValue){
  int status = 0;
  int bMute = 0;
  int32_t *pParamTemp = (int32_t *)pParam;
  int32_t param = *pParamTemp++;
  int32_t param2;
  char *name;
 
 
  switch (param) {
  case EQ_PARAM_NUM_BANDS:
  case EQ_PARAM_CUR_PRESET:
  case EQ_PARAM_GET_NUM_OF_PRESETS:
  case EQ_PARAM_BAND_LEVEL:
  case EQ_PARAM_GET_BAND:
  if (*pValueSize < sizeof(int16_t)) {
             ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize);
  return -EINVAL;
  }
  *pValueSize = sizeof(int16_t);
  break;
 
  case EQ_PARAM_LEVEL_RANGE:
  if (*pValueSize < 2 * sizeof(int16_t)) {
             ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d"", *pValueSize);
  return -EINVAL;
  }
  *pValueSize = 2 * sizeof(int16_t);
  break;
  case EQ_PARAM_BAND_FREQ_RANGE:
  if (*pValueSize < 2 * sizeof(int32_t)) {
             ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d"", *pValueSize);
  return -EINVAL;
  }
  *pValueSize = 2 * sizeof(int32_t);
  break;
 
  case EQ_PARAM_CENTER_FREQ:
  if (*pValueSize < sizeof(int32_t)) {
             ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d"", *pValueSize);
  return -EINVAL;
  }
  *pValueSize = sizeof(int32_t);
  break;
 
  case EQ_PARAM_GET_PRESET_NAME:
  break;
 
  case EQ_PARAM_PROPERTIES:
  if (*pValueSize < (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t)) {
             ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize);
  return -EINVAL;
  }
  *pValueSize = (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t);
  break;
 
  default:
         ALOGV(""\tLVM_ERROR : Equalizer_getParameter unknown param %d"", param);
  return -EINVAL;
  }
 
  switch (param) {
  case EQ_PARAM_NUM_BANDS:
  *(uint16_t *)pValue = (uint16_t)FIVEBAND_NUMBANDS;
  break;
 
  case EQ_PARAM_LEVEL_RANGE:
  *(int16_t *)pValue = -1500;
  *((int16_t *)pValue + 1) = 1500;
  break;
 
  
      case EQ_PARAM_BAND_LEVEL:
          param2 = *pParamTemp;
        if (param2 >= FIVEBAND_NUMBANDS) {
         if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
              status = -EINVAL;
             if (param2 < 0) {
                 android_errorWriteLog(0x534e4554, ""32438598"");
                 ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", param2);
             }
              break;
          }
          *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);
  break;
 
  
      case EQ_PARAM_CENTER_FREQ:
          param2 = *pParamTemp;
        if (param2 >= FIVEBAND_NUMBANDS) {
         if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
              status = -EINVAL;
             if (param2 < 0) {
                 android_errorWriteLog(0x534e4554, ""32436341"");
                 ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", param2);
             }
              break;
          }
          *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);
  break;
 
  
      case EQ_PARAM_BAND_FREQ_RANGE:
          param2 = *pParamTemp;
        if (param2 >= FIVEBAND_NUMBANDS) {
         if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
              status = -EINVAL;
             if (param2 < 0) {
                 android_errorWriteLog(0x534e4554, ""32247948"");
                 ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
             }
              break;
          }
          EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));
  break;
 
  case EQ_PARAM_GET_BAND:
         param2 = *pParamTemp;
  *(uint16_t *)pValue = (uint16_t)EqualizerGetBand(pContext, param2);
  break;
 
  case EQ_PARAM_CUR_PRESET:
  *(uint16_t *)pValue = (uint16_t)EqualizerGetPreset(pContext);
  break;
 
  case EQ_PARAM_GET_NUM_OF_PRESETS:
  *(uint16_t *)pValue = (uint16_t)EqualizerGetNumPresets();
  break;
 
  case EQ_PARAM_GET_PRESET_NAME:
         param2 = *pParamTemp;
  if (param2 >= EqualizerGetNumPresets()) {
             status = -EINVAL;
  break;
  }
         name = (char *)pValue;
         strncpy(name, EqualizerGetPresetName(param2), *pValueSize - 1);
         name[*pValueSize - 1] = 0;
  *pValueSize = strlen(name) + 1;
  break;
 
  case EQ_PARAM_PROPERTIES: {
  int16_t *p = (int16_t *)pValue;
         ALOGV(""\tEqualizer_getParameter() EQ_PARAM_PROPERTIES"");
         p[0] = (int16_t)EqualizerGetPreset(pContext);
         p[1] = (int16_t)FIVEBAND_NUMBANDS;
  for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
             p[2 + i] = (int16_t)EqualizerGetBandLevel(pContext, i);
  }
  } break;
 
  default:
         ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid param %d"", param);
         status = -EINVAL;
  break;
  }
 
  return status;
 }  
 
 int Equalizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){
  int status = 0;
  int32_t preset;
  int32_t band;
  int32_t level;
  int32_t *pParamTemp = (int32_t *)pParam;
  int32_t param = *pParamTemp++;
 
 
  switch (param) {
  case EQ_PARAM_CUR_PRESET:
         preset = (int32_t)(*(uint16_t *)pValue);
 
  if ((preset >= EqualizerGetNumPresets())||(preset < 0)) {
             status = -EINVAL;
  break;
  }
  EqualizerSetPreset(pContext, preset);
  break;
  case EQ_PARAM_BAND_LEVEL:
         band = *pParamTemp;
         level = (int32_t)(*(int16_t *)pValue);
  if (band >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
  break;
  }
  EqualizerSetBandLevel(pContext, band, level);
  break;
  case EQ_PARAM_PROPERTIES: {
  int16_t *p = (int16_t *)pValue;
  if ((int)p[0] >= EqualizerGetNumPresets()) {
             status = -EINVAL;
  break;
  }
  if (p[0] >= 0) {
  EqualizerSetPreset(pContext, (int)p[0]);
  } else {
  if ((int)p[1] != FIVEBAND_NUMBANDS) {
                 status = -EINVAL;
  break;
  }
  for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
  EqualizerSetBandLevel(pContext, i, (int)p[2 + i]);
  }
  }
  } break;
  default:
         ALOGV(""\tLVM_ERROR : Equalizer_setParameter() invalid param %d"", param);
         status = -EINVAL;
  break;
  }
 
  return status;
 }  
 
 
 int Volume_getParameter(EffectContext *pContext,
  void *pParam,
  uint32_t *pValueSize,
  void *pValue){
  int status = 0;
  int bMute = 0;
  int32_t *pParamTemp = (int32_t *)pParam;
  int32_t param = *pParamTemp++;;
  char *name;
 
 
  switch (param){
  case VOLUME_PARAM_LEVEL:
  case VOLUME_PARAM_MAXLEVEL:
  case VOLUME_PARAM_STEREOPOSITION:
  if (*pValueSize != sizeof(int16_t)){
                 ALOGV(""\tLVM_ERROR : Volume_getParameter() invalid pValueSize 1  %d"", *pValueSize);
  return -EINVAL;
  }
  *pValueSize = sizeof(int16_t);
  break;
 
  case VOLUME_PARAM_MUTE:
  case VOLUME_PARAM_ENABLESTEREOPOSITION:
  if (*pValueSize < sizeof(int32_t)){
                 ALOGV(""\tLVM_ERROR : Volume_getParameter() invalid pValueSize 2  %d"", *pValueSize);
  return -EINVAL;
  }
  *pValueSize = sizeof(int32_t);
  break;
 
  default:
             ALOGV(""\tLVM_ERROR : Volume_getParameter unknown param %d"", param);
  return -EINVAL;
  }
 
  switch (param){
  case VOLUME_PARAM_LEVEL:
             status = VolumeGetVolumeLevel(pContext, (int16_t *)(pValue));
  break;
 
  case VOLUME_PARAM_MAXLEVEL:
  *(int16_t *)pValue = 0;
  break;
 
  case VOLUME_PARAM_STEREOPOSITION:
  VolumeGetStereoPosition(pContext, (int16_t *)pValue);
  break;
 
  case VOLUME_PARAM_MUTE:
             status = VolumeGetMute(pContext, (uint32_t *)pValue);
             ALOGV(""\tVolume_getParameter() VOLUME_PARAM_MUTE Value is %d"",
  *(uint32_t *)pValue);
  break;
 
  case VOLUME_PARAM_ENABLESTEREOPOSITION:
  *(int32_t *)pValue = pContext->pBundledContext->bStereoPositionEnabled;
  break;
 
  default:
             ALOGV(""\tLVM_ERROR : Volume_getParameter() invalid param %d"", param);
             status = -EINVAL;
  break;
  }
 
  return status;
 }  
 
 
 
 int Volume_setParameter (EffectContext *pContext, void *pParam, void *pValue){
  int      status = 0;
  int16_t  level;
  int16_t  position;
  uint32_t mute;
  uint32_t positionEnabled;
  int32_t *pParamTemp = (int32_t *)pParam;
  int32_t param = *pParamTemp++;
 
 
  switch (param){
  case VOLUME_PARAM_LEVEL:
             level = *(int16_t *)pValue;
             status = VolumeSetVolumeLevel(pContext, (int16_t)level);
  break;
 
  case VOLUME_PARAM_MUTE:
             mute = *(uint32_t *)pValue;
             status = VolumeSetMute(pContext, mute);
  break;
 
  case VOLUME_PARAM_ENABLESTEREOPOSITION:
             positionEnabled = *(uint32_t *)pValue;
             status = VolumeEnableStereoPosition(pContext, positionEnabled);
             status = VolumeSetStereoPosition(pContext, pContext->pBundledContext->positionSaved);
  break;
 
  case VOLUME_PARAM_STEREOPOSITION:
             position = *(int16_t *)pValue;
             status = VolumeSetStereoPosition(pContext, (int16_t)position);
  break;
 
  default:
             ALOGV(""\tLVM_ERROR : Volume_setParameter() invalid param %d"", param);
  break;
  }
 
  return status;
 }  
 
  
 
 LVM_INT16 LVC_ToDB_s32Tos16(LVM_INT32 Lin_fix)
 {
     LVM_INT16   db_fix;
     LVM_INT16   Shift;
     LVM_INT16   SmallRemainder;
     LVM_UINT32  Remainder = (LVM_UINT32)Lin_fix;
 
   
  for (Shift = 0; Shift<32; Shift++)
  {
  if ((Remainder & 0x80000000U)!=0)
  {
  break;
  }
  Remainder = Remainder << 1;
  }
 
   
     db_fix    = (LVM_INT16)(-96 * Shift);  
  SmallRemainder = (LVM_INT16)((Remainder & 0x7fffffff) >> 24);
     db_fix = (LVM_INT16)(db_fix + SmallRemainder );
  SmallRemainder = (LVM_INT16)(SmallRemainder * SmallRemainder);
     db_fix = (LVM_INT16)(db_fix - (LVM_INT16)((LVM_UINT16)SmallRemainder >> 9));
 
   
     db_fix = (LVM_INT16)(db_fix - 5);
 
  return db_fix;
 }
 
 
 int Effect_setEnabled(EffectContext *pContext, bool enabled)
 {
     ALOGV(""\tEffect_setEnabled() type %d, enabled %d"", pContext->EffectType, enabled);
 
  if (enabled) {
  bool tempDisabled = false;
  switch (pContext->EffectType) {
  case LVM_BASS_BOOST:
  if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {
                      ALOGV(""\tEffect_setEnabled() LVM_BASS_BOOST is already enabled"");
  return -EINVAL;
  }
  if(pContext->pBundledContext->SamplesToExitCountBb <= 0){
                     pContext->pBundledContext->NumberEffectsEnabled++;
  }
                 pContext->pBundledContext->SamplesToExitCountBb =
  (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                 pContext->pBundledContext->bBassEnabled = LVM_TRUE;
                 tempDisabled = pContext->pBundledContext->bBassTempDisabled;
  break;
  case LVM_EQUALIZER:
  if (pContext->pBundledContext->bEqualizerEnabled == LVM_TRUE) {
                     ALOGV(""\tEffect_setEnabled() LVM_EQUALIZER is already enabled"");
  return -EINVAL;
  }
  if(pContext->pBundledContext->SamplesToExitCountEq <= 0){
                     pContext->pBundledContext->NumberEffectsEnabled++;
  }
                 pContext->pBundledContext->SamplesToExitCountEq =
  (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                 pContext->pBundledContext->bEqualizerEnabled = LVM_TRUE;
  break;
  case LVM_VIRTUALIZER:
  if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {
                     ALOGV(""\tEffect_setEnabled() LVM_VIRTUALIZER is already enabled"");
  return -EINVAL;
  }
  if(pContext->pBundledContext->SamplesToExitCountVirt <= 0){
                     pContext->pBundledContext->NumberEffectsEnabled++;
  }
                 pContext->pBundledContext->SamplesToExitCountVirt =
  (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);
                 pContext->pBundledContext->bVirtualizerEnabled = LVM_TRUE;
                 tempDisabled = pContext->pBundledContext->bVirtualizerTempDisabled;
  break;
  case LVM_VOLUME:
  if (pContext->pBundledContext->bVolumeEnabled == LVM_TRUE) {
                     ALOGV(""\tEffect_setEnabled() LVM_VOLUME is already enabled"");
  return -EINVAL;
  }
                 pContext->pBundledContext->NumberEffectsEnabled++;
                 pContext->pBundledContext->bVolumeEnabled = LVM_TRUE;
  break;
  default:
                 ALOGV(""\tEffect_setEnabled() invalid effect type"");
  return -EINVAL;
  }
  if (!tempDisabled) {
  LvmEffect_enable(pContext);
  }
  } else {
  switch (pContext->EffectType) {
  case LVM_BASS_BOOST:
  if (pContext->pBundledContext->bBassEnabled == LVM_FALSE) {
                     ALOGV(""\tEffect_setEnabled() LVM_BASS_BOOST is already disabled"");
  return -EINVAL;
  }
                 pContext->pBundledContext->bBassEnabled = LVM_FALSE;
  break;
  case LVM_EQUALIZER:
  if (pContext->pBundledContext->bEqualizerEnabled == LVM_FALSE) {
                     ALOGV(""\tEffect_setEnabled() LVM_EQUALIZER is already disabled"");
  return -EINVAL;
  }
                 pContext->pBundledContext->bEqualizerEnabled = LVM_FALSE;
  break;
  case LVM_VIRTUALIZER:
  if (pContext->pBundledContext->bVirtualizerEnabled == LVM_FALSE) {
                     ALOGV(""\tEffect_setEnabled() LVM_VIRTUALIZER is already disabled"");
  return -EINVAL;
  }
                 pContext->pBundledContext->bVirtualizerEnabled = LVM_FALSE;
  break;
  case LVM_VOLUME:
  if (pContext->pBundledContext->bVolumeEnabled == LVM_FALSE) {
                     ALOGV(""\tEffect_setEnabled() LVM_VOLUME is already disabled"");
  return -EINVAL;
  }
                 pContext->pBundledContext->bVolumeEnabled = LVM_FALSE;
  break;
  default:
                 ALOGV(""\tEffect_setEnabled() invalid effect type"");
  return -EINVAL;
  }
  LvmEffect_disable(pContext);
  }
 
  return 0;
 }
 
 
 int16_t LVC_Convert_VolToDb(uint32_t vol){
  int16_t  dB;
 
     dB = LVC_ToDB_s32Tos16(vol <<7);
     dB = (dB +8)>>4;
     dB = (dB <-96) ? -96 : dB ;
 
  return dB;
 }
 
 }  ","[79, 81, 82, 83, 84, 94, 96, 97, 98, 99, 109, 111, 112, 113, 114, 78, 93, 108]","An information disclosure vulnerability in lvm/wrapper/Bundle/EffectBundle.cpp in libeffects in Audioserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32436341."
205702,"   void AddChunk(const TransformPaintPropertyNode* t,
                const ClipPaintPropertyNode* c,
                const EffectPaintPropertyNode* e,
   void AddChunk(const TransformPaintPropertyNode& t,
                 const ClipPaintPropertyNode& c,
                 const EffectPaintPropertyNode& e,
                  const FloatRect& bounds = FloatRect(0, 0, 100, 100)) {
      auto record = sk_make_sp<PaintRecord>();
      record->push<cc::DrawRectOp>(bounds, cc::PaintFlags());
     AddChunk(std::move(record), t, c, e, bounds);
   }","[4, 5, 6, 2, 3]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
201971," MagickExport MagickBooleanType SetQuantumDepth(const Image *image,
   QuantumInfo *quantum_info,const size_t depth)
 {
   size_t
     extent,
     quantum;
 
    
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   assert(quantum_info != (QuantumInfo *) NULL);
   assert(quantum_info->signature == MagickCoreSignature);
   quantum_info->depth=depth;
   if (quantum_info->format == FloatingPointQuantumFormat)
     {
       if (quantum_info->depth > 32)
         quantum_info->depth=64;
       else
         if (quantum_info->depth > 16)
           quantum_info->depth=32;
         else
           quantum_info->depth=16;
     }
    if (quantum_info->pixels != (unsigned char **) NULL)
      DestroyQuantumPixels(quantum_info);
    quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;
  extent=image->columns*quantum;
  if ((image->columns != 0) && (quantum != (extent/image->columns)))
   extent=MagickMax(image->columns,image->rows)*quantum;
   if ((MagickMax(image->columns,image->rows) != 0) &&
       (quantum != (extent/MagickMax(image->columns,image->rows))))
      return(MagickFalse);
    return(AcquireQuantumPixels(quantum_info,extent));
  }","[31, 32, 33, 29, 30]",The quantum handling code in ImageMagick allows remote attackers to cause a denial of service (divide-by-zero error or out-of-bounds write) via a crafted file.
202204," _bson_iter_next_internal (bson_iter_t *iter,     
                           uint32_t next_keylen,  
                           const char **key,      
                           uint32_t *bson_type,   
                           bool *unsupported)     
 {
    const uint8_t *data;
    uint32_t o;
    unsigned int len;
 
    BSON_ASSERT (iter);
 
    *unsupported = false;
 
    if (!iter->raw) {
       *key = NULL;
       *bson_type = BSON_TYPE_EOD;
       return false;
    }
 
    data = iter->raw;
    len = iter->len;
 
    iter->off = iter->next_off;
    iter->type = iter->off;
    iter->key = iter->off + 1;
    iter->d1 = 0;
    iter->d2 = 0;
    iter->d3 = 0;
    iter->d4 = 0;
 
    if (next_keylen == 0) {
        
       for (o = iter->key; o < len; o++) {
          if (!data[o]) {
             iter->d1 = ++o;
             goto fill_data_fields;
          }
       }
    } else {
       o = iter->key + next_keylen + 1;
       iter->d1 = o;
       goto fill_data_fields;
    }
 
    goto mark_invalid;
 
 fill_data_fields:
 
    *key = bson_iter_key_unsafe (iter);
    *bson_type = ITER_TYPE (iter);
 
    switch (*bson_type) {
    case BSON_TYPE_DATE_TIME:
    case BSON_TYPE_DOUBLE:
    case BSON_TYPE_INT64:
    case BSON_TYPE_TIMESTAMP:
       iter->next_off = o + 8;
       break;
    case BSON_TYPE_CODE:
    case BSON_TYPE_SYMBOL:
    case BSON_TYPE_UTF8: {
       uint32_t l;
 
       if ((o + 4) >= len) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->d2 = o + 4;
       memcpy (&l, iter->raw + iter->d1, sizeof (l));
       l = BSON_UINT32_FROM_LE (l);
 
       if (l > (len - (o + 4))) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->next_off = o + 4 + l;
 
        
       if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
        
       if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\0')) {
          iter->err_off = o + 4 + l - 1;
          goto mark_invalid;
       }
    } break;
    case BSON_TYPE_BINARY: {
       bson_subtype_t subtype;
       uint32_t l;
 
       if (o >= (len - 4)) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->d2 = o + 4;
       iter->d3 = o + 5;
 
        memcpy (&l, iter->raw + iter->d1, sizeof (l));
        l = BSON_UINT32_FROM_LE (l);
  
      if (l >= (len - o)) {
       if (l >= (len - o - 4)) {
           iter->err_off = o;
           goto mark_invalid;
        }
 
       subtype = *(iter->raw + iter->d2);
 
       if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {
          int32_t binary_len;
 
          if (l < 4) {
             iter->err_off = o;
             goto mark_invalid;
          }
 
           
          memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));
          binary_len = BSON_UINT32_FROM_LE (binary_len);
          if (binary_len + 4 != l) {
             iter->err_off = iter->d3;
             goto mark_invalid;
          }
       }
 
       iter->next_off = o + 5 + l;
    } break;
    case BSON_TYPE_ARRAY:
    case BSON_TYPE_DOCUMENT: {
       uint32_t l;
 
       if (o >= (len - 4)) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       memcpy (&l, iter->raw + iter->d1, sizeof (l));
       l = BSON_UINT32_FROM_LE (l);
 
       if ((l > len) || (l > (len - o))) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->next_off = o + l;
    } break;
    case BSON_TYPE_OID:
       iter->next_off = o + 12;
       break;
    case BSON_TYPE_BOOL: {
       char val;
 
       if (iter->d1 >= len) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       memcpy (&val, iter->raw + iter->d1, 1);
       if (val != 0x00 && val != 0x01) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->next_off = o + 1;
    } break;
    case BSON_TYPE_REGEX: {
       bool eor = false;
       bool eoo = false;
 
       for (; o < len; o++) {
          if (!data[o]) {
             iter->d2 = ++o;
             eor = true;
             break;
          }
       }
 
       if (!eor) {
          iter->err_off = iter->next_off;
          goto mark_invalid;
       }
 
       for (; o < len; o++) {
          if (!data[o]) {
             eoo = true;
             break;
          }
       }
 
       if (!eoo) {
          iter->err_off = iter->next_off;
          goto mark_invalid;
       }
 
       iter->next_off = o + 1;
    } break;
    case BSON_TYPE_DBPOINTER: {
       uint32_t l;
 
       if (o >= (len - 4)) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->d2 = o + 4;
       memcpy (&l, iter->raw + iter->d1, sizeof (l));
       l = BSON_UINT32_FROM_LE (l);
 
        
       if (l == 0 || l > (len - o - 4)) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       if (*(iter->raw + o + l + 3)) {
           
          iter->err_off = o + l + 3;
          goto mark_invalid;
       }
 
       iter->d3 = o + 4 + l;
       iter->next_off = o + 4 + l + 12;
    } break;
    case BSON_TYPE_CODEWSCOPE: {
       uint32_t l;
       uint32_t doclen;
 
       if ((len < 19) || (o >= (len - 14))) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->d2 = o + 4;
       iter->d3 = o + 8;
 
       memcpy (&l, iter->raw + iter->d1, sizeof (l));
       l = BSON_UINT32_FROM_LE (l);
 
       if ((l < 14) || (l >= (len - o))) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       iter->next_off = o + l;
 
       if (iter->next_off >= len) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       memcpy (&l, iter->raw + iter->d2, sizeof (l));
       l = BSON_UINT32_FROM_LE (l);
 
       if (l == 0 || l >= (len - o - 4 - 4)) {
          iter->err_off = o;
          goto mark_invalid;
       }
 
       if ((o + 4 + 4 + l + 4) >= iter->next_off) {
          iter->err_off = o + 4;
          goto mark_invalid;
       }
 
       iter->d4 = o + 4 + 4 + l;
       memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));
       doclen = BSON_UINT32_FROM_LE (doclen);
 
       if ((o + 4 + 4 + l + doclen) != iter->next_off) {
          iter->err_off = o + 4 + 4 + l;
          goto mark_invalid;
       }
    } break;
    case BSON_TYPE_INT32:
       iter->next_off = o + 4;
       break;
    case BSON_TYPE_DECIMAL128:
       iter->next_off = o + 16;
       break;
    case BSON_TYPE_MAXKEY:
    case BSON_TYPE_MINKEY:
    case BSON_TYPE_NULL:
    case BSON_TYPE_UNDEFINED:
       iter->next_off = o;
       break;
    default:
       *unsupported = true;
     
    case BSON_TYPE_EOD:
       iter->err_off = o;
       goto mark_invalid;
    }
 
     
    if (iter->next_off >= len) {
       iter->err_off = o;
       goto mark_invalid;
    }
 
    iter->err_off = 0;
 
    return true;
 
 mark_invalid:
    iter->raw = NULL;
    iter->len = 0;
    iter->next_off = 0;
 
    return false;
 }","[109, 108]","_bson_iter_next_internal in bson-iter.c in libbson 1.12.0, as used in MongoDB mongo-c-driver and other products, has a heap-based buffer over-read via a crafted bson buffer."
201148," static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;
 
   register const IndexPacket
     *indexes;
 
   register const PixelPacket
     *p;
 
   register ssize_t
     i,
     x;
 
   register unsigned char
     *q;
 
   size_t
     depth,
     packet_size;
 
   ssize_t
     y;
 
   unsigned char
     *colormap,
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
    
   if (IsPaletteImage(image,&image->exception) == MagickFalse)
     (void) SetImageType(image,PaletteType);
   depth=GetImageQuantumDepth(image,MagickTrue);
   packet_size=(size_t) (depth/8);
   pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*
     sizeof(*pixels));
   packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);
   colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*
      sizeof(*colormap));
    if ((pixels == (unsigned char *) NULL) ||
        (colormap == (unsigned char *) NULL))
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
     {
       if (colormap != (unsigned char *) NULL)
         colormap=(unsigned char *) RelinquishMagickMemory(colormap);
       if (pixels != (unsigned char *) NULL)
         pixels=(unsigned char *) RelinquishMagickMemory(pixels);
       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
     }
     
    q=colormap;
  q=colormap;
    if (image->colors <= 256)
      for (i=0; i < (ssize_t) image->colors; i++)
      {
       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);
       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);
       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);
     }
   else
     for (i=0; i < (ssize_t) image->colors; i++)
     {
        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);
        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);
        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);
      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &
         0xff);
        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);
      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &
         0xff);
      }
    (void) WriteBlob(image,packet_size*image->colors,colormap);
    colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     indexes=GetVirtualIndexQueue(image);
     q=pixels;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       if (image->colors > 256)
         *q++=(unsigned char) ((size_t) GetPixelIndex(indexes+x) >> 8);
       *q++=(unsigned char) GetPixelIndex(indexes+x);
     }
     (void) WriteBlob(image,(size_t) (q-pixels),pixels);
   }
   pixels=(unsigned char *) RelinquishMagickMemory(pixels);
   (void) CloseBlob(image);
   return(status);
 }","[54, 55, 56, 57, 58, 59, 60, 78, 79, 82, 83, 53, 63, 77, 81]",ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteMAPImage in coders/map.c.
206570," void AcceleratedStaticBitmapImage::Draw(cc::PaintCanvas* canvas,
                                         const cc::PaintFlags& flags,
                                         const FloatRect& dst_rect,
                                         const FloatRect& src_rect,
                                          RespectImageOrientationEnum,
                                          ImageClampingMode image_clamping_mode,
                                          ImageDecodingMode decode_mode) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
    auto paint_image = PaintImageForCurrentFrame();
    if (!paint_image)
      return;
   auto paint_image_decoding_mode = ToPaintImageDecodingMode(decode_mode);
   if (paint_image.decoding_mode() != paint_image_decoding_mode) {
     paint_image = PaintImageBuilder::WithCopy(std::move(paint_image))
                       .set_decoding_mode(paint_image_decoding_mode)
                       .TakePaintImage();
   }
   StaticBitmapImage::DrawHelper(canvas, flags, dst_rect, src_rect,
                                 image_clamping_mode, paint_image);
 }",[8],"Incorrect, thread-unsafe use of SkImage in Canvas in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
9389,"flatpak_context_merge (FlatpakContext *context,
FlatpakContext *other)
{
GHashTableIter iter;
gpointer key, value;

context->shares &= ~other->shares_valid;
context->shares |= other->shares;
context->shares_valid |= other->shares_valid;
context->sockets &= ~other->sockets_valid;
context->sockets |= other->sockets;
context->sockets_valid |= other->sockets_valid;
context->devices &= ~other->devices_valid;
context->devices |= other->devices;
context->devices_valid |= other->devices_valid;
context->features &= ~other->features_valid;
context->features |= other->features;
context->features_valid |= other->features_valid;

g_hash_table_iter_init (&iter, other->env_vars);
while (g_hash_table_iter_next (&iter, &key, &value))
g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));

g_hash_table_iter_init (&iter, other->persistent);
while (g_hash_table_iter_next (&iter, &key, &value))
g_hash_table_insert (context->persistent, g_strdup (key), value);

g_hash_table_iter_init (&iter, other->filesystems);
while (g_hash_table_iter_next (&iter, &key, &value))
g_hash_table_insert (context->filesystems, g_strdup (key), value);

g_hash_table_iter_init (&iter, other->session_bus_policy);
while (g_hash_table_iter_next (&iter, &key, &value))
g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);

g_hash_table_iter_init (&iter, other->system_bus_policy);
while (g_hash_table_iter_next (&iter, &key, &value))
g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);

g_hash_table_iter_init (&iter, other->system_bus_policy);
while (g_hash_table_iter_next (&iter, &key, &value))
g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);

g_hash_table_iter_init (&iter, other->generic_policy);
while (g_hash_table_iter_next (&iter, &key, &value))
{
const char **policy_values = (const char **) value;
int i;

for (i = 0; policy_values[i] != NULL; i++)
flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);
}
}","[7, 28]","Flatpak is a Linux application sandboxing and distribution framework. A path traversal vulnerability affects versions of Flatpak prior to 1.12.3 and 1.10.6. flatpak-builder applies `finish-args` last in the build. At this point the build directory will have the full access that is specified in the manifest, so running `flatpak build` against it will gain those permissions. Normally this will not be done, so this is not problem. However, if `--mirror-screenshots-url` is specified, then flatpak-builder will launch `flatpak build --nofilesystem=host appstream-utils mirror-screenshots` after finalization, which can lead to issues even with the `--nofilesystem=host` protection. In normal use, the only issue is that these empty directories can be created wherever the user has write permissions. However, a malicious application could replace the `appstream-util` binary and potentially do something more hostile. This has been resolved in Flatpak 1.12.3 and 1.10.6 by changing the behaviour of `--nofilesystem=home` and `--nofilesystem=host`."
200703," static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...)  
 {
 	va_list va;
 	char *message = NULL;
 
 	va_start(va, format);
  	zend_vspprintf(&message, 0, format, va);
  
  	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, message);
 		zend_throw_error(exception_ce, ""%s"", message);
  	} else {
  		zend_error(E_ERROR, ""%s"", message);
  	}
 
 	efree(message);
 	va_end(va);
 }
  ","[11, 10]","Format string vulnerability in the zend_throw_or_error function in Zend/zend_execute_API.c in PHP 7.x before 7.0.1 allows remote attackers to execute arbitrary code via format string specifiers in a string that is misused as a class name, leading to incorrect error handling."
207525," OMX_ERRORTYPE  omx_video::use_input_buffer(
         OMX_IN OMX_HANDLETYPE            hComp,
         OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,
         OMX_IN OMX_U32                   port,
         OMX_IN OMX_PTR                   appData,
         OMX_IN OMX_U32                   bytes,
         OMX_IN OMX_U8*                   buffer)
 {
  (void) hComp;
     OMX_ERRORTYPE eRet = OMX_ErrorNone;
 
  unsigned   i = 0;
  unsigned char *buf_addr = NULL;
 
     DEBUG_PRINT_HIGH(""use_input_buffer: port = %u appData = %p bytes = %u buffer = %p"",(unsigned int)port,appData,(unsigned int)bytes,buffer);
  if (bytes != m_sInPortDef.nBufferSize) {
         DEBUG_PRINT_ERROR(""ERROR: use_input_buffer: Size Mismatch!! ""
  ""bytes[%u] != Port.nBufferSize[%u]"", (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);
  return OMX_ErrorBadParameter;
  }
 
  if (!m_inp_mem_ptr) {
         input_use_buffer = true;
         m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \
                         calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);
  if (m_inp_mem_ptr == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_inp_mem_ptr"");
  return OMX_ErrorInsufficientResources;
  }
         DEBUG_PRINT_LOW(""Successfully allocated m_inp_mem_ptr = %p"", m_inp_mem_ptr);
 
 
         m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);
  if (m_pInput_pmem == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_pInput_pmem"");
  return OMX_ErrorInsufficientResources;
  }
 #ifdef USE_ION
         m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);
  if (m_pInput_ion == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_pInput_ion"");
  return OMX_ErrorInsufficientResources;
  }
 #endif
 
  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {
             m_pInput_pmem[i].fd = -1;
 #ifdef USE_ION
             m_pInput_ion[i].ion_device_fd =-1;
             m_pInput_ion[i].fd_ion_data.fd =-1;
             m_pInput_ion[i].ion_alloc_data.handle = 0;
 #endif
  }
 
  }
 
  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {
  if (BITMASK_ABSENT(&m_inp_bm_count,i)) {
  break;
  }
  }
 
  if (i < m_sInPortDef.nBufferCountActual) {
 
  *bufferHdr = (m_inp_mem_ptr + i);
         BITMASK_SET(&m_inp_bm_count,i);
 
  (*bufferHdr)->pBuffer           = (OMX_U8 *)buffer;
  (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);
  (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;
  (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;
  (*bufferHdr)->pAppPrivate       = appData;
  (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;
 
  if (!m_use_input_pmem) {
 #ifdef USE_ION
 #ifdef _MSM8974_
             m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,
  &m_pInput_ion[i].ion_alloc_data,
  &m_pInput_ion[i].fd_ion_data,0);
 #else
             m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,
  &m_pInput_ion[i].ion_alloc_data,
  &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);
 #endif
  if (m_pInput_ion[i].ion_device_fd < 0) {
                 DEBUG_PRINT_ERROR(""ERROR:ION device open() Failed"");
  return OMX_ErrorInsufficientResources;
  }
             m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;
 #else
             m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
  if (m_pInput_pmem[i].fd == 0) {
                 m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
  }
 
  if (m_pInput_pmem[i] .fd < 0) {
                 DEBUG_PRINT_ERROR(""ERROR: /dev/pmem_adsp open() Failed"");
  return OMX_ErrorInsufficientResources;
  }
 #endif
 
              m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;
              m_pInput_pmem[i].offset = 0;
  
            m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;
             m_pInput_pmem[i].buffer = NULL;
              if(!secure_session) {
                  m_pInput_pmem[i].buffer = (unsigned char *)mmap(
                      NULL,m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,
                     MAP_SHARED,m_pInput_pmem[i].fd,0);
 
  
              if (m_pInput_pmem[i].buffer == MAP_FAILED) {
                      DEBUG_PRINT_ERROR(""ERROR: mmap() Failed"");
                 m_pInput_pmem[i].buffer = NULL;
                  close(m_pInput_pmem[i].fd);
  #ifdef USE_ION
                  free_ion_memory(&m_pInput_ion[i]);
 #endif
  return OMX_ErrorInsufficientResources;
  }
  }
 
  } else {
             OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *pParam = reinterpret_cast<OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *>((*bufferHdr)->pAppPrivate);
             DEBUG_PRINT_LOW(""Inside qcom_ext with luma:(fd:%lu,offset:0x%x)"", pParam->pmem_fd, (unsigned)pParam->offset);
 
  if (pParam) {
                 m_pInput_pmem[i].fd = pParam->pmem_fd;
                 m_pInput_pmem[i].offset = pParam->offset;
                 m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;
                 m_pInput_pmem[i].buffer = (unsigned char *)buffer;
                 DEBUG_PRINT_LOW(""DBG:: pParam->pmem_fd = %u, pParam->offset = %u"",
  (unsigned int)pParam->pmem_fd, (unsigned int)pParam->offset);
  } else {
                 DEBUG_PRINT_ERROR(""ERROR: Invalid AppData given for PMEM i/p UseBuffer case"");
  return OMX_ErrorBadParameter;
  }
  }
 
         DEBUG_PRINT_LOW(""use_inp:: bufhdr = %p, pBuffer = %p, m_pInput_pmem[i].buffer = %p"",
  (*bufferHdr), (*bufferHdr)->pBuffer, m_pInput_pmem[i].buffer);
  if ( dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true) {
             DEBUG_PRINT_ERROR(""ERROR: dev_use_buf() Failed for i/p buf"");
  return OMX_ErrorInsufficientResources;
  }
  } else {
         DEBUG_PRINT_ERROR(""ERROR: All buffers are already used, invalid use_buf call for ""
  ""index = %u"", i);
         eRet = OMX_ErrorInsufficientResources;
  }
 
  return eRet;
 }","[107, 116, 106]","The secure-session feature in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 mishandles heap pointers, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 28920116."
200917,"  logger_get_mask_expanded (struct t_gui_buffer *buffer, const char *mask)
  {
    char *mask2, *mask_decoded, *mask_decoded2, *mask_decoded3, *mask_decoded4;
    char *mask_decoded5;
     char *mask2, *mask3, *mask4, *mask5, *mask6, *mask7;
      const char *dir_separator;
      int length;
      time_t seconds;
      struct tm *date_tmp;
  
      mask2 = NULL;
    mask_decoded = NULL;
    mask_decoded2 = NULL;
    mask_decoded3 = NULL;
    mask_decoded4 = NULL;
    mask_decoded5 = NULL;
     mask3 = NULL;
     mask4 = NULL;
     mask5 = NULL;
     mask6 = NULL;
     mask7 = NULL;
  
      dir_separator = weechat_info_get (""dir_separator"", """");
      if (!dir_separator)
          return NULL;
  
      
    mask2 = weechat_string_replace (mask, dir_separator, ""\01"");
      
     length = strlen (mask) + 256 + 1;
     mask2 = malloc (length);
     if (!mask2)
         goto end;
     seconds = time (NULL);
     date_tmp = localtime (&seconds);
     mask2[0] = '\0';
     if (strftime (mask2, length - 1, mask, date_tmp) == 0)
         mask2[0] = '\0';
 
       
     mask3 = weechat_string_replace (mask2, dir_separator, ""\01"");
     if (!mask3)
          goto end;
  
    mask_decoded = weechat_buffer_string_replace_local_var (buffer, mask2);
    if (!mask_decoded)
     mask4 = weechat_buffer_string_replace_local_var (buffer, mask3);
     if (!mask4)
          goto end;
  
    mask_decoded2 = weechat_string_replace (mask_decoded,
                                            dir_separator,
                                            weechat_config_string (logger_config_file_replacement_char));
    if (!mask_decoded2)
     mask5 = weechat_string_replace (mask4,
                                     dir_separator,
                                     weechat_config_string (logger_config_file_replacement_char));
     if (!mask5)
          goto end;
  
  #ifdef __CYGWIN__
    mask_decoded3 = weechat_string_replace (mask_decoded2, ""\\"",
                                            weechat_config_string (logger_config_file_replacement_char));
     mask6 = weechat_string_replace (mask5, ""\\"",
                                     weechat_config_string (logger_config_file_replacement_char));
  #else
    mask_decoded3 = strdup (mask_decoded2);
     mask6 = strdup (mask5);
  #endif  
    if (!mask_decoded3)
     if (!mask6)
          goto end;
  
       
    mask_decoded4 = weechat_string_replace (mask_decoded3,
                                            ""\01"", dir_separator);
    if (!mask_decoded4)
        goto end;
     
    length = strlen (mask_decoded4) + 256 + 1;
    mask_decoded5 = malloc (length);
    if (!mask_decoded5)
     mask7 = weechat_string_replace (mask6,
                                     ""\01"", dir_separator);
     if (!mask7)
          goto end;
    seconds = time (NULL);
    date_tmp = localtime (&seconds);
    mask_decoded5[0] = '\0';
    strftime (mask_decoded5, length - 1, mask_decoded4, date_tmp);
  
       
      if (weechat_config_boolean (logger_config_file_name_lower_case))
        weechat_string_tolower (mask_decoded5);
         weechat_string_tolower (mask7);
  
      if (weechat_logger_plugin->debug)
      {
         weechat_printf_date_tags (NULL, 0, ""no_log"",
                                   ""%s: buffer = \""%s\"", mask = \""%s\"", ""
                                    ""decoded mask = \""%s\"""",
                                    LOGGER_PLUGIN_NAME,
                                    weechat_buffer_get_string (buffer, ""name""),
                                  mask, mask_decoded5);
                                   mask, mask7);
      }
  
  end:
      if (mask2)
          free (mask2);
    if (mask_decoded)
        free (mask_decoded);
    if (mask_decoded2)
        free (mask_decoded2);
    if (mask_decoded3)
        free (mask_decoded3);
    if (mask_decoded4)
        free (mask_decoded4);
    return mask_decoded5;
     if (mask3)
         free (mask3);
     if (mask4)
         free (mask4);
     if (mask5)
         free (mask5);
     if (mask6)
         free (mask6);
 
     return mask7;
  }","[5, 17, 18, 19, 20, 21, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 47, 48, 55, 56, 57, 58, 64, 65, 68, 71, 83, 84, 85, 95, 105, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 3, 4, 12, 13, 14, 15, 16, 27, 28, 45, 46, 51, 52, 53, 54, 62, 63, 67, 70, 75, 76, 77, 78, 79, 80, 81, 82, 87, 88, 89, 90, 94, 104, 111, 112, 113, 114, 115, 116, 117, 118, 119]","logger.c in the logger plugin in WeeChat before 1.9.1 allows a crash via strftime date/time specifiers, because a buffer is not initialized."
8284,"void Compute(OpKernelContext* context) override {

OpInputList params_nested_splits_in;
OP_REQUIRES_OK(context, context->input_list(""params_nested_splits"",
&params_nested_splits_in));
const Tensor& params_dense_values_in =
context->input(params_nested_splits_in.size());
const Tensor& indices_in =
context->input(params_nested_splits_in.size() + 1);

DCHECK_GT(params_nested_splits_in.size(), 0);
SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;
OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));

OP_REQUIRES(context, params_dense_values_in.dims() > 0,
errors::InvalidArgument(""params.rank must be nonzero""));
SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);



std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;
SPLITS_TYPE num_values = 0;
std::vector<std::vector<SPLITS_TYPE>> out_splits;
OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,
num_params_dense_values, &out_splits,
&value_slices, &num_values));


OP_REQUIRES_OK(context, WriteSplits(out_splits, context));
OP_REQUIRES_OK(context,
WriteValues(params_dense_values_in, value_slices,
out_splits.size(), num_values, context));
}","[3, 6, 11]","TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
206413,"  void BluetoothDeviceChooserController::PostErrorCallback(
    blink::mojom::WebBluetoothResult error) {
     WebBluetoothResult error) {
    if (!base::ThreadTaskRunnerHandle::Get()->PostTask(
            FROM_HERE, base::BindOnce(error_callback_, error))) {
      LOG(WARNING) << ""No TaskRunner."";
   }
 }","[3, 2]","Heap buffer overflow in filter processing in Skia in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
204833," views::View* CardUnmaskPromptViews::CreateFootnoteView() {
   if (!controller_->CanStoreLocally())
     return nullptr;
 
   storage_row_ = new FadeOutView();
   views::BoxLayout* storage_row_layout = new views::BoxLayout(
       views::BoxLayout::kHorizontal, kEdgePadding, kEdgePadding, 0);
   storage_row_->SetLayoutManager(storage_row_layout);
    storage_row_->SetBorder(
        views::Border::CreateSolidSidedBorder(1, 0, 0, 0, kSubtleBorderColor));
    storage_row_->set_background(
      views::Background::CreateSolidBackground(kShadingColor));
       views::Background::CreateSolidBackground(kLightShadingColor));
  
    storage_checkbox_ = new views::Checkbox(l10n_util::GetStringUTF16(
        IDS_AUTOFILL_CARD_UNMASK_PROMPT_STORAGE_CHECKBOX));
   storage_checkbox_->SetChecked(controller_->GetStoreLocallyStartState());
   storage_row_->AddChildView(storage_checkbox_);
   storage_row_layout->SetFlexForView(storage_checkbox_, 1);
 
   storage_row_->AddChildView(new TooltipIcon(l10n_util::GetStringUTF16(
       IDS_AUTOFILL_CARD_UNMASK_PROMPT_STORAGE_TOOLTIP)));
 
   return storage_row_;
  }","[13, 12]","The FrameLoader::notifyIfInitialDocumentAccessed function in core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 31.0.1650.63, makes an incorrect check for an empty document during presentation of a modal dialog, which allows remote attackers to spoof the address bar via vectors involving the document.write method."
199342," static void xen_netbk_tx_submit(struct xen_netbk *netbk)
 {
 	struct gnttab_copy *gop = netbk->tx_copy_ops;
 	struct sk_buff *skb;
 
 	while ((skb = __skb_dequeue(&netbk->tx_queue)) != NULL) {
 		struct xen_netif_tx_request *txp;
 		struct xenvif *vif;
 		u16 pending_idx;
 		unsigned data_len;
 
 		pending_idx = *((u16 *)skb->data);
 		vif = netbk->pending_tx_info[pending_idx].vif;
 		txp = &netbk->pending_tx_info[pending_idx].req;
 
 		 
 		if (unlikely(xen_netbk_tx_check_gop(netbk, skb, &gop))) {
 			netdev_dbg(vif->dev, ""netback grant failed.\n"");
 			skb_shinfo(skb)->nr_frags = 0;
 			kfree_skb(skb);
 			continue;
 		}
 
 		data_len = skb->len;
 		memcpy(skb->data,
 		       (void *)(idx_to_kaddr(netbk, pending_idx)|txp->offset),
 		       data_len);
 		if (data_len < txp->size) {
 			 
 			txp->offset += data_len;
  			txp->size -= data_len;
  		} else {
  			 
			xen_netbk_idx_release(netbk, pending_idx);
 			xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
  		}
  
  		if (txp->flags & XEN_NETTXF_csum_blank)
 			skb->ip_summed = CHECKSUM_PARTIAL;
 		else if (txp->flags & XEN_NETTXF_data_validated)
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
 
 		xen_netbk_fill_frags(netbk, skb);
 
 		 
 		if (skb_headlen(skb) < PKT_PROT_LEN && skb_is_nonlinear(skb)) {
 			int target = min_t(int, skb->len, PKT_PROT_LEN);
 			__pskb_pull_tail(skb, target - skb_headlen(skb));
 		}
 
 		skb->dev      = vif->dev;
 		skb->protocol = eth_type_trans(skb, skb->dev);
 
 		if (checksum_setup(vif, skb)) {
 			netdev_dbg(vif->dev,
 				   ""Can't setup checksum in net_tx_action\n"");
 			kfree_skb(skb);
 			continue;
 		}
 
 		vif->dev->stats.rx_bytes += skb->len;
 		vif->dev->stats.rx_packets++;
 
 		xenvif_receive_skb(vif, skb);
 	}
 }","[35, 34]",Memory leak in drivers/net/xen-netback/netback.c in the Xen netback functionality in the Linux kernel before 3.7.8 allows guest OS users to cause a denial of service (memory consumption) by triggering certain error conditions.
205706," void PropertyTreeManager::SetupRootEffectNode() {
   cc::EffectTree& effect_tree = property_trees_.effect_tree;
   effect_tree.clear();
   property_trees_.element_id_to_effect_node_index.clear();
   cc::EffectNode& effect_node =
       *effect_tree.Node(effect_tree.Insert(cc::EffectNode(), kInvalidNodeId));
   DCHECK_EQ(effect_node.id, kSecondaryRootNodeId);
 
   static UniqueObjectId unique_id = NewUniqueObjectId();
 
   effect_node.stable_id =
       CompositorElementIdFromUniqueObjectId(unique_id).ToInternalValue();
   effect_node.transform_id = kRealRootNodeId;
   effect_node.clip_id = kSecondaryRootNodeId;
   effect_node.has_render_surface = true;
   root_layer_->SetEffectTreeIndex(effect_node.id);
  
    current_effect_id_ = effect_node.id;
    current_effect_type_ = CcEffectType::kEffect;
  current_effect_ = EffectPaintPropertyNode::Root();
   current_effect_ = &EffectPaintPropertyNode::Root();
    current_clip_ = current_effect_->OutputClip();
  }","[21, 20]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
10001,"TEST_F(QuantizedMatMulTest, Small_NoParams) {
TF_ASSERT_OK(NodeDefBuilder(""quantized_mat_mul_op"", ""QuantizedMatMul"")
.Input(FakeInput(DT_QUINT8))
.Input(FakeInput(DT_QUINT8))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Attr(""Toutput"", DataTypeToEnum<qint32>::v())
.Finalize(node_def()));
TF_ASSERT_OK(InitOp());



AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});




AddInputFromArray<quint8>(TensorShape({3, 4}),
{7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});
AddInputFromArray<float>(TensorShape({1}), {0});
AddInputFromArray<float>(TensorShape({1}), {255.0f});
AddInputFromArray<float>(TensorShape({1}), {0});
AddInputFromArray<float>(TensorShape({1}), {255.0f});

TF_ASSERT_OK(RunOpKernel());









Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));
test::FillValues<qint32>(&expected, {74, 80, 86, 92, 173, 188, 203, 218});
test::ExpectTensorEqual<qint32>(expected, *GetOutput(0));
}","[22, 23, 24, 25]","TensorFlow is an open source platform for machine learning. If `QuantizedMatMul` is given nonscalar input for: `min_a`, `max_a`, `min_b`, or `max_b` It gives a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit aca766ac7693bf29ed0df55ad6bfcc78f35e7f48. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
205886,"  void HostCache::RecordSet(SetOutcome outcome,
                            base::TimeTicks now,
                            const Entry* old_entry,
                          const Entry& new_entry) {
                           const Entry& new_entry,
                           AddressListDeltaType delta) {
    CACHE_HISTOGRAM_ENUM(""Set"", outcome, MAX_SET_OUTCOME);
    switch (outcome) {
      case SET_INSERT:
     case SET_UPDATE_VALID:
       break;
     case SET_UPDATE_STALE: {
       EntryStaleness stale;
       old_entry->GetStaleness(now, network_changes_, &stale);
       CACHE_HISTOGRAM_TIME(""UpdateStale.ExpiredBy"", stale.expired_by);
       CACHE_HISTOGRAM_COUNT(""UpdateStale.NetworkChanges"",
                              stale.network_changes);
        CACHE_HISTOGRAM_COUNT(""UpdateStale.StaleHits"", stale.stale_hits);
        if (old_entry->error() == OK && new_entry.error() == OK) {
        AddressListDeltaType delta = FindAddressListDeltaType(
            old_entry->addresses(), new_entry.addresses());
          RecordUpdateStale(delta, stale);
        }
        break;
     }
     case MAX_SET_OUTCOME:
       NOTREACHED();
       break;
   }
 }","[5, 6, 4, 20, 21]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
199000,"  static void do_perf_sw_event(enum perf_type_id type, u32 event_id,
				    u64 nr, int nmi,
 				    u64 nr,
  				    struct perf_sample_data *data,
  				    struct pt_regs *regs)
  {
 	struct swevent_htable *swhash = &__get_cpu_var(swevent_htable);
 	struct perf_event *event;
 	struct hlist_node *node;
 	struct hlist_head *head;
 
 	rcu_read_lock();
 	head = find_swevent_head_rcu(swhash, type, event_id);
 	if (!head)
 		goto end;
  
  	hlist_for_each_entry_rcu(event, node, head, hlist_entry) {
  		if (perf_swevent_match(event, type, event_id, data, regs))
			perf_swevent_event(event, nr, nmi, data, regs);
 			perf_swevent_event(event, nr, data, regs);
  	}
  end:
  	rcu_read_unlock();
 }","[3, 20, 2, 19]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
198040," int tls1_cbc_remove_padding(const SSL* s,
 			    SSL3_RECORD *rec,
 			    unsigned block_size,
 			    unsigned mac_size)
 	{
 	unsigned padding_length, good, to_check, i;
 	const char has_explicit_iv =
 		s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;
 	const unsigned overhead = 1   +
 				  mac_size +
 				  (has_explicit_iv ? block_size : 0);
 
 	 
         if (overhead > rec->length)
                 return 0;
  
         
        if (has_explicit_iv)
                {
                rec->data += block_size;
                rec->input += block_size;
                rec->length -= block_size;
                }
 
         padding_length = rec->data[rec->length-1];
  
         /* NB: if compression is in operation the first packet may not be of
 			padding_length--;
 			}","[17, 18, 19, 20, 21, 22, 23, 24]",crypto/evp/e_aes_cbc_hmac_sha1.c in the AES-NI functionality in the TLS 1.1 and 1.2 implementations in OpenSSL 1.0.1 before 1.0.1d allows remote attackers to cause a denial of service (application crash) via crafted CBC data.
200724," static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd, sector_t logical,
 				 struct buffer_head *exbh)
 {
 	struct inode *inode = mpd->inode;
 	struct address_space *mapping = inode->i_mapping;
 	int blocks = exbh->b_size >> inode->i_blkbits;
 	sector_t pblock = exbh->b_blocknr, cur_logical;
 	struct buffer_head *head, *bh;
 	pgoff_t index, end;
 	struct pagevec pvec;
 	int nr_pages, i;
 
 	index = logical >> (PAGE_CACHE_SHIFT - inode->i_blkbits);
 	end = (logical + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);
 	cur_logical = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
 
 	pagevec_init(&pvec, 0);
 
 	while (index <= end) {
 		 
 		nr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);
 		if (nr_pages == 0)
 			break;
 		for (i = 0; i < nr_pages; i++) {
 			struct page *page = pvec.pages[i];
 
 			index = page->index;
 			if (index > end)
 				break;
 			index++;
 
 			BUG_ON(!PageLocked(page));
 			BUG_ON(PageWriteback(page));
 			BUG_ON(!page_has_buffers(page));
 
 			bh = page_buffers(page);
 			head = bh;
 
 			 
 			do {
 				if (cur_logical >= logical)
 					break;
 				cur_logical++;
 			} while ((bh = bh->b_this_page) != head);
 
 			do {
 				if (cur_logical >= logical + blocks)
 					break;
 
 				if (buffer_delay(bh) ||
 						buffer_unwritten(bh)) {
 
 					BUG_ON(bh->b_bdev != inode->i_sb->s_bdev);
 
 					if (buffer_delay(bh)) {
 						clear_buffer_delay(bh);
 						bh->b_blocknr = pblock;
 					} else {
 						 
 						clear_buffer_unwritten(bh);
 						BUG_ON(bh->b_blocknr != pblock);
 					}
 
  				} else if (buffer_mapped(bh))
  					BUG_ON(bh->b_blocknr != pblock);
  
 				if (buffer_uninit(exbh))
 					set_buffer_uninit(bh);
  				cur_logical++;
  				pblock++;
  			} while ((bh = bh->b_this_page) != head);
 		}
 		pagevec_release(&pvec);
 	}
 }","[67, 68]","The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function."
8132,"GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)
{
GF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;
u32 i, j, count;

if (!ptr) return GF_BAD_PARAM;
ptr->scalability_mask = gf_bs_read_u16(bs);
gf_bs_read_int(bs, 2);
count = gf_bs_read_int(bs, 6);
for (i = 0; i < count; i++) {
LHEVC_ProfileTierLevel *ptl;
GF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);
if (!ptl) return GF_OUT_OF_MEM;
ptl->general_profile_space = gf_bs_read_int(bs, 2);
ptl->general_tier_flag= gf_bs_read_int(bs, 1);
ptl->general_profile_idc = gf_bs_read_int(bs, 5);
ptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);
ptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);
ptl->general_level_idc = gf_bs_read_u8(bs);
gf_list_add(ptr->profile_tier_levels, ptl);
}
count = gf_bs_read_u16(bs);
for (i = 0; i < count; i++) {
LHEVC_OperatingPoint *op;
GF_SAFEALLOC(op, LHEVC_OperatingPoint);
if (!op) return GF_OUT_OF_MEM;
op->output_layer_set_idx = gf_bs_read_u16(bs);
op->max_temporal_id = gf_bs_read_u8(bs);
op->layer_count = gf_bs_read_u8(bs);
if (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))
return GF_NON_COMPLIANT_BITSTREAM;
for (j = 0; j < op->layer_count; j++) {
op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);
op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);
op->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
op->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
}
op->minPicWidth = gf_bs_read_u16(bs);
op->minPicHeight = gf_bs_read_u16(bs);
op->maxPicWidth = gf_bs_read_u16(bs);
op->maxPicHeight = gf_bs_read_u16(bs);
op->maxChromaFormat = gf_bs_read_int(bs, 2);
op->maxBitDepth = gf_bs_read_int(bs, 3) + 8;
gf_bs_read_int(bs, 1);
op->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
op->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;
if (op->frame_rate_info_flag) {
op->avgFrameRate = gf_bs_read_u16(bs);
gf_bs_read_int(bs, 6);
op->constantFrameRate = gf_bs_read_int(bs, 2);
}
if (op->bit_rate_info_flag) {
op->maxBitRate = gf_bs_read_u32(bs);
op->avgBitRate = gf_bs_read_u32(bs);
}
gf_list_add(ptr->operating_points, op);
}
count = gf_bs_read_u8(bs);
for (i = 0; i < count; i++) {
LHEVC_DependentLayer *dep;
GF_SAFEALLOC(dep, LHEVC_DependentLayer);
if (!dep) return GF_OUT_OF_MEM;
dep->dependent_layerID = gf_bs_read_u8(bs);
dep->num_layers_dependent_on = gf_bs_read_u8(bs);
if (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {
gf_free(dep);
return GF_NON_COMPLIANT_BITSTREAM;
}
for (j = 0; j < dep->num_layers_dependent_on; j++)
dep->dependent_on_layerID[j] = gf_bs_read_u8(bs);
for (j = 0; j < 16; j++) {
if (ptr->scalability_mask & (1 << j))
dep->dimension_identifier[j] = gf_bs_read_u8(bs);
}
gf_list_add(ptr->dependency_layers, dep);
}

return GF_OK;
}","[30, 32]",Memory leak in the gf_isom_oinf_read_entry function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.
8872,"static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,
const void *pdu, uint16_t length,
void *user_data)
{
struct bt_gatt_server *server = user_data;
uint16_t handle = 0;
uint16_t offset;
struct gatt_db_attribute *attr;
struct prep_write_complete_data *pwcd;
uint8_t ecode, status;

if (length < 4) {
ecode = BT_ATT_ERROR_INVALID_PDU;
goto error;
}

if (queue_length(server->prep_queue) >= server->max_prep_queue_len) {
ecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;
goto error;
}

handle = get_le16(pdu);
offset = get_le16(pdu + 2);

attr = gatt_db_get_attribute(server->db, handle);
if (!attr) {
ecode = BT_ATT_ERROR_INVALID_HANDLE;
goto error;
}

util_debug(server->debug_callback, server->debug_data,
""Prep Write Req - handle: 0x%04x"", handle);

ecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);
if (ecode)
goto error;

pwcd = new0(struct prep_write_complete_data, 1);
pwcd->chan = chan;
pwcd->pdu = malloc(length);
memcpy(pwcd->pdu, pdu, length);
pwcd->length = length;
pwcd->server = server;

status = gatt_db_attribute_write(attr, offset, NULL, 0,
BT_ATT_OP_PREP_WRITE_REQ,
server->att,
prep_write_complete_cb, pwcd);

if (status)
return;

ecode = BT_ATT_ERROR_UNLIKELY;

error:
bt_att_chan_send_error_rsp(chan, opcode, handle, ecode);
}",[34],"A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service."
6249,"TEST_P(WasmTest, DivByZero) {
Stats::IsolatedStoreImpl stats_store;
Api::ApiPtr api = Api::createApiForTest(stats_store);
Upstream::MockClusterManager cluster_manager;
Event::DispatcherPtr dispatcher(api->allocateDispatcher());
auto scope = Stats::ScopeSharedPtr(stats_store.createScope(""wasm.""));
NiceMock<LocalInfo::MockLocalInfo> local_info;
auto name = """";
auto root_id = """";
auto vm_id = """";
auto vm_configuration = """";
auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(
name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,
nullptr);
auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(
absl::StrCat(""envoy.wasm.runtime."", GetParam()), vm_id, vm_configuration, plugin, scope,
cluster_manager, *dispatcher);
EXPECT_NE(wasm, nullptr);
const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(
""{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm""));
EXPECT_FALSE(code.empty());
auto context = std::make_unique<TestContext>(wasm.get());
EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(""before div by zero"")));
EXPECT_TRUE(wasm->initialize(code, false));
wasm->setContext(context.get());

if (GetParam() == ""v8"") {
EXPECT_THROW_WITH_MESSAGE(
context->onLog(), Extensions::Common::Wasm::WasmException,
""Function: proxy_onLog failed: Uncaught RuntimeError: divide by zero"");
} else if (GetParam() == ""wavm"") {
EXPECT_THROW_WITH_REGEX(context->onLog(), Extensions::Common::Wasm::WasmException,
""Function: proxy_onLog failed: wavm.integerDivideByZeroOrOverflow.*"");
} else {
ASSERT_FALSE(true);
}
}",[25],"Istio 1.4.x before 1.4.9 and Istio 1.5.x before 1.5.4 contain the following vulnerability when telemetry v2 is enabled: by sending a specially crafted packet, an attacker could trigger a Null Pointer Exception resulting in a Denial of Service. This could be sent to the ingress gateway or a sidecar, triggering a null pointer exception which results in a denial of service. This also affects servicemesh-proxy where a null pointer exception flaw was found in servicemesh-proxy. When running Telemetry v2 (not on by default in version 1.4.x), an attacker could send a specially crafted packet to the ingress gateway or proxy sidecar, triggering a denial of service."
199885," static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)
 {
 	int r;
 	size_t i;
 	static struct {
 		int match_mask;
 		int match_flag;
 		const char *source;
 		const char *destination;
 		const char *fstype;
 		unsigned long flags;
 		const char *options;
 	} default_mounts[] = {
 		 
  		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/net"",                  NULL,       MS_BIND,                        NULL },
 		 
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys/net"",                                   ""%r/proc/tty"",                  NULL,       MS_BIND,                        NULL },
  		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sys"",                                       ""%r/proc/sys"",                  NULL,       MS_BIND,                        NULL },
  		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sys"",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/net"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
 		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/tty"",                                       ""%r/proc/sys/net"",              NULL,       MS_MOVE,                        NULL },
  		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, ""%r/proc/sysrq-trigger"",                             ""%r/proc/sysrq-trigger"",        NULL,       MS_BIND,                        NULL },
  		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                ""%r/proc/sysrq-trigger"",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
  		{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    ""proc"",                                              ""%r/proc"",                      ""proc"",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    0,                              NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_RDONLY,                      NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys"",                       ""sysfs"",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys"",                                            ""%r/sys"",                       NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys"",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""sysfs"",                                             ""%r/sys/devices/virtual/net"",   ""sysfs"",    0,                              NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  ""%r/sys/devices/virtual/net/devices/virtual/net"",    ""%r/sys/devices/virtual/net"",   NULL,       MS_BIND,                        NULL },
 		{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                ""%r/sys/devices/virtual/net"",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },
 		{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }
 	};
 
 	for (i = 0; default_mounts[i].match_mask; i++) {
 		if ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {
 			char *source = NULL;
 			char *destination = NULL;
 			int saved_errno;
 			unsigned long mflags;
 
 			if (default_mounts[i].source) {
 				 
 				source = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].source);
 				if (!source) {
 					SYSERROR(""memory allocation error"");
 					return -1;
 				}
 			}
 			if (default_mounts[i].destination) {
 				 
 				destination = lxc_string_replace(""%r"", conf->rootfs.path ? conf->rootfs.mount : """", default_mounts[i].destination);
 				if (!destination) {
 					saved_errno = errno;
 					SYSERROR(""memory allocation error"");
 					free(source);
 					errno = saved_errno;
 					return -1;
 				}
  			}
  			mflags = add_required_remount_flags(source, destination,
  					default_mounts[i].flags);
			r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);
 			r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);
  			saved_errno = errno;
  			if (r < 0 && errno == ENOENT) {
  				INFO(""Mount source or target for %s on %s doesn't exist. Skipping."", source, destination);
 				r = 0;
 			}
 			else if (r < 0)
 				SYSERROR(""error mounting %s on %s flags %lu"", source, destination, mflags);
 
 			free(source);
 			free(destination);
 			if (r < 0) {
 				errno = saved_errno;
 				return -1;
 			}
 		}
 	}
 
 	if (flags & LXC_AUTO_CGROUP_MASK) {
 		int cg_flags;
 
 		cg_flags = flags & LXC_AUTO_CGROUP_MASK;
 		 
 		if (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {
 			int has_sys_admin = 0;
 			if (!lxc_list_empty(&conf->keepcaps)) {
 				has_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);
 			} else {
 				has_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);
 			}
 			if (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {
 				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;
 			} else {
 				cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;
 			}
 		}
 
 		if (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : """", handler, cg_flags)) {
 			SYSERROR(""error mounting /sys/fs/cgroup"");
 			return -1;
 		}
 	}
 
 	return 0;
 }","[17, 18, 22, 66, 16, 21, 65]",lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.
206495,"  void GM2TabStyle::PaintTabBackgroundFill(gfx::Canvas* canvas,
                                         bool active,
                                          TabState active_state,
                                           bool paint_hover_effect,
                                         SkColor active_color,
                                         SkColor inactive_color,
                                           int fill_id,
                                           int y_inset) const {
  const SkPath fill_path =
      GetPath(PathType::kFill, canvas->image_scale(), active);
   const SkPath fill_path = GetPath(PathType::kFill, canvas->image_scale(),
                                    active_state == TAB_ACTIVE);
    gfx::ScopedCanvas scoped_canvas(canvas);
    const float scale = canvas->UndoDeviceScaleFactor();
  
    canvas->ClipPath(fill_path, true);
  
  if (active || !fill_id) {
   if (ShouldPaintTabBackgroundColor(active_state, fill_id)) {
      cc::PaintFlags flags;
      flags.setAntiAlias(true);
    flags.setColor(active ? active_color : inactive_color);
     flags.setColor(GetTabBackgroundColor(active_state));
      canvas->DrawRect(gfx::ScaleToEnclosingRect(tab_->GetLocalBounds(), scale),
                       flags);
    }
 
   if (fill_id) {
     gfx::ScopedCanvas scale_scoper(canvas);
     canvas->sk_canvas()->scale(scale, scale);
     canvas->TileImageInt(*tab_->GetThemeProvider()->GetImageSkiaNamed(fill_id),
                          tab_->GetMirroredX() + tab_->background_offset(), 0, 0,
                          y_inset, tab_->width(), tab_->height());
   }
 
   if (paint_hover_effect) {
     SkPoint hover_location(gfx::PointToSkPoint(hover_controller_->location()));
     hover_location.scale(SkFloatToScalar(scale));
     const SkScalar kMinHoverRadius = 16;
      const SkScalar radius =
          std::max(SkFloatToScalar(tab_->width() / 4.f), kMinHoverRadius);
      DrawHighlight(canvas, hover_location, radius * scale,
                  SkColorSetA(active_color, hover_controller_->GetAlpha()));
                   SkColorSetA(GetTabBackgroundColor(TAB_ACTIVE),
                               hover_controller_->GetAlpha()));
    }
  }","[3, 11, 12, 19, 23, 44, 45, 2, 5, 6, 9, 10, 18, 22, 43]","The extensions API in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly handled navigation within PDFs, which allowed a remote attacker to temporarily spoof the contents of the Omnibox (URL bar) via a crafted HTML page containing PDF data."
5563,"static int lookup1_values(int entries, int dim)
{
int r = (int) floor(exp((float) log((float) entries) / dim));
if ((int) floor(pow((float) r+1, dim)) <= entries)
++r;
assert(pow((float) r+1, dim) > entries);
assert((int) floor(pow((float) r, dim)) <= entries);
return r;
}","[6, 7]",A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.
202071," static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,
   ExceptionInfo *exception)
 {
   DDSColors
     colors;
 
   PixelPacket
     *q;
 
   register ssize_t
     i,
     x;
 
   size_t
     bits;
 
   ssize_t
     j,
     y;
 
   unsigned char
     code;
 
   unsigned short
     c0,
     c1;
 
   for (y = 0; y < (ssize_t) dds_info->height; y += 4)
   {
      for (x = 0; x < (ssize_t) dds_info->width; x += 4)
      {
         
      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),
        Min(4, dds_info->height - y),exception);
       q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),
         MagickMin(4, dds_info->height - y),exception);
  
        if (q == (PixelPacket *) NULL)
          return MagickFalse;
 
        
       c0 = ReadBlobLSBShort(image);
       c1 = ReadBlobLSBShort(image);
       bits = ReadBlobLSBLong(image);
 
       CalculateColors(c0, c1, &colors, MagickFalse);
 
        
       for (j = 0; j < 4; j++)
       {
         for (i = 0; i < 4; i++)
         {
           if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)
             {
               code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);
               SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));
               SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));
               SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));
               SetPixelOpacity(q,ScaleCharToQuantum(colors.a[code]));
               if (colors.a[code] && image->matte == MagickFalse)
                  
                 image->matte = MagickTrue;
               q++;
             }
         }
       }
 
       if (SyncAuthenticPixels(image,exception) == MagickFalse)
         return MagickFalse;
      }
    }
  
  SkipDXTMipmaps(image, dds_info, 8);
  return MagickTrue;
   return(SkipDXTMipmaps(image,dds_info,8,exception));
  }","[35, 36, 75, 33, 34, 73, 74]",coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file.
200618," zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,
     struct zip_entry *rsrc)
 {
 	struct zip *zip = (struct zip *)a->format->data;
 	unsigned char *metadata, *mp;
 	int64_t offset = archive_filter_bytes(&a->archive, 0);
 	size_t remaining_bytes, metadata_bytes;
 	ssize_t hsize;
 	int ret = ARCHIVE_OK, eof;
  
  	switch(rsrc->compression) {
  	case 0:   
 		if (rsrc->uncompressed_size != rsrc->compressed_size) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Malformed OS X metadata entry: inconsistent size"");
 			return (ARCHIVE_FATAL);
 		}
  #ifdef HAVE_ZLIB_H
  	case 8:  
  #endif
 		break;
 	default:  
 		 
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Unsupported ZIP compression method (%s)"",
 		    compression_name(rsrc->compression));
 		 
 		return (ARCHIVE_WARN);
 	}
 
 	if (rsrc->uncompressed_size > (4 * 1024 * 1024)) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Mac metadata is too large: %jd > 4M bytes"",
  		    (intmax_t)rsrc->uncompressed_size);
  		return (ARCHIVE_WARN);
  	}
 	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Mac metadata is too large: %jd > 4M bytes"",
 		    (intmax_t)rsrc->compressed_size);
 		return (ARCHIVE_WARN);
 	}
  
  	metadata = malloc((size_t)rsrc->uncompressed_size);
  	if (metadata == NULL) {
 		archive_set_error(&a->archive, ENOMEM,
 		    ""Can't allocate memory for Mac metadata"");
 		return (ARCHIVE_FATAL);
 	}
 
 	if (offset < rsrc->local_header_offset)
 		__archive_read_consume(a, rsrc->local_header_offset - offset);
 	else if (offset != rsrc->local_header_offset) {
 		__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);
 	}
 
 	hsize = zip_get_local_file_header_size(a, 0);
 	__archive_read_consume(a, hsize);
 
 	remaining_bytes = (size_t)rsrc->compressed_size;
 	metadata_bytes = (size_t)rsrc->uncompressed_size;
 	mp = metadata;
 	eof = 0;
 	while (!eof && remaining_bytes) {
 		const unsigned char *p;
 		ssize_t bytes_avail;
 		size_t bytes_used;
 
 		p = __archive_read_ahead(a, 1, &bytes_avail);
 		if (p == NULL) {
 			archive_set_error(&a->archive,
 			    ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Truncated ZIP file header"");
 			ret = ARCHIVE_WARN;
 			goto exit_mac_metadata;
 		}
 		if ((size_t)bytes_avail > remaining_bytes)
  			bytes_avail = remaining_bytes;
  		switch(rsrc->compression) {
  		case 0:   
 			if ((size_t)bytes_avail > metadata_bytes)
 				bytes_avail = metadata_bytes;
  			memcpy(mp, p, bytes_avail);
  			bytes_used = (size_t)bytes_avail;
  			metadata_bytes -= bytes_used;
 			mp += bytes_used;
 			if (metadata_bytes == 0)
 				eof = 1;
 			break;
 #ifdef HAVE_ZLIB_H
 		case 8:  
 		{
 			int r;
 
 			ret = zip_deflate_init(a, zip);
 			if (ret != ARCHIVE_OK)
 				goto exit_mac_metadata;
 			zip->stream.next_in =
 			    (Bytef *)(uintptr_t)(const void *)p;
 			zip->stream.avail_in = (uInt)bytes_avail;
 			zip->stream.total_in = 0;
 			zip->stream.next_out = mp;
 			zip->stream.avail_out = (uInt)metadata_bytes;
 			zip->stream.total_out = 0;
 
 			r = inflate(&zip->stream, 0);
 			switch (r) {
 			case Z_OK:
 				break;
 			case Z_STREAM_END:
 				eof = 1;
 				break;
 			case Z_MEM_ERROR:
 				archive_set_error(&a->archive, ENOMEM,
 				    ""Out of memory for ZIP decompression"");
 				ret = ARCHIVE_FATAL;
 				goto exit_mac_metadata;
 			default:
 				archive_set_error(&a->archive,
 				    ARCHIVE_ERRNO_MISC,
 				    ""ZIP decompression failed (%d)"", r);
 				ret = ARCHIVE_FATAL;
 				goto exit_mac_metadata;
 			}
 			bytes_used = zip->stream.total_in;
 			metadata_bytes -= zip->stream.total_out;
 			mp += zip->stream.total_out;
 			break;
 		}
 #endif
 		default:
 			bytes_used = 0;
 			break;
 		}
 		__archive_read_consume(a, bytes_used);
 		remaining_bytes -= bytes_used;
 	}
 	archive_entry_copy_mac_metadata(entry, metadata,
 	    (size_t)rsrc->uncompressed_size - metadata_bytes);
 
 exit_mac_metadata:
 	__archive_read_seek(a, offset, SEEK_SET);
 	zip->decompress_init = 0;
 	free(metadata);
 	return (ret);
 }","[13, 14, 15, 16, 17, 37, 38, 39, 40, 41, 42, 81, 82]",Heap-based buffer overflow in the zip_read_mac_metadata function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to execute arbitrary code via crafted entry-size values in a ZIP archive.
208503," static void encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         VpxVideoWriter *writer) {
 static int encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         VpxVideoWriter *writer) {
   int got_pkts = 0;
    vpx_codec_iter_t iter = NULL;
    const vpx_codec_cx_pkt_t *pkt = NULL;
    const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,
                                                VPX_DL_GOOD_QUALITY);
  if (res != VPX_CODEC_OK)
 
      die_codec(codec, ""Failed to encode frame"");
  
    while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {
     got_pkts = 1;
 
      if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
        const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
        if (!vpx_video_writer_write_frame(writer,
                                         pkt->data.frame.buf,
                                         pkt->data.frame.sz,
                                         pkt->data.frame.pts)) {
         die_codec(codec, ""Failed to write compressed frame"");
  }
 
       printf(keyframe ? ""K"" : ""."");
 
        fflush(stdout);
      }
    }
 
   return got_pkts;
  }","[5, 6, 7, 8, 9, 19, 20, 35, 36, 2, 3, 4]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
205843," void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,
                         int nav_entry_id,
                         bool did_create_new_entry,
                         const GURL& url,
                          ui::PageTransition transition) {
    params->nav_entry_id = nav_entry_id;
    params->url = url;
   params->origin = url::Origin(url);
    params->referrer = Referrer();
    params->transition = transition;
    params->redirects = std::vector<GURL>();
   params->should_update_history = false;
   params->searchable_form_url = GURL();
   params->searchable_form_encoding = std::string();
   params->did_create_new_entry = did_create_new_entry;
   params->gesture = NavigationGestureUser;
   params->was_within_same_document = false;
   params->method = ""GET"";
   params->page_state = PageState::CreateFromURL(url);
 }",[8],"content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document."
198670," jbig2_decode_symbol_dict(Jbig2Ctx *ctx,
                          Jbig2Segment *segment,
                          const Jbig2SymbolDictParams *params, const byte *data, size_t size, Jbig2ArithCx *GB_stats, Jbig2ArithCx *GR_stats)
 {
     Jbig2SymbolDict *SDNEWSYMS = NULL;
     Jbig2SymbolDict *SDEXSYMS = NULL;
     uint32_t HCHEIGHT;
     uint32_t NSYMSDECODED;
     uint32_t SYMWIDTH, TOTWIDTH;
     uint32_t HCFIRSTSYM;
     uint32_t *SDNEWSYMWIDTHS = NULL;
     int SBSYMCODELEN = 0;
     Jbig2WordStream *ws = NULL;
     Jbig2HuffmanState *hs = NULL;
     Jbig2HuffmanTable *SDHUFFRDX = NULL;
     Jbig2HuffmanTable *SBHUFFRSIZE = NULL;
     Jbig2ArithState *as = NULL;
     Jbig2ArithIntCtx *IADH = NULL;
     Jbig2ArithIntCtx *IADW = NULL;
     Jbig2ArithIntCtx *IAEX = NULL;
     Jbig2ArithIntCtx *IAAI = NULL;
     Jbig2ArithIaidCtx *IAID = NULL;
     Jbig2ArithIntCtx *IARDX = NULL;
     Jbig2ArithIntCtx *IARDY = NULL;
     int code = 0;
     Jbig2SymbolDict **refagg_dicts = NULL;
     int n_refagg_dicts = 1;
 
     Jbig2TextRegionParams *tparams = NULL;
 
      
     HCHEIGHT = 0;
     NSYMSDECODED = 0;
 
     ws = jbig2_word_stream_buf_new(ctx, data, size);
     if (ws == NULL) {
         jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""failed to allocate ws in jbig2_decode_symbol_dict"");
         return NULL;
     }
 
     as = jbig2_arith_new(ctx, ws);
     if (as == NULL) {
         jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""failed to allocate as in jbig2_decode_symbol_dict"");
         jbig2_word_stream_buf_free(ctx, ws);
         return NULL;
     }
 
     if (!params->SDHUFF) {
         IADH = jbig2_arith_int_ctx_new(ctx);
         IADW = jbig2_arith_int_ctx_new(ctx);
         IAEX = jbig2_arith_int_ctx_new(ctx);
         IAAI = jbig2_arith_int_ctx_new(ctx);
         if ((IADH == NULL) || (IADW == NULL) || (IAEX == NULL) || (IAAI == NULL)) {
             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""failed to allocate storage for symbol bitmap"");
             goto cleanup1;
         }
         if (params->SDREFAGG) {
             int64_t tmp = params->SDNUMINSYMS + params->SDNUMNEWSYMS;
 
             for (SBSYMCODELEN = 0; ((int64_t) 1 << SBSYMCODELEN) < tmp; SBSYMCODELEN++);
             IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);
             IARDX = jbig2_arith_int_ctx_new(ctx);
             IARDY = jbig2_arith_int_ctx_new(ctx);
             if ((IAID == NULL) || (IARDX == NULL) || (IARDY == NULL)) {
                 jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""failed to allocate storage for symbol bitmap"");
                 goto cleanup2;
             }
         }
     } else {
         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""huffman coded symbol dictionary"");
         hs = jbig2_huffman_new(ctx, ws);
         SDHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);
         SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);
         if ((hs == NULL) || (SDHUFFRDX == NULL) || (SBHUFFRSIZE == NULL)) {
             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""failed to allocate storage for symbol bitmap"");
             goto cleanup2;
         }
         if (!params->SDREFAGG) {
             SDNEWSYMWIDTHS = jbig2_new(ctx, uint32_t, params->SDNUMNEWSYMS);
             if (SDNEWSYMWIDTHS == NULL) {
                 jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""could not allocate storage for (%u) symbol widths"", params->SDNUMNEWSYMS);
                 goto cleanup2;
             }
         }
     }
 
     SDNEWSYMS = jbig2_sd_new(ctx, params->SDNUMNEWSYMS);
     if (SDNEWSYMS == NULL) {
         jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""could not allocate storage for (%u) new symbols"", params->SDNUMNEWSYMS);
         goto cleanup2;
     }
 
      
     while (NSYMSDECODED < params->SDNUMNEWSYMS) {
         int32_t HCDH, DW;
 
          
         if (params->SDHUFF) {
             HCDH = jbig2_huffman_get(hs, params->SDHUFFDH, &code);
         } else {
             code = jbig2_arith_int_decode(IADH, as, &HCDH);
         }
 
         if (code != 0) {
             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""error or OOB decoding height class delta (%d)\n"", code);
         }
 
         if (!params->SDHUFF && jbig2_arith_has_reached_marker(as)) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""prevent DOS while decoding height classes"");
             goto cleanup2;
         }
 
          
         HCHEIGHT = HCHEIGHT + HCDH;
         SYMWIDTH = 0;
         TOTWIDTH = 0;
         HCFIRSTSYM = NSYMSDECODED;
 
         if ((int32_t) HCHEIGHT < 0) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Invalid HCHEIGHT value"");
             goto cleanup2;
         }
 #ifdef JBIG2_DEBUG
         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""HCHEIGHT = %d"", HCHEIGHT);
 #endif
         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""decoding height class %d with %d syms decoded"", HCHEIGHT, NSYMSDECODED);
 
         for (;;) {
              
             if (params->SDHUFF) {
                 DW = jbig2_huffman_get(hs, params->SDHUFFDW, &code);
             } else {
                 code = jbig2_arith_int_decode(IADW, as, &DW);
             }
             if (code < 0)
                 goto cleanup4;
 
              
             if (code == 1) {
                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, "" OOB signals end of height class %d"", HCHEIGHT);
                 break;
             }
 
              
             if (NSYMSDECODED >= params->SDNUMNEWSYMS) {
                 jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""No OOB signalling end of height class %d"", HCHEIGHT);
                 goto cleanup4;
             }
 
             SYMWIDTH = SYMWIDTH + DW;
             TOTWIDTH = TOTWIDTH + SYMWIDTH;
             if ((int32_t) SYMWIDTH < 0) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Invalid SYMWIDTH value (%d) at symbol %d"", SYMWIDTH, NSYMSDECODED + 1);
                 goto cleanup4;
             }
 #ifdef JBIG2_DEBUG
             jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""SYMWIDTH = %d TOTWIDTH = %d"", SYMWIDTH, TOTWIDTH);
 #endif
              
             if (!params->SDHUFF || params->SDREFAGG) {
 #ifdef JBIG2_DEBUG
                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""SDHUFF = %d; SDREFAGG = %d"", params->SDHUFF, params->SDREFAGG);
 #endif
                  
                 if (!params->SDREFAGG) {
                     Jbig2GenericRegionParams region_params;
                     int sdat_bytes;
                     Jbig2Image *image;
 
                      
                     region_params.MMR = 0;
                     region_params.GBTEMPLATE = params->SDTEMPLATE;
                     region_params.TPGDON = 0;
                     region_params.USESKIP = 0;
                     sdat_bytes = params->SDTEMPLATE == 0 ? 8 : 2;
                     memcpy(region_params.gbat, params->sdat, sdat_bytes);
 
                     image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);
                     if (image == NULL) {
                         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate image in jbig2_decode_symbol_dict"");
                         goto cleanup4;
                     }
 
                     code = jbig2_decode_generic_region(ctx, segment, &region_params, as, image, GB_stats);
                     if (code < 0) {
                         jbig2_image_release(ctx, image);
                         goto cleanup4;
                     }
 
                     SDNEWSYMS->glyphs[NSYMSDECODED] = image;
                 } else {
                      
                     uint32_t REFAGGNINST;
 
                     if (params->SDHUFF) {
                         REFAGGNINST = jbig2_huffman_get(hs, params->SDHUFFAGGINST, &code);
                     } else {
                         code = jbig2_arith_int_decode(IAAI, as, (int32_t *) & REFAGGNINST);
                     }
                     if (code || (int32_t) REFAGGNINST <= 0) {
                         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""invalid number of symbols or OOB in aggregate glyph"");
                         goto cleanup4;
                     }
 
                     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""aggregate symbol coding (%d instances)"", REFAGGNINST);
  
                      if (REFAGGNINST > 1) {
                          Jbig2Image *image;
                        int i;
                         uint32_t i;
  
                          if (tparams == NULL) {
                               
                              
                              
                             refagg_dicts = jbig2_new(ctx, Jbig2SymbolDict *, n_refagg_dicts);
                             if (refagg_dicts == NULL) {
                                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Out of memory allocating dictionary array"");
                                 goto cleanup4;
                             }
                             refagg_dicts[0] = jbig2_sd_new(ctx, params->SDNUMINSYMS + params->SDNUMNEWSYMS);
                             if (refagg_dicts[0] == NULL) {
                                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Out of memory allocating symbol dictionary"");
                                 jbig2_free(ctx->allocator, refagg_dicts);
                                 goto cleanup4;
                             }
                             for (i = 0; i < params->SDNUMINSYMS; i++) {
                                 refagg_dicts[0]->glyphs[i] = jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]);
                             }
 
                             tparams = jbig2_new(ctx, Jbig2TextRegionParams, 1);
                             if (tparams == NULL) {
                                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Out of memory creating text region params"");
                                 goto cleanup4;
                             }
                             if (!params->SDHUFF) {
                                  
                                 tparams->IADT = jbig2_arith_int_ctx_new(ctx);
                                 tparams->IAFS = jbig2_arith_int_ctx_new(ctx);
                                 tparams->IADS = jbig2_arith_int_ctx_new(ctx);
                                 tparams->IAIT = jbig2_arith_int_ctx_new(ctx);
                                  
                                 for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < (int)(params->SDNUMINSYMS + params->SDNUMNEWSYMS); SBSYMCODELEN++);
                                 tparams->IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);
                                 tparams->IARI = jbig2_arith_int_ctx_new(ctx);
                                 tparams->IARDW = jbig2_arith_int_ctx_new(ctx);
                                 tparams->IARDH = jbig2_arith_int_ctx_new(ctx);
                                 tparams->IARDX = jbig2_arith_int_ctx_new(ctx);
                                 tparams->IARDY = jbig2_arith_int_ctx_new(ctx);
                             } else {
                                 tparams->SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);     
                                 tparams->SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);     
                                 tparams->SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);     
                                 tparams->SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    
                                 tparams->SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    
                                 tparams->SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    
                                 tparams->SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    
                             }
                             tparams->SBHUFF = params->SDHUFF;
                             tparams->SBREFINE = 1;
                             tparams->SBSTRIPS = 1;
                             tparams->SBDEFPIXEL = 0;
                             tparams->SBCOMBOP = JBIG2_COMPOSE_OR;
                             tparams->TRANSPOSED = 0;
                             tparams->REFCORNER = JBIG2_CORNER_TOPLEFT;
                             tparams->SBDSOFFSET = 0;
                             tparams->SBRTEMPLATE = params->SDRTEMPLATE;
                         }
                         tparams->SBNUMINSTANCES = REFAGGNINST;
 
                         image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);
                         if (image == NULL) {
                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Out of memory creating symbol image"");
                             goto cleanup4;
                         }
 
                          
                         jbig2_decode_text_region(ctx, segment, tparams, (const Jbig2SymbolDict * const *)refagg_dicts,
                                                  n_refagg_dicts, image, data, size, GR_stats, as, ws);
 
                         SDNEWSYMS->glyphs[NSYMSDECODED] = image;
                         refagg_dicts[0]->glyphs[params->SDNUMINSYMS + NSYMSDECODED] = jbig2_image_clone(ctx, SDNEWSYMS->glyphs[NSYMSDECODED]);
                     } else {
                          
                          
                         Jbig2RefinementRegionParams rparams;
                         Jbig2Image *image;
                          uint32_t ID;
                          int32_t RDX, RDY;
                          int BMSIZE = 0;
                        int ninsyms = params->SDNUMINSYMS;
                         uint32_t ninsyms = params->SDNUMINSYMS;
                          int code1 = 0;
                          int code2 = 0;
                          int code3 = 0;
                         int code4 = 0;
 
                          
                         if (params->SDHUFF) {
                             ID = jbig2_huffman_get_bits(hs, SBSYMCODELEN, &code4);
                             RDX = jbig2_huffman_get(hs, SDHUFFRDX, &code1);
                             RDY = jbig2_huffman_get(hs, SDHUFFRDX, &code2);
                             BMSIZE = jbig2_huffman_get(hs, SBHUFFRSIZE, &code3);
                             jbig2_huffman_skip(hs);
                         } else {
                             code1 = jbig2_arith_iaid_decode(IAID, as, (int32_t *) & ID);
                             code2 = jbig2_arith_int_decode(IARDX, as, &RDX);
                             code3 = jbig2_arith_int_decode(IARDY, as, &RDY);
                         }
 
                         if ((code1 < 0) || (code2 < 0) || (code3 < 0) || (code4 < 0)) {
                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to decode data"");
                             goto cleanup4;
                         }
 
                         if (ID >= ninsyms + NSYMSDECODED) {
                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""refinement references unknown symbol %d"", ID);
                             goto cleanup4;
                         }
 
                         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,
                                     ""symbol is a refinement of id %d with the "" ""refinement applied at (%d,%d)"", ID, RDX, RDY);
 
                         image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);
                         if (image == NULL) {
                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Out of memory creating symbol image"");
                             goto cleanup4;
                         }
 
                          
                         rparams.GRTEMPLATE = params->SDRTEMPLATE;
                         rparams.reference = (ID < ninsyms) ? params->SDINSYMS->glyphs[ID] : SDNEWSYMS->glyphs[ID - ninsyms];
                          
                         if (rparams.reference == NULL) {
                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""missing glyph %d/%d!"", ID, ninsyms);
                             jbig2_image_release(ctx, image);
                             goto cleanup4;
                         }
                         rparams.DX = RDX;
                         rparams.DY = RDY;
                         rparams.TPGRON = 0;
                         memcpy(rparams.grat, params->sdrat, 4);
                         code = jbig2_decode_refinement_region(ctx, segment, &rparams, as, image, GR_stats);
                         if (code < 0)
                             goto cleanup4;
 
                         SDNEWSYMS->glyphs[NSYMSDECODED] = image;
 
                          
                         if (params->SDHUFF) {
                             if (BMSIZE == 0)
                                 BMSIZE = image->height * image->stride;
                             jbig2_huffman_advance(hs, BMSIZE);
                         }
                     }
                 }
 
 #ifdef OUTPUT_PBM
                 {
                     char name[64];
                     FILE *out;
 
                     snprintf(name, 64, ""sd.%04d.%04d.pbm"", segment->number, NSYMSDECODED);
                     out = fopen(name, ""wb"");
                     jbig2_image_write_pbm(SDNEWSYMS->glyphs[NSYMSDECODED], out);
                     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""writing out glyph as '%s' ..."", name);
                     fclose(out);
                 }
 #endif
 
             }
 
              
             if (params->SDHUFF && !params->SDREFAGG) {
                 SDNEWSYMWIDTHS[NSYMSDECODED] = SYMWIDTH;
             }
 
              
             NSYMSDECODED = NSYMSDECODED + 1;
 
             jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""decoded symbol %u of %u (%ux%u)"", NSYMSDECODED, params->SDNUMNEWSYMS, SYMWIDTH, HCHEIGHT);
 
         }                        
 
          
          if (params->SDHUFF && !params->SDREFAGG) {
               
              Jbig2Image *image;
            int BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);
            int j, x;
             uint32_t BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);
             uint32_t j;
             int x;
  
              if (code || (BMSIZE < 0)) {
                  jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""error decoding size of collective bitmap!"");
             }
 
              
             jbig2_huffman_skip(hs);
 
             image = jbig2_image_new(ctx, TOTWIDTH, HCHEIGHT);
             if (image == NULL) {
                 jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""could not allocate collective bitmap image!"");
                 goto cleanup4;
             }
 
             if (BMSIZE == 0) {
                  
                 const byte *src = data + jbig2_huffman_offset(hs);
                 const int stride = (image->width >> 3) + ((image->width & 7) ? 1 : 0);
                 byte *dst = image->data;
 
                  
                 if (size - jbig2_huffman_offset(hs) < image->height * stride) {
                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""not enough data for decoding (%d/%d)"", image->height * stride,
                                 size - jbig2_huffman_offset(hs));
                     jbig2_image_release(ctx, image);
                     goto cleanup4;
                 }
 
                 BMSIZE = image->height * stride;
                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,
                             ""reading %dx%d uncompressed bitmap"" "" for %d symbols (%d bytes)"", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);
 
                 for (j = 0; j < image->height; j++) {
                     memcpy(dst, src, stride);
                     dst += image->stride;
                     src += stride;
                 }
             } else {
                 Jbig2GenericRegionParams rparams;
 
                  
                 if (size - jbig2_huffman_offset(hs) < BMSIZE) {
                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""not enough data for decoding (%d/%d)"", BMSIZE, size - jbig2_huffman_offset(hs));
                     jbig2_image_release(ctx, image);
                     goto cleanup4;
                 }
 
                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,
                             ""reading %dx%d collective bitmap for %d symbols (%d bytes)"", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);
 
                 rparams.MMR = 1;
                 code = jbig2_decode_generic_mmr(ctx, segment, &rparams, data + jbig2_huffman_offset(hs), BMSIZE, image);
                 if (code) {
                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""error decoding MMR bitmap image!"");
                     jbig2_image_release(ctx, image);
                     goto cleanup4;
                 }
             }
 
              
             jbig2_huffman_advance(hs, BMSIZE);
 
              
             x = 0;
             for (j = HCFIRSTSYM; j < NSYMSDECODED; j++) {
                 Jbig2Image *glyph;
 
                 glyph = jbig2_image_new(ctx, SDNEWSYMWIDTHS[j], HCHEIGHT);
                 if (glyph == NULL) {
                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to copy the collective bitmap into symbol dictionary"");
                     jbig2_image_release(ctx, image);
                     goto cleanup4;
                 }
                 jbig2_image_compose(ctx, glyph, image, -x, 0, JBIG2_COMPOSE_REPLACE);
                 x += SDNEWSYMWIDTHS[j];
                 SDNEWSYMS->glyphs[j] = glyph;
             }
             jbig2_image_release(ctx, image);
         }
 
     }                            
 
      
     SDEXSYMS = jbig2_sd_new(ctx, params->SDNUMEXSYMS);
     if (SDEXSYMS == NULL) {
         jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate symbols exported from symbols dictionary"");
          jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate symbols exported from symbols dictionary"");
          goto cleanup4;
      } else {
        int i = 0;
        int j = 0;
        int k;
         uint32_t i = 0;
         uint32_t j = 0;
         uint32_t k;
          int exflag = 0;
        int64_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;
        int32_t exrunlength;
         uint32_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;
         uint32_t exrunlength;
          int zerolength = 0;
  
          while (i < limit) {
              if (params->SDHUFF)
                  exrunlength = jbig2_huffman_get(hs, SBHUFFRSIZE, &code);
              else
                code = jbig2_arith_int_decode(IAEX, as, &exrunlength);
                 code = jbig2_arith_int_decode(IAEX, as, (int32_t *)&exrunlength);
               
              zerolength = exrunlength > 0 ? 0 : zerolength + 1;
            if (code || (exrunlength > limit - i) || (exrunlength < 0) || (zerolength > 4) || (exflag && (exrunlength > params->SDNUMEXSYMS - j))) {
             if (code || (exrunlength > limit - i) || (exrunlength < 0) || (zerolength > 4) || (exflag && (exrunlength + j > params->SDNUMEXSYMS))) {
                  if (code)
                      jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to decode exrunlength for exported symbols"");
                  else if (exrunlength <= 0)
                 else
                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number,
                                 ""runlength too large in export symbol table (%d > %d - %d)\n"", exrunlength, params->SDNUMEXSYMS, j);
                  
                 jbig2_sd_release(ctx, SDEXSYMS);
                 SDEXSYMS = NULL;
                 break;
             }
             for (k = 0; k < exrunlength; k++) {
                 if (exflag) {
                     SDEXSYMS->glyphs[j++] = (i < params->SDNUMINSYMS) ?
                                             jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]) : jbig2_image_clone(ctx, SDNEWSYMS->glyphs[i - params->SDNUMINSYMS]);
                 }
                 i++;
             }
             exflag = !exflag;
         }
     }
 
 cleanup4:
     if (tparams != NULL) {
         if (!params->SDHUFF) {
             jbig2_arith_int_ctx_free(ctx, tparams->IADT);
             jbig2_arith_int_ctx_free(ctx, tparams->IAFS);
             jbig2_arith_int_ctx_free(ctx, tparams->IADS);
             jbig2_arith_int_ctx_free(ctx, tparams->IAIT);
             jbig2_arith_iaid_ctx_free(ctx, tparams->IAID);
             jbig2_arith_int_ctx_free(ctx, tparams->IARI);
             jbig2_arith_int_ctx_free(ctx, tparams->IARDW);
             jbig2_arith_int_ctx_free(ctx, tparams->IARDH);
             jbig2_arith_int_ctx_free(ctx, tparams->IARDX);
             jbig2_arith_int_ctx_free(ctx, tparams->IARDY);
         } else {
             jbig2_release_huffman_table(ctx, tparams->SBHUFFFS);
             jbig2_release_huffman_table(ctx, tparams->SBHUFFDS);
             jbig2_release_huffman_table(ctx, tparams->SBHUFFDT);
             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDX);
             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDY);
             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDW);
             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDH);
         }
         jbig2_free(ctx->allocator, tparams);
     }
     if (refagg_dicts != NULL) {
         jbig2_sd_release(ctx, refagg_dicts[0]);
         jbig2_free(ctx->allocator, refagg_dicts);
     }
 
 cleanup2:
     jbig2_sd_release(ctx, SDNEWSYMS);
     if (params->SDHUFF && !params->SDREFAGG) {
         jbig2_free(ctx->allocator, SDNEWSYMWIDTHS);
     }
     jbig2_release_huffman_table(ctx, SDHUFFRDX);
     jbig2_release_huffman_table(ctx, SBHUFFRSIZE);
     jbig2_huffman_free(ctx, hs);
     jbig2_arith_iaid_ctx_free(ctx, IAID);
     jbig2_arith_int_ctx_free(ctx, IARDX);
     jbig2_arith_int_ctx_free(ctx, IARDY);
 
 cleanup1:
     jbig2_word_stream_buf_free(ctx, ws);
     jbig2_free(ctx->allocator, as);
     jbig2_arith_int_ctx_free(ctx, IADH);
     jbig2_arith_int_ctx_free(ctx, IADW);
     jbig2_arith_int_ctx_free(ctx, IAEX);
     jbig2_arith_int_ctx_free(ctx, IAAI);
 
     return SDEXSYMS;
 }","[210, 292, 391, 392, 393, 486, 487, 488, 492, 493, 501, 505, 209, 291, 389, 390, 483, 484, 485, 490, 491, 500, 504]","ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript."
9947,"TEST_F(RequantizeTest, HandCraftedRequantize) {
ConfigureRequantize();
const int value_count = 3;


AddInputFromArray<qint32>(TensorShape({value_count}),
{-(1 << 23), 0, (1 << 23)});
AddInputFromArray<float>(TensorShape({1}), {-256.0f});
AddInputFromArray<float>(TensorShape({1}), {256.0f});
AddInputFromArray<float>(TensorShape({1}), {-1.0f});
AddInputFromArray<float>(TensorShape({1}), {1.0f});
TF_ASSERT_OK(RunOpKernel());
Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));
test::FillValues<quint8>(&expected, {0, 128, 255});
test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));
test::ExpectTensorEqual<float>(test::AsScalar<float>(-1.0f), *GetOutput(1));
test::ExpectTensorEqual<float>(test::AsScalar<float>(1.0f), *GetOutput(2));
}","[8, 9, 10, 11]","TensorFlow is an open source platform for machine learning. If `QuantizedInstanceNorm` is given `x_min` or `x_max` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 785d67a78a1d533759fcd2f5e8d6ef778de849e0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
205359," bool PermissionsData::CanRunOnPage(const Extension* extension,
                                    const GURL& document_url,
                                    const GURL& top_frame_url,
                                    int tab_id,
                                    int process_id,
                                    const URLPatternSet& permitted_url_patterns,
                                    std::string* error) const {
   if (g_policy_delegate &&
       !g_policy_delegate->CanExecuteScriptOnPage(
           extension, document_url, top_frame_url, tab_id, process_id, error)) {
      return false;
    }
  
  bool can_execute_everywhere = CanExecuteScriptEverywhere(extension);
  if (!can_execute_everywhere &&
      !ExtensionsClient::Get()->IsScriptableURL(document_url, error)) {
    return false;
  }
  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kExtensionsOnChromeURLs)) {
    if (document_url.SchemeIs(content::kChromeUIScheme) &&
        !can_execute_everywhere) {
      if (error)
        *error = manifest_errors::kCannotAccessChromeUrl;
      return false;
    }
  }
  if (top_frame_url.SchemeIs(kExtensionScheme) &&
      top_frame_url.GetOrigin() !=
          Extension::GetBaseURLFromExtensionId(extension->id()).GetOrigin() &&
      !can_execute_everywhere) {
    if (error)
      *error = manifest_errors::kCannotAccessExtensionUrl;
   if (IsRestrictedUrl(document_url, top_frame_url, extension, error))
      return false;
  }
  
    if (HasTabSpecificPermissionToExecuteScript(tab_id, top_frame_url))
      return true;
 
   bool can_access = permitted_url_patterns.MatchesURL(document_url);
 
   if (!can_access && error) {
     *error = ErrorUtils::FormatErrorMessage(manifest_errors::kCannotAccessPage,
                                             document_url.spec());
   }
 
   return can_access;
 }","[34, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 36]","The Debugger extension API in browser/extensions/api/debugger/debugger_api.cc in Google Chrome before 37.0.2062.94 does not validate a tab's URL before an attach operation, which allows remote attackers to bypass intended access limitations via an extension that uses a restricted URL, as demonstrated by a chrome:// URL."
1353,"explicit HashContext(const HashContext* ctx) {
assert(ctx->ops);
assert(ctx->ops->context_size >= 0);
ops = ctx->ops;
context = malloc(ops->context_size);
ops->hash_copy(context, ctx->context);
options = ctx->options;
key = ctx->key ? strdup(ctx->key) : nullptr;
}",[8],"The HashContext class in hphp/runtime/ext/ext_hash.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 incorrectly expects that a certain key string uses '\0' for termination, which allows remote attackers to obtain sensitive information by leveraging read access beyond the end of the string, and makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging truncation of a string containing an internal '\0' character."
201192," gss_wrap( OM_uint32 *minor_status,
           gss_ctx_id_t context_handle,
           int conf_req_flag,
           gss_qop_t qop_req,
           gss_buffer_t input_message_buffer,
           int *conf_state,
           gss_buffer_t output_message_buffer)
 {
 
      
 
     OM_uint32           status;
     gss_union_ctx_id_t  ctx;
     gss_mechanism       mech;
 
     status = val_wrap_args(minor_status, context_handle,
                            conf_req_flag, qop_req,
                            input_message_buffer, conf_state,
                            output_message_buffer);
     if (status != GSS_S_COMPLETE)
         return (status);
 
      
  
      ctx = (gss_union_ctx_id_t) context_handle;
     if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
         return (GSS_S_NO_CONTEXT);
      mech = gssint_get_mechanism (ctx->mech_type);
  
      if (mech) {
         if (mech->gss_wrap) {
             status = mech->gss_wrap(minor_status,
                                     ctx->internal_ctx_id,
                                     conf_req_flag,
                                     qop_req,
                                     input_message_buffer,
                                     conf_state,
                                     output_message_buffer);
             if (status != GSS_S_COMPLETE)
                 map_error(minor_status, mech);
         } else if (mech->gss_wrap_aead ||
                    (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {
             status = gssint_wrap_aead(mech,
                                       minor_status,
                                       ctx,
                                       conf_req_flag,
                                       (gss_qop_t)qop_req,
                                       GSS_C_NO_BUFFER,
                                       input_message_buffer,
                                       conf_state,
                                       output_message_buffer);
         } else
             status = GSS_S_UNAVAILABLE;
 
         return(status);
     }
      
 
     return (GSS_S_BAD_MECH);
 }","[26, 27]",Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.
198639," tight_filter_gradient24(VncState *vs, uint8_t *buf, int w, int h)
 {
     uint32_t *buf32;
     uint32_t pix32;
     int shift[3];
     int *prev;
     int here[3], upper[3], left[3], upperleft[3];
     int prediction;
     int x, y, c;
 
      buf32 = (uint32_t *)buf;
      memset(vs->tight.gradient.buffer, 0, w * 3 * sizeof(int));
  
    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==
        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {
        shift[0] = vs->clientds.pf.rshift;
        shift[1] = vs->clientds.pf.gshift;
        shift[2] = vs->clientds.pf.bshift;
     if (1  ) {
         shift[0] = vs->client_pf.rshift;
         shift[1] = vs->client_pf.gshift;
         shift[2] = vs->client_pf.bshift;
      } else {
        shift[0] = 24 - vs->clientds.pf.rshift;
        shift[1] = 24 - vs->clientds.pf.gshift;
        shift[2] = 24 - vs->clientds.pf.bshift;
         shift[0] = 24 - vs->client_pf.rshift;
         shift[1] = 24 - vs->client_pf.gshift;
         shift[2] = 24 - vs->client_pf.bshift;
      }
  
      for (y = 0; y < h; y++) {
         for (c = 0; c < 3; c++) {
             upper[c] = 0;
             here[c] = 0;
         }
         prev = (int *)vs->tight.gradient.buffer;
         for (x = 0; x < w; x++) {
             pix32 = *buf32++;
             for (c = 0; c < 3; c++) {
                 upperleft[c] = upper[c];
                 left[c] = here[c];
                 upper[c] = *prev;
                 here[c] = (int)(pix32 >> shift[c] & 0xFF);
                 *prev++ = here[c];
 
                 prediction = left[c] + upper[c] - upperleft[c];
                 if (prediction < 0) {
                     prediction = 0;
                 } else if (prediction > 0xFF) {
                     prediction = 0xFF;
                 }
                 *buf++ = (char)(here[c] - prediction);
             }
         }
     }
 }","[19, 20, 21, 22, 27, 28, 29, 14, 15, 16, 17, 18, 24, 25, 26]",An out-of-bounds memory access issue was found in Quick Emulator (QEMU) before 1.7.2 in the VNC display driver. This flaw could occur while refreshing the VNC display surface area in the 'vnc_refresh_server_surface'. A user inside a guest could use this flaw to crash the QEMU process.
198338," SPL_METHOD(Array, unserialize)
 {
 	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 
 	char *buf;
 	int buf_len;
 	const unsigned char *p, *s;
 	php_unserialize_data_t var_hash;
 	zval *pmembers, *pflags = NULL;
 	long flags;
 	
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &buf, &buf_len) == FAILURE) {
 		return;
 	}
 
 	if (buf_len == 0) {
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Empty serialized string cannot be empty"");
 		return;
 	}
 
 	 
 	s = p = (const unsigned char*)buf;
 	PHP_VAR_UNSERIALIZE_INIT(var_hash);
 
 	if (*p!= 'x' || *++p != ':') {
 		goto outexcept;
 	}
 	++p;
 
 	ALLOC_INIT_ZVAL(pflags);
 	if (!php_var_unserialize(&pflags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pflags) != IS_LONG) {
 		zval_ptr_dtor(&pflags);
 		goto outexcept;
 	}
 
 	--p;  
 	flags = Z_LVAL_P(pflags);
 	zval_ptr_dtor(&pflags);
 	 
 
 	if (*p != ';') {
 		goto outexcept;
 	}
 	++p;
 
 	if (*p!='m') {
 		if (*p!='a' && *p!='O' && *p!='C' && *p!='r') {
 			goto outexcept;
 		}
 		intern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;
 		intern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;
 		zval_ptr_dtor(&intern->array);
 		ALLOC_INIT_ZVAL(intern->array);
 		if (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {
 			goto outexcept;
 		}
 	}
 	if (*p != ';') {
 		goto outexcept;
 	}
 	++p;
 
 	 
 	if (*p!= 'm' || *++p != ':') {
 		goto outexcept;
 	}
         ++p;
  
         ALLOC_INIT_ZVAL(pmembers);
       if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC)) {
        if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) {
                 zval_ptr_dtor(&pmembers);
                 goto outexcept;
         }
 
 	 
 	if (!intern->std.properties) {
 		rebuild_object_properties(&intern->std);
 	}
 	zend_hash_copy(intern->std.properties, Z_ARRVAL_P(pmembers), (copy_ctor_func_t) zval_add_ref, (void *) NULL, sizeof(zval *));
 	zval_ptr_dtor(&pmembers);
 
 	 
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	return;
 
 outexcept:
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Error at offset %ld of %d bytes"", (long)((char*)p - buf), buf_len);
 	return;
 
 }  
 
  ","[71, 70]","The SPL component in PHP before 5.4.30 and 5.5.x before 5.5.14 incorrectly anticipates that certain data structures will have the array data type after unserialization, which allows remote attackers to execute arbitrary code via a crafted string that triggers use of a Hashtable destructor, related to ""type confusion"" issues in (1) ArrayObject and (2) SPLObjectStorage."
207507," ssize_t socket_bytes_available(const socket_t *socket) {
 
    assert(socket != NULL);
  
    int size = 0;
  if (ioctl(socket->fd, FIONREAD, &size) == -1)
   if (TEMP_FAILURE_RETRY(ioctl(socket->fd, FIONREAD, &size)) == -1)
      return -1;
    return size;
  }","[7, 6]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
204903,"  void BaseMultipleFieldsDateAndTimeInputType::didBlurFromControl()
  {
  
     if (containsFocusedShadowElement())
         return;
      RefPtr<HTMLInputElement> protector(element());
      element()->setFocus(false);
 }","[4, 5]",Use-after-free vulnerability in Google Chrome before 28.0.1500.95 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to not properly considering focus during the processing of JavaScript events in the presence of a multiple-fields input type.
204794," static v8::Handle<v8::Value> overloadedMethod6Callback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestObj.overloadedMethod6"");
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestObj* imp = V8TestObj::toNative(args.Holder());
      EXCEPTION_BLOCK(RefPtr<DOMStringList>, listArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
      imp->overloadedMethod(listArg);
     return v8::Handle<v8::Value>();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
197753," pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict)
 {
 	pdf_obj *obj;
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_LW);
 	if (pdf_is_number(ctx, obj) && proc->op_w)
 		proc->op_w(ctx, proc, pdf_to_real(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_LC);
 	if (pdf_is_int(ctx, obj) && proc->op_J)
 		proc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_LJ);
 	if (pdf_is_int(ctx, obj) && proc->op_j)
 		proc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_ML);
 	if (pdf_is_number(ctx, obj) && proc->op_M)
 		proc->op_M(ctx, proc, pdf_to_real(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_D);
 	if (pdf_is_array(ctx, obj) && proc->op_d)
 	{
 		pdf_obj *dash_array = pdf_array_get(ctx, obj, 0);
 		pdf_obj *dash_phase = pdf_array_get(ctx, obj, 1);
 		proc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase));
 	}
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_RI);
 	if (pdf_is_name(ctx, obj) && proc->op_ri)
 		proc->op_ri(ctx, proc, pdf_to_name(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_FL);
 	if (pdf_is_number(ctx, obj) && proc->op_i)
 		proc->op_i(ctx, proc, pdf_to_real(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_Font);
 	if (pdf_is_array(ctx, obj) && proc->op_Tf)
 	{
 		pdf_obj *font_ref = pdf_array_get(ctx, obj, 0);
 		pdf_obj *font_size = pdf_array_get(ctx, obj, 1);
 		pdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie);
 		fz_try(ctx)
 			proc->op_Tf(ctx, proc, ""ExtGState"", font, pdf_to_real(ctx, font_size));
 		fz_always(ctx)
 			pdf_drop_font(ctx, font);
 		fz_catch(ctx)
 			fz_rethrow(ctx);
 	}
 
 	 
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_OP);
 	if (pdf_is_bool(ctx, obj) && proc->op_gs_OP)
 		proc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_op);
 	if (pdf_is_bool(ctx, obj) && proc->op_gs_op)
 		proc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_OPM);
 	if (pdf_is_int(ctx, obj) && proc->op_gs_OPM)
 		proc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp);
 	if (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp)
 		proc->op_gs_UseBlackPtComp(ctx, proc, obj);
 
 	 
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_TR2);
 	if (pdf_is_name(ctx, obj))
 		if (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default))
 			fz_warn(ctx, ""ignoring transfer function"");
 	if (!obj)  
 	{
 		pdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR);
 		if (pdf_is_name(ctx, tr))
 			if (!pdf_name_eq(ctx, tr, PDF_NAME_Identity))
 				fz_warn(ctx, ""ignoring transfer function"");
 	}
 
 	 
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_CA);
 	if (pdf_is_number(ctx, obj) && proc->op_gs_CA)
 		proc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_ca);
 	if (pdf_is_number(ctx, obj) && proc->op_gs_ca)
 		proc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_BM);
 	if (pdf_is_array(ctx, obj))
 		obj = pdf_array_get(ctx, obj, 0);
 	if (pdf_is_name(ctx, obj) && proc->op_gs_BM)
 		proc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj));
 
 	obj = pdf_dict_get(ctx, dict, PDF_NAME_SMask);
 	if (proc->op_gs_SMask)
 	{
 		if (pdf_is_dict(ctx, obj))
 		{
 			pdf_xobject *xobj;
 			pdf_obj *group, *s, *bc, *tr;
 			float softmask_bc[FZ_MAX_COLORS];
 			fz_colorspace *colorspace;
 			int colorspace_n = 1;
 			int k, luminosity;
 
                         fz_var(xobj);
  
                         group = pdf_dict_get(ctx, obj, PDF_NAME_G);
                       if (!group)
                               fz_throw(ctx, FZ_ERROR_SYNTAX, ""cannot load softmask xobject (%d 0 R)"", pdf_to_num(ctx, obj));
                         xobj = pdf_load_xobject(ctx, csi->doc, group);
  
 
 			fz_try(ctx)
 			{
 				colorspace = pdf_xobject_colorspace(ctx, xobj);
 				if (colorspace)
 					colorspace_n = fz_colorspace_n(ctx, colorspace);
 
 				 
 				for (k = 0; k < colorspace_n; k++)
 					softmask_bc[k] = 0;
 				 
 				if (fz_colorspace_is_cmyk(ctx, colorspace))
 					softmask_bc[3] = 1.0f;
 				fz_drop_colorspace(ctx, colorspace);
 
 				bc = pdf_dict_get(ctx, obj, PDF_NAME_BC);
 				if (pdf_is_array(ctx, bc))
 				{
 					for (k = 0; k < colorspace_n; k++)
 						softmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k));
 				}
 
 				s = pdf_dict_get(ctx, obj, PDF_NAME_S);
 				if (pdf_name_eq(ctx, s, PDF_NAME_Luminosity))
 					luminosity = 1;
 				else
 					luminosity = 0;
 
 				tr = pdf_dict_get(ctx, obj, PDF_NAME_TR);
 				if (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity))
 					fz_warn(ctx, ""ignoring transfer function"");
 
 				proc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity);
 			}
 			fz_always(ctx)
 			{
 				pdf_drop_xobject(ctx, xobj);
 			}
 			fz_catch(ctx)
 			{
 				fz_rethrow(ctx);
 			}
 		}
 		else if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None))
 		{
 			proc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0);
 		}
 	}
 }","[114, 115]","In MuPDF 1.12.0 and earlier, multiple reachable assertions in the PDF parser allow an attacker to cause a denial of service (assert crash) via a crafted file."
204043," EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert4(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
     if (!thisValue.inherits(&JSTestObj::s_info))
         return throwVMTypeError(exec);
     JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));
      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
      TestObj* impl = static_cast<TestObj*>(castedThis->impl());
      if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      d* (tod(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
      if (exec->hadException())
          return JSValue::encode(jsUndefined());
     impl->convert4();
     return JSValue::encode(jsUndefined());
 }","[11, 10]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
207044," UseCounterPageLoadMetricsObserver::GetAllowedUkmFeatures() {
   static base::NoDestructor<UseCounterPageLoadMetricsObserver::UkmFeatureList>
       opt_in_features(std::initializer_list<WebFeature>({
           WebFeature::kNavigatorVibrate,
           WebFeature::kNavigatorVibrateSubFrame,
           WebFeature::kTouchEventPreventedNoTouchAction,
           WebFeature::kTouchEventPreventedForcedDocumentPassiveNoTouchAction,
           WebFeature::kDataUriHasOctothorpe,
           WebFeature::kApplicationCacheManifestSelectInsecureOrigin,
           WebFeature::kApplicationCacheManifestSelectSecureOrigin,
           WebFeature::kMixedContentAudio,
           WebFeature::kMixedContentImage,
           WebFeature::kMixedContentVideo,
           WebFeature::kMixedContentPlugin,
           WebFeature::kOpenerNavigationWithoutGesture,
           WebFeature::kUsbRequestDevice,
           WebFeature::kXMLHttpRequestSynchronous,
           WebFeature::kPaymentHandler,
           WebFeature::kPaymentRequestShowWithoutGesture,
           WebFeature::kHTMLImports,
           WebFeature::kHTMLImportsHasStyleSheets,
           WebFeature::kElementCreateShadowRoot,
           WebFeature::kDocumentRegisterElement,
           WebFeature::kCredentialManagerCreatePublicKeyCredential,
           WebFeature::kCredentialManagerGetPublicKeyCredential,
           WebFeature::kCredentialManagerMakePublicKeyCredentialSuccess,
           WebFeature::kCredentialManagerGetPublicKeyCredentialSuccess,
           WebFeature::kV8AudioContext_Constructor,
           WebFeature::kElementAttachShadow,
           WebFeature::kElementAttachShadowOpen,
           WebFeature::kElementAttachShadowClosed,
           WebFeature::kCustomElementRegistryDefine,
           WebFeature::kTextToSpeech_Speak,
           WebFeature::kTextToSpeech_SpeakDisallowedByAutoplay,
           WebFeature::kCSSEnvironmentVariable,
           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetTop,
           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetLeft,
           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetRight,
           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetBottom,
           WebFeature::kMediaControlsDisplayCutoutGesture,
           WebFeature::kPolymerV1Detected,
           WebFeature::kPolymerV2Detected,
           WebFeature::kFullscreenSecureOrigin,
           WebFeature::kFullscreenInsecureOrigin,
           WebFeature::kPrefixedVideoEnterFullscreen,
           WebFeature::kPrefixedVideoExitFullscreen,
           WebFeature::kPrefixedVideoEnterFullScreen,
           WebFeature::kPrefixedVideoExitFullScreen,
           WebFeature::kDocumentLevelPassiveDefaultEventListenerPreventedWheel,
           WebFeature::kDocumentDomainBlockedCrossOriginAccess,
           WebFeature::kDocumentDomainEnabledCrossOriginAccess,
           WebFeature::kSuppressHistoryEntryWithoutUserGesture,
           WebFeature::kCursorImageGT32x32,
           WebFeature::kCursorImageLE32x32,
           WebFeature::kHistoryPushState,
           WebFeature::kHistoryReplaceState,
           WebFeature::kCursorImageGT64x64,
           WebFeature::kAdClick,
           WebFeature::kUpdateWithoutShippingOptionOnShippingAddressChange,
           WebFeature::kUpdateWithoutShippingOptionOnShippingOptionChange,
           WebFeature::kSignedExchangeInnerResponseInMainFrame,
           WebFeature::kSignedExchangeInnerResponseInSubFrame,
           WebFeature::kWebShareShare,
           WebFeature::kHTMLAnchorElementDownloadInSandboxWithUserGesture,
           WebFeature::kHTMLAnchorElementDownloadInSandboxWithoutUserGesture,
           WebFeature::kNavigationDownloadInSandboxWithUserGesture,
           WebFeature::kNavigationDownloadInSandboxWithoutUserGesture,
           WebFeature::kDownloadInAdFrameWithUserGesture,
            WebFeature::kDownloadInAdFrameWithoutUserGesture,
            WebFeature::kOpenWebDatabase,
            WebFeature::kV8MediaCapabilities_DecodingInfo_Method,
           WebFeature::kOpenerNavigationDownloadCrossOriginNoGesture,
        }));
    return *opt_in_features;
  }",[72],Incorrect handling of download origins in Navigation in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to perform domain spoofing via a crafted HTML page.
198527,"  static void vmxnet3_activate_device(VMXNET3State *s)
  {
      int i;
     VMW_CFPRN(""MTU is %u"", s->mtu);
 
     s->max_rx_frags =
         VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.misc.maxNumRxSG);
 
     if (s->max_rx_frags == 0) {
         s->max_rx_frags = 1;
     }
 
     VMW_CFPRN(""Max RX fragments is %u"", s->max_rx_frags);
 
     s->event_int_idx =
         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.eventIntrIdx);
     assert(vmxnet3_verify_intx(s, s->event_int_idx));
     VMW_CFPRN(""Events interrupt line is %u"", s->event_int_idx);
 
     s->auto_int_masking =
         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.autoMask);
     VMW_CFPRN(""Automatic interrupt masking is %d"", (int)s->auto_int_masking);
 
     s->txq_num =
         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numTxQueues);
     s->rxq_num =
         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);
 
     VMW_CFPRN(""Number of TX/RX queues %u/%u"", s->txq_num, s->rxq_num);
     assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);
 
     qdescr_table_pa =
         VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);
     VMW_CFPRN(""TX queues descriptors table is at 0x%"" PRIx64, qdescr_table_pa);
 
      
     s->max_tx_frags = 0;
 
      
     for (i = 0; i < s->txq_num; i++) {
          VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);
  
      VMW_CFPRN(""Number of TX/RX queues %u/%u"", s->txq_num, s->rxq_num);
    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);
     vmxnet3_validate_queues(s);
  
      qdescr_table_pa =
          VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);
 
         VMW_CFPRN(""TX Queue %d interrupt: %d"", i, s->txq_descr[i].intr_idx);
 
          
         pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.txRingBasePA);
         size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.txRingSize);
 
         vmxnet3_ring_init(&s->txq_descr[i].tx_ring, pa, size,
                           sizeof(struct Vmxnet3_TxDesc), false);
         VMXNET3_RING_DUMP(VMW_CFPRN, ""TX"", i, &s->txq_descr[i].tx_ring);
 
         s->max_tx_frags += size;
 
          
         pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.compRingBasePA);
         size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.compRingSize);
         vmxnet3_ring_init(&s->txq_descr[i].comp_ring, pa, size,
                           sizeof(struct Vmxnet3_TxCompDesc), true);
         VMXNET3_RING_DUMP(VMW_CFPRN, ""TXC"", i, &s->txq_descr[i].comp_ring);
 
         s->txq_descr[i].tx_stats_pa =
             qdescr_pa + offsetof(struct Vmxnet3_TxQueueDesc, stats);
 
         memset(&s->txq_descr[i].txq_stats, 0,
                sizeof(s->txq_descr[i].txq_stats));
 
          
         VMXNET3_WRITE_TX_QUEUE_DESCR32(qdescr_pa,
                                        ctrl.txThreshold,
                                        VMXNET3_DEF_TX_THRESHOLD);
     }
 
      
     VMW_CFPRN(""Max TX fragments is %u"", s->max_tx_frags);
     vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);
     vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);
 
      
     for (i = 0; i < s->rxq_num; i++) {
         int j;
         hwaddr qd_pa =
             qdescr_table_pa + s->txq_num * sizeof(struct Vmxnet3_TxQueueDesc) +
             i * sizeof(struct Vmxnet3_RxQueueDesc);
 
          
         s->rxq_descr[i].intr_idx =
             VMXNET3_READ_TX_QUEUE_DESCR8(qd_pa, conf.intrIdx);
         assert(vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx));
 
         VMW_CFPRN(""RX Queue %d interrupt: %d"", i, s->rxq_descr[i].intr_idx);
 
          
         for (j = 0; j < VMXNET3_RX_RINGS_PER_QUEUE; j++) {
              
             pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.rxRingBasePA[j]);
             size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.rxRingSize[j]);
             vmxnet3_ring_init(&s->rxq_descr[i].rx_ring[j], pa, size,
                               sizeof(struct Vmxnet3_RxDesc), false);
             VMW_CFPRN(""RX queue %d:%d: Base: %"" PRIx64 "", Size: %d"",
                       i, j, pa, size);
         }
 
          
         pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.compRingBasePA);
         size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.compRingSize);
         vmxnet3_ring_init(&s->rxq_descr[i].comp_ring, pa, size,
                           sizeof(struct Vmxnet3_RxCompDesc), true);
         VMW_CFPRN(""RXC queue %d: Base: %"" PRIx64 "", Size: %d"", i, pa, size);
 
         s->rxq_descr[i].rx_stats_pa =
             qd_pa + offsetof(struct Vmxnet3_RxQueueDesc, stats);
         memset(&s->rxq_descr[i].rxq_stats, 0,
                sizeof(s->rxq_descr[i].rxq_stats));
     }
 
     vmxnet3_validate_interrupts(s);
 
      
     smp_wmb();
 
     vmxnet3_reset_mac(s);
 
     s->device_active = true;
 }","[45, 44]","hw/net/vmxnet3.c in QEMU 2.0.0-rc0, 1.7.1, and earlier allows local guest users to cause a denial of service or possibly execute arbitrary code via vectors related to (1) RX or (2) TX queue numbers or (3) interrupt indices.  NOTE: some of these details are obtained from third party information."
199685," static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,
 			struct msghdr *msg, size_t size, int flags)
  {
  	struct sock *sk = sock->sk;
  	struct rose_sock *rose = rose_sk(sk);
	struct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;
  	size_t copied;
  	unsigned char *asmptr;
  	struct sk_buff *skb;
 	int n, er, qbit;
 
 	 
 	if (sk->sk_state != TCP_ESTABLISHED)
 		return -ENOTCONN;
 
 	 
 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)
 		return er;
 
 	qbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;
 
 	skb_pull(skb, ROSE_MIN_LEN);
 
 	if (rose->qbitincl) {
 		asmptr  = skb_push(skb, 1);
 		*asmptr = qbit;
 	}
 
 	skb_reset_transport_header(skb);
 	copied     = skb->len;
 
 	if (copied > size) {
 		copied = size;
 		msg->msg_flags |= MSG_TRUNC;
 	}
  
  	skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
  
	if (srose != NULL) {
		memset(srose, 0, msg->msg_namelen);
 	if (msg->msg_name) {
 		struct sockaddr_rose *srose;
 
 		memset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));
 		srose = msg->msg_name;
  		srose->srose_family = AF_ROSE;
  		srose->srose_addr   = rose->dest_addr;
  		srose->srose_call   = rose->dest_call;
 		srose->srose_ndigis = rose->dest_ndigis;
 		if (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {
 			struct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;
 			for (n = 0 ; n < rose->dest_ndigis ; n++)
 				full_srose->srose_digis[n] = rose->dest_digis[n];
 			msg->msg_namelen = sizeof(struct full_sockaddr_rose);
 		} else {
 			if (rose->dest_ndigis >= 1) {
 				srose->srose_ndigis = 1;
 				srose->srose_digi = rose->dest_digis[0];
 			}
 			msg->msg_namelen = sizeof(struct sockaddr_rose);
 		}
 	}
 
 	skb_free_datagram(sk, skb);
 
 	return copied;
 }","[41, 42, 43, 44, 45, 6, 39, 40]","The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
6420,"void Compute(OpKernelContext* context) override {
const Tensor& splits = context->input(0);
const Tensor& values = context->input(1);
const Tensor& weights = context->input(2);
bool use_weights = weights.NumElements() > 0;
bool is_1d = false;

const auto splits_values = splits.flat<int64>();
const auto values_values = values.flat<T>();
const auto weight_values = weights.flat<W>();
int num_batches = splits.NumElements() - 1;
int num_values = values.NumElements();

auto per_batch_counts = BatchedMap<W>(num_batches);
T max_value = 0;
int batch_idx = 0;

for (int idx = 0; idx < num_values; ++idx) {
while (idx >= splits_values(batch_idx)) {
batch_idx++;
}
const auto& value = values_values(idx);
if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {
if (binary_output_) {
per_batch_counts[batch_idx - 1][value] = 1;
} else if (use_weights) {
per_batch_counts[batch_idx - 1][value] += weight_values(idx);
} else {
per_batch_counts[batch_idx - 1][value]++;
}
if (value > max_value) {
max_value = value;
}
}
}

int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);
OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,
is_1d, context));
}","[8, 14]","In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1."
206378," void NavigationControllerImpl::RendererDidNavigateToExistingPage(
     RenderFrameHostImpl* rfh,
     const FrameHostMsg_DidCommitProvisionalLoad_Params& params,
     bool is_in_page,
     bool was_restored,
     NavigationHandleImpl* handle) {
   DCHECK(!rfh->GetParent());
 
 
   NavigationEntryImpl* entry;
   if (params.intended_as_new_entry) {
      entry = GetLastCommittedEntry();
     MaybeDumpCopiedNonSameOriginEntry(""Existing page navigation"", params,
                                       is_in_page, entry);
    } else if (params.nav_entry_id) {
      entry = GetEntryWithUniqueID(params.nav_entry_id);
 
     if (is_in_page) {
       NavigationEntryImpl* last_entry = GetLastCommittedEntry();
       if (entry->GetURL().GetOrigin() == last_entry->GetURL().GetOrigin() &&
           last_entry->GetSSL().initialized && !entry->GetSSL().initialized &&
           was_restored) {
         entry->GetSSL() = last_entry->GetSSL();
       }
     } else {
       entry->GetSSL() = handle->ssl_status();
     }
   } else {
     entry = GetLastCommittedEntry();
 
     if (!is_in_page)
       entry->GetSSL() = handle->ssl_status();
   }
   DCHECK(entry);
 
   entry->set_page_type(params.url_is_unreachable ? PAGE_TYPE_ERROR
                                                  : PAGE_TYPE_NORMAL);
   entry->SetURL(params.url);
   entry->SetReferrer(params.referrer);
   if (entry->update_virtual_url_with_url())
     UpdateVirtualURLToURL(entry, params.url);
 
   DCHECK(entry->site_instance() == nullptr ||
          !entry->GetRedirectChain().empty() ||
          entry->site_instance() == rfh->GetSiteInstance());
 
   entry->AddOrUpdateFrameEntry(
       rfh->frame_tree_node(), params.item_sequence_number,
       params.document_sequence_number, rfh->GetSiteInstance(), nullptr,
       params.url, params.referrer, params.redirects, params.page_state,
       params.method, params.post_id);
 
   if (ui::PageTransitionIsRedirect(params.transition) && !is_in_page)
     entry->GetFavicon() = FaviconStatus();
 
   DiscardNonCommittedEntriesInternal();
 
   last_committed_entry_index_ = GetIndexOfEntry(entry);
 }","[13, 14]","Google Chrome prior to 57.0.2987.98 for Windows and Mac had a race condition, which could cause Chrome to display incorrect certificate information for a site."
202437," static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
                                       unsigned char **p,
                                       unsigned char *end )
 {
     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
     size_t  len;
     ((void) ssl);
 
      
     if( (*p) > end - 2 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
                                     ""(psk_identity_hint length)"" ) );
         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
     }
      len = (*p)[0] << 8 | (*p)[1];
      *p += 2;
  
     if( (*p) + len > end )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
                                     ""(psk_identity_hint length)"" ) );
         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
     }
 
      
     *p += len;
     ret = 0;
 
     return( ret );
 }","[10, 11, 12, 13, 14, 15]","ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_psk_hint() that could cause a crash on invalid input."
206472,"  static sk_sp<SkImage> newSkImageFromRaster(const SkImageInfo& info,
                                             PassRefPtr<Uint8Array> imagePixels,
                                           size_t imageRowBytes) {
                                            unsigned imageRowBytes) {
    SkPixmap pixmap(info, imagePixels->data(), imageRowBytes);
    return SkImage::MakeFromRaster(pixmap,
                                   [](const void*, void* pixels) {
                                    static_cast<Uint8Array*>(pixels)->deref();
                                  },
                                  imagePixels.leakRef());
  }","[4, 3]","Bad casting in bitmap manipulation in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
207112,"  GLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer) {
  if (!buffer || isContextLost())
   if (!buffer || isContextLost() || !buffer->Validate(ContextGroup(), this))
      return 0;
  
    if (!buffer->HasEverBeenBound())
     return 0;
   if (buffer->IsDeleted())
     return 0;
 
   return ContextGL()->IsBuffer(buffer->Object());
 }","[3, 2]",Insufficient data validation in WebGL in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
201749," static Image *ReadLABELImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   char
     geometry[MaxTextExtent],
     *property;
 
   const char
     *label;
 
   DrawInfo
     *draw_info;
 
   Image
     *image;
 
   MagickBooleanType
     status;
 
   TypeMetric
     metrics;
 
   size_t
     height,
     width;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   (void) ResetImagePage(image,""0x0+0+0"");
   property=InterpretImageProperties(image_info,image,image_info->filename);
   (void) SetImageProperty(image,""label"",property);
   property=DestroyString(property);
   label=GetImageProperty(image,""label"");
   draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
   draw_info->text=ConstantString(label);
   metrics.width=0;
   metrics.ascent=0.0;
   status=GetMultilineTypeMetrics(image,draw_info,&metrics);
   if ((image->columns == 0) && (image->rows == 0))
     {
       image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
       image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
     }
   else
     if (((image->columns == 0) || (image->rows == 0)) ||
         (fabs(image_info->pointsize) < MagickEpsilon))
       {
         double
           high,
           low;
 
          
         for ( ; ; draw_info->pointsize*=2.0)
         {
           (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
             -metrics.bounds.x1,metrics.ascent);
           if (draw_info->gravity == UndefinedGravity)
             (void) CloneString(&draw_info->geometry,geometry);
           status=GetMultilineTypeMetrics(image,draw_info,&metrics);
           (void) status;
           width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
           height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
           if ((image->columns != 0) && (image->rows != 0))
             {
               if ((width >= image->columns) && (height >= image->rows))
                 break;
             }
           else
             if (((image->columns != 0) && (width >= image->columns)) ||
                 ((image->rows != 0) && (height >= image->rows)))
               break;
         }
         high=draw_info->pointsize;
         for (low=1.0; (high-low) > 0.5; )
         {
           draw_info->pointsize=(low+high)/2.0;
           (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
             -metrics.bounds.x1,metrics.ascent);
           if (draw_info->gravity == UndefinedGravity)
             (void) CloneString(&draw_info->geometry,geometry);
           status=GetMultilineTypeMetrics(image,draw_info,&metrics);
           width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
           height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
           if ((image->columns != 0) && (image->rows != 0))
             {
               if ((width < image->columns) && (height < image->rows))
                 low=draw_info->pointsize+0.5;
               else
                 high=draw_info->pointsize-0.5;
             }
           else
             if (((image->columns != 0) && (width < image->columns)) ||
                 ((image->rows != 0) && (height < image->rows)))
               low=draw_info->pointsize+0.5;
             else
               high=draw_info->pointsize-0.5;
         }
         draw_info->pointsize=(low+high)/2.0-0.5;
       }
   status=GetMultilineTypeMetrics(image,draw_info,&metrics);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   if (image->columns == 0)
     image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
   if (image->columns == 0)
     image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
   if (image->rows == 0)
     image->rows=(size_t) (metrics.ascent-metrics.descent+
        draw_info->stroke_width+0.5);
    if (image->rows == 0)
      image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
    if (draw_info->gravity == UndefinedGravity)
      {
        (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
         -metrics.bounds.x1+draw_info->stroke_width/2.0,metrics.ascent+
         draw_info->stroke_width/2.0);
       (void) CloneString(&draw_info->geometry,geometry);
     }
   if (draw_info->direction == RightToLeftDirection)
     {
       if (draw_info->direction == RightToLeftDirection)
         (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
           image->columns-(metrics.bounds.x2+draw_info->stroke_width/2.0),
           metrics.ascent+draw_info->stroke_width/2.0);
       (void) CloneString(&draw_info->geometry,geometry);
     }
   if (SetImageBackgroundColor(image) == MagickFalse)
     {
       InheritException(exception,&image->exception);
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   (void) AnnotateImage(image,draw_info);
   if (image_info->pointsize == 0.0)
     {
       char
         pointsize[MaxTextExtent];
 
       (void) FormatLocaleString(pointsize,MaxTextExtent,""%.20g"",
         draw_info->pointsize);
       (void) SetImageProperty(image,""label:pointsize"",pointsize);
     }
   draw_info=DestroyDrawInfo(draw_info);
   return(GetFirstImageInList(image));
 }","[123, 124, 125, 126, 127, 128]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
9826,"static int log_statement_ex(const struct connection_info *cn,
time_t ev_time, unsigned long thd_id,
const char *query, unsigned int query_len,
int error_code, const char *type, int take_lock)
{
size_t csize;
char message_loc[1024];
char *message= message_loc;
size_t message_size= sizeof(message_loc);
char *uh_buffer;
size_t uh_buffer_size;
const char *db;
unsigned int db_length;
long long query_id;
int result;

if ((db= cn->db))
db_length= cn->db_length;
else
{
db= """";
db_length= 0;
}

if (!(query_id= cn->query_id))
query_id= query_counter++;

if (query == 0)
{

query= cn->query;
query_len= cn->query_length;
if (query == 0 || query_len == 0)
return 0;
}

if (query && !(events & EVENT_QUERY_ALL) &&
(events & EVENT_QUERY && !cn->log_always))
{
const char *orig_query= query;

if (filter_query_type(query, keywords_to_skip))
{
char fword[MAX_KEYWORD + 1];
int len;
do
{
len= get_next_word(query, fword);
query+= len ? len : 1;
if (len == 3 && strncmp(fword, ""FOR"", 3) == 0)
break;
} while (*query);

if (*query == 0)
return 0;
}

if (events & EVENT_QUERY_DDL)
{
if (!filter_query_type(query, not_ddl_keywords) &&
filter_query_type(query, ddl_keywords))
goto do_log_query;
}
if (events & EVENT_QUERY_DML)
{
if (filter_query_type(query, dml_keywords))
goto do_log_query;
}
if (events & EVENT_QUERY_DML_NO_SELECT)
{
if (filter_query_type(query, dml_no_select_keywords))
goto do_log_query;
}
if (events & EVENT_QUERY_DCL)
{
if (filter_query_type(query, dcl_keywords))
goto do_log_query;
}

return 0;
do_log_query:
query= orig_query;
}

csize= log_header(message, message_size-1, &ev_time,
servhost, servhost_len,
cn->user, cn->user_length,cn->host, cn->host_length,
cn->ip, cn->ip_length, thd_id, query_id, type);

csize+= my_snprintf(message+csize, message_size - 1 - csize,
"",%.*s,\'"", db_length, db);

if (query_log_limit > 0 && query_len > query_log_limit)
query_len= query_log_limit;

if (query_len > (message_size - csize)/2)
{
flogger_mutex_lock(&lock_bigbuffer);
if (big_buffer_alloced < (query_len * 2 + csize))
{
big_buffer_alloced= (query_len * 2 + csize + 4095) & ~4095L;
big_buffer= realloc(big_buffer, big_buffer_alloced);
if (big_buffer == NULL)
{
big_buffer_alloced= 0;
return 0;
}
}

memcpy(big_buffer, message, csize);
message= big_buffer;
message_size= big_buffer_alloced;
}

uh_buffer= message + csize;
uh_buffer_size= message_size - csize;
if (query_log_limit > 0 && uh_buffer_size > query_log_limit+2)
uh_buffer_size= query_log_limit+2;

switch (filter_query_type(query, passwd_keywords))
{
case SQLCOM_GRANT:
case SQLCOM_CREATE_USER:
csize+= escape_string_hide_passwords(query, query_len,
uh_buffer, uh_buffer_size,
""IDENTIFIED"", 10, ""BY"", 2, 0);
break;
case SQLCOM_CHANGE_MASTER:
csize+= escape_string_hide_passwords(query, query_len,
uh_buffer, uh_buffer_size,
""MASTER_PASSWORD"", 15, ""="", 1, 0);
break;
case SQLCOM_CREATE_SERVER:
case SQLCOM_ALTER_SERVER:
csize+= escape_string_hide_passwords(query, query_len,
uh_buffer, uh_buffer_size,
""PASSWORD"", 8, NULL, 0, 0);
break;
case SQLCOM_SET_OPTION:
csize+= escape_string_hide_passwords(query, query_len,
uh_buffer, uh_buffer_size,
""="", 1, NULL, 0, 1);
break;
default:
csize+= escape_string(query, query_len,
uh_buffer, uh_buffer_size);
break;
}
csize+= my_snprintf(message+csize, message_size - 1 - csize,
""\',%d"", error_code);
message[csize]= '\n';
result= write_log(message, csize + 1, take_lock);
if (message == big_buffer)
flogger_mutex_unlock(&lock_bigbuffer);

return result;
}","[7, 17, 98, 99, 101, 102, 103, 105, 106, 153, 154]","MariaDB Server before 10.7 is vulnerable to Denial of Service. While executing the plugin/server_audit/server_audit.c method log_statement_ex, the held lock lock_bigbuffer is not released correctly, which allows local users to trigger a denial of service due to the deadlock."
207126," void ProcessHeap::Init() {
   total_allocated_space_ = 0;
    total_allocated_object_size_ = 0;
    total_marked_object_size_ = 0;
  
  GCInfoTable::Init();
    base::SamplingHeapProfiler::SetHooksInstallCallback([]() {
      HeapAllocHooks::SetAllocationHook(&BlinkGCAllocHook);
      HeapAllocHooks::SetFreeHook(&BlinkGCFreeHook);
   });
 }",[6],A race condition in Oilpan in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
198560," static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,
 				     int off_pitch, int bytesperline,
 				     int lines)
 {
     int y;
      int off_cur;
      int off_cur_end;
  
     if (off_pitch < 0) {
         off_begin -= bytesperline - 1;
     }
 
      for (y = 0; y < lines; y++) {
         off_cur = off_begin;
         off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;
         assert(off_cur_end >= off_cur);
          memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);
         off_begin += off_pitch;
      }
     uint8_t *dst;
 
     dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);
 
     if (blit_is_unsafe(s, false))
         return 0;
 
     (*s->cirrus_rop) (s, dst, src,
                       s->cirrus_blt_dstpitch, 0,
                       s->cirrus_blt_width, s->cirrus_blt_height);
     cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,
                              s->cirrus_blt_dstpitch, s->cirrus_blt_width,
                              s->cirrus_blt_height);
     return 1;
 }","[9, 10, 11, 12, 16]",The cirrus_invalidate_region function in hw/display/cirrus_vga.c in Qemu allows local OS guest privileged users to cause a denial of service (out-of-bounds array access and QEMU process crash) via vectors related to negative pitch.
200831," static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,
 			    int bpf_size, enum bpf_access_type t,
 			    int value_regno)
 {
 	struct bpf_verifier_state *state = env->cur_state;
 	struct bpf_reg_state *regs = cur_regs(env);
 	struct bpf_reg_state *reg = regs + regno;
 	int size, err = 0;
 
 	size = bpf_size_to_bytes(bpf_size);
 	if (size < 0)
 		return size;
 
 	 
 	err = check_ptr_alignment(env, reg, off, size);
 	if (err)
 		return err;
 
 	 
 	off += reg->off;
 
 	if (reg->type == PTR_TO_MAP_VALUE) {
 		if (t == BPF_WRITE && value_regno >= 0 &&
 		    is_pointer_value(env, value_regno)) {
 			verbose(env, ""R%d leaks addr into map\n"", value_regno);
 			return -EACCES;
 		}
 
 		err = check_map_access(env, regno, off, size, false);
 		if (!err && t == BPF_READ && value_regno >= 0)
 			mark_reg_unknown(env, regs, value_regno);
 
 	} else if (reg->type == PTR_TO_CTX) {
 		enum bpf_reg_type reg_type = SCALAR_VALUE;
 
 		if (t == BPF_WRITE && value_regno >= 0 &&
 		    is_pointer_value(env, value_regno)) {
 			verbose(env, ""R%d leaks addr into ctx\n"", value_regno);
 			return -EACCES;
 		}
 		 
 		if (reg->off) {
 			verbose(env,
 				""dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\n"",
 				regno, reg->off, off - reg->off);
 			return -EACCES;
 		}
 		if (!tnum_is_const(reg->var_off) || reg->var_off.value) {
 			char tn_buf[48];
 
 			tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);
 			verbose(env,
 				""variable ctx access var_off=%s off=%d size=%d"",
 				tn_buf, off, size);
 			return -EACCES;
 		}
 		err = check_ctx_access(env, insn_idx, off, size, t, &reg_type);
 		if (!err && t == BPF_READ && value_regno >= 0) {
 			 
 			if (reg_type == SCALAR_VALUE)
 				mark_reg_unknown(env, regs, value_regno);
 			else
 				mark_reg_known_zero(env, regs,
 						    value_regno);
 			regs[value_regno].id = 0;
 			regs[value_regno].off = 0;
 			regs[value_regno].range = 0;
 			regs[value_regno].type = reg_type;
 		}
 
 	} else if (reg->type == PTR_TO_STACK) {
 		 
 		if (!tnum_is_const(reg->var_off)) {
 			char tn_buf[48];
 
 			tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);
 			verbose(env, ""variable stack access var_off=%s off=%d size=%d"",
 				tn_buf, off, size);
 			return -EACCES;
 		}
 		off += reg->var_off.value;
 		if (off >= 0 || off < -MAX_BPF_STACK) {
 			verbose(env, ""invalid stack off=%d size=%d\n"", off,
 				size);
 			return -EACCES;
 		}
 
 		if (env->prog->aux->stack_depth < -off)
 			env->prog->aux->stack_depth = -off;
 
 		if (t == BPF_WRITE)
 			err = check_stack_write(env, state, off, size,
 						value_regno);
 		else
 			err = check_stack_read(env, state, off, size,
 					       value_regno);
 	} else if (reg_is_pkt_pointer(reg)) {
 		if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {
 			verbose(env, ""cannot write into packet\n"");
 			return -EACCES;
 		}
 		if (t == BPF_WRITE && value_regno >= 0 &&
 		    is_pointer_value(env, value_regno)) {
 			verbose(env, ""R%d leaks addr into packet\n"",
 				value_regno);
 			return -EACCES;
 		}
 		err = check_packet_access(env, regno, off, size, false);
 		if (!err && t == BPF_READ && value_regno >= 0)
 			mark_reg_unknown(env, regs, value_regno);
 	} else {
 		verbose(env, ""R%d invalid mem access '%s'\n"", regno,
 			reg_type_str[reg->type]);
 		return -EACCES;
 	}
 
  	if (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&
  	    regs[value_regno].type == SCALAR_VALUE) {
  		 
		regs[value_regno].var_off =
			tnum_cast(regs[value_regno].var_off, size);
		__update_reg_bounds(&regs[value_regno]);
 		coerce_reg_to_size(&regs[value_regno], size);
  	}
  	return err;
  }","[123, 120, 121, 122]",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging register truncation mishandling.
204987," xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
     int len = 0, l;
     int c;
     int count = 0;
 
 #ifdef DEBUG
     nbParseNCNameComplex++;
 #endif
 
      
     GROW;
     c = CUR_CHAR(l);
     if ((c == ' ') || (c == '>') || (c == '/') ||  
 	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
 	return(NULL);
     }
 
     while ((c != ' ') && (c != '>') && (c != '/') &&  
 	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
  	if (count++ > 100) {
  	    count = 0;
  	    GROW;
             if (ctxt->instate == XML_PARSER_EOF)
                 return(NULL);
  	}
  	len += l;
  	NEXTL(l);
 	c = CUR_CHAR(l);
     }
     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 }","[23, 24]","parser.c in libxml2 before 2.9.0, as used in Google Chrome before 28.0.1500.71 and other products, allows remote attackers to cause a denial of service (out-of-bounds read) via a document that ends abruptly, related to the lack of certain checks for the XML_PARSER_EOF state."
199718," static int init_nss_hash(struct crypto_instance *instance)
 {
 	PK11SlotInfo*	hash_slot = NULL;
 	SECItem		hash_param;
 
 	if (!hash_to_nss[instance->crypto_hash_type]) {
 		return 0;
  	}
  
  	hash_param.type = siBuffer;
	hash_param.data = 0;
	hash_param.len = 0;
 	hash_param.data = instance->private_key;
 	hash_param.len = instance->private_key_len;
  
  	hash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);
  	if (hash_slot == NULL) {
 		log_printf(instance->log_level_security, ""Unable to find security slot (err %d)"",
 			   PR_GetError());
 		return -1;
 	}
 
 	instance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,
 						       hash_to_nss[instance->crypto_hash_type],
 						       PK11_OriginUnwrap, CKA_SIGN,
 						       &hash_param, NULL);
 	if (instance->nss_sym_key_sign == NULL) {
 		log_printf(instance->log_level_security, ""Failure to import key into NSS (err %d)"",
 			   PR_GetError());
 		return -1;
 	}
 
 	PK11_FreeSlot(hash_slot);
 
 	return 0;
 }","[13, 14, 11, 12]","The init_nss_hash function in exec/totemcrypto.c in Corosync 2.0 before 2.3 does not properly initialize the HMAC key, which allows remote attackers to cause a denial of service (crash) via a crafted packet."
204465,"  bool LauncherView::IsShowingMenu() const {
  #if !defined(OS_MACOSX)
  return (overflow_menu_runner_.get() &&
          overflow_menu_runner_->IsRunning()) ||
      (launcher_menu_runner_.get() &&
   return (launcher_menu_runner_.get() &&
         launcher_menu_runner_->IsRunning());
  #endif
    return false;
  }","[6, 3, 4, 5]",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
203136,"  cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,
  	Buffer *buf, int *err, gchar **err_info)
  {
	int	pkt_len;
  	char	line[COSINE_LINE_LENGTH];
  
  	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
 		return FALSE;
 
 	if (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {
 		*err = file_error(wth->random_fh, err_info);
 		if (*err == 0) {
 			*err = WTAP_ERR_SHORT_READ;
 		}
  		return FALSE;
  	}
  
 	 
	pkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	 
	return parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,
 	return parse_cosine_packet(wth->random_fh, phdr, buf, line, err,
  	    err_info);
  }","[24, 4, 19, 20, 21, 22, 23]","wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
201324," nfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)
 {
  	p = decode_fh(p, &args->fh);
  	if (!p)
  		return 0;
 	if (!xdr_argsize_check(rqstp, p))
 		return 0;
  	args->buffer = page_address(*(rqstp->rq_next_page++));
  
	return xdr_argsize_check(rqstp, p);
 	return 1;
  }","[6, 7, 11, 10]","The NFSv4 implementation in the Linux kernel through 4.11.1 allows local users to cause a denial of service (resource consumption) by leveraging improper channel callback shutdown when unmounting an NFSv4 filesystem, aka a *module reference and kernel daemon* leak."
199102," static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){
     long i;
 #if !HAVE_FAST_UNALIGNED
     if((long)src2 & (sizeof(long)-1)){
         for(i=0; i+7<w; i+=8){
             dst[i+0] = src1[i+0]-src2[i+0];
             dst[i+1] = src1[i+1]-src2[i+1];
             dst[i+2] = src1[i+2]-src2[i+2];
             dst[i+3] = src1[i+3]-src2[i+3];
             dst[i+4] = src1[i+4]-src2[i+4];
             dst[i+5] = src1[i+5]-src2[i+5];
             dst[i+6] = src1[i+6]-src2[i+6];
             dst[i+7] = src1[i+7]-src2[i+7];
          }
      }else
  #endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
     for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
          long a = *(long*)(src1+i);
          long b = *(long*)(src2+i);
          *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
     }
     for(; i<w; i++)
         dst[i+0] = src1[i+0]-src2[i+0];
 }","[18, 17]",Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.
201131," linkaddr_string(netdissect_options *ndo, const u_char *ep,
 		const unsigned int type, const unsigned int len)
  {
  	register u_int i;
  	register char *cp;
	register struct enamemem *tp;
 	register struct bsnamemem *tp;
  
  	if (len == 0)
  		return (""<empty>"");
 
 	if (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)
 		return (etheraddr_string(ndo, ep));
 
 	if (type == LINKADDR_FRELAY)
  		return (q922_string(ndo, ep, len));
  
  	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);
 	if (tp->bs_name)
 		return (tp->bs_name);
  
	tp->e_name = cp = (char *)malloc(len*3);
	if (tp->e_name == NULL)
 	tp->bs_name = cp = (char *)malloc(len*3);
 	if (tp->bs_name == NULL)
  		(*ndo->ndo_error)(ndo, ""linkaddr_string: malloc"");
  	*cp++ = hex[*ep >> 4];
  	*cp++ = hex[*ep++ & 0xf];
 	for (i = len-1; i > 0 ; --i) {
 		*cp++ = ':';
 		*cp++ = hex[*ep >> 4];
  		*cp++ = hex[*ep++ & 0xf];
  	}
  	*cp = '\0';
	return (tp->e_name);
 	return (tp->bs_name);
  }","[7, 21, 22, 26, 27, 38, 6, 19, 20, 24, 25, 37]",Several protocol parsers in tcpdump before 4.9.2 could cause a buffer over-read in addrtoname.c:lookup_bytestring().
0,"getlogin_r (name, name_len)
char *name;
size_t name_len;
{
char tty_pathname[2 + 2 * NAME_MAX];
char *real_tty_path = tty_pathname;
int result = 0;
struct utmp *ut, line, buffer;

{
int d = __open (""/dev/tty"", 0);
if (d < 0)
return errno;

result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));
(void) __close (d);

if (result != 0)
{
__set_errno (result);
return result;
}
}

real_tty_path += 5;

__setutent ();
strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);
if (__getutline_r (&line, &buffer, &ut) < 0)
{
if (errno == ESRCH)

result = ENOENT;
else
result = errno;
}
else
{
size_t needed = strlen (ut->ut_line) + 1;

if (needed < name_len)
{
__set_errno (ERANGE);
result = ERANGE;
}
else
{
memcpy (name, ut->ut_line, needed);
result = 0;
}
}
__endutent ();

return result;
}","[11, 12, 13, 15, 16, 18, 20, 21, 39, 41, 48]","manual/search.texi in the GNU C Library (aka glibc) before 2.2 lacks a statement about the unspecified tdelete return value upon deletion of a tree's root, which might allow attackers to access a dangling pointer in an application whose developer was unaware of a documentation update from 1999."
9811,"char *url_canonize2(char *d, char const * const s, size_t n,
unsigned syn33,
unsigned m32, unsigned m64, unsigned m96)
{
size_t i = 0;

if (d == s)
for (;s[i] && i < n; d++, i++)
if (s[i] == '%')
break;

for (;s[i] && i < n; d++, i++) {
unsigned char c = s[i], h1, h2;

if (c != '%') {
if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))
return NULL;
*d = c;
continue;
}

h1 = s[i + 1], h2 = s[i + 2];

if (!IS_HEX(h1) || !IS_HEX(h2)) {
*d = '\0';
return NULL;
}

#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))
c = (UNHEX(h1) << 4) | UNHEX(h2);

if (!IS_EXCLUDED(c, m32, m64, m96)) {

*d = c, i += 2;
continue;
}


if (h1 >= 'a'                   )
h1 = h1 - 'a' + 'A';
if (h2 >= 'a'                   )
h2 = h2 - 'a' + 'A';

d[0] = '%', d[1] = h1, d[2] = h2;

d +=2, i += 2;
#undef    UNHEX
}

*d = '\0';

return d;
}",[22],"Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent library. Prior to version 1.13.8, an attacker can send a message with evil sdp to FreeSWITCH, which may cause a crash. This type of crash may be caused by a URL ending with `%`. Version 1.13.8 contains a patch for this issue."
203290," static MagickBooleanType WriteImageChannels(const PSDInfo *psd_info,
   const ImageInfo *image_info,Image *image,Image *next_image,
   const MagickBooleanType separate,ExceptionInfo *exception)
 {
   size_t
     channels,
     packet_size;
 
   unsigned char
     *compact_pixels;
 
    
   channels=1;
   packet_size=next_image->depth > 8UL ? 2UL : 1UL;
    compact_pixels=(unsigned char *) NULL;
    if (next_image->compression == RLECompression)
      {
      compact_pixels=(unsigned char *) AcquireQuantumMemory(2*channels*
        next_image->columns,packet_size*sizeof(*compact_pixels));
       compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels*
         next_image->columns)+1,packet_size*sizeof(*compact_pixels));
        if (compact_pixels == (unsigned char *) NULL)
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      }
   if (IsImageGray(next_image) != MagickFalse)
     {
       if (next_image->compression == RLECompression)
         {
            
           (void) WriteBlobMSBShort(image,1);
           WritePackbitsLength(psd_info,image_info,image,next_image,
             compact_pixels,GrayQuantum,exception);
           if (next_image->alpha_trait != UndefinedPixelTrait)
             WritePackbitsLength(psd_info,image_info,image,next_image,
               compact_pixels,AlphaQuantum,exception);
         }
       WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
         GrayQuantum,MagickTrue,exception);
       if (next_image->alpha_trait != UndefinedPixelTrait)
         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
           AlphaQuantum,separate,exception);
       (void) SetImageProgress(image,SaveImagesTag,0,1);
     }
   else
     if (next_image->storage_class == PseudoClass)
       {
         if (next_image->compression == RLECompression)
           {
              
             (void) WriteBlobMSBShort(image,1);
             WritePackbitsLength(psd_info,image_info,image,next_image,
               compact_pixels,IndexQuantum,exception);
             if (next_image->alpha_trait != UndefinedPixelTrait)
               WritePackbitsLength(psd_info,image_info,image,next_image,
                 compact_pixels,AlphaQuantum,exception);
           }
         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
           IndexQuantum,MagickTrue,exception);
         if (next_image->alpha_trait != UndefinedPixelTrait)
           WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
             AlphaQuantum,separate,exception);
         (void) SetImageProgress(image,SaveImagesTag,0,1);
       }
     else
       {
         if (next_image->colorspace == CMYKColorspace)
           (void) NegateCMYK(next_image,exception);
         if (next_image->compression == RLECompression)
           {
              
             (void) WriteBlobMSBShort(image,1);
             WritePackbitsLength(psd_info,image_info,image,next_image,
               compact_pixels,RedQuantum,exception);
             WritePackbitsLength(psd_info,image_info,image,next_image,
               compact_pixels,GreenQuantum,exception);
             WritePackbitsLength(psd_info,image_info,image,next_image,
               compact_pixels,BlueQuantum,exception);
             if (next_image->colorspace == CMYKColorspace)
               WritePackbitsLength(psd_info,image_info,image,next_image,
                 compact_pixels,BlackQuantum,exception);
             if (next_image->alpha_trait != UndefinedPixelTrait)
               WritePackbitsLength(psd_info,image_info,image,next_image,
                 compact_pixels,AlphaQuantum,exception);
           }
         (void) SetImageProgress(image,SaveImagesTag,0,6);
         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
           RedQuantum,MagickTrue,exception);
         (void) SetImageProgress(image,SaveImagesTag,1,6);
         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
           GreenQuantum,separate,exception);
         (void) SetImageProgress(image,SaveImagesTag,2,6);
         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
           BlueQuantum,separate,exception);
         (void) SetImageProgress(image,SaveImagesTag,3,6);
         if (next_image->colorspace == CMYKColorspace)
           WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
             BlackQuantum,separate,exception);
         (void) SetImageProgress(image,SaveImagesTag,4,6);
         if (next_image->alpha_trait != UndefinedPixelTrait)
           WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,
             AlphaQuantum,separate,exception);
         (void) SetImageProgress(image,SaveImagesTag,5,6);
         if (next_image->colorspace == CMYKColorspace)
           (void) NegateCMYK(next_image,exception);
       }
   if (next_image->compression == RLECompression)
     compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);
   return(MagickTrue);
 }","[20, 21, 18, 19]",The ReadPSDChannelPixels function in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
10020,"void Compute(OpKernelContext* context) override {
const Tensor& in_grads = context->input(0);
const Tensor& in_image = context->input(1);
const Tensor& out_image = context->input(2);

OP_REQUIRES(context, in_grads.dims() == 4 && in_image.dims() == 4,
errors::InvalidArgument(""inputs must be 4-dimensional""));
const int64_t batch = in_grads.dim_size(0);
const int64_t rows = in_grads.dim_size(1);
const int64_t cols = in_grads.dim_size(2);
const int64_t depth = in_grads.dim_size(3);
OP_REQUIRES(
context,
in_image.dim_size(0) == batch && in_image.dim_size(1) == rows &&
in_image.dim_size(2) == cols && in_image.dim_size(3) == depth &&
out_image.dim_size(0) == batch && out_image.dim_size(1) == rows &&
out_image.dim_size(2) == cols && out_image.dim_size(3) == depth,
errors::InvalidArgument(
""input_grads, input_image, and out_image should have the same ""
""shape""));

Tensor* output = nullptr;
OP_REQUIRES_OK(context,
context->allocate_output(
0, TensorShape({batch, rows, cols, depth}), &output));

LaunchLRNGrad<Device, T> launcher(depth_radius_, bias_, alpha_, beta_);
launcher.launch(context, this, in_grads, in_image, out_image, output);
}",[17],"TensorFlow is an open source platform for machine learning. If `LRNGrad` is given an `output_image` input tensor that is not 4-D, it results in a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bd90b3efab4ec958b228cd7cfe9125be1c0cf255. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
4511,"const char * util_acl_to_str(const sc_acl_entry_t *e)
{
static char line[80], buf[20];
unsigned int acl;

if (e == NULL)
return ""N/A"";
line[0] = 0;
while (e != NULL) {
acl = e->method;

switch (acl) {
case SC_AC_UNKNOWN:
return ""N/A"";
case SC_AC_NEVER:
return ""NEVR"";
case SC_AC_NONE:
return ""NONE"";
case SC_AC_CHV:
strcpy(buf, ""CHV"");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""%d"", e->key_ref);
break;
case SC_AC_TERM:
strcpy(buf, ""TERM"");
break;
case SC_AC_PRO:
strcpy(buf, ""PROT"");
break;
case SC_AC_AUT:
strcpy(buf, ""AUTH"");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 4, ""%d"", e->key_ref);
break;
case SC_AC_SEN:
strcpy(buf, ""Sec.Env. "");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""#%d"", e->key_ref);
break;
case SC_AC_SCB:
strcpy(buf, ""Sec.ControlByte "");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""Ox%X"", e->key_ref);
break;
case SC_AC_IDA:
strcpy(buf, ""PKCS#15 AuthID "");
if (e->key_ref != SC_AC_KEY_REF_NONE)
sprintf(buf + 3, ""#%d"", e->key_ref);
break;
default:
strcpy(buf, ""????"");
break;
}
strcat(line, buf);
strcat(line, "" "");
e = e->next;
}
line[strlen(line)-1] = 0;
return line;
}","[54, 55, 58]",Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
205940," void TypingCommand::insertText(Document& document,
                                const String& text,
                                Options options,
                                TextCompositionType composition,
                                const bool isIncrementalInsertion) {
   LocalFrame* frame = document.frame();
   DCHECK(frame);
 
   if (!text.isEmpty())
      document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(
          isSpaceOrNewline(text[0]));
  
  insertText(document, text,
             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),
             options, composition, isIncrementalInsertion);
   insertText(document, text, frame->selection().selectionInDOMTree(), options,
              composition, isIncrementalInsertion);
  }","[16, 17, 13, 14, 15]","Use-after-free vulnerability in Blink, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging incorrect ordering of operations in the Web SQL Database thread relative to Blink's main thread, related to the shutdown function in web/WebKit.cpp."
205273," void PageSerializer::serializeFrame(Frame* frame)
 {
     Document* document = frame->document();
     KURL url = document->url();
     if (!url.isValid() || url.isBlankURL()) {
         url = urlForBlankFrame(frame);
     }
 
     if (m_resourceURLs.contains(url)) {
          return;
      }
  
    if (document->isImageDocument()) {
        ImageDocument* imageDocument = toImageDocument(document);
        addImageToResources(imageDocument->cachedImage(), imageDocument->imageElement()->renderer(), url);
        return;
    }
      Vector<Node*> nodes;
    OwnPtr<SerializerMarkupAccumulator> accumulator;
    if (m_URLs)
        accumulator = adoptPtr(new LinkChangeSerializerMarkupAccumulator(this, document, &nodes, m_URLs, m_directory));
    else
        accumulator = adoptPtr(new SerializerMarkupAccumulator(this, document, &nodes));
    String text = accumulator->serializeNodes(document, IncludeNode);
     SerializerMarkupAccumulator accumulator(this, document, &nodes);
      WTF::TextEncoding textEncoding(document->charset());
     CString data;
     if (!textEncoding.isValid()) {
          
         return;
     }
     String text = accumulator.serializeNodes(document, IncludeNode);
      CString frameHTML = textEncoding.normalizeAndEncode(text, WTF::EntitiesForUnencodables);
      m_resources->append(SerializedResource(url, document->suggestedMIMEType(), SharedBuffer::create(frameHTML.data(), frameHTML.length())));
      m_resourceURLs.add(url);
 
     for (Vector<Node*>::iterator iter = nodes.begin(); iter != nodes.end(); ++iter) {
         Node* node = *iter;
         if (!node->isElementNode())
             continue;
  
          Element* element = toElement(node);
        if (element->isStyledElement()) {
         if (element->isStyledElement())
              retrieveResourcesForProperties(element->inlineStyle(), document);
            retrieveResourcesForProperties(element->presentationAttributeStyle(), document);
        }
  
          if (element->hasTagName(HTMLNames::imgTag)) {
              HTMLImageElement* imageElement = toHTMLImageElement(element);
             KURL url = document->completeURL(imageElement->getAttribute(HTMLNames::srcAttr));
             ImageResource* cachedImage = imageElement->cachedImage();
             addImageToResources(cachedImage, imageElement->renderer(), url);
         } else if (element->hasTagName(HTMLNames::inputTag)) {
             HTMLInputElement* inputElement = toHTMLInputElement(element);
             if (inputElement->isImageButton() && inputElement->hasImageLoader()) {
                 KURL url = inputElement->src();
                 ImageResource* cachedImage = inputElement->imageLoader()->image();
                 addImageToResources(cachedImage, inputElement->renderer(), url);
             }
         } else if (element->hasTagName(HTMLNames::linkTag)) {
             HTMLLinkElement* linkElement = toHTMLLinkElement(element);
             if (CSSStyleSheet* sheet = linkElement->sheet()) {
                 KURL url = document->completeURL(linkElement->getAttribute(HTMLNames::hrefAttr));
                 serializeCSSStyleSheet(sheet, url);
                 ASSERT(m_resourceURLs.contains(url));
             }
         } else if (element->hasTagName(HTMLNames::styleTag)) {
             HTMLStyleElement* styleElement = toHTMLStyleElement(element);
             if (CSSStyleSheet* sheet = styleElement->sheet())
                 serializeCSSStyleSheet(sheet, KURL());
         }
     }
 
     for (Frame* childFrame = frame->tree().firstChild(); childFrame; childFrame = childFrame->tree().nextSibling())
         serializeFrame(childFrame);
 }","[25, 27, 28, 29, 30, 31, 32, 44, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 43, 46, 47]","Google Chrome before 24.0.1312.52 does not properly handle image data in PDF documents, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted document."
200784," static ssize_t aio_setup_single_vector(struct kiocb *kiocb)
 static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)
  {
 	int bytes;
 
 	bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
 	if (bytes < 0)
 		return bytes;
 
  	kiocb->ki_iovec = &kiocb->ki_inline_vec;
  	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
	kiocb->ki_iovec->iov_len = kiocb->ki_left;
 	kiocb->ki_iovec->iov_len = bytes;
  	kiocb->ki_nr_segs = 1;
  	kiocb->ki_cur_seg = 0;
  	return 0;
 }","[2, 4, 5, 6, 7, 8, 9, 13, 12]",Integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.
7935,"TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
const TfLiteTensor* input,
const TfLiteTensor* size_splits,
const TfLiteTensor* axis) {
int axis_value = GetTensorData<int>(axis)[0];
if (axis_value < 0) {
axis_value += NumDimensions(input);
}

std::vector<int64_t> size_splits_vector;
if (size_splits->type == kTfLiteInt32) {
GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);
} else if (size_splits->type == kTfLiteInt64) {
GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);
} else {
context->ReportError(context, ""size_splits only support type int32|int64."");
return kTfLiteError;
}

int minus_one_index = -1;
int64_t size_splits_sum = 0;

for (int i = 0; i < size_splits_vector.size(); ++i) {
if (size_splits_vector.at(i) == -1) {
if (minus_one_index == -1) {
minus_one_index = i;
} else {
context->ReportError(context,
""The size_splits contains more than one -1."");
}
} else {
size_splits_sum += size_splits_vector.at(i);
}
}

const int input_size = SizeOfDimension(input, axis_value);

if (minus_one_index != -1) {
if (size_splits_sum > input_size) {
context->ReportError(
context,
""The sum of size_splits must be less than the dimension of value."");
} else {
size_splits_vector[minus_one_index] = input_size - size_splits_sum;
}
} else if (size_splits_sum != input_size) {
context->ReportError(
context,
""The size_splits must sum to the dimension of value along axis."");
}

for (int i = 0; i < NumOutputs(node); ++i) {
TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);
output_dims->data[axis_value] = size_splits_vector.at(i);
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));
TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));
}

return kTfLiteOk;
}",[36],"TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
9649,"int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,
u8 event, struct sk_buff *skb)
{
int r = 0;
struct device *dev = &hdev->ndev->dev;
struct nfc_evt_transaction *transaction;

pr_debug(""connectivity gate event: %x\n"", event);

switch (event) {
case ST21NFCA_EVT_CONNECTIVITY:
r = nfc_se_connectivity(hdev->ndev, host);
break;
case ST21NFCA_EVT_TRANSACTION:







if (skb->len < NFC_MIN_AID_LENGTH + 2 &&
skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)
return -EPROTO;

transaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);
if (!transaction)
return -ENOMEM;

transaction->aid_len = skb->data[1];
memcpy(transaction->aid, &skb->data[2],
transaction->aid_len);


if (skb->data[transaction->aid_len + 2] !=
NFC_EVT_TRANSACTION_PARAMS_TAG)
return -EPROTO;

transaction->params_len = skb->data[transaction->aid_len + 3];
memcpy(transaction->params, skb->data +
transaction->aid_len + 4, transaction->params_len);

r = nfc_se_transaction(hdev->ndev, host, transaction);
break;
default:
nfc_err(&hdev->ndev->dev, ""Unexpected event on connectivity gate\n"");
return 1;
}
kfree_skb(skb);
return r;
}","[31, 40]",st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.
206612,"  base::string16 GetAppForProtocolUsingAssocQuery(const GURL& url) {
  base::string16 url_scheme = base::ASCIIToUTF16(url.scheme());
  if (url_scheme.empty())
   const base::string16 url_scheme = base::ASCIIToUTF16(url.scheme());
   if (!IsValidCustomProtocol(url_scheme))
      return base::string16();
  
    wchar_t out_buffer[1024];
    DWORD buffer_size = arraysize(out_buffer);
  HRESULT hr = AssocQueryString(ASSOCF_IS_PROTOCOL,
                                ASSOCSTR_FRIENDLYAPPNAME,
                                url_scheme.c_str(),
                                NULL,
                                out_buffer,
                                &buffer_size);
   HRESULT hr =
       AssocQueryString(ASSOCF_IS_PROTOCOL, ASSOCSTR_FRIENDLYAPPNAME,
                        url_scheme.c_str(), NULL, out_buffer, &buffer_size);
    if (FAILED(hr)) {
      DLOG(WARNING) << ""AssocQueryString failed!"";
      return base::string16();
   }
   return base::string16(out_buffer);
  }","[4, 5, 16, 17, 18, 2, 3, 10, 11, 12, 13, 14, 15]",Insufficient validate of external protocols in Shell Integration in Google Chrome on Windows prior to 71.0.3578.80 allowed a remote attacker to launch external programs via a crafted HTML page.
9700,"static void singlevar (LexState *ls, expdesc *var) {
TString *varname = str_checkname(ls);
FuncState *fs = ls->fs;
singlevaraux(fs, varname, var, 1);
if (var->k == VVOID) {
expdesc key;
singlevaraux(fs, ls->envn, var, 1);
lua_assert(var->k != VVOID);
codestring(&key, varname);
luaK_indexed(fs, var, &key);
}
}",[9],"singlevar in lparser.c in Lua from (including) 5.4.0 up to (excluding) 5.4.4 lacks a certain luaK_exp2anyregup call, leading to a heap-based buffer over-read that might affect a system that compiles untrusted Lua code."
2267,"smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)
{
int rc;
unsigned char key2[8];
struct crypto_skcipher *tfm_des;
struct scatterlist sgin, sgout;
struct skcipher_request *req;

str_to_key(key, key2);

tfm_des = crypto_alloc_skcipher(""ecb(des)"", 0, CRYPTO_ALG_ASYNC);
if (IS_ERR(tfm_des)) {
rc = PTR_ERR(tfm_des);
cifs_dbg(VFS, ""could not allocate des crypto API\n"");
goto smbhash_err;
}

req = skcipher_request_alloc(tfm_des, GFP_KERNEL);
if (!req) {
rc = -ENOMEM;
cifs_dbg(VFS, ""could not allocate des crypto API\n"");
goto smbhash_free_skcipher;
}

crypto_skcipher_setkey(tfm_des, key2, 8);

sg_init_one(&sgin, in, 8);
sg_init_one(&sgout, out, 8);

skcipher_request_set_callback(req, 0, NULL, NULL);
skcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);

rc = crypto_skcipher_encrypt(req);
if (rc)
cifs_dbg(VFS, ""could not encrypt crypt key rc: %d\n"", rc);

skcipher_request_free(req);

smbhash_free_skcipher:
crypto_free_skcipher(tfm_des);
smbhash_err:
return rc;
}","[3, 5, 6, 7, 11, 13, 14, 15, 18, 19, 20, 22, 25, 27, 28, 30, 31, 33, 34, 35, 37, 39, 40, 41, 42]","The smbhash function in fs/cifs/smbencrypt.c in the Linux kernel 4.9.x before 4.9.1 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a scatterlist."
8577,"free_link_refs(struct link_ref **references)
{
size_t i;

for (i = 0; i < REF_TABLE_SIZE; ++i) {
struct link_ref *r = references[i];
struct link_ref *next;

while (r) {
next = r->next;
bufrelease(r->link);
bufrelease(r->title);
free(r);
r = next;
}
}
}",[11],"Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0."
205708," void PropertyTreeManager::SetupRootTransformNode() {
   cc::TransformTree& transform_tree = property_trees_.transform_tree;
   transform_tree.clear();
   property_trees_.element_id_to_transform_node_index.clear();
   cc::TransformNode& transform_node = *transform_tree.Node(
       transform_tree.Insert(cc::TransformNode(), kRealRootNodeId));
   DCHECK_EQ(transform_node.id, kSecondaryRootNodeId);
   transform_node.source_node_id = transform_node.parent_id;
 
   float device_scale_factor =
       root_layer_->layer_tree_host()->device_scale_factor();
   gfx::Transform to_screen;
   to_screen.Scale(device_scale_factor, device_scale_factor);
   transform_tree.SetToScreen(kRealRootNodeId, to_screen);
   gfx::Transform from_screen;
   bool invertible = to_screen.GetInverse(&from_screen);
   DCHECK(invertible);
    transform_tree.SetFromScreen(kRealRootNodeId, from_screen);
    transform_tree.set_needs_update(true);
  
  transform_node_map_.Set(TransformPaintPropertyNode::Root(),
   transform_node_map_.Set(&TransformPaintPropertyNode::Root(),
                            transform_node.id);
    root_layer_->SetTransformTreeIndex(transform_node.id);
  }","[22, 21]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
9441,"static void rose_idletimer_expiry(struct timer_list *t)
{
struct rose_sock *rose = from_timer(rose, t, idletimer);
struct sock *sk = &rose->sock;

bh_lock_sock(sk);
rose_clear_queues(sk);

rose_write_internal(sk, ROSE_CLEAR_REQUEST);
rose_sk(sk)->state = ROSE_STATE_2;

rose_start_t3timer(sk);

sk->sk_state     = TCP_CLOSE;
sk->sk_err       = 0;
sk->sk_shutdown |= SEND_SHUTDOWN;

if (!sock_flag(sk, SOCK_DEAD)) {
sk->sk_state_change(sk);
sock_set_flag(sk, SOCK_DEAD);
}
bh_unlock_sock(sk);
}",[20],There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c of linux that allow attackers to crash linux kernel without any privileges.
202077," static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)
 static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,
   int pixel_size,ExceptionInfo *exception)
  {
    MagickOffsetType
      offset;
 
   register ssize_t
     i;
 
   size_t
     h,
     w;
 
    
   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
        && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
            || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
      {
       if (EOFBlob(image) != MagickFalse)
         {
           ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
             image->filename);
           return(MagickFalse);
         }
        w = DIV2(dds_info->width);
        h = DIV2(dds_info->height);
  
        
       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) w * h * pixel_size;
         (void) SeekBlob(image, offset, SEEK_CUR);
 
         w = DIV2(w);
          h = DIV2(h);
        }
      }
   return(MagickTrue);
  }","[2, 3, 20, 21, 22, 23, 24, 25, 39]",coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file.
205972,"  void ForeignSessionHelper::TriggerSessionSync(
      JNIEnv* env,
      const JavaParamRef<jobject>& obj) {
  browser_sync::ProfileSyncService* service =
      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);
   syncer::SyncService* service =
       ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
    if (!service)
      return;
  
  const syncer::ModelTypeSet types(syncer::SESSIONS);
  service->TriggerRefresh(types);
   service->TriggerRefresh({syncer::SESSIONS});
  }","[6, 7, 13, 4, 5, 11, 12]","Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site."
204850," void ContainerNode::removeChildren()
 {
     if (!m_firstChild)
         return;
 
     RefPtr<ContainerNode> protect(this);
 
     if (FullscreenElementStack* fullscreen = FullscreenElementStack::fromIfExists(&document()))
         fullscreen->removeFullScreenElementOfSubtree(this, true);
 
     willRemoveChildren(protect.get());
 
     {
         SubframeLoadingDisabler disabler(this);
 
          document().removeFocusedElementOfSubtree(this, true);
      }
  
     document().nodeChildrenWillBeRemoved(this);
 
      NodeVector removedChildren;
      {
          RenderWidget::UpdateSuspendScope suspendWidgetHierarchyUpdates;
         {
             NoEventDispatchAssertion assertNoEventDispatch;
             removedChildren.reserveInitialCapacity(childNodeCount());
             while (m_firstChild) {
                 removedChildren.append(m_firstChild);
                 removeBetween(0, m_firstChild->nextSibling(), m_firstChild);
             }
         }
 
         childrenChanged(false, 0, 0, -static_cast<int>(removedChildren.size()));
 
         for (size_t i = 0; i < removedChildren.size(); ++i)
             ChildNodeRemovalNotifier(this).notify(removedChildren[i].get());
     }
 
     dispatchSubtreeModifiedEvent();
 }","[19, 20]","Use-after-free vulnerability in core/dom/ContainerNode.cpp in Blink, as used in Google Chrome before 31.0.1650.48, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper handling of DOM range objects in circumstances that require child node removal after a (1) mutation or (2) blur event."
203753,"     virtual void runTest()
     void runTest()
      {
        if (m_settings.enableCompositorThread)
            CCLayerTreeHostTest::runTest();
         CCLayerTreeHostTest::runTest(true);
      }","[2, 6, 4, 5]","Google Chrome before 14.0.835.202 does not properly handle Google V8 hidden objects, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted JavaScript code."
207861," long Chapters::Edition::Parse(IMkvReader* pReader, long long pos,
  long long size) {
  const long long stop = pos + size;
 
  while (pos < stop) {
  long long id, size;
 
  long status = ParseElementHeader(pReader, pos, stop, id, size);
 
  if (status < 0)  
  return status;
 
  if (size == 0)  
  continue;
 
  if (id == 0x36) {  
       status = ParseAtom(pReader, pos, size);
 
  if (status < 0)  
  return status;
 
      }
  
      pos += size;
    assert(pos <= stop);
     if (pos > stop)
       return E_FILE_FORMAT_INVALID;
    }
  
  assert(pos == stop);
   if (pos != stop)
     return E_FILE_FORMAT_INVALID;
    return 0;
  }","[26, 27, 31, 32, 25, 30]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
8550,"PJ_DEF(pj_status_t) pjmedia_vid_conf_add_port( pjmedia_vid_conf *vid_conf,
pj_pool_t *parent_pool,
pjmedia_port *port,
const pj_str_t *name,
void *opt,
unsigned *p_slot)
{
pj_pool_t *pool;
vconf_port *cport;
unsigned index;

PJ_ASSERT_RETURN(vid_conf && parent_pool && port, PJ_EINVAL);
PJ_ASSERT_RETURN(port->info.fmt.type==PJMEDIA_TYPE_VIDEO &&
port->info.fmt.detail_type==PJMEDIA_FORMAT_DETAIL_VIDEO,
PJ_EINVAL);
PJ_UNUSED_ARG(opt);


if (!name)
name = &port->info.name;

pj_mutex_lock(vid_conf->mutex);

if (vid_conf->port_cnt >= vid_conf->opt.max_slot_cnt) {
pj_assert(!""Too many ports"");
pj_mutex_unlock(vid_conf->mutex);
return PJ_ETOOMANY;
}


for (index=0; index < vid_conf->opt.max_slot_cnt; ++index) {
if (vid_conf->ports[index] == NULL)
break;
}
pj_assert(index != vid_conf->opt.max_slot_cnt);


pool = pj_pool_create(parent_pool->factory, name->ptr, 500, 500, NULL);
PJ_ASSERT_RETURN(pool, PJ_ENOMEM);


cport = PJ_POOL_ZALLOC_T(pool, vconf_port);
PJ_ASSERT_RETURN(cport, PJ_ENOMEM);


cport->pool = pool;
cport->port = port;
cport->format = port->info.fmt;
cport->idx  = index;
pj_strdup_with_null(pool, &cport->name, name);


{
pjmedia_ratio *fps = &port->info.fmt.det.vid.fps;
pj_uint32_t vconf_interval = (pj_uint32_t)
(TS_CLOCK_RATE * 1.0 /
vid_conf->opt.frame_rate);
cport->ts_interval = (pj_uint32_t)(TS_CLOCK_RATE * 1.0 /
fps->num * fps->denum);


if (cport->ts_interval < vconf_interval) {
cport->ts_interval = vconf_interval;
PJ_LOG(3,(THIS_FILE, ""Warning: frame rate of port %s is higher ""
""than video conference bridge (%d > %d)"",
name->ptr, (int)(fps->num/fps->denum),
vid_conf->opt.frame_rate));
}
}


{
const pjmedia_video_format_info *vfi;
pjmedia_video_apply_fmt_param vafp;
pj_status_t status;

vfi = pjmedia_get_video_format_info(NULL, port->info.fmt.id);
if (!vfi) {
PJ_LOG(4,(THIS_FILE, ""pjmedia_vid_conf_add_port(): ""
""unrecognized format %04X"",
port->info.fmt.id));
return PJMEDIA_EBADFMT;
}

pj_bzero(&vafp, sizeof(vafp));
vafp.size = port->info.fmt.det.vid.size;
status = (*vfi->apply_fmt)(vfi, &vafp);
if (status != PJ_SUCCESS) {
PJ_LOG(4,(THIS_FILE, ""pjmedia_vid_conf_add_port(): ""
""Failed to apply format %04X"",
port->info.fmt.id));
return status;
}
if (port->put_frame) {
cport->put_buf_size = vafp.framebytes;
cport->put_buf = pj_pool_zalloc(cport->pool, cport->put_buf_size);
}
if (port->get_frame) {
cport->get_buf_size = vafp.framebytes;
cport->get_buf = pj_pool_zalloc(cport->pool, cport->get_buf_size);
}
}


cport->listener_slots = (unsigned*)
pj_pool_zalloc(pool,
vid_conf->opt.max_slot_cnt *
sizeof(unsigned));
PJ_ASSERT_RETURN(cport->listener_slots, PJ_ENOMEM);


cport->transmitter_slots = (unsigned*)
pj_pool_zalloc(pool,
vid_conf->opt.max_slot_cnt *
sizeof(unsigned));
PJ_ASSERT_RETURN(cport->transmitter_slots, PJ_ENOMEM);


cport->render_states = (render_state**)
pj_pool_zalloc(pool,
vid_conf->opt.max_slot_cnt *
sizeof(render_state*));
PJ_ASSERT_RETURN(cport->render_states, PJ_ENOMEM);


cport->render_pool = (pj_pool_t**)
pj_pool_zalloc(pool,
vid_conf->opt.max_slot_cnt *
sizeof(pj_pool_t*));
PJ_ASSERT_RETURN(cport->render_pool, PJ_ENOMEM);


vid_conf->ports[index] = cport;
vid_conf->port_cnt++;

PJ_LOG(4,(THIS_FILE,""Added port %d (%.*s)"",
index, (int)cport->name.slen, cport->name.ptr));

pj_mutex_unlock(vid_conf->mutex);


if (p_slot) {
*p_slot = index;
}

return PJ_SUCCESS;
}","[82, 92, 109, 115, 116, 123, 129, 130]","PJSIP is a free and open source multimedia communication library written in the C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In various parts of PJSIP, when error/failure occurs, it is found that the function returns without releasing the currently held locks. This could result in a system deadlock, which cause a denial of service for the users. No release has yet been made which contains the linked fix commit. All versions up to an including 2.11.1 are affected. Users may need to manually apply the patch."
207814," OMX_ERRORTYPE omx_vdec::update_portdef(OMX_PARAM_PORTDEFINITIONTYPE *portDefn)
 {
     OMX_ERRORTYPE eRet = OMX_ErrorNone;
  struct v4l2_format fmt;
  if (!portDefn) {
  return OMX_ErrorBadParameter;
 
      }
      DEBUG_PRINT_LOW(""omx_vdec::update_portdef"");
      portDefn->nVersion.nVersion = OMX_SPEC_VERSION;
    portDefn->nSize = sizeof(portDefn);
     portDefn->nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
      portDefn->eDomain    = OMX_PortDomainVideo;
      if (drv_ctx.frame_rate.fps_denominator > 0)
          portDefn->format.video.xFramerate = (drv_ctx.frame_rate.fps_numerator /
             drv_ctx.frame_rate.fps_denominator) << 16;  
  else {
         DEBUG_PRINT_ERROR(""Error: Divide by zero"");
  return OMX_ErrorBadParameter;
  }
     memset(&fmt, 0x0, sizeof(struct v4l2_format));
  if (0 == portDefn->nPortIndex) {
         portDefn->eDir =  OMX_DirInput;
         portDefn->nBufferCountActual = drv_ctx.ip_buf.actualcount;
         portDefn->nBufferCountMin    = drv_ctx.ip_buf.mincount;
         portDefn->nBufferSize        = drv_ctx.ip_buf.buffer_size;
         portDefn->format.video.eColorFormat = OMX_COLOR_FormatUnused;
         portDefn->format.video.eCompressionFormat = eCompressionFormat;
         portDefn->bEnabled   = m_inp_bEnabled;
         portDefn->bPopulated = m_inp_bPopulated;
 
         fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
         fmt.fmt.pix_mp.pixelformat = output_capability;
  } else if (1 == portDefn->nPortIndex) {
  unsigned int buf_size = 0;
  if (!client_buffers.update_buffer_req()) {
             DEBUG_PRINT_ERROR(""client_buffers.update_buffer_req Failed"");
  return OMX_ErrorHardware;
  }
  if (!client_buffers.get_buffer_req(buf_size)) {
             DEBUG_PRINT_ERROR(""update buffer requirements"");
  return OMX_ErrorHardware;
  }
         portDefn->nBufferSize = buf_size;
         portDefn->eDir =  OMX_DirOutput;
         portDefn->nBufferCountActual = drv_ctx.op_buf.actualcount;
         portDefn->nBufferCountMin    = drv_ctx.op_buf.mincount;
         portDefn->format.video.eCompressionFormat = OMX_VIDEO_CodingUnused;
         portDefn->bEnabled   = m_out_bEnabled;
         portDefn->bPopulated = m_out_bPopulated;
  if (!client_buffers.get_color_format(portDefn->format.video.eColorFormat)) {
             DEBUG_PRINT_ERROR(""Error in getting color format"");
  return OMX_ErrorHardware;
  }
         fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
         fmt.fmt.pix_mp.pixelformat = capture_capability;
  } else {
         portDefn->eDir = OMX_DirMax;
         DEBUG_PRINT_LOW("" get_parameter: Bad Port idx %d"",
  (int)portDefn->nPortIndex);
         eRet = OMX_ErrorBadPortIndex;
  }
  if (is_down_scalar_enabled) {
  int ret = 0;
         ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_G_FMT, &fmt);
  if (ret) {
             DEBUG_PRINT_ERROR(""update_portdef : Error in getting port resolution"");
  return OMX_ErrorHardware;
  } else {
             portDefn->format.video.nFrameWidth = fmt.fmt.pix_mp.width;
             portDefn->format.video.nFrameHeight = fmt.fmt.pix_mp.height;
             portDefn->format.video.nStride = fmt.fmt.pix_mp.plane_fmt[0].bytesperline;
             portDefn->format.video.nSliceHeight = fmt.fmt.pix_mp.plane_fmt[0].reserved[0];
  }
  } else {
     portDefn->format.video.nFrameHeight =  drv_ctx.video_resolution.frame_height;
     portDefn->format.video.nFrameWidth  =  drv_ctx.video_resolution.frame_width;
     portDefn->format.video.nStride = drv_ctx.video_resolution.stride;
     portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.scan_lines;
  }
 
  if ((portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420Planar) ||
  (portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar)) {
            portDefn->format.video.nStride = ALIGN(drv_ctx.video_resolution.frame_width, 16);
         portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.frame_height;
  }
     DEBUG_PRINT_HIGH(""update_portdef(%u): Width = %u Height = %u Stride = %d ""
  ""SliceHeight = %u eColorFormat = %d nBufSize %u nBufCnt %u"",
  (unsigned int)portDefn->nPortIndex,
  (unsigned int)portDefn->format.video.nFrameWidth,
  (unsigned int)portDefn->format.video.nFrameHeight,
  (int)portDefn->format.video.nStride,
  (unsigned int)portDefn->format.video.nSliceHeight,
  (unsigned int)portDefn->format.video.eColorFormat,
  (unsigned int)portDefn->nBufferSize,
  (unsigned int)portDefn->nBufferCountActual);
 
  return eRet;
 }","[12, 11]","The mm-video-v4l2 vidc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate certain OMX parameter data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27532721."
199042," SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,
 		unsigned long, nbytes, int __user *, start, void __user *, arg)
 {
 	unsigned long w;
 	struct percpu_struct *cpu;
 
 	switch (op) {
 	case GSI_IEEE_FP_CONTROL:
 		 
 		 
 
  		w = current_thread_info()->ieee_state & IEEE_SW_MASK;
  		w = swcr_update_status(w, rdfpcr());
 		if (put_user(w, (unsigned long __user *) buffer))
 			return -EFAULT;
 		return 0;
 
 	case GSI_IEEE_STATE_AT_SIGNAL:
 		 
 		break;
 
  	case GSI_UACPROC:
 		if (nbytes < sizeof(unsigned int))
 			return -EINVAL;
  		w = (current_thread_info()->flags >> UAC_SHIFT) & UAC_BITMASK;
  		if (put_user(w, (unsigned int __user *)buffer))
  			return -EFAULT;
  		return 1;
 
 	case GSI_PROC_TYPE:
 		if (nbytes < sizeof(unsigned long))
 			return -EINVAL;
 		cpu = (struct percpu_struct*)
 		  ((char*)hwrpb + hwrpb->processor_offset);
 		w = cpu->type;
 		if (put_user(w, (unsigned long  __user*)buffer))
 			return -EFAULT;
  		return 1;
  
  	case GSI_GET_HWRPB:
		if (nbytes < sizeof(*hwrpb))
 		if (nbytes > sizeof(*hwrpb))
  			return -EINVAL;
  		if (copy_to_user(buffer, hwrpb, nbytes) != 0)
  			return -EFAULT;
 		return 1;
 
 	default:
 		break;
 	}
 
 	return -EOPNOTSUPP;
 }","[42, 41]","The osf_wait4 function in arch/alpha/kernel/osf_sys.c in the Linux kernel before 2.6.39.4 on the Alpha platform uses an incorrect pointer, which allows local users to gain privileges by writing a certain integer value to kernel memory."
202423," int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
     int64_t total_samples = 0, infilesize;
     Wave64ChunkHeader chunk_header;
     Wave64FileHeader filehdr;
     WaveHeader WaveHeader;
     uint32_t bcount;
 
     infilesize = DoGetFileSize (infile);
     memcpy (&filehdr, fourcc, 4);
 
     if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||
         bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||
         memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {
             error_line (""%s is not a valid .W64 file!"", infilename);
             return WAVPACK_SOFT_ERROR;
     }
     else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
         !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {
             error_line (""%s"", WavpackGetErrorMessage (wpc));
             return WAVPACK_SOFT_ERROR;
     }
 
 #if 1    
     WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);
 
     if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&
         filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {
             error_line (""%s is not a valid .W64 file!"", infilename);
             return WAVPACK_SOFT_ERROR;
     }
 #endif
 
 
     while (1) {
         if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||
             bcount != sizeof (Wave64ChunkHeader)) {
                 error_line (""%s is not a valid .W64 file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
         }
         else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
             !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {
                 error_line (""%s"", WavpackGetErrorMessage (wpc));
                 return WAVPACK_SOFT_ERROR;
         }
 
         WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);
         chunk_header.ckSize -= sizeof (chunk_header);
 
 
         if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {
             int supported = TRUE, format;
 
             chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;
 
             if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                 !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||
                 bcount != chunk_header.ckSize) {
                     error_line (""%s is not a valid .W64 file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     return WAVPACK_SOFT_ERROR;
             }
 
             WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);
 
             if (debug_logging_mode) {
                 error_line (""format tag size = %d"", chunk_header.ckSize);
                 error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"",
                     WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);
                 error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"",
                     WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);
 
                 if (chunk_header.ckSize > 16)
                     error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize,
                         WaveHeader.ValidBitsPerSample);
 
                 if (chunk_header.ckSize > 20)
                     error_line (""ChannelMask = %x, SubFormat = %d"",
                         WaveHeader.ChannelMask, WaveHeader.SubFormat);
             }
 
             if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)
                 config->qmode |= QMODE_ADOBE_MODE;
 
             format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?
                 WaveHeader.SubFormat : WaveHeader.FormatTag;
 
             config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?
                 WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;
 
             if (format != 1 && format != 3)
                 supported = FALSE;
 
             if (format == 3 && config->bits_per_sample != 32)
                 supported = FALSE;
 
             if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||
                 WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||
                 WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||
                 WaveHeader.BlockAlign % WaveHeader.NumChannels)
                     supported = FALSE;
 
             if (config->bits_per_sample < 1 || config->bits_per_sample > 32)
                 supported = FALSE;
 
             if (!supported) {
                 error_line (""%s is an unsupported .W64 format!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }
 
             if (chunk_header.ckSize < 40) {
                 if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {
                     if (WaveHeader.NumChannels <= 2)
                         config->channel_mask = 0x5 - WaveHeader.NumChannels;
                     else if (WaveHeader.NumChannels <= 18)
                         config->channel_mask = (1 << WaveHeader.NumChannels) - 1;
                     else
                         config->channel_mask = 0x3ffff;
                 }
             }
             else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {
                 error_line (""this W64 file already has channel order information!"");
                 return WAVPACK_SOFT_ERROR;
             }
             else if (WaveHeader.ChannelMask)
                 config->channel_mask = WaveHeader.ChannelMask;
 
             if (format == 3)
                 config->float_norm_exp = 127;
             else if ((config->qmode & QMODE_ADOBE_MODE) &&
                 WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {
                     if (WaveHeader.BitsPerSample == 24)
                         config->float_norm_exp = 127 + 23;
                     else if (WaveHeader.BitsPerSample == 32)
                         config->float_norm_exp = 127 + 15;
             }
 
             if (debug_logging_mode) {
                 if (config->float_norm_exp == 127)
                     error_line (""data format: normalized 32-bit floating point"");
                 else
                     error_line (""data format: %d-bit integers stored in %d byte(s)"",
                         config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);
             }
         }
         else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) {  
 
             if (!WaveHeader.NumChannels) {           
                 error_line (""%s is not a valid .W64 file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }
 
             if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {
                 config->qmode |= QMODE_IGNORE_LENGTH;
 
                 if (infilesize && DoGetFilePosition (infile) != -1)
                     total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;
                 else
                     total_samples = -1;
             }
             else {
                 if (infilesize && infilesize - chunk_header.ckSize > 16777216) {
                     error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!"");
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;
 
                 if (!total_samples) {
                     error_line (""this .W64 file has no audio samples, probably is corrupt!"");
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 if (total_samples > MAX_WAVPACK_SAMPLES) {
                     error_line (""%s has too many samples for WavPack!"", infilename);
                     return WAVPACK_SOFT_ERROR;
                 }
             }
 
             config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;
             config->num_channels = WaveHeader.NumChannels;
             config->sample_rate = WaveHeader.SampleRate;
             break;
          }
          else {           
              int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;
            char *buff = malloc (bytes_to_copy);
             char *buff;
 
             if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                 error_line (""%s is not a valid .W64 file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }
 
             buff = malloc (bytes_to_copy);
  
              if (debug_logging_mode)
                  error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                     chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],
                     chunk_header.ckID [3], chunk_header.ckSize);
 
             if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                 bcount != bytes_to_copy ||
                 (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     free (buff);
                     return WAVPACK_SOFT_ERROR;
             }
 
             free (buff);
         }
     }
 
     if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {
         error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc));
         return WAVPACK_SOFT_ERROR;
     }
 
     return WAVPACK_NO_ERROR;
 }","[192, 193, 194, 195, 196, 197, 198, 199, 191]","An issue was discovered in WavPack 5.1.0 and earlier for W64 input. Out-of-bounds writes can occur because ParseWave64HeaderConfig in wave64.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation."
7487,"get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,
const uint8_t **contents_out, size_t *clen_out,
const uint8_t **remainder_out, size_t *rlen_out)
{
krb5_error_code ret;
uint8_t o;
const uint8_t *c, *p, *tag_start = asn1;
size_t clen, llen, i;
taginfo t;

*contents_out = *remainder_out = NULL;
*clen_out = *rlen_out = 0;
if (len == 0)
return ASN1_OVERRUN;
o = *asn1++;
len--;
tag_out->asn1class = o & 0xC0;
tag_out->construction = o & 0x20;
if ((o & 0x1F) != 0x1F) {
tag_out->tagnum = o & 0x1F;
} else {
tag_out->tagnum = 0;
do {
if (len == 0)
return ASN1_OVERRUN;
o = *asn1++;
len--;
tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);
} while (o & 0x80);
}

if (len == 0)
return ASN1_OVERRUN;
o = *asn1++;
len--;

if (o == 0x80) {

if (tag_out->construction != CONSTRUCTED)
return ASN1_MISMATCH_INDEF;
p = asn1;
while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {
ret = get_tag(p, len, &t, &c, &clen, &p, &len);
if (ret)
return ret;
}
tag_out->tag_end_len = 2;
*contents_out = asn1;
*clen_out = p - asn1;
*remainder_out = p + 2;
*rlen_out = len - 2;
} else if ((o & 0x80) == 0) {

if (o > len)
return ASN1_OVERRUN;
tag_out->tag_end_len = 0;
*contents_out = asn1;
*clen_out = o;
*remainder_out = asn1 + *clen_out;
*rlen_out = len - (*remainder_out - asn1);
} else {

llen = o & 0x7F;
if (llen > len)
return ASN1_OVERRUN;
if (llen > sizeof(*clen_out))
return ASN1_OVERFLOW;
for (i = 0, clen = 0; i < llen; i++)
clen = (clen << 8) | asn1[i];
if (clen > len - llen)
return ASN1_OVERRUN;
tag_out->tag_end_len = 0;
*contents_out = asn1 + llen;
*clen_out = clen;
*remainder_out = *contents_out + clen;
*rlen_out = len - (*remainder_out - asn1);
}
tag_out->tag_len = *contents_out - tag_start;
return 0;
}","[3, 41, 43]",MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.
9612,"njs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t *await)
{
size_t              size;
njs_int_t           ret;
njs_frame_t         *frame;
njs_value_t         ctor, val, on_fulfilled, on_rejected, *value;
njs_promise_t       *promise;
njs_function_t      *fulfilled, *rejected;
njs_async_ctx_t     *ctx;
njs_native_frame_t  *active;

active = &vm->active_frame->native;

value = njs_scope_valid_value(vm, await->retval);
if (njs_slow_path(value == NULL)) {
return NJS_ERROR;
}

njs_set_function(&ctor, &vm->constructors[NJS_OBJ_TYPE_PROMISE]);

promise = njs_promise_resolve(vm, &ctor, value);
if (njs_slow_path(promise == NULL)) {
return NJS_ERROR;
}

ctx = active->function->await;

if (ctx == NULL) {
ctx = njs_mp_alloc(vm->mem_pool, sizeof(njs_async_ctx_t));
if (njs_slow_path(ctx == NULL)) {
njs_memory_error(vm);
return NJS_ERROR;
}

size = njs_function_frame_size(active);

fulfilled = njs_promise_create_function(vm, size);
if (njs_slow_path(fulfilled == NULL)) {
return NJS_ERROR;
}

ctx->await = fulfilled->context;
ctx->capability = active->function->context;

active->function->context = NULL;

ret = njs_function_frame_save(vm, ctx->await, NULL);
if (njs_slow_path(ret != NJS_OK)) {
return NJS_ERROR;
}

} else {
fulfilled = njs_promise_create_function(vm, 0);
if (njs_slow_path(fulfilled == NULL)) {
return NJS_ERROR;
}
}

ctx->pc = (u_char *) await + sizeof(njs_vmcode_await_t);
ctx->index = await->retval;

frame = (njs_frame_t *) active;

if (frame->exception.catch != NULL) {
ctx->await->native.pc = frame->exception.catch;

} else {
ctx->await->native.pc = ctx->pc;
}

fulfilled->context = ctx;
fulfilled->args_count = 1;
fulfilled->u.native = njs_await_fulfilled;

rejected = njs_promise_create_function(vm, 0);
if (njs_slow_path(rejected == NULL)) {
return NJS_ERROR;
}

rejected->context = ctx;
rejected->args_count = 1;
rejected->u.native = njs_await_rejected;

njs_set_promise(&val, promise);
njs_set_function(&on_fulfilled, fulfilled);
njs_set_function(&on_rejected, rejected);

ret = njs_promise_perform_then(vm, &val, &on_fulfilled, &on_rejected, NULL);
if (njs_slow_path(ret != NJS_OK)) {
return NJS_ERROR;
}

(void) njs_vmcode_return(vm, NULL, &vm->retval);

return NJS_AGAIN;
}","[9, 26, 43, 45]","njs through 0.7.0, used in NGINX, was discovered to contain a heap use-after-free in njs_await_fulfilled."
198127," static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
 {
    struct virgl_gl_ctx_param ctx_params;
    int i;
    if (blit_ctx->initialised) {
       vrend_clicbs->make_current(0, blit_ctx->gl_context);
        return;
     }
  
    blit_ctx->initialised = true;
     ctx_params.shared = true;
     ctx_params.major_ver = VREND_GL_VER_MAJOR;
     ctx_params.minor_ver = VREND_GL_VER_MINOR;
 
    vrend_clicbs->make_current(0, blit_ctx->gl_context);
    glGenVertexArrays(1, &blit_ctx->vaoid);
    glGenFramebuffers(1, &blit_ctx->fb_id);
 
    glGenBuffers(1, &blit_ctx->vbo_id);
    blit_build_vs_passthrough(blit_ctx);
 
    for (i = 0; i < 4; i++)
       blit_ctx->vertices[i][0][3] = 1;  
    glBindVertexArray(blit_ctx->vaoid);
    glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
 }",[10],Memory leak in the vrend_renderer_init_blit_ctx function in vrend_blitter.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_CCMD_BLIT commands.
207074," void RenderFrameHostImpl::RegisterMojoInterfaces() {
 #if !defined(OS_ANDROID)
   registry_->AddInterface(base::Bind(&InstalledAppProviderImplDefault::Create));
 #endif   
 
   PermissionControllerImpl* permission_controller =
       PermissionControllerImpl::FromBrowserContext(
           GetProcess()->GetBrowserContext());
   if (delegate_) {
     auto* geolocation_context = delegate_->GetGeolocationContext();
     if (geolocation_context) {
       geolocation_service_.reset(new GeolocationServiceImpl(
           geolocation_context, permission_controller, this));
       registry_->AddInterface(
           base::Bind(&GeolocationServiceImpl::Bind,
                      base::Unretained(geolocation_service_.get())));
     }
   }
 
   registry_->AddInterface<device::mojom::WakeLock>(base::Bind(
       &RenderFrameHostImpl::BindWakeLockRequest, base::Unretained(this)));
 
 #if defined(OS_ANDROID)
   if (base::FeatureList::IsEnabled(features::kWebNfc)) {
     registry_->AddInterface<device::mojom::NFC>(base::Bind(
         &RenderFrameHostImpl::BindNFCRequest, base::Unretained(this)));
   }
 #endif
 
   if (!permission_service_context_)
     permission_service_context_.reset(new PermissionServiceContext(this));
 
   registry_->AddInterface(
       base::Bind(&PermissionServiceContext::CreateService,
                  base::Unretained(permission_service_context_.get())));
 
   registry_->AddInterface(
       base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,
                  base::Unretained(this)));
 
   registry_->AddInterface(
       base::Bind(&MediaSessionServiceImpl::Create, base::Unretained(this)));
 
   registry_->AddInterface(base::Bind(
       base::IgnoreResult(&RenderFrameHostImpl::CreateWebBluetoothService),
       base::Unretained(this)));
 
   registry_->AddInterface(base::BindRepeating(
       &RenderFrameHostImpl::CreateWebUsbService, base::Unretained(this)));
 
   registry_->AddInterface<media::mojom::InterfaceFactory>(
       base::Bind(&RenderFrameHostImpl::BindMediaInterfaceFactoryRequest,
                  base::Unretained(this)));
 
   registry_->AddInterface(base::BindRepeating(
       &RenderFrameHostImpl::CreateWebSocket, base::Unretained(this)));
 
   registry_->AddInterface(base::BindRepeating(
       &RenderFrameHostImpl::CreateDedicatedWorkerHostFactory,
       base::Unretained(this)));
 
   registry_->AddInterface(base::Bind(&SharedWorkerConnectorImpl::Create,
                                      process_->GetID(), routing_id_));
 
   registry_->AddInterface(base::BindRepeating(&device::GamepadMonitor::Create));
 
   registry_->AddInterface<device::mojom::VRService>(base::Bind(
       &WebvrServiceProvider::BindWebvrService, base::Unretained(this)));
 
   registry_->AddInterface(
       base::BindRepeating(&RenderFrameHostImpl::CreateAudioInputStreamFactory,
                           base::Unretained(this)));
 
   registry_->AddInterface(
       base::BindRepeating(&RenderFrameHostImpl::CreateAudioOutputStreamFactory,
                           base::Unretained(this)));
 
   registry_->AddInterface(
       base::Bind(&CreateFrameResourceCoordinator, base::Unretained(this)));
 
   if (BrowserMainLoop::GetInstance()) {
     MediaStreamManager* media_stream_manager =
         BrowserMainLoop::GetInstance()->media_stream_manager();
     registry_->AddInterface(
         base::Bind(&MediaDevicesDispatcherHost::Create, GetProcess()->GetID(),
                    GetRoutingID(), base::Unretained(media_stream_manager)),
          base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));
  
      registry_->AddInterface(
        base::BindRepeating(
            &RenderFrameHostImpl::CreateMediaStreamDispatcherHost,
            base::Unretained(this), base::Unretained(media_stream_manager)),
         base::BindRepeating(&MediaStreamDispatcherHost::Create,
                             GetProcess()->GetID(), GetRoutingID(),
                             base::Unretained(media_stream_manager)),
          base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));
    }
  
 #if BUILDFLAG(ENABLE_MEDIA_REMOTING)
   registry_->AddInterface(base::Bind(&RemoterFactoryImpl::Bind,
                                      GetProcess()->GetID(), GetRoutingID()));
 #endif   
 
   registry_->AddInterface(base::BindRepeating(
       &KeyboardLockServiceImpl::CreateMojoService, base::Unretained(this)));
 
   registry_->AddInterface(base::Bind(&ImageCaptureImpl::Create));
 
 #if !defined(OS_ANDROID)
   if (base::FeatureList::IsEnabled(features::kWebAuth)) {
     registry_->AddInterface(
         base::Bind(&RenderFrameHostImpl::BindAuthenticatorRequest,
                    base::Unretained(this)));
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
             switches::kEnableWebAuthTestingAPI)) {
       auto* environment_singleton =
           ScopedVirtualAuthenticatorEnvironment::GetInstance();
       registry_->AddInterface(base::BindRepeating(
           &ScopedVirtualAuthenticatorEnvironment::AddBinding,
           base::Unretained(environment_singleton)));
     }
   }
 #endif   
 
   sensor_provider_proxy_.reset(
       new SensorProviderProxyImpl(permission_controller, this));
   registry_->AddInterface(
       base::Bind(&SensorProviderProxyImpl::Bind,
                  base::Unretained(sensor_provider_proxy_.get())));
 
   media::VideoDecodePerfHistory::SaveCallback save_stats_cb;
   if (GetSiteInstance()->GetBrowserContext()->GetVideoDecodePerfHistory()) {
     save_stats_cb = GetSiteInstance()
                         ->GetBrowserContext()
                         ->GetVideoDecodePerfHistory()
                         ->GetSaveCallback();
   }
 
   registry_->AddInterface(base::BindRepeating(
       &media::MediaMetricsProvider::Create, frame_tree_node_->IsMainFrame(),
       base::BindRepeating(
           &RenderFrameHostDelegate::GetUkmSourceIdForLastCommittedSource,
           base::Unretained(delegate_)),
       std::move(save_stats_cb)));
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           cc::switches::kEnableGpuBenchmarking)) {
     registry_->AddInterface(
         base::Bind(&InputInjectorImpl::Create, weak_ptr_factory_.GetWeakPtr()));
   }
 
   registry_->AddInterface(base::BindRepeating(
       &QuotaDispatcherHost::CreateForFrame, GetProcess(), routing_id_));
 
   registry_->AddInterface(
       base::BindRepeating(SpeechRecognitionDispatcherHost::Create,
                           GetProcess()->GetID(), routing_id_),
       base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));
 
   file_system_manager_.reset(new FileSystemManagerImpl(
       GetProcess()->GetID(), routing_id_,
       GetProcess()->GetStoragePartition()->GetFileSystemContext(),
       ChromeBlobStorageContext::GetFor(GetProcess()->GetBrowserContext())));
   registry_->AddInterface(
       base::BindRepeating(&FileSystemManagerImpl::BindRequest,
                           base::Unretained(file_system_manager_.get())),
       base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));
 
   if (Portal::IsEnabled()) {
     registry_->AddInterface(base::BindRepeating(IgnoreResult(&Portal::Create),
                                                 base::Unretained(this)));
   }
 
   registry_->AddInterface(base::BindRepeating(
       &BackgroundFetchServiceImpl::CreateForFrame, GetProcess(), routing_id_));
 
   registry_->AddInterface(base::BindRepeating(&ContactsManagerImpl::Create));
 
   registry_->AddInterface(
       base::BindRepeating(&FileChooserImpl::Create, base::Unretained(this)));
 
   registry_->AddInterface(base::BindRepeating(&AudioContextManagerImpl::Create,
                                               base::Unretained(this)));
 
   registry_->AddInterface(base::BindRepeating(&WakeLockServiceImpl::Create,
                                               base::Unretained(this)));
 }","[93, 94, 95, 90, 91, 92]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
203055,"  cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,
      const cdf_header_t *h, cdf_secid_t id)
  {
	assert((size_t)CDF_SEC_SIZE(h) == len);
	return cdf_read(info, (off_t)CDF_SEC_POS(h, id),
	    ((char *)buf) + offs, len);
 	size_t ss = CDF_SEC_SIZE(h);
 	size_t pos = CDF_SEC_POS(h, id);
 	assert(ss == len);
 	return cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);
  }","[7, 8, 9, 10, 4, 5, 6]",file before 5.11 and libmagic allow remote attackers to cause a denial of service (crash) via a crafted Composite Document File (CDF) file that triggers (1) an out-of-bounds read or (2) an invalid pointer dereference.
202331," static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
 {
     AC3HeaderInfo *hdr = NULL;
     struct eac3_info *info;
     int num_blocks, ret;
 
     if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
         return AVERROR(ENOMEM);
     info = track->eac3_priv;
 
     if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
          
         if (!track->entry) {
             av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
             ret = 0;
         } else
             ret = AVERROR_INVALIDDATA;
         goto end;
     }
 
     info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
     num_blocks = hdr->num_blocks;
 
     if (!info->ec3_done) {
          
         if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
             ret = AVERROR(EINVAL);
             goto end;
         }
 
          
         if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
              
             if (hdr->substreamid > info->num_ind_sub + 1) {
                 ret = AVERROR(EINVAL);
                 goto end;
             }
 
             if (hdr->substreamid == info->num_ind_sub + 1) {
                 avpriv_request_sample(track->par, ""Multiple independent substreams"");
                 ret = AVERROR_PATCHWELCOME;
                 goto end;
             } else if (hdr->substreamid < info->num_ind_sub ||
                        hdr->substreamid == 0 && info->substream[0].bsid) {
                  info->ec3_done = 1;
                  goto concatenate;
              }
         } else {
             if (hdr->substreamid != 0) {
                 avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
                 ret = AVERROR_PATCHWELCOME;
                 goto end;
             }
          }
  
           
         info->substream[hdr->substreamid].fscod = hdr->sr_code;
         info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
         info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
         info->substream[hdr->substreamid].acmod = hdr->channel_mode;
         info->substream[hdr->substreamid].lfeon = hdr->lfe_on;
 
          
         if (pkt->size != hdr->frame_size) {
             int cumul_size = hdr->frame_size;
             int parent = hdr->substreamid;
 
             while (cumul_size != pkt->size) {
                 GetBitContext gbc;
                 int i;
                 ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                 if (ret < 0)
                     goto end;
                 if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                     ret = AVERROR(EINVAL);
                     goto end;
                 }
                 info->substream[parent].num_dep_sub++;
                 ret /= 8;
 
                  
                 init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                  
                 skip_bits(&gbc, 5);
                  
                 for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                     skip_bits(&gbc, 5);  
                     if (get_bits1(&gbc)) {
                         skip_bits(&gbc, 8);  
                     }
                 }
                  
                 if (get_bits1(&gbc))
                     info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                 else
                     info->substream[parent].chan_loc |= hdr->channel_mode;
                 cumul_size += hdr->frame_size;
             }
         }
     }
 
 concatenate:
     if (!info->num_blocks && num_blocks == 6) {
         ret = pkt->size;
         goto end;
     }
     else if (info->num_blocks + num_blocks > 6) {
         ret = AVERROR_INVALIDDATA;
         goto end;
     }
 
     if (!info->num_blocks) {
         ret = av_packet_ref(&info->pkt, pkt);
         if (!ret)
             info->num_blocks = num_blocks;
         goto end;
     } else {
         if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
             goto end;
         memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
         info->num_blocks += num_blocks;
         info->pkt.duration += pkt->duration;
         if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
             goto end;
         if (info->num_blocks != 6)
             goto end;
         av_packet_unref(pkt);
         av_packet_move_ref(pkt, &info->pkt);
         info->num_blocks = 0;
     }
     ret = pkt->size;
 
 end:
     av_free(hdr);
 
     return ret;
 }","[48, 49, 50, 51, 52, 53]","In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact."
8061,"unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {

if (first == NULL || *first == NULL || second == NULL || *second == NULL)
return NULL;


if (*first == *second)
return NULL;

size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));

size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));

int append;
unsigned char *source, *target;
size_t target_bytes, source_bytes;



if (first_len >= second_len) {

target = *first;
target_bytes = first_bytes;
source = *second;
source_bytes = second_bytes;
append = 1;
} else {

target = *second;
target_bytes = second_bytes;
source = *first;
source_bytes = first_bytes;
append = 0;
}


size_t zlbytes = first_bytes + second_bytes -
ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;
size_t zllength = first_len + second_len;


zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;


size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));


target = zrealloc(target, zlbytes);
if (append) {



memcpy(target + target_bytes - ZIPLIST_END_SIZE,
source + ZIPLIST_HEADER_SIZE,
source_bytes - ZIPLIST_HEADER_SIZE);
} else {




memmove(target + source_bytes - ZIPLIST_END_SIZE,
target + ZIPLIST_HEADER_SIZE,
target_bytes - ZIPLIST_HEADER_SIZE);
memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);
}


ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);
ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);





ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(
(first_bytes - ZIPLIST_END_SIZE) +
(second_offset - ZIPLIST_HEADER_SIZE));





target = __ziplistCascadeUpdate(target, target+first_offset);


if (append) {
zfree(*second);
*second = NULL;
*first = target;
} else {
zfree(*first);
*first = NULL;
*second = target;
}
return target;
}",[47],"Redis is an open source, in-memory database that persists on disk. In affected versions an integer overflow bug in Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves changing the default proto-max-bulk-len and client-query-buffer-limit configuration parameters to very large values and constructing specially crafted very large stream elements. The problem is fixed in Redis 6.2.6, 6.0.16 and 5.0.14. For users unable to upgrade an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the proto-max-bulk-len configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command."
200911," static Image *ReadYCBCRImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   const unsigned char
     *pixels;
 
   Image
     *canvas_image,
     *image;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     scene;
 
   QuantumInfo
     *quantum_info;
 
   QuantumType
     quantum_type;
 
   register const Quantum
     *p;
 
   register ssize_t
     i,
     x;
 
   register Quantum
     *q;
 
   size_t
     length;
 
   ssize_t
     count,
     y;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   if ((image->columns == 0) || (image->rows == 0))
     ThrowReaderException(OptionError,""MustSpecifyImageSize"");
   status=SetImageExtent(image,image->columns,image->rows,exception);
   if (status == MagickFalse)
     return(DestroyImageList(image));
   SetImageColorspace(image,YCbCrColorspace,exception);
   if (image_info->interlace != PartitionInterlace)
     {
       status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
       if (status == MagickFalse)
         {
           image=DestroyImageList(image);
           return((Image *) NULL);
         }
       if (DiscardBlobBytes(image,image->offset) == MagickFalse)
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
     }
    
   canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,
     exception);
   (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod,
     exception);
   quantum_info=AcquireQuantumInfo(image_info,canvas_image);
   if (quantum_info == (QuantumInfo *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   quantum_type=RGBQuantum;
   if (LocaleCompare(image_info->magick,""YCbCrA"") == 0)
     {
       quantum_type=RGBAQuantum;
       image->alpha_trait=BlendPixelTrait;
     }
   pixels=(const unsigned char *) NULL;
   if (image_info->number_scenes != 0)
     while (image->scene < image_info->scene)
     {
        
       image->scene++;
       length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);
       for (y=0; y < (ssize_t) image->rows; y++)
       {
         pixels=(const unsigned char *) ReadBlobStream(image,length,
           GetQuantumPixels(quantum_info),&count);
         if (count != (ssize_t) length)
           break;
       }
     }
   count=0;
   length=0;
   scene=0;
   do
   {
      
     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=SetImageExtent(image,image->columns,image->rows,exception);
      if (status == MagickFalse)
      {
        quantum_info=DestroyQuantumInfo(quantum_info);
       canvas_image=DestroyImage(canvas_image);
        return(DestroyImageList(image));
      }
      SetImageColorspace(image,YCbCrColorspace,exception);
     switch (image_info->interlace)
     {
       case NoInterlace:
       default:
       {
          
         if (scene == 0)
           {
             length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
           }
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           if (count != (ssize_t) length)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
             exception);
           if (q == (Quantum *) NULL)
             break;
           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
             quantum_info,quantum_type,pixels,exception);
           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
             break;
           if (((y-image->extract_info.y) >= 0) && 
               ((y-image->extract_info.y) < (ssize_t) image->rows))
             {
               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,
                 canvas_image->columns,1,exception);
               q=QueueAuthenticPixels(image,0,y-image->extract_info.y,
                 image->columns,1,exception);
               if ((p == (const Quantum *) NULL) ||
                   (q == (Quantum *) NULL))
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelRed(image,GetPixelRed(canvas_image,p),q);
                 SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);
                 SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);
                 if (image->alpha_trait != UndefinedPixelTrait)
                   SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);
                 p+=GetPixelChannels(canvas_image);
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
             }
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
           pixels=(const unsigned char *) ReadBlobStream(image,length,
             GetQuantumPixels(quantum_info),&count);
         }
         break;
       }
       case LineInterlace:
       {
         static QuantumType
           quantum_types[4] =
           {
             RedQuantum,
             GreenQuantum,
             BlueQuantum,
             OpacityQuantum
           };
 
          
         if (scene == 0)
           {
             length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
           }
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           for (i=0; i < (image->alpha_trait != UndefinedPixelTrait ? 4 : 3); i++)
           {
             if (count != (ssize_t) length)
               {
                 ThrowFileException(exception,CorruptImageError,
                   ""UnexpectedEndOfFile"",image->filename);
                 break;
               }
             quantum_type=quantum_types[i];
             q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
               quantum_info,quantum_type,pixels,exception);
             if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
               break;
             if (((y-image->extract_info.y) >= 0) && 
                 ((y-image->extract_info.y) < (ssize_t) image->rows))
               {
                 p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,
                   0,canvas_image->columns,1,exception);
                 q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                   image->columns,1,exception);
                 if ((p == (const Quantum *) NULL) ||
                     (q == (Quantum *) NULL))
                   break;
                 for (x=0; x < (ssize_t) image->columns; x++)
                 {
                   switch (quantum_type)
                   {
                     case RedQuantum:
                     {
                       SetPixelRed(image,GetPixelRed(canvas_image,p),q);
                       break;
                     }
                     case GreenQuantum:
                     {
                       SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);
                       break;
                     }
                     case BlueQuantum:
                     {
                       SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);
                       break;
                     }
                     case OpacityQuantum:
                     {
                       SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);
                       break;
                     }
                     default:
                       break;
                   }
                   p+=GetPixelChannels(canvas_image);
                   q+=GetPixelChannels(image);
                 }
                 if (SyncAuthenticPixels(image,exception) == MagickFalse)
                   break;
               }
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
           }
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case PlaneInterlace:
       {
          
         if (scene == 0)
           {
             length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
           }
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           if (count != (ssize_t) length)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
             exception);
           if (q == (Quantum *) NULL)
             break;
           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
             quantum_info,RedQuantum,pixels,exception);
           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
             break;
           if (((y-image->extract_info.y) >= 0) && 
               ((y-image->extract_info.y) < (ssize_t) image->rows))
             {
               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,
                 canvas_image->columns,1,exception);
               q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                 image->columns,1,exception);
               if ((p == (const Quantum *) NULL) ||
                   (q == (Quantum *) NULL))
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelRed(image,GetPixelRed(canvas_image,p),q);
                 p+=GetPixelChannels(canvas_image);
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
             }
           pixels=(const unsigned char *) ReadBlobStream(image,length,
             GetQuantumPixels(quantum_info),&count);
         }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,1,5);
             if (status == MagickFalse)
               break;
           }
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           if (count != (ssize_t) length)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
             exception);
           if (q == (Quantum *) NULL)
             break;
           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
             quantum_info,GreenQuantum,pixels,exception);
           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
             break;
           if (((y-image->extract_info.y) >= 0) && 
               ((y-image->extract_info.y) < (ssize_t) image->rows))
             {
               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,
                 canvas_image->columns,1,exception);
               q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                 image->columns,1,exception);
               if ((p == (const Quantum *) NULL) ||
                   (q == (Quantum *) NULL))
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);
                 p+=GetPixelChannels(canvas_image);
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
           pixels=(const unsigned char *) ReadBlobStream(image,length,
             GetQuantumPixels(quantum_info),&count);
         }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,2,5);
             if (status == MagickFalse)
               break;
           }
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           if (count != (ssize_t) length)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
             exception);
           if (q == (Quantum *) NULL)
             break;
           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
             quantum_info,BlueQuantum,pixels,exception);
           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
             break;
           if (((y-image->extract_info.y) >= 0) && 
               ((y-image->extract_info.y) < (ssize_t) image->rows))
             {
               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,
                 canvas_image->columns,1,exception);
               q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                 image->columns,1,exception);
               if ((p == (const Quantum *) NULL) ||
                   (q == (Quantum *) NULL))
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);
                 p+=GetPixelChannels(canvas_image);
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
             }
           pixels=(const unsigned char *) ReadBlobStream(image,length,
             GetQuantumPixels(quantum_info),&count);
         }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,3,5);
             if (status == MagickFalse)
               break;
           }
         if (image->alpha_trait != UndefinedPixelTrait)
           {
             for (y=0; y < (ssize_t) image->extract_info.height; y++)
             {
               if (count != (ssize_t) length)
                 {
                   ThrowFileException(exception,CorruptImageError,
                     ""UnexpectedEndOfFile"",image->filename);
                   break;
                 }
               q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
                 exception);
               if (q == (Quantum *) NULL)
                 break;
               length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
                 quantum_info,AlphaQuantum,pixels,exception);
               if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
                 break;
               if (((y-image->extract_info.y) >= 0) && 
                   ((y-image->extract_info.y) < (ssize_t) image->rows))
                 {
                   p=GetVirtualPixels(canvas_image,
                     canvas_image->extract_info.x,0,canvas_image->columns,1,
                     exception);
                   q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                     image->columns,1,exception);
                   if ((p == (const Quantum *) NULL) ||
                       (q == (Quantum *) NULL))
                     break;
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);
                     p+=GetPixelChannels(canvas_image);
                     q+=GetPixelChannels(image);
                   }
                   if (SyncAuthenticPixels(image,exception) == MagickFalse)
                     break;
                 }
               pixels=(const unsigned char *) ReadBlobStream(image,length,
                 GetQuantumPixels(quantum_info),&count);
             }
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,4,5);
                 if (status == MagickFalse)
                   break;
               }
           }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,5,5);
             if (status == MagickFalse)
               break;
           }
         break;
       }
       case PartitionInterlace:
       {
          
         AppendImageFormat(""Y"",image->filename);
         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
         if (status == MagickFalse)
           {
             canvas_image=DestroyImageList(canvas_image);
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         if (DiscardBlobBytes(image,image->offset) == MagickFalse)
           ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
             image->filename);
         length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);
         for (i=0; i < (ssize_t) scene; i++)
           for (y=0; y < (ssize_t) image->extract_info.height; y++)
           {
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
             if (count != (ssize_t) length)
               {
                 ThrowFileException(exception,CorruptImageError,
                   ""UnexpectedEndOfFile"",image->filename);
                 break;
               }
           }
         pixels=(const unsigned char *) ReadBlobStream(image,length,
           GetQuantumPixels(quantum_info),&count);
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           if (count != (ssize_t) length)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
             exception);
           if (q == (Quantum *) NULL)
             break;
           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
             quantum_info,RedQuantum,pixels,exception);
           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
             break;
           if (((y-image->extract_info.y) >= 0) && 
               ((y-image->extract_info.y) < (ssize_t) image->rows))
             {
               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,
                 canvas_image->columns,1,exception);
               q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                 image->columns,1,exception);
               if ((p == (const Quantum *) NULL) ||
                   (q == (Quantum *) NULL))
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelRed(image,GetPixelRed(canvas_image,p),q);
                 p+=GetPixelChannels(canvas_image);
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
             }
           pixels=(const unsigned char *) ReadBlobStream(image,length,
             GetQuantumPixels(quantum_info),&count);
         }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,1,5);
             if (status == MagickFalse)
               break;
           }
         (void) CloseBlob(image);
         AppendImageFormat(""Cb"",image->filename);
         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
         if (status == MagickFalse)
           {
             canvas_image=DestroyImageList(canvas_image);
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         length=GetQuantumExtent(canvas_image,quantum_info,GreenQuantum);
         for (i=0; i < (ssize_t) scene; i++)
           for (y=0; y < (ssize_t) image->extract_info.height; y++)
           {
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
             if (count != (ssize_t) length)
               {
                 ThrowFileException(exception,CorruptImageError,
                   ""UnexpectedEndOfFile"",image->filename);
                 break;
               }
           }
         pixels=(const unsigned char *) ReadBlobStream(image,length,
           GetQuantumPixels(quantum_info),&count);
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           if (count != (ssize_t) length)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
             exception);
           if (q == (Quantum *) NULL)
             break;
           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
             quantum_info,GreenQuantum,pixels,exception);
           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
             break;
           if (((y-image->extract_info.y) >= 0) && 
               ((y-image->extract_info.y) < (ssize_t) image->rows))
             {
               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,
                 canvas_image->columns,1,exception);
               q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                 image->columns,1,exception);
               if ((p == (const Quantum *) NULL) ||
                   (q == (Quantum *) NULL))
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);
                 p+=GetPixelChannels(canvas_image);
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
           pixels=(const unsigned char *) ReadBlobStream(image,length,
             GetQuantumPixels(quantum_info),&count);
         }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,2,5);
             if (status == MagickFalse)
               break;
           }
         (void) CloseBlob(image);
         AppendImageFormat(""Cr"",image->filename);
         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
         if (status == MagickFalse)
           {
             canvas_image=DestroyImageList(canvas_image);
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         length=GetQuantumExtent(canvas_image,quantum_info,BlueQuantum);
         for (i=0; i < (ssize_t) scene; i++)
           for (y=0; y < (ssize_t) image->extract_info.height; y++)
           {
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
             if (count != (ssize_t) length)
               {
                 ThrowFileException(exception,CorruptImageError,
                   ""UnexpectedEndOfFile"",image->filename);
                 break;
               }
           }
         pixels=(const unsigned char *) ReadBlobStream(image,length,
           GetQuantumPixels(quantum_info),&count);
         for (y=0; y < (ssize_t) image->extract_info.height; y++)
         {
           if (count != (ssize_t) length)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
             exception);
           if (q == (Quantum *) NULL)
             break;
           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
             quantum_info,BlueQuantum,pixels,exception);
           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
             break;
           if (((y-image->extract_info.y) >= 0) && 
               ((y-image->extract_info.y) < (ssize_t) image->rows))
             {
               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,
                 canvas_image->columns,1,exception);
               q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                 image->columns,1,exception);
               if ((p == (const Quantum *) NULL) ||
                   (q == (Quantum *) NULL))
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);
                 p+=GetPixelChannels(canvas_image);
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
           pixels=(const unsigned char *) ReadBlobStream(image,length,
             GetQuantumPixels(quantum_info),&count);
         }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,3,5);
             if (status == MagickFalse)
               break;
           }
         if (image->alpha_trait != UndefinedPixelTrait)
           {
             (void) CloseBlob(image);
             AppendImageFormat(""A"",image->filename);
             status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
             if (status == MagickFalse)
               {
                 canvas_image=DestroyImageList(canvas_image);
                 image=DestroyImageList(image);
                 return((Image *) NULL);
               }
             length=GetQuantumExtent(canvas_image,quantum_info,AlphaQuantum);
             for (i=0; i < (ssize_t) scene; i++)
               for (y=0; y < (ssize_t) image->extract_info.height; y++)
               {
                 pixels=(const unsigned char *) ReadBlobStream(image,length,
                   GetQuantumPixels(quantum_info),&count);
                 if (count != (ssize_t) length)
                   {
                     ThrowFileException(exception,CorruptImageError,
                       ""UnexpectedEndOfFile"",image->filename);
                     break;
                   }
               }
             pixels=(const unsigned char *) ReadBlobStream(image,length,
               GetQuantumPixels(quantum_info),&count);
             for (y=0; y < (ssize_t) image->extract_info.height; y++)
             {
               if (count != (ssize_t) length)
                 {
                   ThrowFileException(exception,CorruptImageError,
                     ""UnexpectedEndOfFile"",image->filename);
                   break;
                 }
               q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,
                 exception);
               if (q == (Quantum *) NULL)
                 break;
               length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,
                 quantum_info,BlueQuantum,pixels,exception);
               if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)
                 break;
               if (((y-image->extract_info.y) >= 0) && 
                   ((y-image->extract_info.y) < (ssize_t) image->rows))
                 {
                   p=GetVirtualPixels(canvas_image,
                     canvas_image->extract_info.x,0,canvas_image->columns,1,
                     exception);
                   q=GetAuthenticPixels(image,0,y-image->extract_info.y,
                     image->columns,1,exception);
                   if ((p == (const Quantum *) NULL) ||
                       (q == (Quantum *) NULL))
                     break;
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);
                     p+=GetPixelChannels(canvas_image);
                     q+=GetPixelChannels(image);
                   }
                   if (SyncAuthenticPixels(image,exception) == MagickFalse)
                     break;
                }
               pixels=(const unsigned char *) ReadBlobStream(image,length,
                 GetQuantumPixels(quantum_info),&count);
             }
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,4,5);
                 if (status == MagickFalse)
                   break;
               }
           }
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,5,5);
             if (status == MagickFalse)
               break;
           }
         break;
       }
     }
     SetQuantumImageType(image,quantum_type);
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     if (count == (ssize_t) length)
       {
          
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
     scene++;
   } while (count == (ssize_t) length);
   quantum_info=DestroyQuantumInfo(quantum_info);
   canvas_image=DestroyImage(canvas_image);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }",[109],ImageMagick version 7.0.7-2 contains a memory leak in ReadYCBCRImage in coders/ycbcr.c.
200002,"  void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
  	{
	BN_ULONG t1,t2;
  	BN_ULONG c1,c2,c3;
  
  	c1=0;
 	c2=0;
 	c3=0;
 	sqr_add_c(a,0,c1,c2,c3);
 	r[0]=c1;
 	c1=0;
 	sqr_add_c2(a,1,0,c2,c3,c1);
 	r[1]=c2;
 	c2=0;
 	sqr_add_c(a,1,c3,c1,c2);
 	sqr_add_c2(a,2,0,c3,c1,c2);
 	r[2]=c3;
 	c3=0;
 	sqr_add_c2(a,3,0,c1,c2,c3);
 	sqr_add_c2(a,2,1,c1,c2,c3);
 	r[3]=c1;
 	c1=0;
 	sqr_add_c(a,2,c2,c3,c1);
 	sqr_add_c2(a,3,1,c2,c3,c1);
 	r[4]=c2;
 	c2=0;
 	sqr_add_c2(a,3,2,c3,c1,c2);
 	r[5]=c3;
 	c3=0;
 	sqr_add_c(a,3,c1,c2,c3);
 	r[6]=c1;
 	r[7]=c2;
 	}",[3],"The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c."
205128,"  void LocalFileSystem::resolveURL(ExecutionContext* context, const KURL& fileSystemURL, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
  {
      RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
     CallbackWrapper* wrapper = new CallbackWrapper(callbacks);
      requestFileSystemAccessInternal(context,
          bind(&LocalFileSystem::resolveURLInternal, this, contextPtr, fileSystemURL, wrapper),
          bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
 }","[5, 4]",The URL loader in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.
207100," IDNSpoofChecker::IDNSpoofChecker() {
   UErrorCode status = U_ZERO_ERROR;
   checker_ = uspoof_open(&status);
   if (U_FAILURE(status)) {
     checker_ = nullptr;
     return;
   }
 
 
   uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);
 
   SetAllowedUnicodeSet(&status);
 
   int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;
   uspoof_setChecks(checker_, checks, &status);
 
   deviation_characters_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u00df\\u03c2\\u200c\\u200d]""), status);
   deviation_characters_.freeze();
 
   non_ascii_latin_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Latin:] - [a-zA-Z]]""), status);
   non_ascii_latin_letters_.freeze();
 
   kana_letters_exceptions_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u3078-\\u307a\\u30d8-\\u30da\\u30fb-\\u30fe]""),
       status);
   kana_letters_exceptions_.freeze();
   combining_diacritics_exceptions_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[\\u0300-\\u0339]""), status);
   combining_diacritics_exceptions_.freeze();
 
    cyrillic_letters_latin_alike_ = icu::UnicodeSet(
      icu::UnicodeString::fromUTF8(""[асԁеһіјӏорԛѕԝхуъЬҽпгѵѡ]""), status);
       icu::UnicodeString::fromUTF8(""[асԁеһіјӏорԗԛѕԝхуъЬҽпгѵѡ]""), status);
    cyrillic_letters_latin_alike_.freeze();
  
    cyrillic_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Cyrl:]]""), status);
   cyrillic_letters_.freeze();
 
   DCHECK(U_SUCCESS(status));
   lgc_letters_n_ascii_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[[:Latin:][:Greek:][:Cyrillic:][0-9\\u002e_""
                             ""\\u002d][\\u0300-\\u0339]]""),
       status);
   lgc_letters_n_ascii_.freeze();
 
   UParseError parse_error;
   diacritic_remover_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""DropAcc""),
       icu::UnicodeString::fromUTF8(""::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;""
                                    "" ł > l; ø > o; đ > d;""),
       UTRANS_FORWARD, parse_error, status));
 
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(
           ""[æӕ] > ae; [þϼҏ] > p; [ħнћңҥӈӊԋԧԩ] > h;""
           ""[ĸκкқҝҟҡӄԟ] > k; [ŋпԥก] > n; œ > ce;""
           ""[ŧтҭԏ] > t; [ƅьҍв] > b;  [ωшщพฟພຟ] > w;""
           ""[мӎ] > m; [єҽҿၔ] > e; ґ > r; [ғӻ] > f;""
           ""[ҫင] > c; ұ > y; [χҳӽӿ] > x;""
           ""ԃ  > d; [ԍဌ] > g; [ടรຣຮ] > s; ၂ > j;""
           ""[зҙӡउওဒვპ] > 3; [บບ] > u""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: ""
       << u_errorName(status);
 }","[35, 34]",Incorrect handling of a confusable character in Omnibox in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
805,"PHP_FUNCTION(imagecrop)
{
zval *IM;
gdImagePtr im;
gdImagePtr im_crop;
gdRect rect;
zval *z_rect;
zval **tmp;

if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &z_rect) == FAILURE)  {
return;
}

ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

if (zend_hash_find(HASH_OF(z_rect), ""x"", sizeof(""x""), (void **)&tmp) != FAILURE) {
rect.x = Z_LVAL_PP(tmp);
} else {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing x position"");
RETURN_FALSE;
}

if (zend_hash_find(HASH_OF(z_rect), ""y"", sizeof(""x""), (void **)&tmp) != FAILURE) {
rect.y = Z_LVAL_PP(tmp);
} else {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
RETURN_FALSE;
}

if (zend_hash_find(HASH_OF(z_rect), ""width"", sizeof(""width""), (void **)&tmp) != FAILURE) {
rect.width = Z_LVAL_PP(tmp);
} else {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing width"");
RETURN_FALSE;
}

if (zend_hash_find(HASH_OF(z_rect), ""height"", sizeof(""height""), (void **)&tmp) != FAILURE) {
rect.height = Z_LVAL_PP(tmp);
} else {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing height"");
RETURN_FALSE;
}

im_crop = gdImageCrop(im, &rect);

if (im_crop == NULL) {
RETURN_FALSE;
} else {
ZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);
}
}","[17, 24, 31, 38]","Integer overflow in the gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an imagecrop function call with a large x dimension value, leading to a heap-based buffer overflow."
197845," static bool ldb_dn_explode(struct ldb_dn *dn)
 {
 	char *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;
 	bool trim = true;
 	bool in_extended = true;
 	bool in_ex_name = false;
 	bool in_ex_value = false;
 	bool in_attr = false;
 	bool in_value = false;
 	bool in_quote = false;
 	bool is_oid = false;
 	bool escape = false;
 	unsigned int x;
 	size_t l = 0;
 	int ret;
 	char *parse_dn;
 	bool is_index;
 
 	if ( ! dn || dn->invalid) return false;
 
 	if (dn->components) {
 		return true;
 	}
 
 	if (dn->ext_linearized) {
 		parse_dn = dn->ext_linearized;
 	} else {
 		parse_dn = dn->linearized;
 	}
 
 	if ( ! parse_dn ) {
 		return false;
 	}
 
 	is_index = (strncmp(parse_dn, ""DN=@INDEX:"", 10) == 0);
 
 	 
 	if (parse_dn[0] == '\0') {
 		return true;
 	}
 
 	 
 	if (dn->special) {
 		return true;
 	}
 
 	 
 	LDB_FREE(dn->components);
 	dn->comp_num = 0;
 
 	LDB_FREE(dn->ext_components);
 	dn->ext_comp_num = 0;
 
 	 
 	 
 	dn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);
 	if ( ! dn->components) {
 		return false;
 	}
 
 	 
 	data = talloc_array(dn->components, char, strlen(parse_dn) + 1);
 	if (!data) {
 		return false;
 	}
 
 	p = parse_dn;
 	t = NULL;
 	d = dt = data;
 
 	while (*p) {
 		if (in_extended) {
 
 			if (!in_ex_name && !in_ex_value) {
 
 				if (p[0] == '<') {
 					p++;
 					ex_name = d;
 					in_ex_name = true;
 					continue;
 				} else if (p[0] == '\0') {
 					p++;
 					continue;
 				} else {
 					in_extended = false;
 					in_attr = true;
 					dt = d;
 
 					continue;
 				}
 			}
 
 			if (in_ex_name && *p == '=') {
 				*d++ = '\0';
 				p++;
 				ex_value = d;
 				in_ex_name = false;
 				in_ex_value = true;
 				continue;
 			}
 
 			if (in_ex_value && *p == '>') {
 				const struct ldb_dn_extended_syntax *ext_syntax;
 				struct ldb_val ex_val = {
 					.data = (uint8_t *)ex_value,
 					.length = d - ex_value
 				};
 
 				*d++ = '\0';
 				p++;
 				in_ex_value = false;
 
 				 
 
 				dn->ext_components = talloc_realloc(dn,
 								    dn->ext_components,
 								    struct ldb_dn_ext_component,
 								    dn->ext_comp_num + 1);
 				if ( ! dn->ext_components) {
 					 
 					goto failed;
 				}
 
 				ext_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);
 				if (!ext_syntax) {
 					 
 					goto failed;
 				}
 
 				dn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);
 				if (!dn->ext_components[dn->ext_comp_num].name) {
 					 
 					goto failed;
 				}
 				ret = ext_syntax->read_fn(dn->ldb, dn->ext_components,
 							  &ex_val, &dn->ext_components[dn->ext_comp_num].value);
 				if (ret != LDB_SUCCESS) {
 					ldb_dn_mark_invalid(dn);
 					goto failed;
 				}
 
 				dn->ext_comp_num++;
 
 				if (*p == '\0') {
 					 
 					talloc_free(data);
 					return true;
 
 				} else if (*p == ';') {
 					p++;
 					continue;
 				} else {
 					ldb_dn_mark_invalid(dn);
 					goto failed;
 				}
 			}
 
 			*d++ = *p++;
 			continue;
 		}
 		if (in_attr) {
 			if (trim) {
 				if (*p == ' ') {
 					p++;
 					continue;
 				}
 
 				 
 				trim = false;
 
 				if (!isascii(*p)) {
 					 
 					ldb_dn_mark_invalid(dn);
 					goto failed;
 				}
 
 				if (isdigit(*p)) {
 					is_oid = true;
 				} else
 				if ( ! isalpha(*p)) {
 					 
 					ldb_dn_mark_invalid(dn);
 					goto failed;
 				}
 
 				 
 				*d++ = *p++;
 				continue;
 			}
 
 			if (*p == ' ') {
 				p++;
 				 
 				trim = true;
 				continue;
 			}
 
 			if (trim && (*p != '=')) {
 				 
 				ldb_dn_mark_invalid(dn);
 				goto failed;
 			}
 
 			if (*p == '=') {
 				 
 				in_attr = false;
 				in_value = true;
 				trim = true;
 				l = 0;
 
 				 
 				*d++ = '\0';
 				dn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);
 				if ( ! dn->components[dn->comp_num].name) {
 					 
 					goto failed;
 				}
 
 				dt = d;
 
 				p++;
 				continue;
 			}
 
 			if (!isascii(*p)) {
 				 
 				ldb_dn_mark_invalid(dn);
 				goto failed;
 			}
 
 			if (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {
 				 
 				ldb_dn_mark_invalid(dn);
 				goto failed;
 			} else
 			if ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {
 				 
 				ldb_dn_mark_invalid(dn);
 				goto failed;
 			}
 
 			*d++ = *p++;
 			continue;
 		}
 
 		if (in_value) {
 			if (in_quote) {
 				if (*p == '\""') {
 					if (p[-1] != '\\') {
 						p++;
 						in_quote = false;
 						continue;
 					}
 				}
 				*d++ = *p++;
 				l++;
 				continue;
 			}
 
 			if (trim) {
 				if (*p == ' ') {
 					p++;
 					continue;
 				}
 
 				 
 				trim = false;
 
 				if (*p == '\""') {
 					in_quote = true;
 					p++;
 					continue;
 				}
 			}
 
 			switch (*p) {
 
 			 
 
 			case ',':
 				if (escape) {
 					*d++ = *p++;
 					l++;
 					escape = false;
 					continue;
 				}
 				 
 
 				if ( t ) {
 					 
 					d -= (p - t);
 					l -= (p - t);
 				}
 
 				in_attr = true;
 				in_value = false;
 				trim = true;
  
                                 p++;
                                 *d++ = '\0';
                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);
                                dn->components[dn->comp_num].value.data = \
                                        (uint8_t *)talloc_memdup(dn->components, dt, l + 1);
                                 dn->components[dn->comp_num].value.length = l;
                                 if ( ! dn->components[dn->comp_num].value.data) {
                                          
                                         goto failed;
                                 }
                                talloc_set_name_const(dn->components[dn->comp_num].value.data,
                                                      (const char *)dn->components[dn->comp_num].value.data);
  
                                 dt = d;
  
 									dn->components,
 									struct ldb_dn_component,
 									dn->comp_num + 1);
 					if ( ! dn->components) {
 						 
 						goto failed;
 					}
 					 
 					memset(&dn->components[dn->comp_num], '\0', sizeof(struct ldb_dn_component));
 				}
 
 				continue;
 
 			case '+':
 			case '=':
 				 
 				if (is_index) {
 					if ( t ) t = NULL;
 					*d++ = *p++;
 					l++;
 					break;
 				}
 				 
 			case '\""':
 			case '<':
 			case '>':
 			case ';':
 				 
 				if ( ! escape) {
 					ldb_dn_mark_invalid(dn);
 					goto failed;
 				}
 				escape = false;
 
 				*d++ = *p++;
 				l++;
 
 				if ( t ) t = NULL;
 				break;
 
 			case '\\':
 				if ( ! escape) {
 					escape = true;
 					p++;
 					continue;
 				}
 				escape = false;
 
 				*d++ = *p++;
 				l++;
 
 				if ( t ) t = NULL;
 				break;
 
 			default:
 				if (escape) {
 					if (isxdigit(p[0]) && isxdigit(p[1])) {
 						if (sscanf(p, ""%02x"", &x) != 1) {
 							 
 							ldb_dn_mark_invalid(dn);
 							goto failed;
 						}
 						p += 2;
 						*d++ = (unsigned char)x;
 					} else {
 						*d++ = *p++;
 					}
 
 					escape = false;
 					l++;
 					if ( t ) t = NULL;
 					break;
 				}
 
 				if (*p == ' ') {
 					if ( ! t) t = p;
 				} else {
 					if ( t ) t = NULL;
 				}
 
 				*d++ = *p++;
 				l++;
 
 				break;
 			}
 
 		}
 	}","[302, 303, 309, 310, 301]","ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value."
198454," dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)
 	{
 	unsigned char wire[DTLS1_HM_HEADER_LENGTH];
 	unsigned long len, frag_off, frag_len;
         int i,al;
         struct hm_header_st msg_hdr;
  
        redo:
          
         if ((frag_len = dtls1_retrieve_buffered_fragment(s,max,ok)) || *ok)
                 {
 		return frag_len;
 		}
 
 	 
 	i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,wire,
 		DTLS1_HM_HEADER_LENGTH, 0);
 	if (i <= 0) 	 
 		{
 		s->rwstate=SSL_READING;
 		*ok = 0;
 		return i;
 		}
 	 
 	if (i != DTLS1_HM_HEADER_LENGTH)
 		{
 		al=SSL_AD_UNEXPECTED_MESSAGE;
 		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);
 		goto f_err;
 		}
 
 	 
 	dtls1_get_message_header(wire, &msg_hdr);
 
 	 
 	if (msg_hdr.seq != s->d1->handshake_read_seq && !(s->d1->listen && msg_hdr.seq == 1))
 		return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
 
 	len = msg_hdr.msg_len;
 	frag_off = msg_hdr.frag_off;
 	frag_len = msg_hdr.frag_len;
 
 	if (frag_len && frag_len < len)
 		return dtls1_reassemble_fragment(s, &msg_hdr, ok);
 
 	if (!s->server && s->d1->r_msg_hdr.frag_off == 0 &&
 		wire[0] == SSL3_MT_HELLO_REQUEST)
 		{
 		 
 		if (wire[1] == 0 && wire[2] == 0 && wire[3] == 0)
 			{
 			if (s->msg_callback)
 				s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, 
 					wire, DTLS1_HM_HEADER_LENGTH, s, 
 					s->msg_callback_arg);
                                         s->msg_callback_arg);
                         
                         s->init_num = 0;
                       return dtls1_get_message_fragment(s, st1, stn,
                               max, ok);
                        goto redo;
                         }
                 else  
                         {
 			al=SSL_AD_UNEXPECTED_MESSAGE;
 			SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);
 			goto f_err;
 			}
 		}
 
 	if ((al=dtls1_preprocess_fragment(s,&msg_hdr,max)))
 		goto f_err;
 
 	 
 	s->state=stn;
 
 	if ( frag_len > 0)
 		{
 		unsigned char *p=(unsigned char *)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;
 
 		i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
 			&p[frag_off],frag_len,0);
 		 
 		if (i <= 0)
 			{
 			s->rwstate=SSL_READING;
 			*ok = 0;
 			return i;
 			}
 		}
 	else
 		i = 0;
 
 	 
 	if (i != (int)frag_len)
 		{
 		al=SSL3_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL3_AD_ILLEGAL_PARAMETER);
 		goto f_err;
 		}
 
 	*ok = 1;
 
 	 
 	s->init_num = frag_len;
 	return frag_len;
 
 f_err:
 	ssl3_send_alert(s,SSL3_AL_FATAL,al);
 	s->init_num = 0;
 
 	*ok=0;
 	return(-1);
 	}","[8, 61, 59, 60]","The dtls1_get_message_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (recursion and client crash) via a DTLS hello message in an invalid DTLS handshake."
8963,"static pyc_object *get_list_object(RBuffer *buffer) {
pyc_object *ret = NULL;
bool error = false;
ut32 n = 0;

n = get_ut32 (buffer, &error);
if (n > ST32_MAX) {
eprintf (""bad marshal data (list size out of range)\n"");
return NULL;
}
if (error) {
return NULL;
}
ret = get_array_object_generic (buffer, n);
if (ret) {
ret->type = TYPE_LIST;
return ret;
}
return NULL;
}","[4, 6]",Expired Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.2.
200048," PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)
 {
 	TIFFPredictorState *sp = PredictorState(tif);
 
 	assert(sp != NULL);
 	assert(sp->decoderow != NULL);
  	assert(sp->decodepfunc != NULL);  
  
  	if ((*sp->decoderow)(tif, op0, occ0, s)) {
		(*sp->decodepfunc)(tif, op0, occ0);
		return 1;
 		return (*sp->decodepfunc)(tif, op0, occ0);
  	} else
  		return 0;
  }","[12, 10, 11]","tif_predict.h and tif_predict.c in libtiff 4.0.6 have assertions that can lead to assertion failures in debug mode, or buffer overflows in release mode, when dealing with unusual tile size like YCbCr with subsampling. Reported as MSVR 35105, aka *Predictor heap-buffer-overflow.*"
202745," pdf_t *pdf_new(const char *name)
 {
      const char *n;
      pdf_t      *pdf;
     
    pdf = calloc(1, sizeof(pdf_t));
     pdf = safe_calloc(sizeof(pdf_t));
  
      if (name)
      {
          
         if ((n = strrchr(name, '/')))
           ++n;
          else
            n = name;
  
        pdf->name = malloc(strlen(n) + 1);
         pdf->name = safe_calloc(strlen(n) + 1);
          strcpy(pdf->name, n);
      }
      else  
      {
        pdf->name = malloc(strlen(""Unknown"") + 1);
         pdf->name = safe_calloc(strlen(""Unknown"") + 1);
          strcpy(pdf->name, ""Unknown"");
      }
  
     return pdf;
 }","[7, 18, 24, 6, 17, 23]","An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write."
198736," void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,
  		   unsigned int len)
  {
  	struct inet_sock *inet = inet_sk(sk);
	struct {
		struct ip_options	opt;
		char			data[40];
	} replyopts;
 	struct ip_options_data replyopts;
  	struct ipcm_cookie ipc;
  	__be32 daddr;
  	struct rtable *rt = skb_rtable(skb);
  
	if (ip_options_echo(&replyopts.opt, skb))
 	if (ip_options_echo(&replyopts.opt.opt, skb))
  		return;
  
  	daddr = ipc.addr = rt->rt_src;
  	ipc.opt = NULL;
  	ipc.tx_flags = 0;
  
	if (replyopts.opt.optlen) {
 	if (replyopts.opt.opt.optlen) {
  		ipc.opt = &replyopts.opt;
  
		if (ipc.opt->srr)
			daddr = replyopts.opt.faddr;
 		if (replyopts.opt.opt.srr)
 			daddr = replyopts.opt.opt.faddr;
  	}
  
  	{
 		struct flowi4 fl4;
 
 		flowi4_init_output(&fl4, arg->bound_dev_if, 0,
 				   RT_TOS(ip_hdr(skb)->tos),
 				   RT_SCOPE_UNIVERSE, sk->sk_protocol,
 				   ip_reply_arg_flowi_flags(arg),
 				   daddr, rt->rt_spec_dst,
 				   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);
 		security_skb_classify_flow(skb, flowi4_to_flowi(&fl4));
 		rt = ip_route_output_key(sock_net(sk), &fl4);
 		if (IS_ERR(rt))
 			return;
 	}
 
 	 
 	bh_lock_sock(sk);
 	inet->tos = ip_hdr(skb)->tos;
 	sk->sk_priority = skb->priority;
 	sk->sk_protocol = ip_hdr(skb)->protocol;
 	sk->sk_bound_dev_if = arg->bound_dev_if;
 	ip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,
 		       &ipc, &rt, MSG_DONTWAIT);
 	if ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {
 		if (arg->csumoffset >= 0)
 			*((__sum16 *)skb_transport_header(skb) +
 			  arg->csumoffset) = csum_fold(csum_add(skb->csum,
 								arg->csum));
 		skb->ip_summed = CHECKSUM_NONE;
 		ip_push_pending_frames(sk);
 	}
 
 	bh_unlock_sock(sk);
 
 	ip_rt_put(rt);
 }","[9, 15, 23, 28, 29, 5, 6, 7, 8, 14, 22, 26, 27]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
203329," _rsvg_io_get_file_path (const gchar * filename,
                         const gchar * base_uri)
  {
      gchar *absolute_filename;
  
    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {
     if (g_path_is_absolute (filename)) {
          absolute_filename = g_strdup (filename);
      } else {
          gchar *tmpcdir;
         gchar *base_filename;
 
         if (base_uri) {
             base_filename = g_filename_from_uri (base_uri, NULL, NULL);
             if (base_filename != NULL) {
                 tmpcdir = g_path_get_dirname (base_filename);
                 g_free (base_filename);
             } else 
                 return NULL;
         } else
             tmpcdir = g_get_current_dir ();
 
         absolute_filename = g_build_filename (tmpcdir, filename, NULL);
         g_free (tmpcdir);
     }
 
     return absolute_filename;
 }","[7, 6]",GNOME librsvg version before commit c6ddf2ed4d768fd88adbea2b63f575cd523022ea contains a Improper input validation vulnerability in rsvg-io.c that can result in the victim's Windows username and NTLM password hash being leaked to remote attackers through SMB. This attack appear to be exploitable via The victim must process a specially crafted SVG file containing an UNC path on Windows.
206662," IDNSpoofChecker::IDNSpoofChecker() {
   UErrorCode status = U_ZERO_ERROR;
   checker_ = uspoof_open(&status);
   if (U_FAILURE(status)) {
     checker_ = nullptr;
     return;
   }
 
 
   uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);
 
   SetAllowedUnicodeSet(&status);
 
   int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;
   uspoof_setChecks(checker_, checks, &status);
 
   deviation_characters_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u00df\\u03c2\\u200c\\u200d]""), status);
   deviation_characters_.freeze();
 
   non_ascii_latin_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Latin:] - [a-zA-Z]]""), status);
   non_ascii_latin_letters_.freeze();
 
   kana_letters_exceptions_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u3078-\\u307a\\u30d8-\\u30da\\u30fb-\\u30fe]""),
       status);
   kana_letters_exceptions_.freeze();
   combining_diacritics_exceptions_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[\\u0300-\\u0339]""), status);
   combining_diacritics_exceptions_.freeze();
 
   cyrillic_letters_latin_alike_ =
       icu::UnicodeSet(icu::UnicodeString(""[асԁеһіјӏорԛѕԝхуъЬҽпгѵѡ]""), status);
   cyrillic_letters_latin_alike_.freeze();
 
   cyrillic_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Cyrl:]]""), status);
   cyrillic_letters_.freeze();
 
   DCHECK(U_SUCCESS(status));
   lgc_letters_n_ascii_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[[:Latin:][:Greek:][:Cyrillic:][0-9\\u002e_""
                             ""\\u002d][\\u0300-\\u0339]]""),
       status);
   lgc_letters_n_ascii_.freeze();
  
    
    UParseError parse_error;
  transliterator_.reset(icu::Transliterator::createFromRules(
   diacritic_remover_.reset(icu::Transliterator::createFromRules(
        UNICODE_STRING_SIMPLE(""DropAcc""),
        icu::UnicodeString(""::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;""
                         "" ł > l; ø > o; đ > d; ӏ > l; [кĸκ] > k; п > n;""),
                          "" ł > l; ø > o; đ > d;""),
       UTRANS_FORWARD, parse_error, status));
 
    
    
    
    
    
    
    
    
    
    
    
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString(
           ""ӏ > l; [кĸκ] > k; п > n; [ƅь] > b; в > b; м > m; н > h; ""
           ""т > t; [шщ] > w; ട > s;""),
        UTRANS_FORWARD, parse_error, status));
    DCHECK(U_SUCCESS(status))
        << ""Spoofchecker initalization failed due to an error: ""
       << u_errorName(status);
 }","[48, 51, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 50, 54]",Incorrect security UI in Omnibox in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
204048," EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
     if (!thisValue.inherits(&JSTestObj::s_info))
         return throwVMTypeError(exec);
     JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));
      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
      TestObj* impl = static_cast<TestObj*>(castedThis->impl());
      if (exec->argumentCount() < 2)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      ExceptionCode ec = 0;
      const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
      if (exec->hadException())
         return JSValue::encode(jsUndefined());
     TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
 
     JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec)));
     setDOMException(exec, ec);
     return JSValue::encode(result);
 }","[11, 10]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
203313," USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const
  {
      USHORT Res;
      auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),
                                       GetDataLength(), __FUNCTION__);
                                        GetDataLength(), FALSE, __FUNCTION__);
      if (ppr.ipStatus != ppresNotIP)
      {
          Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);
     }
     else
     {
         DPrintf(0, (""[%s] ERROR: NOT an IP packet - expected troubles!\n"", __FUNCTION__));
         Res = 0;
     }
     return Res;
 }","[6, 5]","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options."
201554," _handle_carbons(xmpp_stanza_t *const stanza)
 {
     xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);
     if (!carbons) {
         return FALSE;
     }
 
     const char *name = xmpp_stanza_get_name(carbons);
     if (!name) {
         log_error(""Unable to retrieve stanza name for Carbon"");
         return TRUE;
     }
 
     if (g_strcmp0(name, ""private"") == 0) {
         log_info(""Carbon received with private element."");
         return FALSE;
     }
 
     if ((g_strcmp0(name, ""received"") != 0) && (g_strcmp0(name, ""sent"") != 0)) {
         log_warning(""Carbon received with unrecognised stanza name: %s"", name);
         return TRUE;
     }
 
     xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);
     if (!forwarded) {
         log_warning(""Carbon received with no forwarded element"");
         return TRUE;
     }
 
     xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);
     if (!message) {
         log_warning(""Carbon received with no message element"");
         return TRUE;
     }
 
     char *message_txt = xmpp_message_get_body(message);
     if (!message_txt) {
         log_warning(""Carbon received with no message."");
          return TRUE;
      }
  
     Jid *my_jid = jid_create(connection_get_fulljid());
     const char *const stanza_from = xmpp_stanza_get_from(stanza);
     Jid *msg_jid = jid_create(stanza_from);
     if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {
         log_warning(""Invalid carbon received, from: %s"", stanza_from);
         return TRUE;
     }
 
      const gchar *to = xmpp_stanza_get_to(message);
      const gchar *from = xmpp_stanza_get_from(message);
  
     if (!to) to = from;
  
      Jid *jid_from = jid_create(from);
      Jid *jid_to = jid_create(to);
    Jid *my_jid = jid_create(connection_get_fulljid());
  
      char *enc_message = NULL;
     xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);
     if (x) {
         enc_message = xmpp_stanza_get_text(x);
     }
 
     if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {
         sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);
 
     } else {
         sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);
     }
 
     xmpp_ctx_t *ctx = connection_get_ctx();
     xmpp_free(ctx, message_txt);
     xmpp_free(ctx, enc_message);
 
     jid_destroy(jid_from);
     jid_destroy(jid_to);
     jid_destroy(my_jid);
 
     return TRUE;
 }","[42, 43, 44, 45, 46, 47, 48, 49, 57]","An incorrect implementation of *XEP-0280: Message Carbons* in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0)."
205548,"  void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)
  {
      ASSERT(m_form);
    if (toHTMLElement(this)->highestAncestor() != formRoot)
        setForm(0);
     if (toHTMLElement(this)->highestAncestor() == formRoot)
         return;
     RefPtr<HTMLElement> protector(toHTMLElement(this));
     setForm(0);
  }","[6, 7, 8, 9, 4, 5]",The OneClickSigninBubbleView::WindowClosing function in browser/ui/views/sync/one_click_signin_bubble_view.cc in Google Chrome before 32.0.1700.76 on Windows and before 32.0.1700.77 on Mac OS X and Linux allows attackers to trigger a sync with an arbitrary Google account by leveraging improper handling of the closing of an untrusted signin confirm dialog.
206332," void RequestSender::OnNetworkFetcherComplete(
     const GURL& original_url,
     std::unique_ptr<std::string> response_body,
     int net_error,
     const std::string& header_etag,
     int64_t xheader_retry_after_sec) {
   DCHECK(thread_checker_.CalledOnValidThread());
 
    VLOG(1) << ""request completed from url: "" << original_url.spec();
  
    int error = -1;
  if (response_body && response_code_ == 200) {
    DCHECK_EQ(0, net_error);
   if (!net_error && response_code_ == 200)
      error = 0;
  } else if (response_code_ != -1) {
   else if (response_code_ != -1)
      error = response_code_;
  } else {
   else
      error = net_error;
  }
  
    int retry_after_sec = -1;
    if (original_url.SchemeIsCryptographic() && error > 0)
     retry_after_sec = base::saturated_cast<int>(xheader_retry_after_sec);
 
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE, base::BindOnce(&RequestSender::SendInternalComplete,
                                 base::Unretained(this), error,
                                 response_body ? *response_body : std::string(),
                                 header_etag, retry_after_sec));
 }","[14, 17, 20, 12, 13, 16, 19, 22]","Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 59.0.3071.86 for Mac, Windows, and Linux, and 59.0.3071.92 for Android, allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
202137," static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
  {
  	struct crypto_report_cipher rcipher;
  
	strlcpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
  
  	rcipher.blocksize = alg->cra_blocksize;
  	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
 	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
 		    sizeof(struct crypto_report_cipher), &rcipher))
 		goto nla_put_failure;
 	return 0;
 
 nla_put_failure:
 	return -EMSGSIZE;
 }","[6, 5]","An issue was discovered in the Linux kernel before 4.19.3. crypto_report_one() and related functions in crypto/crypto_user.c (the crypto user configuration API) do not fully initialize structures that are copied to userspace, potentially leaking sensitive memory to user programs. NOTE: this is a CVE-2013-2547 regression but with easier exploitability because the attacker does not need a capability (however, the system must have the CONFIG_CRYPTO_USER kconfig option)."
203252," void Com_WriteConfig_f( void ) {
 	char filename[MAX_QPATH];
 
 	if ( Cmd_Argc() != 2 ) {
 		Com_Printf( ""Usage: writeconfig <filename>\n"" );
  		return;
  	}
  
 	if (!COM_CompareExtension(filename, "".cfg""))
 	{
 		Com_Printf(""Com_WriteConfig_f: Only the \"".cfg\"" extension is supported by this command!\n"");
 		return;
 	}
 
  	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
  	COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" );
  	Com_Printf( ""Writing %s.\n"", filename );
 	Com_WriteConfigToFile( filename );
 }","[9, 10, 11, 12, 13, 14]","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
200913," sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
 {
 	void __user *p = (void __user *)arg;
 	int __user *ip = p;
 	int result, val, read_only;
 	Sg_device *sdp;
 	Sg_fd *sfp;
 	Sg_request *srp;
 	unsigned long iflags;
 
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
 				   ""sg_ioctl: cmd=0x%x\n"", (int) cmd_in));
 	read_only = (O_RDWR != (filp->f_flags & O_ACCMODE));
 
 	switch (cmd_in) {
 	case SG_IO:
 		if (atomic_read(&sdp->detaching))
 			return -ENODEV;
 		if (!scsi_block_when_processing_errors(sdp->device))
 			return -ENXIO;
 		if (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR))
 			return -EFAULT;
 		result = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR,
 				 1, read_only, 1, &srp);
 		if (result < 0)
 			return result;
 		result = wait_event_interruptible(sfp->read_wait,
 			(srp_done(sfp, srp) || atomic_read(&sdp->detaching)));
 		if (atomic_read(&sdp->detaching))
 			return -ENODEV;
 		write_lock_irq(&sfp->rq_list_lock);
 		if (srp->done) {
 			srp->done = 2;
 			write_unlock_irq(&sfp->rq_list_lock);
 			result = sg_new_read(sfp, p, SZ_SG_IO_HDR, srp);
 			return (result < 0) ? result : 0;
 		}
 		srp->orphan = 1;
 		write_unlock_irq(&sfp->rq_list_lock);
 		return result;	 
 	case SG_SET_TIMEOUT:
 		result = get_user(val, ip);
 		if (result)
 			return result;
 		if (val < 0)
 			return -EIO;
 		if (val >= mult_frac((s64)INT_MAX, USER_HZ, HZ))
 			val = min_t(s64, mult_frac((s64)INT_MAX, USER_HZ, HZ),
 				    INT_MAX);
 		sfp->timeout_user = val;
 		sfp->timeout = mult_frac(val, HZ, USER_HZ);
 
 		return 0;
 	case SG_GET_TIMEOUT:	 
 				 
 		return sfp->timeout_user;
 	case SG_SET_FORCE_LOW_DMA:
 		 
 		return 0;
 	case SG_GET_LOW_DMA:
 		return put_user((int) sdp->device->host->unchecked_isa_dma, ip);
 	case SG_GET_SCSI_ID:
 		if (!access_ok(VERIFY_WRITE, p, sizeof (sg_scsi_id_t)))
 			return -EFAULT;
 		else {
 			sg_scsi_id_t __user *sg_idp = p;
 
 			if (atomic_read(&sdp->detaching))
 				return -ENODEV;
 			__put_user((int) sdp->device->host->host_no,
 				   &sg_idp->host_no);
 			__put_user((int) sdp->device->channel,
 				   &sg_idp->channel);
 			__put_user((int) sdp->device->id, &sg_idp->scsi_id);
 			__put_user((int) sdp->device->lun, &sg_idp->lun);
 			__put_user((int) sdp->device->type, &sg_idp->scsi_type);
 			__put_user((short) sdp->device->host->cmd_per_lun,
 				   &sg_idp->h_cmd_per_lun);
 			__put_user((short) sdp->device->queue_depth,
 				   &sg_idp->d_queue_depth);
 			__put_user(0, &sg_idp->unused[0]);
 			__put_user(0, &sg_idp->unused[1]);
 			return 0;
 		}
 	case SG_SET_FORCE_PACK_ID:
 		result = get_user(val, ip);
 		if (result)
 			return result;
 		sfp->force_packid = val ? 1 : 0;
 		return 0;
 	case SG_GET_PACK_ID:
 		if (!access_ok(VERIFY_WRITE, ip, sizeof (int)))
 			return -EFAULT;
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
 		list_for_each_entry(srp, &sfp->rq_list, entry) {
 			if ((1 == srp->done) && (!srp->sg_io_owned)) {
 				read_unlock_irqrestore(&sfp->rq_list_lock,
 						       iflags);
 				__put_user(srp->header.pack_id, ip);
 				return 0;
 			}
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		__put_user(-1, ip);
 		return 0;
 	case SG_GET_NUM_WAITING:
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
 		val = 0;
 		list_for_each_entry(srp, &sfp->rq_list, entry) {
 			if ((1 == srp->done) && (!srp->sg_io_owned))
 				++val;
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		return put_user(val, ip);
 	case SG_GET_SG_TABLESIZE:
 		return put_user(sdp->sg_tablesize, ip);
 	case SG_SET_RESERVED_SIZE:
 		result = get_user(val, ip);
 		if (result)
 			return result;
                 if (val < 0)
                         return -EINVAL;
 		val = min_t(int, val,
 			    max_sectors_bytes(sdp->device->request_queue));
 		mutex_lock(&sfp->f_mutex);
 		if (val != sfp->reserve.bufflen) {
 			if (sfp->mmap_called ||
 			    sfp->res_in_use) {
 				mutex_unlock(&sfp->f_mutex);
 				return -EBUSY;
 			}
 
 			sg_remove_scat(sfp, &sfp->reserve);
 			sg_build_reserve(sfp, val);
 		}
 		mutex_unlock(&sfp->f_mutex);
 		return 0;
 	case SG_GET_RESERVED_SIZE:
 		val = min_t(int, sfp->reserve.bufflen,
 			    max_sectors_bytes(sdp->device->request_queue));
 		return put_user(val, ip);
 	case SG_SET_COMMAND_Q:
 		result = get_user(val, ip);
 		if (result)
 			return result;
 		sfp->cmd_q = val ? 1 : 0;
 		return 0;
 	case SG_GET_COMMAND_Q:
 		return put_user((int) sfp->cmd_q, ip);
 	case SG_SET_KEEP_ORPHAN:
 		result = get_user(val, ip);
 		if (result)
 			return result;
 		sfp->keep_orphan = val;
 		return 0;
 	case SG_GET_KEEP_ORPHAN:
 		return put_user((int) sfp->keep_orphan, ip);
 	case SG_NEXT_CMD_LEN:
 		result = get_user(val, ip);
 		if (result)
 			return result;
 		if (val > SG_MAX_CDB_SIZE)
 			return -ENOMEM;
 		sfp->next_cmd_len = (val > 0) ? val : 0;
 		return 0;
 	case SG_GET_VERSION_NUM:
 		return put_user(sg_version_num, ip);
 	case SG_GET_ACCESS_COUNT:
 		 
 		val = (sdp->device ? 1 : 0);
 		return put_user(val, ip);
 	case SG_GET_REQUEST_TABLE:
 		if (!access_ok(VERIFY_WRITE, p, SZ_SG_REQ_INFO * SG_MAX_QUEUE))
 			return -EFAULT;
  		else {
  			sg_req_info_t *rinfo;
  
			rinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,
								GFP_KERNEL);
 			rinfo = kzalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,
 					GFP_KERNEL);
  			if (!rinfo)
  				return -ENOMEM;
  			read_lock_irqsave(&sfp->rq_list_lock, iflags);
 			sg_fill_request_table(sfp, rinfo);
 			read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 			result = __copy_to_user(p, rinfo,
 						SZ_SG_REQ_INFO * SG_MAX_QUEUE);
 			result = result ? -EFAULT : 0;
 			kfree(rinfo);
 			return result;
 		}
 	case SG_EMULATED_HOST:
 		if (atomic_read(&sdp->detaching))
 			return -ENODEV;
 		return put_user(sdp->device->host->hostt->emulated, ip);
 	case SCSI_IOCTL_SEND_COMMAND:
 		if (atomic_read(&sdp->detaching))
 			return -ENODEV;
 		if (read_only) {
 			unsigned char opcode = WRITE_6;
 			Scsi_Ioctl_Command __user *siocp = p;
 
 			if (copy_from_user(&opcode, siocp->data, 1))
 				return -EFAULT;
 			if (sg_allow_access(filp, &opcode))
 				return -EPERM;
 		}
 		return sg_scsi_ioctl(sdp->device->request_queue, NULL, filp->f_mode, p);
 	case SG_SET_DEBUG:
 		result = get_user(val, ip);
 		if (result)
 			return result;
 		sdp->sgdebug = (char) val;
 		return 0;
 	case BLKSECTGET:
 		return put_user(max_sectors_bytes(sdp->device->request_queue),
 				ip);
 	case BLKTRACESETUP:
 		return blk_trace_setup(sdp->device->request_queue,
 				       sdp->disk->disk_name,
 				       MKDEV(SCSI_GENERIC_MAJOR, sdp->index),
 				       NULL, p);
 	case BLKTRACESTART:
 		return blk_trace_startstop(sdp->device->request_queue, 1);
 	case BLKTRACESTOP:
 		return blk_trace_startstop(sdp->device->request_queue, 0);
 	case BLKTRACETEARDOWN:
 		return blk_trace_remove(sdp->device->request_queue);
 	case SCSI_IOCTL_GET_IDLUN:
 	case SCSI_IOCTL_GET_BUS_NUMBER:
 	case SCSI_IOCTL_PROBE_HOST:
 	case SG_GET_TRANSFORM:
 	case SG_SCSI_RESET:
 		if (atomic_read(&sdp->detaching))
 			return -ENODEV;
 		break;
 	default:
 		if (read_only)
 			return -EPERM;	 
 		break;
 	}
 
 	result = scsi_ioctl_block_when_processing_errors(sdp->device,
 			cmd_in, filp->f_flags & O_NDELAY);
 	if (result)
 		return result;
 	return scsi_ioctl(sdp->device, cmd_in, p);
 }","[183, 184, 181, 182]",The sg_ioctl function in drivers/scsi/sg.c in the Linux kernel before 4.13.4 allows local users to obtain sensitive information from uninitialized kernel heap-memory locations via an SG_GET_REQUEST_TABLE ioctl call for /dev/sg0.
198112," static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
                       X509 **pissuer, int *pscore, unsigned int *preasons,
                       STACK_OF(X509_CRL) *crls)
 {
     int i, crl_score, best_score = *pscore;
     unsigned int reasons, best_reasons = 0;
     X509 *x = ctx->current_cert;
     X509_CRL *crl, *best_crl = NULL;
     X509 *crl_issuer = NULL, *best_crl_issuer = NULL;
 
     for (i = 0; i < sk_X509_CRL_num(crls); i++) {
          crl = sk_X509_CRL_value(crls, i);
          reasons = *preasons;
          crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);
        if (crl_score < best_score)
         if (crl_score < best_score || crl_score == 0)
              continue;
           
        if (crl_score == best_score) {
         if (crl_score == best_score && best_crl != NULL) {
              int day, sec;
              if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),
                                 X509_CRL_get_lastUpdate(crl)) == 0)
                 continue;
              
             if (day <= 0 && sec <= 0)
                 continue;
         }
         best_crl = crl;
         best_crl_issuer = crl_issuer;
         best_score = crl_score;
         best_reasons = reasons;
     }
 
     if (best_crl) {
         if (*pcrl)
             X509_CRL_free(*pcrl);
         *pcrl = best_crl;
         *pissuer = best_crl_issuer;
         *pscore = best_score;
         *preasons = best_reasons;
         CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
         if (*pdcrl) {
             X509_CRL_free(*pdcrl);
             *pdcrl = NULL;
         }
         get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
     }
 
     if (best_score >= CRL_SCORE_VALID)
         return 1;
 
     return 0;
 }","[16, 20, 15, 19]",crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation.
7689,"testHuf (const std::string&)
{
try
{
cout << ""Testing Huffman encoder"" << endl;

IMATH_NAMESPACE::Rand48 rand48 (0);

const int N = 1000000;
Array <unsigned short> raw (N);

fill1 (raw, N, 1, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill1 (raw, N, 10, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill1 (raw, N, 100, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill1 (raw, N, 1000, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);

fill2 (raw, N, 1, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill2 (raw, N, 10, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill2 (raw, N, 100, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill2 (raw, N, 1000, rand48);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);

fill3 (raw, N, 0);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill3 (raw, N, 1);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill3 (raw, N, USHRT_MAX - 1);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);
fill3 (raw, N, USHRT_MAX);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);

fill4 (raw, USHRT_MAX + 1);
compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);
compressUncompress (raw, USHRT_MAX + 1);
compressUncompressSubset (raw, USHRT_MAX + 1);
fill4 (raw, N);
compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);

fill4 (raw, 0);
compressUncompress (raw, 0);
fill4 (raw, 1);
compressUncompress (raw, 1);
fill4 (raw, 2);
compressUncompress (raw, 2);
fill4 (raw, 3);
compressUncompress (raw, 3);

fill5 (raw, N);
compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);
compressUncompress (raw, N);
compressUncompressSubset (raw, N);

cout << ""ok\n"" << endl;
}
catch (const std::exception &e)
{
cerr << ""ERROR -- caught exception: "" << e.what() << endl;
assert (false);
}
}","[9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 72]","A flaw was found in OpenEXR's hufDecode functionality. This flaw allows an attacker who can pass a crafted file to be processed by OpenEXR, to trigger an undefined right shift error. The highest threat from this vulnerability is to system availability."
4350,"void RemoteFsDevice::unmount()
{
if (details.isLocalFile()) {
return;
}

if (!isConnected() || proc) {
return;
}

if (messageSent) {
return;
}
if (constSambaProtocol==details.url.scheme() || constSambaAvahiProtocol==details.url.scheme()) {
mounter()->umount(mountPoint(details, false), getpid());
setStatusMessage(tr(""Disconnecting...""));
messageSent=true;
return;
}

QString cmd;
QStringList args;
if (!details.isLocalFile()) {
QString mp=mountPoint(details, false);
if (!mp.isEmpty()) {
cmd=Utils::findExe(""fusermount"");
if (!cmd.isEmpty()) {
args << QLatin1String(""-u"") << QLatin1String(""-z"") << mp;
} else {
emit error(tr(""\""fusermount\"" is not installed!""));
}
}
}

if (!cmd.isEmpty()) {
setStatusMessage(tr(""Disconnecting...""));
proc=new QProcess(this);
proc->setProperty(""unmount"", true);
connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));
proc->start(cmd, args, QIODevice::ReadOnly);
}
}","[14, 15, 16, 17, 18]","An issue was discovered in the cantata-mounter D-Bus service in Cantata through 2.3.1. The mount target path check in mounter.cpp `mpOk()` is insufficient. A regular user can consequently mount a CIFS filesystem anywhere (e.g., outside of the /home directory tree) by passing directory traversal sequences such as a home/../usr substring."
207423," void SoftMPEG4::onQueueFilled(OMX_U32  ) {
  if (mSignalledError || mOutputPortSettingsChange != NONE) {
  return;
  }
 
  List<BufferInfo *> &inQueue = getPortQueue(0);
  List<BufferInfo *> &outQueue = getPortQueue(1);
 
  while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
  BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
  if (inHeader == NULL) {
             inQueue.erase(inQueue.begin());
             inInfo->mOwnedByUs = false;
  continue;
  }
 
  PortInfo *port = editPortInfo(1);
 
         OMX_BUFFERHEADERTYPE *outHeader =
             port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;
 
  if (inHeader->nFilledLen == 0) {
             inQueue.erase(inQueue.begin());
             inInfo->mOwnedByUs = false;
             notifyEmptyBufferDone(inHeader);
 
  ++mInputBufferCount;
 
  if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                 outHeader->nFilledLen = 0;
                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 
  List<BufferInfo *>::iterator it = outQueue.begin();
  while ((*it)->mHeader != outHeader) {
  ++it;
  }
 
  BufferInfo *outInfo = *it;
                 outInfo->mOwnedByUs = false;
                 outQueue.erase(it);
                 outInfo = NULL;
 
                 notifyFillBufferDone(outHeader);
                 outHeader = NULL;
  }
  return;
  }
 
  uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
  uint32_t *start_code = (uint32_t *)bitstream;
  bool volHeader = *start_code == 0xB0010000;
  if (volHeader) {
  PVCleanUpVideoDecoder(mHandle);
             mInitialized = false;
  }
 
  if (!mInitialized) {
  uint8_t *vol_data[1];
  int32_t vol_size = 0;
 
             vol_data[0] = NULL;
 
  if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                 vol_data[0] = bitstream;
                 vol_size = inHeader->nFilledLen;
  }
 
             MP4DecodingMode mode =
  (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;
 
  Bool success = PVInitVideoDecoder(
                     mHandle, vol_data, &vol_size, 1,
                     outputBufferWidth(), outputBufferHeight(), mode);
 
  if (!success) {
                 ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");
 
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
  return;
  }
 
             MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
  if (mode != actualMode) {
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
  return;
  }
 
  PVSetPostProcType((VideoDecControls *) mHandle, 0);
 
  bool hasFrameData = false;
  if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                 inInfo->mOwnedByUs = false;
                 inQueue.erase(inQueue.begin());
                 inInfo = NULL;
                 notifyEmptyBufferDone(inHeader);
                 inHeader = NULL;
  } else if (volHeader) {
                 hasFrameData = true;
  }
 
             mInitialized = true;
 
  if (mode == MPEG4_MODE && handlePortSettingsChange()) {
  return;
  }
 
  if (!hasFrameData) {
  continue;
  }
  }
 
  if (!mFramesConfigured) {
 
              PortInfo *port = editPortInfo(1);
              OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;
  
             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                 ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                         outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
                 return;
             }
              PVSetReferenceYUV(mHandle, outHeader->pBuffer);
              mFramesConfigured = true;
          }
  
  uint32_t useExtTimestamp = (inHeader->nOffset == 0);
 
  uint32_t timestamp = 0xFFFFFFFF;
  if (useExtTimestamp) {
             mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
             timestamp = mPvTime;
             mPvTime++;
  }
 
 
          int32_t bufferSize = inHeader->nFilledLen;
          int32_t tmp = bufferSize;
  
        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;
         OMX_U32 frameSize;
         OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
         if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
             ALOGE(""Frame size too large"");
             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
             mSignalledError = true;
             return;
         }
         frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));
 
          if (outHeader->nAllocLen < frameSize) {
              android_errorWriteLog(0x534e4554, ""27833616"");
              ALOGE(""Insufficient output buffer size"");
             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
             mSignalledError = true;
  return;
  }
  if (PVDecodeVideoFrame(
                     mHandle, &bitstream, &timestamp, &tmp,
  &useExtTimestamp,
                     outHeader->pBuffer) != PV_TRUE) {
             ALOGE(""failed to decode video frame."");
 
             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
             mSignalledError = true;
  return;
  }
 
  if (handlePortSettingsChange()) {
  return;
  }
 
         outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
         mPvToOmxTimeMap.removeItem(timestamp);
 
         inHeader->nOffset += bufferSize;
         inHeader->nFilledLen = 0;
  if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
             outHeader->nFlags = OMX_BUFFERFLAG_EOS;
  } else {
             outHeader->nFlags = 0;
  }
 
  if (inHeader->nFilledLen == 0) {
             inInfo->mOwnedByUs = false;
             inQueue.erase(inQueue.begin());
             inInfo = NULL;
             notifyEmptyBufferDone(inHeader);
             inHeader = NULL;
  }
 
  ++mInputBufferCount;
 
         outHeader->nOffset = 0;
         outHeader->nFilledLen = frameSize;
 
  List<BufferInfo *>::iterator it = outQueue.begin();
  while ((*it)->mHeader != outHeader) {
  ++it;
  }
 
  BufferInfo *outInfo = *it;
         outInfo->mOwnedByUs = false;
         outQueue.erase(it);
         outInfo = NULL;
 
         notifyFillBufferDone(outHeader);
         outHeader = NULL;
 
  ++mNumSamplesOutput;
  }
 }","[120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 147]","The SoftMPEG4 component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30033990."
202305," enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)
 {
   char q_user[SHORT_STRING], q_pass[SHORT_STRING];
   char buf[STRING];
   int rc;
 
   if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))
   {
     mutt_message(_(""LOGIN disabled on this server.""));
     return IMAP_AUTH_UNAVAIL;
   }
 
   if (mutt_account_getuser(&idata->conn->account) < 0)
     return IMAP_AUTH_FAILURE;
   if (mutt_account_getpass(&idata->conn->account) < 0)
     return IMAP_AUTH_FAILURE;
  
    mutt_message(_(""Logging in...""));
  
  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);
  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);
   imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);
   imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);
  
     
 
   if (DebugLevel < IMAP_LOG_PASS)
     mutt_debug(2, ""Sending LOGIN command for %s...\n"", idata->conn->account.user);
 
   snprintf(buf, sizeof(buf), ""LOGIN %s %s"", q_user, q_pass);
   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);
 
   if (!rc)
   {
     mutt_clear_error();  
     return IMAP_AUTH_SUCCESS;
   }
 
   mutt_error(_(""Login failed.""));
   return IMAP_AUTH_FAILURE;
 }","[22, 23, 20, 21]","An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription."
9836,"void HierarchicalBitmapRequester::PrepareForDecoding(void)
{
#if ACCUSOFT_CODE

UBYTE i;

BuildCommon();

if (m_ppDecodingMCU == NULL) {
m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);
memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);
}

if (m_ppUpsampler == NULL) {
m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);
memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);

for(i = 0;i < m_ucCount;i++) {
class Component *comp = m_pFrame->ComponentOf(i);
UBYTE sx = comp->SubXOf();
UBYTE sy = comp->SubYOf();

if (sx > 1 || sy > 1) {
m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,
m_ulPixelWidth,m_ulPixelHeight,
m_pFrame->TablesOf()->isChromaCentered());
m_bSubsampling   = true;
}
}
}

if (m_pLargestScale)
m_pLargestScale->PrepareForDecoding();
#endif
}",[23],libjpeg 1.63 has a heap-based buffer over-read in HierarchicalBitmapRequester::FetchRegion in hierarchicalbitmaprequester.cpp because the MCU size can be different between allocation and use.
9690,"generate_loadvar(
cctx_T  *cctx,
assign_dest_T dest,
char_u  *name,
lvar_T  *lvar,
type_T  *type)
{
switch (dest)
{
case dest_option:
case dest_func_option:
generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);
break;
case dest_global:
if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)
{
if (name[2] == NUL)
generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);
else
generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);
}
else
generate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);
break;
case dest_buffer:
generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);
break;
case dest_window:
generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);
break;
case dest_tab:
generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);
break;
case dest_script:
compile_load_scriptvar(cctx,
name + (name[1] == ':' ? 2 : 0), NULL, NULL);
break;
case dest_env:

generate_LOAD(cctx, ISN_LOADENV, 0, name, type);
break;
case dest_reg:
generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);
break;
case dest_vimvar:
generate_LOADV(cctx, name + 2);
break;
case dest_local:
if (lvar->lv_from_outer > 0)
generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,
type);
else
generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);
break;
case dest_expr:

break;
}
}","[49, 50, 52, 53]",NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0224.
200037,"  tiffcp(TIFF* in, TIFF* out)
  {
	uint16 bitspersample, samplesperpixel;
	uint16 input_compression, input_photometric;
 	uint16 bitspersample, samplesperpixel = 1;
 	uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;
  	copyFunc cf;
  	uint32 width, length;
  	struct cpTag* p;
 
 	CopyField(TIFFTAG_IMAGEWIDTH, width);
 	CopyField(TIFFTAG_IMAGELENGTH, length);
 	CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);
 	CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
 	if (compression != (uint16)-1)
 		TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
 	else
 		CopyField(TIFFTAG_COMPRESSION, compression);
 	TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);
 	TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);
 	if (input_compression == COMPRESSION_JPEG) {
 		 
 		TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
 	} else if (input_photometric == PHOTOMETRIC_YCBCR) {
 		 
 		uint16 subsamplinghor,subsamplingver;
 
 		TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
 				      &subsamplinghor, &subsamplingver);
 		if (subsamplinghor!=1 || subsamplingver!=1) {
 			fprintf(stderr, ""tiffcp: %s: Can't copy/convert subsampled image.\n"",
 				TIFFFileName(in));
 			return FALSE;
 		}
 	}
 	if (compression == COMPRESSION_JPEG) {
 		if (input_photometric == PHOTOMETRIC_RGB &&
 		    jpegcolormode == JPEGCOLORMODE_RGB)
 		  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
 		else
 		  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
 	}
 	else if (compression == COMPRESSION_SGILOG
 	    || compression == COMPRESSION_SGILOG24)
 		TIFFSetField(out, TIFFTAG_PHOTOMETRIC,
 		    samplesperpixel == 1 ?
 		    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
 	else if (input_compression == COMPRESSION_JPEG &&
 			 samplesperpixel == 3 ) {
 		 
 		TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
 	}
 	else
 		CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);
 	if (fillorder != 0)
 		TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
 	else
 		CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
 	 
 	TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
 	switch (orientation) {
 		case ORIENTATION_BOTRIGHT:
 		case ORIENTATION_RIGHTBOT:	 
 			TIFFWarning(TIFFFileName(in), ""using bottom-left orientation"");
 			orientation = ORIENTATION_BOTLEFT;
 		 
 		case ORIENTATION_LEFTBOT:	 
 		case ORIENTATION_BOTLEFT:
 			break;
 		case ORIENTATION_TOPRIGHT:
 		case ORIENTATION_RIGHTTOP:	 
 		default:
 			TIFFWarning(TIFFFileName(in), ""using top-left orientation"");
 			orientation = ORIENTATION_TOPLEFT;
 		 
 		case ORIENTATION_LEFTTOP:	 
 		case ORIENTATION_TOPLEFT:
 			break;
 	}
 	TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);
 	 
 	if (outtiled == -1)
 		outtiled = TIFFIsTiled(in);
 	if (outtiled) {
 		 
 		if (tilewidth == (uint32) -1)
 			TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
 		if (tilelength == (uint32) -1)
 			TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);
 		TIFFDefaultTileSize(out, &tilewidth, &tilelength);
 		TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
 		TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
 	} else {
 		 
 		if (rowsperstrip == (uint32) 0) {
 			if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,
 			    &rowsperstrip)) {
 				rowsperstrip =
 				    TIFFDefaultStripSize(out, rowsperstrip);
 			}
 			if (rowsperstrip > length && rowsperstrip != (uint32)-1)
 				rowsperstrip = length;
 		}
 		else if (rowsperstrip == (uint32) -1)
 			rowsperstrip = length;
 		TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
 	}
 	if (config != (uint16) -1)
 		TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
 	else
 		CopyField(TIFFTAG_PLANARCONFIG, config);
 	if (samplesperpixel <= 4)
 		CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
 	CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);
  
 	switch (compression) {
 		case COMPRESSION_JPEG:
 			TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
 			TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
 			break;
 		case COMPRESSION_JBIG:
 			CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
 			CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);
 			break;
 		case COMPRESSION_LZW:
 		case COMPRESSION_ADOBE_DEFLATE:
 		case COMPRESSION_DEFLATE:
                 case COMPRESSION_LZMA:
 			if (predictor != (uint16)-1)
 				TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
 			else
 				CopyField(TIFFTAG_PREDICTOR, predictor);
 			if (preset != -1) {
                                 if (compression == COMPRESSION_ADOBE_DEFLATE
                                          || compression == COMPRESSION_DEFLATE)
                                         TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);
 				else if (compression == COMPRESSION_LZMA)
 					TIFFSetField(out, TIFFTAG_LZMAPRESET, preset);
                         }
 			break;
 		case COMPRESSION_CCITTFAX3:
 		case COMPRESSION_CCITTFAX4:
 			if (compression == COMPRESSION_CCITTFAX3) {
 				if (g3opts != (uint32) -1)
 					TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,
 					    g3opts);
 				else
 					CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
 			} else
 				CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
 			CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
 			break;
 	}
 	{
 		uint32 len32;
 		void** data;
 		if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
 			TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
 	}
 	{
 		uint16 ninks;
 		const char* inknames;
 		if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
 			TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
 			if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
 				int inknameslen = strlen(inknames) + 1;
 				const char* cp = inknames;
 				while (ninks > 1) {
 					cp = strchr(cp, '\0');
                                         cp++;
                                         inknameslen += (strlen(cp) + 1);
 					ninks--;
 				}
 				TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
 			}
 		}
 	}
 	{
 		unsigned short pg0, pg1;
 
 		if (pageInSeq == 1) {
 			if (pageNum < 0)   {
 				if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))
 					TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
 			} else
 				TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
 
 		} else {
 			if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
 				if (pageNum < 0)  
 					TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
 				else
 					TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
 			}
 		}
 	}
 
 	for (p = tags; p < &tags[NTAGS]; p++)
 		CopyTag(p->tag, p->count, p->type);
 
 	cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);
 	return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);
 }","[5, 6, 3, 4]",tools/tiffcrop.c in libtiff 4.0.6 reads an undefined buffer in readContigStripsIntoBuffer() because of a uint16 integer overflow. Reported as MSVR 35100.
198774," struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,
 				     unsigned long data_len, int noblock,
 				     int *errcode)
 {
 	struct sk_buff *skb;
  	gfp_t gfp_mask;
  	long timeo;
  	int err;
 	int npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 
 	err = -EMSGSIZE;
 	if (npages > MAX_SKB_FRAGS)
 		goto failure;
  
  	gfp_mask = sk->sk_allocation;
  	if (gfp_mask & __GFP_WAIT)
 		gfp_mask |= __GFP_REPEAT;
 
 	timeo = sock_sndtimeo(sk, noblock);
 	while (1) {
 		err = sock_error(sk);
 		if (err != 0)
 			goto failure;
 
 		err = -EPIPE;
 		if (sk->sk_shutdown & SEND_SHUTDOWN)
 			goto failure;
 
  		if (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
  			skb = alloc_skb(header_len, gfp_mask);
  			if (skb) {
				int npages;
  				int i;
  
  				 
  				if (!data_len)
  					break;
  
				npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
  				skb->truesize += data_len;
  				skb_shinfo(skb)->nr_frags = npages;
  				for (i = 0; i < npages; i++) {
 					struct page *page;
 
 					page = alloc_pages(sk->sk_allocation, 0);
 					if (!page) {
 						err = -ENOBUFS;
 						skb_shinfo(skb)->nr_frags = i;
 						kfree_skb(skb);
 						goto failure;
 					}
 
 					__skb_fill_page_desc(skb, i,
 							page, 0,
 							(data_len >= PAGE_SIZE ?
 							 PAGE_SIZE :
 							 data_len));
 					data_len -= PAGE_SIZE;
 				}
 
 				 
 				break;
 			}
 			err = -ENOBUFS;
 			goto failure;
 		}
 		set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
 		set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
 		err = -EAGAIN;
 		if (!timeo)
 			goto failure;
 		if (signal_pending(current))
 			goto interrupted;
 		timeo = sock_wait_for_wmem(sk, timeo);
 	}
 
 	skb_set_owner_w(skb, sk);
 	return skb;
 
 interrupted:
 	err = sock_intr_errno(timeo);
 failure:
 	*errcode = err;
 	return NULL;
 }","[9, 10, 11, 12, 13, 32, 39]","The sock_alloc_send_pskb function in net/core/sock.c in the Linux kernel before 3.4.5 does not properly validate a certain length value, which allows local users to cause a denial of service (heap-based buffer overflow and system crash) or possibly gain privileges by leveraging access to a TUN/TAP device."
7505,"static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,
char *name) {

XImage *xim;
static int reported_flip = 0;
int db = 0;

shm->shmid = -1;
shm->shmaddr = (char *) -1;
*ximg_ptr = NULL;

if (nofb) {
return 1;
}

X_LOCK;

if (! using_shm || xform24to32 || raw_fb) {

xim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,
0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);

X_UNLOCK;

if (xim == NULL) {
rfbErr(""XCreateImage(%s) failed.\n"", name);
if (quiet) {
fprintf(stderr, ""XCreateImage(%s) failed.\n"",
name);
}
return 0;
}
if (db) fprintf(stderr, ""shm_create simple %d %d\t%p %s\n"", w, h, (void *)xim, name);
xim->data = (char *) malloc(xim->bytes_per_line * xim->height);
if (xim->data == NULL) {
rfbErr(""XCreateImage(%s) data malloc failed.\n"", name);
if (quiet) {
fprintf(stderr, ""XCreateImage(%s) data malloc""
"" failed.\n"", name);
}
return 0;
}
if (flip_byte_order) {
char *order = flip_ximage_byte_order(xim);
if (! reported_flip && ! quiet) {
rfbLog(""Changing XImage byte order""
"" to %s\n"", order);
reported_flip = 1;
}
}

*ximg_ptr = xim;
return 1;
}

if (! dpy) {
X_UNLOCK;
return 0;
}

xim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,
shm, w, h);

if (xim == NULL) {
rfbErr(""XShmCreateImage(%s) failed.\n"", name);
if (quiet) {
fprintf(stderr, ""XShmCreateImage(%s) failed.\n"", name);
}
X_UNLOCK;
return 0;
}

*ximg_ptr = xim;

#if HAVE_XSHM
shm->shmid = shmget(IPC_PRIVATE,
xim->bytes_per_line * xim->height, IPC_CREAT | 0777);

if (shm->shmid == -1) {
rfbErr(""shmget(%s) failed.\n"", name);
rfbLogPerror(""shmget"");

XDestroyImage(xim);
*ximg_ptr = NULL;

X_UNLOCK;
return 0;
}

shm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);

if (shm->shmaddr == (char *)-1) {
rfbErr(""shmat(%s) failed.\n"", name);
rfbLogPerror(""shmat"");

XDestroyImage(xim);
*ximg_ptr = NULL;

shmctl(shm->shmid, IPC_RMID, 0);
shm->shmid = -1;

X_UNLOCK;
return 0;
}

shm->readOnly = False;

if (! XShmAttach_wr(dpy, shm)) {
rfbErr(""XShmAttach(%s) failed.\n"", name);
XDestroyImage(xim);
*ximg_ptr = NULL;

shmdt(shm->shmaddr);
shm->shmaddr = (char *) -1;

shmctl(shm->shmid, IPC_RMID, 0);
shm->shmid = -1;

X_UNLOCK;
return 0;
}
#endif

X_UNLOCK;
return 1;
}",[77],"scan.c in x11vnc 0.9.16 uses IPC_CREAT|0777 in shmget calls, which allows access by actors other than the current user."
205135," bool RenderViewHostManager::ShouldSwapProcessesForNavigation(
     const NavigationEntry* curr_entry,
     const NavigationEntryImpl* new_entry) const {
   DCHECK(new_entry);
 
 
   const GURL& current_url = (curr_entry) ? curr_entry->GetURL() :
       render_view_host_->GetSiteInstance()->GetSiteURL();
   BrowserContext* browser_context =
       delegate_->GetControllerForRenderManager().GetBrowserContext();
   if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(
           browser_context, current_url)) {
     if (!WebUIControllerFactoryRegistry::GetInstance()->IsURLAcceptableForWebUI(
             browser_context, new_entry->GetURL(), false)) {
       return true;
     }
   } else {
     if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(
             browser_context, new_entry->GetURL())) {
       return true;
     }
    }
  
    if (GetContentClient()->browser()->ShouldSwapProcessesForNavigation(
          curr_entry ? curr_entry->GetURL() : GURL(), new_entry->GetURL())) {
           render_view_host_->GetSiteInstance(),
           curr_entry ? curr_entry->GetURL() : GURL(),
           new_entry->GetURL())) {
      return true;
    }
  
   if (!curr_entry)
     return false;
 
   if (curr_entry->IsViewSourceMode() != new_entry->IsViewSourceMode())
     return true;
 
   return false;
 }","[26, 27, 28, 25]","The Isolated Sites feature in Google Chrome before 26.0.1410.43 does not properly enforce the use of separate processes, which makes it easier for remote attackers to bypass intended access restrictions via a crafted web site."
205828," KeyedService* LogoServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* context) const {
   Profile* profile = static_cast<Profile*>(context);
   DCHECK(!profile->IsOffTheRecord());
 #if defined(OS_ANDROID)
   bool use_gray_background = !GetIsChromeHomeEnabled();
  #else
    bool use_gray_background = false;
  #endif
  return new LogoService(profile->GetPath().Append(kCachedLogoDirectory),
                         TemplateURLServiceFactory::GetForProfile(profile),
                         base::MakeUnique<suggestions::ImageDecoderImpl>(),
                         profile->GetRequestContext(), use_gray_background);
   return new LogoServiceImpl(profile->GetPath().Append(kCachedLogoDirectory),
                              TemplateURLServiceFactory::GetForProfile(profile),
                              base::MakeUnique<suggestions::ImageDecoderImpl>(),
                              profile->GetRequestContext(), use_gray_background);
  }","[14, 15, 16, 17, 10, 11, 12, 13]","The Google V8 engine, as used in Google Chrome before 44.0.2403.89 and QtWebEngineCore in Qt before 5.5.1, allows remote attackers to cause a denial of service (memory corruption) or execute arbitrary code via a crafted web site."
201861," static int jas_iccputsint(jas_stream_t *out, int n, longlong val)
 static int jas_iccputsint(jas_stream_t *out, int n, jas_longlong val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	tmp = (val < 0) ? (abort(), 0) : val;
  	return jas_iccputuint(out, n, tmp);
  }","[2, 5, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
205267," void PageSerializer::addImageToResources(ImageResource* image, RenderObject* imageRenderer, const KURL& url)
 {
      if (!shouldAddURL(url))
          return;
  
    if (!image || !image->hasImage() || image->image() == Image::nullImage())
     if (!image || image->image() == Image::nullImage())
          return;
  
      RefPtr<SharedBuffer> data = imageRenderer ? image->imageForRenderer(imageRenderer)->data() : 0;
     if (!data)
         data = image->image()->data();
 
     addToResources(image, data, url);
 }","[7, 6]","Google Chrome before 24.0.1312.52 does not properly handle image data in PDF documents, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted document."
8482,"s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
{
u8 idr_flag;
s32 slice, ret;
u32 nal_hdr;
AVCSliceInfo n_state;

gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);

nal_hdr = gf_bs_read_u8(bs);

slice = 0;
memcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));
avc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;
n_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;

idr_flag = 0;

switch (n_state.nal_unit_type) {
case GF_AVC_NALU_ACCESS_UNIT:
case GF_AVC_NALU_END_OF_SEQ:
case GF_AVC_NALU_END_OF_STREAM:
ret = 1;
break;

case GF_AVC_NALU_SVC_SLICE:
SVC_ReadNal_header_extension(bs, &n_state.NalHeader);

svc_parse_slice(bs, avc, &n_state);
if (avc->s_info.nal_ref_idc) {
n_state.poc_lsb_prev = avc->s_info.poc_lsb;
n_state.poc_msb_prev = avc->s_info.poc_msb;
}
avc_compute_poc(&n_state);

if (avc->s_info.poc != n_state.poc) {
memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
return 1;
}
memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
return 0;

case GF_AVC_NALU_SVC_PREFIX_NALU:
SVC_ReadNal_header_extension(bs, &n_state.NalHeader);
return 0;

case GF_AVC_NALU_IDR_SLICE:
case GF_AVC_NALU_NON_IDR_SLICE:
case GF_AVC_NALU_DP_A_SLICE:
case GF_AVC_NALU_DP_B_SLICE:
case GF_AVC_NALU_DP_C_SLICE:
slice = 1;

ret = avc_parse_slice(bs, avc, idr_flag, &n_state);
if (ret < 0) return ret;
ret = 0;
if (
((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))
&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)
) {
break;
}
if (avc->s_info.frame_num != n_state.frame_num) {
ret = 1;
break;
}

if (avc->s_info.field_pic_flag != n_state.field_pic_flag) {
ret = 1;
break;
}
if ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&
(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {
ret = 1;
break;
}
assert(avc->s_info.sps);

if (avc->s_info.sps->poc_type == n_state.sps->poc_type) {
if (!avc->s_info.sps->poc_type) {
if (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {
ret = 1;
break;
}
if (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {
ret = 1;
break;
}
}
else if (avc->s_info.sps->poc_type == 1) {
if (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {
ret = 1;
break;
}
if (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {
ret = 1;
break;
}
}
}

if (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {
if (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) {
ret = 1;
break;
}
else if (avc->s_info.idr_pic_id != n_state.idr_pic_id) {
ret = 1;
break;
}
}
break;
case GF_AVC_NALU_SEQ_PARAM:
avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);
if (avc->last_ps_idx < 0) return -1;
return 0;

case GF_AVC_NALU_PIC_PARAM:
avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);
if (avc->last_ps_idx < 0) return -1;
return 0;
case GF_AVC_NALU_SVC_SUBSEQ_PARAM:
avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);
if (avc->last_ps_idx < 0) return -1;
return 0;
case GF_AVC_NALU_SEQ_PARAM_EXT:
avc->last_ps_idx = (s32) gf_bs_read_ue(bs);
if (avc->last_ps_idx < 0) return -1;
return 0;

case GF_AVC_NALU_SEI:
case GF_AVC_NALU_FILLER_DATA:
return 0;

default:
if (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;

else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)
ret = 1;
else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)
ret = 1;
else
ret = 0;
break;
}


if (ret && avc->s_info.sps) {
n_state.frame_num_offset_prev = avc->s_info.frame_num_offset;
if ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))
n_state.frame_num_prev = avc->s_info.frame_num;
if (avc->s_info.nal_ref_idc) {
n_state.poc_lsb_prev = avc->s_info.poc_lsb;
n_state.poc_msb_prev = avc->s_info.poc_msb;
}
}
if (slice)
avc_compute_poc(&n_state);
memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
return ret;
}",[77],"A Segmentation fault caused by a null pointer dereference vulnerability exists in Gpac through 1.0.1 via the gf_avc_parse_nalu function in av_parsers.c when using mp4box, which causes a denial of service."
201171," void MSG_WriteBits( msg_t *msg, int value, int bits ) {
 	int	i;
  
  	oldsize += bits;
  
	if ( msg->maxsize - msg->cursize < 4 ) {
		msg->overflowed = qtrue;
 	if ( msg->overflowed ) {
  		return;
  	}
  
 	if ( bits == 0 || bits < -31 || bits > 32 ) {
 		Com_Error( ERR_DROP, ""MSG_WriteBits: bad bits %i"", bits );
 	}
 
 	if ( bits < 0 ) {
 		bits = -bits;
  	}
  
  	if ( msg->oob ) {
 		if ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {
 			msg->overflowed = qtrue;
 			return;
 		}
 
  		if ( bits == 8 ) {
  			msg->data[msg->cursize] = value;
  			msg->cursize += 1;
 			msg->bit += 8;
 		} else if ( bits == 16 ) {
 			short temp = value;
 
 			CopyLittleShort( &msg->data[msg->cursize], &temp );
 			msg->cursize += 2;
 			msg->bit += 16;
 		} else if ( bits==32 ) {
 			CopyLittleLong( &msg->data[msg->cursize], &value );
 			msg->cursize += 4;
 			msg->bit += 32;
 		} else {
 			Com_Error( ERR_DROP, ""can't write %d bits"", bits );
 		}
 	} else {
 		value &= (0xffffffff >> (32 - bits));
  		if ( bits&7 ) {
  			int nbits;
  			nbits = bits&7;
 			if ( msg->bit + nbits > msg->maxsize << 3 ) {
 				msg->overflowed = qtrue;
 				return;
 			}
  			for( i = 0; i < nbits; i++ ) {
  				Huff_putBit( (value & 1), msg->data, &msg->bit );
  				value = (value >> 1);
 			}
 			bits = bits - nbits;
  		}
  		if ( bits ) {
  			for( i = 0; i < bits; i += 8 ) {
				Huff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );
 				Huff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );
  				value = (value >> 8);
 
 				if ( msg->bit > msg->maxsize << 3 ) {
 					msg->overflowed = qtrue;
 					return;
 				}
  			}
  		}
  		msg->cursize = (msg->bit >> 3) + 1;
 	}
 }","[8, 21, 22, 23, 24, 25, 48, 49, 50, 51, 61, 63, 64, 65, 66, 67, 6, 7, 60]",Buffer overflow in ioquake3 before 2017-08-02 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted packet.
202253," static int read_public_key(RSA *rsa)
 {
 	int r;
 	sc_path_t path;
 	sc_file_t *file;
 	u8 buf[2048], *p = buf;
 	size_t bufsize, keysize;
 
 	r = select_app_df();
 	if (r)
 		return 1;
 	sc_format_path(""I1012"", &path);
 	r = sc_select_file(card, &path, &file);
 	if (r) {
  		fprintf(stderr, ""Unable to select public key file: %s\n"", sc_strerror(r));
  		return 2;
  	}
	bufsize = file->size;
 	bufsize = MIN(file->size, sizeof buf);
  	sc_file_free(file);
  	r = sc_read_binary(card, 0, buf, bufsize, 0);
  	if (r < 0) {
 		fprintf(stderr, ""Unable to read public key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
 	bufsize = r;
 	do {
 		if (bufsize < 4)
 			return 3;
 		keysize = (p[0] << 8) | p[1];
 		if (keysize == 0)
 			break;
 		if (keysize < 3)
 			return 3;
 		if (p[2] == opt_key_num)
 			break;
 		p += keysize;
 		bufsize -= keysize;
 	} while (1);
 	if (keysize == 0) {
 		printf(""Key number %d not found.\n"", opt_key_num);
 		return 2;
 	}
 	return parse_public_key(p, keysize, rsa);
 }","[19, 18]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
205648,"  bool TextTrackCueList::Add(TextTrackCue* cue) {
  DCHECK_GE(cue->startTime(), 0);
  DCHECK_GE(cue->endTime(), 0);
    size_t index = FindInsertionIndex(cue);
 
   if (!list_.IsEmpty() && (index > 0) && (list_[index - 1].Get() == cue))
     return false;
 
   list_.insert(index, cue);
   InvalidateCueIndex(index);
   return true;
 }","[2, 3]","fpdfsdk/src/jsapi/fxjs_v8.cpp in PDFium, as used in Google Chrome before 47.0.2526.73, does not use signatures, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage *type confusion.*"
206244," void UpdateTargetInfoAvPairs(bool is_mic_enabled,
                              bool is_epa_enabled,
                              const std::string& channel_bindings,
                              const std::string& spn,
                              std::vector<AvPair>* av_pairs,
                              uint64_t* server_timestamp,
                              size_t* target_info_len) {
   *server_timestamp = UINT64_MAX;
   *target_info_len = 0;
 
   bool need_flags_added = is_mic_enabled;
   for (AvPair& pair : *av_pairs) {
     *target_info_len += pair.avlen + kAvPairHeaderLen;
     switch (pair.avid) {
       case TargetInfoAvId::kFlags:
         if (is_mic_enabled) {
           pair.flags = pair.flags | TargetInfoAvFlags::kMicPresent;
         }
 
         need_flags_added = false;
         break;
       case TargetInfoAvId::kTimestamp:
         *server_timestamp = pair.timestamp;
         break;
       case TargetInfoAvId::kEol:
       case TargetInfoAvId::kChannelBindings:
       case TargetInfoAvId::kTargetName:
         NOTREACHED();
         break;
       default:
         break;
     }
   }
 
   if (need_flags_added) {
     DCHECK(is_mic_enabled);
     AvPair flags_pair(TargetInfoAvId::kFlags, sizeof(uint32_t));
     flags_pair.flags = TargetInfoAvFlags::kMicPresent;
 
     av_pairs->push_back(flags_pair);
     *target_info_len += kAvPairHeaderLen + flags_pair.avlen;
   }
 
   if (is_epa_enabled) {
     std::vector<uint8_t> channel_bindings_hash(kChannelBindingsHashLen, 0);
  
      if (!channel_bindings.empty()) {
      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);
       GenerateChannelBindingHashV2(
           channel_bindings,
           base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));
      }
  
      av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,
                            std::move(channel_bindings_hash));
 
     base::string16 spn16 = base::UTF8ToUTF16(spn);
     NtlmBufferWriter spn_writer(spn16.length() * 2);
     bool spn_writer_result =
         spn_writer.WriteUtf16String(spn16) && spn_writer.IsEndOfBuffer();
     DCHECK(spn_writer_result);
 
     av_pairs->emplace_back(TargetInfoAvId::kTargetName, spn_writer.Pass());
 
     *target_info_len +=
         (2 * kAvPairHeaderLen) + kChannelBindingsHashLen + (spn16.length() * 2);
   }
 
   *target_info_len += kAvPairHeaderLen;
 }","[49, 50, 51, 48]","Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and  (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc."
198699," int mainloop(CLIENT *client) {
 	struct nbd_request request;
 	struct nbd_reply reply;
 	gboolean go_on=TRUE;
 #ifdef DODBG
 	int i = 0;
 #endif
 	negotiate(client->net, client, NULL);
 	DEBUG(""Entering request loop!\n"");
 	reply.magic = htonl(NBD_REPLY_MAGIC);
 	reply.error = 0;
 	while (go_on) {
 		char buf[BUFSIZE];
 		size_t len;
 #ifdef DODBG
 		i++;
 		printf(""%d: "", i);
 #endif
 		readit(client->net, &request, sizeof(request));
 		request.from = ntohll(request.from);
 		request.type = ntohl(request.type);
 
 		if (request.type==NBD_CMD_DISC) {
 			msg2(LOG_INFO, ""Disconnect request received."");
                 	if (client->server->flags & F_COPYONWRITE) { 
 				if (client->difmap) g_free(client->difmap) ;
                 		close(client->difffile);
 				unlink(client->difffilename);
 				free(client->difffilename);
 			}
 			go_on=FALSE;
 			continue;
 		}
 
 		len = ntohl(request.len);
  
  		if (request.magic != htonl(NBD_REQUEST_MAGIC))
  			err(""Not enough magic."");
		if (len > BUFSIZE + sizeof(struct nbd_reply))
 		if (len > BUFSIZE - sizeof(struct nbd_reply))
  			err(""Request too big!"");
  #ifdef DODBG
  		printf(""%s from %llu (%llu) len %d, "", request.type ? ""WRITE"" :
 				""READ"", (unsigned long long)request.from,
 				(unsigned long long)request.from / 512, len);
 #endif
 		memcpy(reply.handle, request.handle, sizeof(reply.handle));
 		if ((request.from + len) > (OFFT_MAX)) {
 			DEBUG(""[Number too large!]"");
 			ERROR(client, reply, EINVAL);
 			continue;
 		}
 
 		if (((ssize_t)((off_t)request.from + len) > client->exportsize)) {
 			DEBUG(""[RANGE!]"");
 			ERROR(client, reply, EINVAL);
 			continue;
 		}
 
 		if (request.type==NBD_CMD_WRITE) {
 			DEBUG(""wr: net->buf, "");
 			readit(client->net, buf, len);
 			DEBUG(""buf->exp, "");
 			if ((client->server->flags & F_READONLY) ||
 			    (client->server->flags & F_AUTOREADONLY)) {
 				DEBUG(""[WRITE to READONLY!]"");
 				ERROR(client, reply, EPERM);
 				continue;
 			}
 			if (expwrite(request.from, buf, len, client)) {
 				DEBUG(""Write failed: %m"" );
 				ERROR(client, reply, errno);
 				continue;
 			}
 			SEND(client->net, reply);
 			DEBUG(""OK!\n"");
 			continue;
 		}
 		 
 
 		DEBUG(""exp->buf, "");
 		if (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {
 			DEBUG(""Read failed: %m"");
 			ERROR(client, reply, errno);
 			continue;
 		}
 
 		DEBUG(""buf->net, "");
 		memcpy(buf, &reply, sizeof(struct nbd_reply));
 		writeit(client->net, buf, len + sizeof(struct nbd_reply));
 		DEBUG(""OK!\n"");
 	}
 	return 0;
 }","[40, 39]",Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.
206316,"  bool MediaControlsProgressView::OnMousePressed(const ui::MouseEvent& event) {
  gfx::Point location_in_bar(event.location());
  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);
  if (!event.IsOnlyLeftMouseButton() ||
      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {
   if (!event.IsOnlyLeftMouseButton() || event.y() < kMinClickHeight ||
       event.y() > kMaxClickHeight) {
      return false;
    }
  
  HandleSeeking(location_in_bar);
   HandleSeeking(event.location());
    return true;
  }","[6, 7, 12, 2, 3, 4, 5, 11]","A timing attack in SVG rendering in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to extract pixel values from a cross-origin page being iframe'd via a crafted HTML page."
208218," OMX_ERRORTYPE SoftAMRWBEncoder::internalGetParameter(
         OMX_INDEXTYPE index, OMX_PTR params) {
  switch (index) {
  case OMX_IndexParamAudioPortFormat:
  {
 
              OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
             if (!isValidOMXParam(formatParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
 
  if (formatParams->nIndex > 0) {
  return OMX_ErrorNoMore;
  }
 
             formatParams->eEncoding =
  (formatParams->nPortIndex == 0)
  ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAMR;
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioAmr:
  {
 
              OMX_AUDIO_PARAM_AMRTYPE *amrParams =
                  (OMX_AUDIO_PARAM_AMRTYPE *)params;
  
             if (!isValidOMXParam(amrParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (amrParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
 
             amrParams->nChannels = 1;
             amrParams->nBitRate = mBitRate;
 
             amrParams->eAMRBandMode =
  (OMX_AUDIO_AMRBANDMODETYPE)(mMode + OMX_AUDIO_AMRBandModeWB0);
 
             amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;
             amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioPcm:
  {
 
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
             if (!isValidOMXParam(pcmParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
 
             pcmParams->eNumData = OMX_NumericalDataSigned;
             pcmParams->eEndian = OMX_EndianBig;
             pcmParams->bInterleaved = OMX_TRUE;
             pcmParams->nBitPerSample = 16;
             pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
             pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelCF;
 
             pcmParams->nChannels = 1;
             pcmParams->nSamplingRate = kSampleRate;
 
  return OMX_ErrorNone;
  }
 
  default:
  return SimpleSoftOMXComponent::internalGetParameter(index, params);
  }
 }","[10, 11, 12, 13, 35, 36, 37, 38, 61, 62, 63, 64]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
205475,"  media::interfaces::ServiceFactory* RenderFrameImpl::GetMediaServiceFactory() {
    if (!media_service_factory_) {
    mojo::InterfacePtr<mojo::Shell> shell_ptr;
    GetServiceRegistry()->ConnectToRemoteService(mojo::GetProxy(&shell_ptr));
    mojo::ServiceProviderPtr service_provider;
    mojo::URLRequestPtr request(mojo::URLRequest::New());
    request->url = mojo::String::From(""mojo:media"");
    shell_ptr->ConnectToApplication(request.Pass(), GetProxy(&service_provider),
                                    nullptr, nullptr);
     mojo::ServiceProviderPtr service_provider =
         ConnectToApplication(GURL(""mojo:media""));
      mojo::ConnectToService(service_provider.get(), &media_service_factory_);
      media_service_factory_.set_connection_error_handler(
          base::Bind(&RenderFrameImpl::OnMediaServiceFactoryConnectionError,
                     base::Unretained(this)));
   }
 
   return media_service_factory_.get();
 }","[10, 11, 3, 4, 5, 6, 7, 8, 9]","Use-after-free vulnerability in modules/speech/SpeechSynthesis.cpp in Blink, as used in Google Chrome before 33.0.1750.149, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper handling of a certain utterance data structure."
4747,"sec_recv(RD_BOOL * is_fastpath)
{
uint8 fastpath_hdr, fastpath_flags;
uint16 sec_flags;
uint16 channel;
STREAM s;

while ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)
{
if (*is_fastpath == True)
{



fastpath_flags = (fastpath_hdr & 0xC0) >> 6;
if (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)
{
in_uint8s(s, 8);
sec_decrypt(s->p, s->end - s->p);
}
return s;
}

if (g_encryption || (!g_licence_issued && !g_licence_error_result))
{

in_uint16_le(s, sec_flags);
in_uint8s(s, 2);

if (g_encryption)
{
if (sec_flags & SEC_ENCRYPT)
{
in_uint8s(s, 8);
sec_decrypt(s->p, s->end - s->p);
}

if (sec_flags & SEC_LICENSE_PKT)
{
licence_process(s);
continue;
}

if (sec_flags & SEC_REDIRECTION_PKT)
{
uint8 swapbyte;

in_uint8s(s, 8);
sec_decrypt(s->p, s->end - s->p);


if (s->p[0] == 0 && s->p[1] == 4)
{






swapbyte = s->p[0];
s->p[0] = s->p[2];
s->p[2] = swapbyte;

swapbyte = s->p[1];
s->p[1] = s->p[3];
s->p[3] = swapbyte;

swapbyte = s->p[2];
s->p[2] = s->p[3];
s->p[3] = swapbyte;
}
}
}
else
{
if (sec_flags & SEC_LICENSE_PKT)
{
licence_process(s);
continue;
}
s->p -= 4;
}
}

if (channel != MCS_GLOBAL_CHANNEL)
{
channel_process(s, channel);
continue;
}

return s;
}

return NULL;
}","[8, 10, 18, 34, 48]",rdesktop versions up to and including v1.8.3 contain an Out-Of-Bounds Read in the function ui_clip_handle_data() that results in an information leak.
206310," void LockScreenMediaControlsView::SetArtwork(
     base::Optional<gfx::ImageSkia> img) {
   if (!img.has_value()) {
     session_artwork_->SetImage(nullptr);
      return;
    }
  
  session_artwork_->SetImageSize(ScaleSizeToFitView(
      img->size(), gfx::Size(kArtworkViewWidth, kArtworkViewHeight)));
   session_artwork_->SetImageSize(ScaleSizeToFitView(img->size(), kArtworkSize));
    session_artwork_->SetImage(*img);
  }","[10, 8, 9]","A timing attack in SVG rendering in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to extract pixel values from a cross-origin page being iframe'd via a crafted HTML page."
9420,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
auto* params =
reinterpret_cast<TfLiteDepthwiseConvParams*>(node->builtin_data);
OpData* data = reinterpret_cast<OpData*>(node->user_data);

bool has_bias = NumInputs(node) == 3;

TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2);
const TfLiteTensor* input;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
const TfLiteTensor* filter;
TF_LITE_ENSURE_OK(context,
GetInputSafe(context, node, kFilterTensor, &filter));
const TfLiteTensor* bias = nullptr;

TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context,
GetOutputSafe(context, node, kOutputTensor, &output));

TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);
TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 4);

const TfLiteType data_type = input->type;

const TfLiteType filter_type = filter->type;
const bool is_hybrid =
data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8;
TF_LITE_ENSURE(context,
data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||
data_type == kTfLiteInt8 || data_type == kTfLiteInt16);
TF_LITE_ENSURE_TYPES_EQ(context, output->type, data_type);
if (!is_hybrid) {
TF_LITE_ENSURE(context,
filter->type == data_type || data_type == kTfLiteInt16);
}

if (data_type == kTfLiteInt16) {
TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);
TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
}


TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 0), 1);

if (has_bias) {
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));
if (data_type == kTfLiteUInt8 || data_type == kTfLiteInt8) {
TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32);
TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);
} else if (data_type == kTfLiteInt16) {
TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64);
TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);
} else {
TF_LITE_ENSURE_TYPES_EQ(context, bias->type, data_type);
}
TF_LITE_ENSURE_EQ(context, NumDimensions(bias), 1);
TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 3),
SizeOfDimension(bias, 0));
}

int channels_out = SizeOfDimension(filter, 3);
int width = SizeOfDimension(input, 2);
int height = SizeOfDimension(input, 1);
int filter_width = SizeOfDimension(filter, 2);
int filter_height = SizeOfDimension(filter, 1);
int batches = SizeOfDimension(input, 0);


auto padding = params->padding;
int out_width, out_height;

data->padding = ComputePaddingHeightWidth(
params->stride_height, params->stride_width,
params->dilation_height_factor, params->dilation_width_factor, height,
width, filter_height, filter_width, padding, &out_height, &out_width);




if (data_type != kTfLiteFloat32) {
TF_LITE_ENSURE_EQ(context, filter->quantization.type,
kTfLiteAffineQuantization);
TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
const auto* affine_quantization =
reinterpret_cast<TfLiteAffineQuantization*>(
filter->quantization.params);
TF_LITE_ENSURE(context, affine_quantization);
TF_LITE_ENSURE(context, affine_quantization->scale);
TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 ||
affine_quantization->scale->size == channels_out));

data->per_channel_output_multiplier.resize(channels_out);
data->per_channel_output_shift.resize(channels_out);
TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(
context, input, filter, bias, output, params->activation,
&data->output_multiplier, &data->output_shift,
&data->output_activation_min, &data->output_activation_max,
data->per_channel_output_multiplier.data(),
data->per_channel_output_shift.data(), channels_out));
}

if (is_hybrid) {
TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
const auto* affine_quantization =
reinterpret_cast<TfLiteAffineQuantization*>(
filter->quantization.params);
TF_LITE_ENSURE(context, affine_quantization);
TF_LITE_ENSURE(context, affine_quantization->scale);
TF_LITE_ENSURE_EQ(
context, affine_quantization->scale->size,
filter->dims->data[affine_quantization->quantized_dimension]);

int temporaries_count = 0;
data->input_quantized_index = temporaries_count;
if (data->input_quantized_id == kTensorNotAllocated) {
TF_LITE_ENSURE_OK(
context, context->AddTensors(context, 1, &data->input_quantized_id));
}
++temporaries_count;
data->scaling_factors_index = temporaries_count;
if (data->scaling_factors_id == kTensorNotAllocated) {
TF_LITE_ENSURE_OK(
context, context->AddTensors(context, 1, &data->scaling_factors_id));
}
++temporaries_count;
data->input_offset_index = temporaries_count;
if (data->input_offset_id == kTensorNotAllocated) {
TF_LITE_ENSURE_OK(
context, context->AddTensors(context, 1, &data->input_offset_id));
}
++temporaries_count;

TfLiteIntArrayFree(node->temporaries);
node->temporaries = TfLiteIntArrayCreate(temporaries_count);

node->temporaries->data[data->input_quantized_index] =
data->input_quantized_id;
TfLiteTensor* input_quantized;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, data->input_quantized_index,
&input_quantized));
input_quantized->type = kTfLiteInt8;
input_quantized->allocation_type = kTfLiteArenaRw;
if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {
TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,
input_quantized_size));
}
node->temporaries->data[data->scaling_factors_index] =
data->scaling_factors_id;
TfLiteTensor* scaling_factors;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, data->scaling_factors_index,
&scaling_factors));
scaling_factors->type = kTfLiteFloat32;
scaling_factors->allocation_type = kTfLiteArenaRw;
const int batch_size = SizeOfDimension(input, 0);
int scaling_dims[1] = {batch_size};
if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {
TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);
scaling_factors_size->data[0] = batch_size;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,
scaling_factors_size));
}
node->temporaries->data[data->input_offset_index] = data->input_offset_id;
TfLiteTensor* input_offsets;
TF_LITE_ENSURE_OK(context,
GetTemporarySafe(context, node, data->input_offset_index,
&input_offsets));
input_offsets->type = kTfLiteInt32;
input_offsets->allocation_type = kTfLiteArenaRw;
if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {
TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);
input_offsets_size->data[0] = batch_size;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,
input_offsets_size));
}
}

TfLiteIntArray* outputSize = TfLiteIntArrayCreate(4);
outputSize->data[0] = batches;
outputSize->data[1] = out_height;
outputSize->data[2] = out_width;
outputSize->data[3] = channels_out;
return context->ResizeTensor(context, output, outputSize);
}",[24],"Tensorflow is an Open Source Machine Learning Framework. ### Impact An attacker can craft a TFLite model that would trigger a division by zero in the implementation of depthwise convolutions. The parameters of the convolution can be user controlled and are also used within a division operation to determine the size of the padding that needs to be added before applying the convolution. There is no check before this division that the divisor is strictly positive. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
202398," struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {
 	const char *symstr;
 	struct symbol_t *symbols;
 	int from, to, i, j, s, stridx, symbols_size, symbols_count;
 	SdbHash *hash;
 
 	if (!bin || !bin->symtab || !bin->symstr) {
 		return NULL;
 	}
 	 
 	 
 	symbols_count = (bin->dysymtab.nextdefsym + \
 			bin->dysymtab.nlocalsym + \
 			bin->dysymtab.nundefsym );
 	symbols_count += bin->nsymtab;
 	symbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);
 
 	if (symbols_size < 1) {
 		return NULL;
 	}
 	if (!(symbols = calloc (1, symbols_size))) {
 		return NULL;
 	}
 	hash = sdb_ht_new ();
 	j = 0;  
 	for (s = 0; s < 2; s++) {
 		switch (s) {
 		case 0:
 			from = bin->dysymtab.iextdefsym;
 			to = from + bin->dysymtab.nextdefsym;
 			break;
 		case 1:
 			from = bin->dysymtab.ilocalsym;
 			to = from + bin->dysymtab.nlocalsym;
 			break;
 #if NOT_USED
 		case 2:
 			from = bin->dysymtab.iundefsym;
 			to = from + bin->dysymtab.nundefsym;
 			break;
 #endif
 		}
 		if (from == to) {
 			continue;
 		}
 #define OLD 1
 #if OLD
 		from = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));
 		to = R_MIN (to , symbols_size / sizeof (struct symbol_t));
 		to = R_MIN (to, bin->nsymtab);
 #else
 		from = R_MIN (R_MAX (0, from), symbols_size/sizeof (struct symbol_t));
 		to = symbols_count;  
 #endif
 		int maxsymbols = symbols_size / sizeof (struct symbol_t);
 		if (to > 0x500000) {
 			bprintf (""WARNING: corrupted mach0 header: symbol table is too big %d\n"", to);
 			free (symbols);
 			sdb_ht_free (hash);
 			return NULL;
 		}
 		if (symbols_count >= maxsymbols) {
 			symbols_count = maxsymbols - 1;
 		}
 		for (i = from; i < to && j < symbols_count; i++, j++) {
 			symbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);
 			symbols[j].addr = bin->symtab[i].n_value;
 			symbols[j].size = 0;  
 			if (bin->symtab[i].n_type & N_EXT) {
 				symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;
 			} else {
 				symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;
 			}
 			stridx = bin->symtab[i].n_strx;
 			if (stridx >= 0 && stridx < bin->symstrlen) {
 				symstr = (char*)bin->symstr + stridx;
 			} else {
 				symstr = ""???"";
 			}
 			{
 				int i = 0;
 				int len = 0;
 				len = bin->symstrlen - stridx;
 				if (len > 0) {
 					for (i = 0; i < len; i++) {
 						if ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {
 							len = i;
 							break;
 						}
 					}
 					char *symstr_dup = NULL;
 					if (len > 0) {
 						symstr_dup = r_str_ndup (symstr, len);
 					}
 					if (!symstr_dup) {
 						symbols[j].name[0] = 0;
 					} else {
 						r_str_ncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);
 						r_str_filter (symbols[j].name, -1);
 						symbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;
 					}
 					free (symstr_dup);
 				} else {
 					symbols[j].name[0] = 0;
 				}
 				symbols[j].last = 0;
 			}
 			if (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {
 				symbols[j].name[0] = 0;
 				j--;
 			}
 		}
 	}
 	to = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);
 	for (i = bin->dysymtab.iundefsym; i < to; i++) {
 		if (j > symbols_count) {
  			bprintf (""mach0-get-symbols: error\n"");
  			break;
  		}
		if (parse_import_stub(bin, &symbols[j], i))
 		if (parse_import_stub(bin, &symbols[j], i)) {
  			symbols[j++].last = 0;
 		}
  	}
  
  #if 1
 	for (i = 0; i < bin->nsymtab; i++) {
 		struct MACH0_(nlist) *st = &bin->symtab[i];
 #if 0
 		bprintf (""stridx %d -> section %d type %d value = %d\n"",
 			st->n_strx, st->n_sect, st->n_type, st->n_value);
 #endif
 		stridx = st->n_strx;
 		if (stridx >= 0 && stridx < bin->symstrlen) {
 			symstr = (char*)bin->symstr + stridx;
 		} else {
 			symstr = ""???"";
 		}
 		int section = st->n_sect;
 		if (section == 1 && j < symbols_count) {  
 			 
 			symbols[j].addr = st->n_value;  
 			symbols[j].offset = addr_to_offset (bin, symbols[j].addr);
 			symbols[j].size = 0;  
 			if (st->n_type & N_EXT) {
 				symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;
 			} else {
 				symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;
 			}
 			strncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);
 			symbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;
 			symbols[j].last = 0;
 			if (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {
 				symbols[j].name[0] = 0;
 			} else {
 				j++;
 			}
 		}
 	}
 #endif
 	sdb_ht_free (hash);
 	symbols[j].last = 1;
 	return symbols;
 }","[121, 123, 120]",The parse_import_ptr() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted Mach-O file.
201432,"  int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
  {
	u16 offset = sizeof(struct ipv6hdr);
 	unsigned int offset = sizeof(struct ipv6hdr);
  	unsigned int packet_len = skb_tail_pointer(skb) -
  		skb_network_header(skb);
  	int found_rhdr = 0;
  	*nexthdr = &ipv6_hdr(skb)->nexthdr;
  
  	while (offset <= packet_len) {
  		struct ipv6_opt_hdr *exthdr;
 		unsigned int len;
  
  		switch (**nexthdr) {
  
 		case NEXTHDR_HOP:
 			break;
 		case NEXTHDR_ROUTING:
 			found_rhdr = 1;
 			break;
 		case NEXTHDR_DEST:
 #if IS_ENABLED(CONFIG_IPV6_MIP6)
 			if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)
 				break;
 #endif
 			if (found_rhdr)
 				return offset;
 			break;
 		default:
 			return offset;
 		}
 
 		if (offset + sizeof(struct ipv6_opt_hdr) > packet_len)
 			return -EINVAL;
  
  		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
  						 offset);
		offset += ipv6_optlen(exthdr);
 		len = ipv6_optlen(exthdr);
 		if (len + offset >= IPV6_MAXPLEN)
 			return -EINVAL;
 		offset += len;
  		*nexthdr = &exthdr->nexthdr;
  	}
  
 	return -EINVAL;
 }","[4, 12, 39, 40, 41, 42, 3, 38]",The ip6_find_1stfragopt function in net/ipv6/output_core.c in the Linux kernel through 4.12.3 allows local users to cause a denial of service (integer overflow and infinite loop) by leveraging the ability to open a raw socket.
207118,"  void GCInfoTable::EnsureGCInfoIndex(const GCInfo* gc_info,
                                      size_t* gc_info_index_slot) {
    DCHECK(gc_info);
    DCHECK(gc_info_index_slot);
  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());
  MutexLocker locker(mutex);
 
    
    
    
   MutexLocker locker(table_mutex_);
  
    if (*gc_info_index_slot)
      return;
  
  int index = ++gc_info_index_;
   int index = ++current_index_;
    size_t gc_info_index = static_cast<size_t>(index);
    CHECK(gc_info_index < GCInfoTable::kMaxIndex);
  if (gc_info_index >= gc_info_table_size_)
   if (current_index_ >= limit_)
      Resize();
  
  g_gc_info_table[gc_info_index] = gc_info;
   table_[gc_info_index] = gc_info;
    ReleaseStore(reinterpret_cast<int*>(gc_info_index_slot), index);
  }","[7, 8, 9, 10, 11, 17, 21, 25, 5, 6, 16, 20, 24]",A race condition in Oilpan in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
207262," bool DebuggerDetachFunction::RunAsync() {
   std::unique_ptr<Detach::Params> params(Detach::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
   CopyDebuggee(&debuggee_, params->target);
    if (!InitClientHost())
      return false;
  
   client_host_->RespondDetachedToPendingRequests();
    client_host_->Close();
    SendResponse(true);
    return true;
 }",[9],Allowing the chrome.debugger API to attach to Web UI pages in DevTools in Google Chrome prior to 67.0.3396.62 allowed an attacker who convinced a user to install a malicious extension to execute arbitrary code via a crafted Chrome Extension.
201294," static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define SkipLinesOp  0x01
 #define SetColorOp  0x02
 #define SkipPixelsOp  0x03
  #define ByteDataOp  0x05
  #define RunDataOp  0x06
  #define EOFOp  0x07
 #define ThrowRLEException(exception,message) \
 { \
   if (colormap != (unsigned char *) NULL) \
     colormap=(unsigned char *) RelinquishMagickMemory(colormap); \
   if (pixel_info != (MemoryInfo *) NULL) \
     pixel_info=RelinquishVirtualMemory(pixel_info); \
   ThrowReaderException((exception),(message)); \
 }
 
  
    char
      magick[12];
 
   Image
     *image;
 
   IndexPacket
     index;
 
   int
     opcode,
     operand,
     status;
 
   MagickStatusType
     flags;
 
   MagickSizeType
     number_pixels;
 
   MemoryInfo
     *pixel_info;
 
   register IndexPacket
     *indexes;
 
   register ssize_t
     x;
 
   register PixelPacket
     *q;
 
   register ssize_t
     i;
 
   register unsigned char
     *p;
 
   size_t
     bits_per_pixel,
     map_length,
     number_colormaps,
     number_planes,
     number_planes_filled,
     one,
     pixel_info_length;
 
   ssize_t
     count,
     offset,
     y;
 
   unsigned char
     background_color[256],
     *colormap,
     pixel,
     plane,
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(DestroyImageList(image));
     
   colormap=(unsigned char *) NULL;
   pixel_info=(MemoryInfo *) NULL;
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   do
   {
       
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
     image->page.x=(ssize_t) ReadBlobLSBShort(image);
     image->page.y=(ssize_t) ReadBlobLSBShort(image);
      image->columns=ReadBlobLSBShort(image);
      image->rows=ReadBlobLSBShort(image);
      flags=(MagickStatusType) ReadBlobByte(image);
     image->matte=flags & 0x04 ? MagickTrue : MagickFalse;
     number_planes=(size_t) ReadBlobByte(image);
     bits_per_pixel=(size_t) ReadBlobByte(image);
     number_colormaps=(size_t) ReadBlobByte(image);
      map_length=(unsigned char) ReadBlobByte(image);
      if (map_length >= 22)
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     if (EOFBlob(image) != MagickFalse)
       ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
      one=1;
      map_length=one << map_length;
      if ((number_planes == 0) || (number_planes == 2) ||
         ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
         (image->columns == 0))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     if (flags & 0x02)
       {
          
         for (i=0; i < (ssize_t) number_planes; i++)
           background_color[i]=0;
         (void) ReadBlobByte(image);
       }
     else
       {
          
         p=background_color;
         for (i=0; i < (ssize_t) number_planes; i++)
           *p++=(unsigned char) ReadBlobByte(image);
       }
      if ((number_planes & 0x01) == 0)
        (void) ReadBlobByte(image);
      if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
       ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
      colormap=(unsigned char *) NULL;
      if (number_colormaps != 0)
        {
          
         colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
           3*map_length*sizeof(*colormap));
         if (colormap == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          p=colormap;
          for (i=0; i < (ssize_t) number_colormaps; i++)
            for (x=0; x < (ssize_t) map_length; x++)
           {
              *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(
                ReadBlobLSBShort(image)));
             if (EOFBlob(image) != MagickFalse)
               ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
           }
        }
      if ((flags & 0x08) != 0)
        {
         char
           *comment;
 
         size_t
           length;
 
          
         length=ReadBlobLSBShort(image);
         if (length != 0)
           {
             comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
             if (comment == (char *) NULL)
               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
             (void) ReadBlob(image,length-1,(unsigned char *) comment);
             comment[length-1]='\0';
             (void) SetImageProperty(image,""comment"",comment);
             comment=DestroyString(comment);
             if ((length & 0x01) == 0)
               (void) ReadBlobByte(image);
            }
        }
      if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
       ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
      if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
        if (image->scene >= (image_info->scene+image_info->number_scenes-1))
          break;
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }
      
     if (image->matte != MagickFalse)
       number_planes++;
     number_pixels=(MagickSizeType) image->columns*image->rows;
     number_planes_filled=(number_planes % 2 == 0) ? number_planes :
       number_planes+1;
     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
          number_planes_filled))
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info=AcquireVirtualMemory(image->columns,image->rows*
       MagickMax(number_planes_filled,4)*sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     (void) ResetMagickMemory(pixels,0,pixel_info_length);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t
           j;
 
          
         p=pixels;
         for (i=0; i < (ssize_t) number_pixels; i++)
         {
           if (image->matte == MagickFalse)
             for (j=0; j < (ssize_t) number_planes; j++)
               *p++=background_color[j];
           else
             {
               for (j=0; j < (ssize_t) (number_planes-1); j++)
                 *p++=background_color[j];
               *p++=0;   
             }
         }
       }
      
     plane=0;
      x=0;
      y=0;
      opcode=ReadBlobByte(image);
     if (opcode == EOF)
       ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
      do
      {
        switch (opcode & 0x3f)
        {
          case SkipLinesOp:
          {
            operand=ReadBlobByte(image);
           if (opcode == EOF)
             ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
             {
               operand=ReadBlobLSBSignedShort(image);
               if (opcode == EOF)
                 ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
             }
            x=0;
            y+=operand;
            break;
          }
          case SetColorOp:
          {
            operand=ReadBlobByte(image);
           if (opcode == EOF)
             ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            plane=(unsigned char) operand;
            if (plane == 255)
              plane=(unsigned char) (number_planes-1);
           x=0;
           break;
         }
          case SkipPixelsOp:
          {
            operand=ReadBlobByte(image);
           if (opcode == EOF)
             ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
             {
               operand=ReadBlobLSBSignedShort(image);
               if (opcode == EOF)
                 ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
             }
            x+=operand;
            break;
          }
          case ByteDataOp:
          {
            operand=ReadBlobByte(image);
           if (opcode == EOF)
             ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
             {
               operand=ReadBlobLSBSignedShort(image);
               if (opcode == EOF)
                 ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
             }
           offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*
             number_planes+plane);
            operand++;
            if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
               ((offset+operand*number_planes) > (ssize_t) pixel_info_length))
              {
                if (number_colormaps != 0)
                  colormap=(unsigned char *) RelinquishMagickMemory(colormap);
               pixel_info=RelinquishVirtualMemory(pixel_info);
               ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
             }
           p=pixels+offset;
           for (i=0; i < (ssize_t) operand; i++)
           {
             pixel=(unsigned char) ReadBlobByte(image);
             if ((y < (ssize_t) image->rows) &&
                 ((x+i) < (ssize_t) image->columns))
               *p=pixel;
             p+=number_planes;
           }
           if (operand & 0x01)
             (void) ReadBlobByte(image);
           x+=operand;
           break;
         }
          case RunDataOp:
          {
            operand=ReadBlobByte(image);
           if (opcode == EOF)
             ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
             {
               operand=ReadBlobLSBSignedShort(image);
               if (opcode == EOF)
                 ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
             }
            pixel=(unsigned char) ReadBlobByte(image);
            (void) ReadBlobByte(image);
            operand++;
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
           offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*
             number_planes+plane);
            if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
               ((offset+operand*number_planes) > (ssize_t) pixel_info_length))
              {
                if (number_colormaps != 0)
                  colormap=(unsigned char *) RelinquishMagickMemory(colormap);
               pixel_info=RelinquishVirtualMemory(pixel_info);
               ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
             }
           p=pixels+offset;
           for (i=0; i < (ssize_t) operand; i++)
           {
             if ((y < (ssize_t) image->rows) &&
                 ((x+i) < (ssize_t) image->columns))
               *p=pixel;
             p+=number_planes;
           }
           x+=operand;
           break;
         }
         default:
            break;
        }
        opcode=ReadBlobByte(image);
       if (opcode == EOF)
         ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
      } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
      if (number_colormaps != 0)
        {
         MagickStatusType
           mask;
 
          
         mask=(MagickStatusType) (map_length-1);
         p=pixels;
         x=(ssize_t) number_planes;
          if (number_colormaps == 1)
            for (i=0; i < (ssize_t) number_pixels; i++)
            {
            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==
             if (IsValidColormapIndex(image,(ssize_t) (*p & mask),&index,exception) ==
                  MagickFalse)
                break;
              *p=colormap[(ssize_t) index];
             p++;
           }
         else
           if ((number_planes >= 3) && (number_colormaps >= 3))
              for (i=0; i < (ssize_t) number_pixels; i++)
                for (x=0; x < (ssize_t) number_planes; x++)
                {
                if (IsValidColormapIndex(image,(size_t) (x*map_length+
                 if (IsValidColormapIndex(image,(ssize_t) (x*map_length+
                      (*p & mask)),&index,exception) == MagickFalse)
                    break;
                  *p=colormap[(ssize_t) index];
                 p++;
               }
         if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
           {
             colormap=(unsigned char *) RelinquishMagickMemory(colormap);
             pixel_info=RelinquishVirtualMemory(pixel_info);
             ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
           }
       }
      
     if (number_planes >= 3)
       {
          
         p=pixels;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(q,ScaleCharToQuantum(*p++));
             SetPixelGreen(q,ScaleCharToQuantum(*p++));
             SetPixelBlue(q,ScaleCharToQuantum(*p++));
             if (image->matte != MagickFalse)
               SetPixelAlpha(q,ScaleCharToQuantum(*p++));
             q++;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
       }
     else
       {
          
         if (number_colormaps == 0)
           map_length=256;
         if (AcquireImageColormap(image,map_length) == MagickFalse)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         p=colormap;
         if (number_colormaps == 1)
           for (i=0; i < (ssize_t) image->colors; i++)
           {
              
             image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);
             image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);
             image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);
           }
         else
           if (number_colormaps > 1)
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               image->colormap[i].red=ScaleCharToQuantum(*p);
               image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));
               image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));
               p++;
             }
         p=pixels;
         if (image->matte == MagickFalse)
           {
              
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (PixelPacket *) NULL)
                 break;
               indexes=GetAuthenticIndexQueue(image);
               for (x=0; x < (ssize_t) image->columns; x++)
                 SetPixelIndex(indexes+x,*p++);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             (void) SyncImage(image);
           }
         else
           {
              
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (PixelPacket *) NULL)
                  break;
                for (x=0; x < (ssize_t) image->columns; x++)
                {
                if (IsValidColormapIndex(image,*p++,&index,exception) ==
                 if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==
                      MagickFalse)
                    break;
                  SetPixelRed(q,image->colormap[(ssize_t) index].red);
                if (IsValidColormapIndex(image,*p++,&index,exception) ==
                 if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==
                      MagickFalse)
                    break;
                  SetPixelGreen(q,image->colormap[(ssize_t) index].green);
                if (IsValidColormapIndex(image,*p++,&index,exception) ==
                 if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==
                      MagickFalse)
                    break;
                  SetPixelBlue(q,image->colormap[(ssize_t) index].blue);
                 SetPixelAlpha(q,ScaleCharToQuantum(*p++));
                 q++;
               }
               if (x < (ssize_t) image->columns)
                 break;
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             image->colormap=(PixelPacket *) RelinquishMagickMemory(
               image->colormap);
             image->storage_class=DirectClass;
             image->colors=0;
           }
       }
     if (number_colormaps != 0)
       colormap=(unsigned char *) RelinquishMagickMemory(colormap);
     pixel_info=RelinquishVirtualMemory(pixel_info);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     (void) ReadBlobByte(image);
     count=ReadBlob(image,2,(unsigned char *) magick);
     if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
       {
          
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[9, 10, 11, 12, 13, 14, 15, 16, 17, 91, 92, 101, 102, 113, 114, 143, 155, 158, 159, 160, 191, 243, 244, 252, 253, 256, 257, 258, 259, 260, 268, 269, 279, 280, 283, 284, 285, 286, 287, 294, 295, 300, 301, 302, 303, 304, 305, 306, 310, 334, 335, 338, 339, 340, 341, 342, 348, 349, 352, 374, 375, 390, 402, 505, 510, 515, 99, 100, 138, 139, 140, 141, 142, 186, 187, 188, 189, 190, 255, 282, 297, 298, 299, 309, 337, 346, 347, 351, 389, 401, 504, 509, 514]","In ImageMagick 7.0.5-5, a crafted RLE image can trigger a crash because of incorrect EOF handling in coders/rle.c."
206883," void BaseRenderingContext2D::Reset() {
   ValidateStateStack();
   UnwindStateStack();
   state_stack_.resize(1);
   state_stack_.front() = CanvasRenderingContext2DState::Create();
   path_.Clear();
   if (PaintCanvas* c = ExistingDrawingCanvas()) {
     DCHECK_EQ(c->getSaveCount(), 2);
     c->restore();
     c->save();
     DCHECK(c->getTotalMatrix().isIdentity());
 #if DCHECK_IS_ON()
     SkIRect clip_bounds;
     DCHECK(c->getDeviceClipBounds(&clip_bounds));
     DCHECK(clip_bounds == c->imageInfo().bounds());
  #endif
    }
    ValidateStateStack();
   origin_tainted_by_content_ = false;
  }",[19],Displacement map filters being applied to cross-origin images in Blink SVG rendering in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
205040," void RenderLayerCompositor::frameViewDidScroll()
 {
     FrameView* frameView = m_renderView->frameView();
     IntPoint scrollPosition = frameView->scrollPosition();
 
     if (!m_scrollLayer)
         return;
 
     bool scrollingCoordinatorHandlesOffset = false;
     if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {
         if (Settings* settings = m_renderView->document().settings()) {
             if (isMainFrame() || settings->compositedScrollingForFramesEnabled())
                 scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);
         }
     }
 
     if (scrollingCoordinatorHandlesOffset)
         m_scrollLayer->setPosition(-frameView->minimumScrollPosition());
     else
         m_scrollLayer->setPosition(-scrollPosition);
 
 
     blink::Platform::current()->histogramEnumeration(""Renderer.AcceleratedFixedRootBackground"",
         ScrolledMainFrameBucket,
         AcceleratedFixedRootBackgroundHistogramMax);
 
      if (!m_renderView->rootBackgroundIsEntirelyFixed())
          return;
  
      
      
     DisableCompositingQueryAsserts disabler;
 
      blink::Platform::current()->histogramEnumeration(""Renderer.AcceleratedFixedRootBackground"",
          !!fixedRootBackgroundLayer()
              ? ScrolledMainFrameWithAcceleratedFixedRootBackground
             : ScrolledMainFrameWithUnacceleratedFixedRootBackground,
         AcceleratedFixedRootBackgroundHistogramMax);
 }","[30, 31, 32, 33]","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allows remote attackers to cause a denial of service (incorrect read operation) via crafted data in the Matroska container format."
199883," static int fill_autodev(const struct lxc_rootfs *rootfs)
 {
 	int ret;
 	char path[MAXPATHLEN];
 	int i;
 	mode_t cmask;
 
 	INFO(""Creating initial consoles under container /dev"");
 
 	ret = snprintf(path, MAXPATHLEN, ""%s/dev"", rootfs->path ? rootfs->mount : """");
 	if (ret < 0 || ret >= MAXPATHLEN) {
 		ERROR(""Error calculating container /dev location"");
 		return -1;
 	}
 
 	if (!dir_exists(path))   
 		return 0;
 
 	INFO(""Populating container /dev"");
 	cmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);
 	for (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {
 		const struct lxc_devs *d = &lxc_devs[i];
 		ret = snprintf(path, MAXPATHLEN, ""%s/dev/%s"", rootfs->path ? rootfs->mount : """", d->name);
 		if (ret < 0 || ret >= MAXPATHLEN)
 			return -1;
 		ret = mknod(path, d->mode, makedev(d->maj, d->min));
 		if (ret && errno != EEXIST) {
 			char hostpath[MAXPATHLEN];
 			FILE *pathfile;
 
 			ret = snprintf(hostpath, MAXPATHLEN, ""/dev/%s"", d->name);
 			if (ret < 0 || ret >= MAXPATHLEN)
 				return -1;
 			pathfile = fopen(path, ""wb"");
 			if (!pathfile) {
 				SYSERROR(""Failed to create device mount target '%s'"", path);
  				return -1;
  			}
  			fclose(pathfile);
			if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {
 			if (safe_mount(hostpath, path, 0, MS_BIND, NULL,
 						rootfs->path ? rootfs->mount : NULL) != 0) {
  				SYSERROR(""Failed bind mounting device %s from host into container"",
  					d->name);
  				return -1;
 			}
 		}
 	}
 	umask(cmask);
 
 	INFO(""Populated container /dev"");
 	return 0;
 }","[41, 42, 40]",lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.
9460,"xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
xmlIDTablePtr table;
xmlIDPtr id;
xmlChar *ID;

if (doc == NULL) return(-1);
if (attr == NULL) return(-1);

table = (xmlIDTablePtr) doc->ids;
if (table == NULL)
return(-1);

ID = xmlNodeListGetString(doc, attr->children, 1);
if (ID == NULL)
return(-1);

id = xmlHashLookup(table, ID);
if (id == NULL || id->attr != attr) {
xmlFree(ID);
return(-1);
}

xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
xmlFree(ID);
attr->atype = 0;
return(0);
}",[17],valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.
201807," MagickBooleanType sixel_decode(unsigned char                 *p,          
                                unsigned char                **pixels,    
                                size_t                       *pwidth,     
                                size_t                       *pheight,    
                                unsigned char                **palette,   
                                size_t                       *ncolors     )
 {
     int n, i, r, g, b, sixel_vertical_mask, c;
     int posision_x, posision_y;
     int max_x, max_y;
     int attributed_pan, attributed_pad;
     int attributed_ph, attributed_pv;
     int repeat_count, color_index, max_color_index = 2, background_color_index;
     int param[10];
     int sixel_palet[SIXEL_PALETTE_MAX];
     unsigned char *imbuf, *dmbuf;
     int imsx, imsy;
     int dmsx, dmsy;
     int y;
 
     posision_x = posision_y = 0;
     max_x = max_y = 0;
     attributed_pan = 2;
     attributed_pad = 1;
     attributed_ph = attributed_pv = 0;
     repeat_count = 1;
     color_index = 0;
     background_color_index = 0;
  
      imsx = 2048;
      imsy = 2048;
    imbuf = (unsigned char *) AcquireQuantumMemory(imsx * imsy,1);
     imbuf = (unsigned char *) AcquireQuantumMemory(imsx , imsy);
  
      if (imbuf == NULL) {
          return(MagickFalse);
     }
 
     for (n = 0; n < 16; n++) {
         sixel_palet[n] = sixel_default_color_table[n];
     }
 
      
     for (r = 0; r < 6; r++) {
         for (g = 0; g < 6; g++) {
             for (b = 0; b < 6; b++) {
                 sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);
             }
         }
     }
      
     for (i = 0; i < 24; i++) {
         sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);
     }
 
     for (; n < SIXEL_PALETTE_MAX; n++) {
          sixel_palet[n] = SIXEL_RGB(255, 255, 255);
      }
  
    (void) ResetMagickMemory(imbuf, background_color_index, imsx * imsy);
     (void) ResetMagickMemory(imbuf, background_color_index, (size_t) imsx * imsy);
  
      while (*p != '\0') {
          if ((p[0] == '\033' && p[1] == 'P') || *p == 0x90) {
             if (*p == '\033') {
                 p++;
             }
 
             p = get_params(++p, param, &n);
 
             if (*p == 'q') {
                 p++;
 
                 if (n > 0) {         
                     switch(param[0]) {
                     case 0:
                     case 1:
                         attributed_pad = 2;
                         break;
                     case 2:
                         attributed_pad = 5;
                         break;
                     case 3:
                         attributed_pad = 4;
                         break;
                     case 4:
                         attributed_pad = 4;
                         break;
                     case 5:
                         attributed_pad = 3;
                         break;
                     case 6:
                         attributed_pad = 3;
                         break;
                     case 7:
                         attributed_pad = 2;
                         break;
                     case 8:
                         attributed_pad = 2;
                         break;
                     case 9:
                         attributed_pad = 1;
                         break;
                     }
                 }
 
                 if (n > 2) {         
                     if (param[2] == 0) {
                         param[2] = 10;
                     }
                     attributed_pan = attributed_pan * param[2] / 10;
                     attributed_pad = attributed_pad * param[2] / 10;
                     if (attributed_pan <= 0) attributed_pan = 1;
                     if (attributed_pad <= 0) attributed_pad = 1;
                 }
             }
 
         } else if ((p[0] == '\033' && p[1] == '\\') || *p == 0x9C) {
             break;
         } else if (*p == '""') {
              
             p = get_params(++p, param, &n);
 
             if (n > 0) attributed_pad = param[0];
             if (n > 1) attributed_pan = param[1];
             if (n > 2 && param[2] > 0) attributed_ph = param[2];
             if (n > 3 && param[3] > 0) attributed_pv = param[3];
 
             if (attributed_pan <= 0) attributed_pan = 1;
             if (attributed_pad <= 0) attributed_pad = 1;
 
              if (imsx < attributed_ph || imsy < attributed_pv) {
                  dmsx = imsx > attributed_ph ? imsx : attributed_ph;
                  dmsy = imsy > attributed_pv ? imsy : attributed_pv;
                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);
                 dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);
                  if (dmbuf == (unsigned char *) NULL) {
                      imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
                      return (MagickFalse);
                  }
                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);
                 (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);
                  for (y = 0; y < imsy; ++y) {
                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);
                     (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + (size_t) imsx * y, imsx);
                  }
                  imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
                  imsx = dmsx;
                 imsy = dmsy;
                 imbuf = dmbuf;
             }
 
         } else if (*p == '!') {
              
             p = get_params(++p, param, &n);
 
             if (n > 0) {
                 repeat_count = param[0];
             }
 
         } else if (*p == '#') {
              
             p = get_params(++p, param, &n);
 
             if (n > 0) {
                 if ((color_index = param[0]) < 0) {
                     color_index = 0;
                 } else if (color_index >= SIXEL_PALETTE_MAX) {
                     color_index = SIXEL_PALETTE_MAX - 1;
                 }
             }
 
             if (n > 4) {
                 if (param[1] == 1) {             
                     if (param[2] > 360) param[2] = 360;
                     if (param[3] > 100) param[3] = 100;
                     if (param[4] > 100) param[4] = 100;
                     sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);
                 } else if (param[1] == 2) {     
                     if (param[2] > 100) param[2] = 100;
                     if (param[3] > 100) param[3] = 100;
                     if (param[4] > 100) param[4] = 100;
                     sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);
                 }
             }
 
         } else if (*p == '$') {
              
             p++;
             posision_x = 0;
             repeat_count = 1;
 
         } else if (*p == '-') {
              
             p++;
             posision_x  = 0;
             posision_y += 6;
             repeat_count = 1;
 
         } else if (*p >= '?' && *p <= '\177') {
             if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {
                 int nx = imsx * 2;
                 int ny = imsy * 2;
 
                 while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {
                     nx *= 2;
                     ny *= 2;
                 }
  
                  dmsx = nx;
                  dmsy = ny;
                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);
                 dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);
                  if (dmbuf == (unsigned char *) NULL) {
                      imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
                      return (MagickFalse);
                  }
                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);
                 (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);
                  for (y = 0; y < imsy; ++y) {
                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);
                     (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + (size_t) imsx * y, imsx);
                  }
                  imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
                  imsx = dmsx;
                 imsy = dmsy;
                 imbuf = dmbuf;
             }
 
             if (color_index > max_color_index) {
                 max_color_index = color_index;
             }
             if ((b = *(p++) - '?') == 0) {
                 posision_x += repeat_count;
 
             } else {
                 sixel_vertical_mask = 0x01;
 
                 if (repeat_count <= 1) {
                     for (i = 0; i < 6; i++) {
                         if ((b & sixel_vertical_mask) != 0) {
                             imbuf[imsx * (posision_y + i) + posision_x] = color_index;
                             if (max_x < posision_x) {
                                 max_x = posision_x;
                             }
                             if (max_y < (posision_y + i)) {
                                 max_y = posision_y + i;
                             }
                         }
                         sixel_vertical_mask <<= 1;
                     }
                     posision_x += 1;
 
                 } else {  
                     for (i = 0; i < 6; i++) {
                         if ((b & sixel_vertical_mask) != 0) {
                             c = sixel_vertical_mask << 1;
                             for (n = 1; (i + n) < 6; n++) {
                                 if ((b & c) == 0) {
                                     break;
                                 }
                                  c <<= 1;
                              }
                              for (y = posision_y + i; y < posision_y + i + n; ++y) {
                                (void) ResetMagickMemory(imbuf + imsx * y + posision_x, color_index, repeat_count);
                                 (void) ResetMagickMemory(imbuf + (size_t) imsx * y + posision_x, color_index, repeat_count);
                              }
                              if (max_x < (posision_x + repeat_count - 1)) {
                                  max_x = posision_x + repeat_count - 1;
                             }
                             if (max_y < (posision_y + i + n - 1)) {
                                 max_y = posision_y + i + n - 1;
                             }
 
                             i += (n - 1);
                             sixel_vertical_mask <<= (n - 1);
                         }
                         sixel_vertical_mask <<= 1;
                     }
                     posision_x += repeat_count;
                 }
             }
             repeat_count = 1;
         } else {
             p++;
         }
     }
 
     if (++max_x < attributed_ph) {
         max_x = attributed_ph;
     }
     if (++max_y < attributed_pv) {
         max_y = attributed_pv;
     }
 
      if (imsx > max_x || imsy > max_y) {
          dmsx = max_x;
          dmsy = max_y;
        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1)) == NULL) {
         if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy)) == NULL) {
              imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
              return (MagickFalse);
          }
         for (y = 0; y < dmsy; ++y) {
             (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);
         }
         imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
         imsx = dmsx;
         imsy = dmsy;
         imbuf = dmbuf;
     }
 
     *pixels = imbuf;
     *pwidth = imsx;
     *pheight = imsy;
     *ncolors = max_color_index + 1;
     *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);
     for (n = 0; n < (ssize_t) *ncolors; ++n) {
         (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;
         (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;
         (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;
         (*palette)[n * 4 + 3] = 0xff;
     }
     return(MagickTrue);
 }","[33, 61, 136, 142, 145, 213, 219, 222, 266, 300, 32, 60, 135, 141, 144, 212, 218, 221, 265, 299]",Buffer overflow in the WriteGROUP4Image function in coders/tiff.c in ImageMagick before 6.9.5-8 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.
207019,"  ExtensionsGuestViewMessageFilter::ExtensionsGuestViewMessageFilter(
      int render_process_id,
     BrowserContext* context)
     : GuestViewMessageFilter(kFilteredMessageClasses,
                              base::size(kFilteredMessageClasses),
                               render_process_id,
                               context),
        content::BrowserAssociatedInterface<mojom::GuestView>(this, this) {
  GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);
  }",[9],Data race in extensions guest view in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
199246," static int key_notify_policy_flush(const struct km_event *c)
 {
 	struct sk_buff *skb_out;
 	struct sadb_msg *hdr;
 
 	skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
 	if (!skb_out)
 		return -ENOBUFS;
 	hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
 	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
 	hdr->sadb_msg_seq = c->seq;
 	hdr->sadb_msg_pid = c->portid;
 	hdr->sadb_msg_version = PF_KEY_V2;
  	hdr->sadb_msg_errno = (uint8_t) 0;
  	hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;
  	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr->sadb_msg_reserved = 0;
  	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
  	return 0;
  
 }",[17],"The (1) key_notify_sa_flush and (2) key_notify_policy_flush functions in net/key/af_key.c in the Linux kernel before 3.10 do not initialize certain structure members, which allows local users to obtain sensitive information from kernel heap memory by reading a broadcast message from the notify interface of an IPSec key_socket."
6123,"repodata_schema2id(Repodata *data, Id *schema, int create)
{
int h, len, i;
Id *sp, cid;
Id *schematahash;

if (!*schema)
return 0;
if ((schematahash = data->schematahash) == 0)
{
data->schematahash = schematahash = solv_calloc(256, sizeof(Id));
for (i = 1; i < data->nschemata; i++)
{
for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)
h = h * 7 + *sp++;
h &= 255;
schematahash[h] = i;
}
data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);
data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);
}

for (sp = schema, len = 0, h = 0; *sp; len++)
h = h * 7 + *sp++;
h &= 255;
len++;

cid = schematahash[h];
if (cid)
{
if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
return cid;

for (cid = 1; cid < data->nschemata; cid++)
if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
return cid;
}

if (!create)
return 0;
data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);
data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);

memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));
data->schemata[data->nschemata] = data->schemadatalen;
data->schemadatalen += len;
schematahash[h] = data->nschemata;
#if 0
fprintf(stderr, ""schema2id: new schema\n"");
#endif
return data->nschemata++;
}","[31, 35]",repodata_schema2id in repodata.c in libsolv before 0.7.6 has a heap-based buffer over-read via a last schema whose length is less than the length of the input schema.
199700," static int hashtable_do_del(hashtable_t *hashtable,
                             const char *key, size_t hash)
 {
     pair_t *pair;
      bucket_t *bucket;
      size_t index;
  
    index = hash % num_buckets(hashtable);
     index = hash & hashmask(hashtable->order);
      bucket = &hashtable->buckets[index];
  
      pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
         return -1;
 
     if(&pair->list == bucket->first && &pair->list == bucket->last)
         bucket->first = bucket->last = &hashtable->list;
 
     else if(&pair->list == bucket->first)
         bucket->first = pair->list.next;
 
     else if(&pair->list == bucket->last)
         bucket->last = pair->list.prev;
 
     list_remove(&pair->list);
     json_decref(pair->value);
 
     jsonp_free(pair);
     hashtable->size--;
 
     return 0;
 }","[9, 8]","Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document."
198849," asmlinkage void __sched schedule(void)
 {
 	struct task_struct *prev, *next;
 	unsigned long *switch_count;
 	struct rq *rq;
 	int cpu;
 
 need_resched:
 	preempt_disable();
 	cpu = smp_processor_id();
 	rq = cpu_rq(cpu);
 	rcu_note_context_switch(cpu);
 	prev = rq->curr;
 
 	release_kernel_lock(prev);
 need_resched_nonpreemptible:
 
 	schedule_debug(prev);
 
 	if (sched_feat(HRTICK))
  		hrtick_clear(rq);
  
  	raw_spin_lock_irq(&rq->lock);
	clear_tsk_need_resched(prev);
  
  	switch_count = &prev->nivcsw;
  	if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {
 		if (unlikely(signal_pending_state(prev->state, prev))) {
 			prev->state = TASK_RUNNING;
 		} else {
 			 
 			if (prev->flags & PF_WQ_WORKER) {
 				struct task_struct *to_wakeup;
 
 				to_wakeup = wq_worker_sleeping(prev, cpu);
 				if (to_wakeup)
 					try_to_wake_up_local(to_wakeup);
 			}
 			deactivate_task(rq, prev, DEQUEUE_SLEEP);
 		}
 		switch_count = &prev->nvcsw;
 	}
 
 	pre_schedule(rq, prev);
 
 	if (unlikely(!rq->nr_running))
 		idle_balance(cpu, rq);
  
  	put_prev_task(rq, prev);
  	next = pick_next_task(rq);
 	clear_tsk_need_resched(prev);
 	rq->skip_clock_update = 0;
  
  	if (likely(prev != next)) {
  		sched_info_switch(prev, next);
 		perf_event_task_sched_out(prev, next);
 
  		rq->nr_switches++;
  		rq->curr = next;
  		++*switch_count;
 		WARN_ON_ONCE(test_tsk_need_resched(next));
  
  		context_switch(rq, prev, next);  
  		 
 		cpu = smp_processor_id();
 		rq = cpu_rq(cpu);
 	} else
 		raw_spin_unlock_irq(&rq->lock);
 
 	post_schedule(rq);
 
 	if (unlikely(reacquire_kernel_lock(prev)))
 		goto need_resched_nonpreemptible;
 
 	preempt_enable_no_resched();
 	if (need_resched())
 		goto need_resched;
 }","[51, 52, 61, 24]","The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop."
2051,"xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {
assert(sxe->instanceof(SimpleXMLElement_classof()));
auto data = Native::data<SimpleXMLElement>(sxe.get());
return php_sxe_get_first_node(data, data->nodep());
}",[2],"Insufficient type checks were employed prior to casting input data in SimpleXMLElement_exportNode and simplexml_import_dom. This issue affects HHVM versions prior to 3.9.5, all versions between 3.10.0 and 3.12.3 (inclusive), and all versions between 3.13.0 and 3.14.1 (inclusive)."
207992," OMX_ERRORTYPE SoftMPEG4Encoder::initEncParams() {
     CHECK(mHandle != NULL);
     memset(mHandle, 0, sizeof(tagvideoEncControls));
 
     CHECK(mEncParams != NULL);
     memset(mEncParams, 0, sizeof(tagvideoEncOptions));
  if (!PVGetDefaultEncOption(mEncParams, 0)) {
         ALOGE(""Failed to get default encoding parameters"");
  return OMX_ErrorUndefined;
  }
     mEncParams->encMode = mEncodeMode;
     mEncParams->encWidth[0] = mWidth;
     mEncParams->encHeight[0] = mHeight;
     mEncParams->encFrameRate[0] = mFramerate >> 16;  
     mEncParams->rcType = VBR_1;
     mEncParams->vbvDelay = 5.0f;
 
     mEncParams->profile_level = CORE_PROFILE_LEVEL2;
     mEncParams->packetSize = 32;
     mEncParams->rvlcEnable = PV_OFF;
     mEncParams->numLayers = 1;
     mEncParams->timeIncRes = 1000;
     mEncParams->tickPerSrc = ((int64_t)mEncParams->timeIncRes << 16) / mFramerate;
 
     mEncParams->bitRate[0] = mBitrate;
     mEncParams->iQuant[0] = 15;
     mEncParams->pQuant[0] = 12;
     mEncParams->quantType[0] = 0;
     mEncParams->noFrameSkipped = PV_OFF;
 
 
      if (mColorFormat != OMX_COLOR_FormatYUV420Planar || mInputDataIsMeta) {
          free(mInputFrameData);
         mInputFrameData = NULL;
         if (((uint64_t)mWidth * mHeight) > ((uint64_t)INT32_MAX / 3)) {
             ALOGE(""b/25812794, Buffer size is too big."");
             return OMX_ErrorBadParameter;
         }
          mInputFrameData =
              (uint8_t *) malloc((mWidth * mHeight * 3 ) >> 1);
          CHECK(mInputFrameData != NULL);
  }
 
  if (mWidth % 16 != 0 || mHeight % 16 != 0) {
         ALOGE(""Video frame size %dx%d must be a multiple of 16"",
             mWidth, mHeight);
  return OMX_ErrorBadParameter;
  }
 
  if (mIDRFrameRefreshIntervalInSec < 0) {
         mEncParams->intraPeriod = -1;
  } else if (mIDRFrameRefreshIntervalInSec == 0) {
         mEncParams->intraPeriod = 1;  
  } else {
         mEncParams->intraPeriod =
  (mIDRFrameRefreshIntervalInSec * mFramerate) >> 16;
  }
 
     mEncParams->numIntraMB = 0;
     mEncParams->sceneDetect = PV_ON;
     mEncParams->searchRange = 16;
     mEncParams->mv8x8Enable = PV_OFF;
     mEncParams->gobHeaderInterval = 0;
     mEncParams->useACPred = PV_ON;
     mEncParams->intraDCVlcTh = 0;
 
  return OMX_ErrorNone;
 }","[34, 35, 36, 37, 38]","libstagefright in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49G, and 6.x before 2016-02-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation in the (1) SoftMPEG4Encoder or (2) SoftVPXEncoder component, aka internal bug 25812794."
202675," static int __net_init sit_init_net(struct net *net)
 {
 	struct sit_net *sitn = net_generic(net, sit_net_id);
 	struct ip_tunnel *t;
 	int err;
 
 	sitn->tunnels[0] = sitn->tunnels_wc;
 	sitn->tunnels[1] = sitn->tunnels_l;
 	sitn->tunnels[2] = sitn->tunnels_r;
 	sitn->tunnels[3] = sitn->tunnels_r_l;
 
 	if (!net_has_fallback_tunnels(net))
 		return 0;
 
 	sitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), ""sit0"",
 					   NET_NAME_UNKNOWN,
 					   ipip6_tunnel_setup);
 	if (!sitn->fb_tunnel_dev) {
 		err = -ENOMEM;
 		goto err_alloc_dev;
 	}
 	dev_net_set(sitn->fb_tunnel_dev, net);
 	sitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;
 	 
 	sitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;
 
 	err = register_netdev(sitn->fb_tunnel_dev);
 	if (err)
 		goto err_reg_dev;
 
 	ipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);
 	ipip6_fb_tunnel_init(sitn->fb_tunnel_dev);
 
 	t = netdev_priv(sitn->fb_tunnel_dev);
 
 	strcpy(t->parms.name, sitn->fb_tunnel_dev->name);
 	return 0;
  
  err_reg_dev:
  	ipip6_dev_free(sitn->fb_tunnel_dev);
 	free_netdev(sitn->fb_tunnel_dev);
  err_alloc_dev:
  	return err;
  }",[41],"In the Linux kernel before 5.0, a memory leak exists in sit_init_net() in net/ipv6/sit.c when register_netdev() fails to register sitn->fb_tunnel_dev, which may cause denial of service, aka CID-07f12b26e21a."
198347," static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)
 	{
 	unsigned short length;
 	unsigned short type;
 	unsigned short size;
 	unsigned char *data = *p;
 	int tlsext_servername = 0;
 	int renegotiate_seen = 0;
 
 #ifndef OPENSSL_NO_NEXTPROTONEG
 	s->s3->next_proto_neg_seen = 0;
 #endif
 
 	if (s->s3->alpn_selected)
 		{
 		OPENSSL_free(s->s3->alpn_selected);
 		s->s3->alpn_selected = NULL;
 		}
 
 #ifndef OPENSSL_NO_HEARTBEATS
 	s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
 	                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
 #endif
 
 #ifdef TLSEXT_TYPE_encrypt_then_mac
 	s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;
 #endif
 
 	if (data >= (d+n-2))
 		goto ri_check;
 
 	n2s(data,length);
 	if (data+length != d+n)
 		{
 		*al = SSL_AD_DECODE_ERROR;
 		return 0;
 		}
 
 	while(data <= (d+n-4))
 		{
 		n2s(data,type);
 		n2s(data,size);
 
 		if (data+size > (d+n))
 	   		goto ri_check;
 
 		if (s->tlsext_debug_cb)
 			s->tlsext_debug_cb(s, 1, type, data, size,
 						s->tlsext_debug_arg);
 
 		if (type == TLSEXT_TYPE_server_name)
 			{
 			if (s->tlsext_hostname == NULL || size > 0)
 				{
 				*al = TLS1_AD_UNRECOGNIZED_NAME;
 				return 0;
 				}
 			tlsext_servername = 1;   
 			}
 
 #ifndef OPENSSL_NO_EC
 		else if (type == TLSEXT_TYPE_ec_point_formats)
 			{
 			unsigned char *sdata = data;
 			int ecpointformatlist_length = *(sdata++);
 
 			if (ecpointformatlist_length != size - 1)
 				{
                                 *al = TLS1_AD_DECODE_ERROR;
                                 return 0;
                                 }
                       s->session->tlsext_ecpointformatlist_length = 0;
                       if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
                       if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
                        if (!s->hit)
                                 {
                               *al = TLS1_AD_INTERNAL_ERROR;
                               return 0;
                                s->session->tlsext_ecpointformatlist_length = 0;
                                if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
                                if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
                                        {
                                        *al = TLS1_AD_INTERNAL_ERROR;
                                        return 0;
                                        }
                                s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
                                memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
                                 }
                       s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
                       memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
  #if 0
                         fprintf(stderr,""ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist "");
                         sdata = s->session->tlsext_ecpointformatlist;
 #endif
 			}
 #endif  
 
 		else if (type == TLSEXT_TYPE_session_ticket)
 			{
 			if (s->tls_session_ticket_ext_cb &&
 			    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))
 				{
 				*al = TLS1_AD_INTERNAL_ERROR;
 				return 0;
 				}
 			if (!tls_use_ticket(s) || (size > 0))
 				{
 				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
 				return 0;
 				}
 			s->tlsext_ticket_expected = 1;
 			}
 #ifdef TLSEXT_TYPE_opaque_prf_input
 		else if (type == TLSEXT_TYPE_opaque_prf_input)
 			{
 			unsigned char *sdata = data;
 
 			if (size < 2)
 				{
 				*al = SSL_AD_DECODE_ERROR;
 				return 0;
 				}
 			n2s(sdata, s->s3->server_opaque_prf_input_len);
 			if (s->s3->server_opaque_prf_input_len != size - 2)
 				{
 				*al = SSL_AD_DECODE_ERROR;
 				return 0;
 				}
 			
 			if (s->s3->server_opaque_prf_input != NULL)  
 				OPENSSL_free(s->s3->server_opaque_prf_input);
 			if (s->s3->server_opaque_prf_input_len == 0)
 				s->s3->server_opaque_prf_input = OPENSSL_malloc(1);  
 			else
 				s->s3->server_opaque_prf_input = BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);
 
 			if (s->s3->server_opaque_prf_input == NULL)
 				{
 				*al = TLS1_AD_INTERNAL_ERROR;
 				return 0;
 				}
 			}
 #endif
 		else if (type == TLSEXT_TYPE_status_request)
 			{
 			  
 			if ((s->tlsext_status_type == -1) || (size > 0))
 				{
 				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
 				return 0;
 				}
 			 
 			s->tlsext_status_expected = 1;
 			}
 #ifndef OPENSSL_NO_NEXTPROTONEG
 		else if (type == TLSEXT_TYPE_next_proto_neg &&
 			 s->s3->tmp.finish_md_len == 0)
 			{
 			unsigned char *selected;
 			unsigned char selected_len;
 
 			 
 			if (s->ctx->next_proto_select_cb == NULL)
 				{
 				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
 				return 0;
 				}
 			 
 			if (!ssl_next_proto_validate(data, size))
 				{
 				*al = TLS1_AD_DECODE_ERROR;
 				return 0;
 				}
 			if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s->ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK)
 				{
 				*al = TLS1_AD_INTERNAL_ERROR;
 				return 0;
 				}
 			s->next_proto_negotiated = OPENSSL_malloc(selected_len);
 			if (!s->next_proto_negotiated)
 				{
 				*al = TLS1_AD_INTERNAL_ERROR;
 				return 0;
 				}
 			memcpy(s->next_proto_negotiated, selected, selected_len);
 			s->next_proto_negotiated_len = selected_len;
 			s->s3->next_proto_neg_seen = 1;
 			}
 #endif
 
 		else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation)
 			{
 			unsigned len;
 
 			 
 			if (s->alpn_client_proto_list == NULL)
 				{
 				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
 				return 0;
 				}
 			if (size < 4)
 				{
 				*al = TLS1_AD_DECODE_ERROR;
 				return 0;
 				}
 			 
 			len = data[0];
 			len <<= 8;
 			len |= data[1];
 			if (len != (unsigned) size - 2)
 				{
 				*al = TLS1_AD_DECODE_ERROR;
 				return 0;
 				}
 			len = data[2];
 			if (len != (unsigned) size - 3)
 				{
 				*al = TLS1_AD_DECODE_ERROR;
 				return 0;
 				}
 			if (s->s3->alpn_selected)
 				OPENSSL_free(s->s3->alpn_selected);
 			s->s3->alpn_selected = OPENSSL_malloc(len);
 			if (!s->s3->alpn_selected)
 				{
 				*al = TLS1_AD_INTERNAL_ERROR;
 				return 0;
 				}
 			memcpy(s->s3->alpn_selected, data + 3, len);
 			s->s3->alpn_selected_len = len;
 			}
 
 		else if (type == TLSEXT_TYPE_renegotiate)
 			{
 			if(!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
 				return 0;
 			renegotiate_seen = 1;
 			}
 #ifndef OPENSSL_NO_HEARTBEATS
 		else if (type == TLSEXT_TYPE_heartbeat)
 			{
 			switch(data[0])
 				{
 				case 0x01:	 
 							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
 							break;
 				case 0x02:	 
 							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
 							s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
 							break;
 				default:	*al = SSL_AD_ILLEGAL_PARAMETER;
 							return 0;
 				}
 			}
 #endif
 		else if (type == TLSEXT_TYPE_use_srtp)
                         {
                         if(ssl_parse_serverhello_use_srtp_ext(s, data, size,
 							      al))
                                 return 0;
                         }
 		 
 		else if (s->ctx->custom_cli_ext_records_count)
 			{
 			size_t i;
 			custom_cli_ext_record* record;
 
 			for (i = 0; i < s->ctx->custom_cli_ext_records_count; i++)
 				{
 				record = &s->ctx->custom_cli_ext_records[i];
 				if (record->ext_type == type)
 					{
 					if (record->fn2 && !record->fn2(s, type, data, size, al, record->arg))
 						return 0;
 					break;
 					}
 				}			
 			}
 #ifdef TLSEXT_TYPE_encrypt_then_mac
 		else if (type == TLSEXT_TYPE_encrypt_then_mac)
 			{
 			 
 			if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD)
 				s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;
 			}
 #endif
  
 		data += size;
 		}
 
 	if (data != d+n)
 		{
 		*al = SSL_AD_DECODE_ERROR;
 		return 0;
 		}
 
 	if (!s->hit && tlsext_servername == 1)
 		{
  		if (s->tlsext_hostname)
 			{
 			if (s->session->tlsext_hostname == NULL)
 				{
 				s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);	
 				if (!s->session->tlsext_hostname)
 					{
 					*al = SSL_AD_UNRECOGNIZED_NAME;
 					return 0;
 					}
 				}
 			else 
 				{
 				*al = SSL_AD_DECODE_ERROR;
 				return 0;
 				}
 			}
 		}
 
 	*p = data;
 
 	ri_check:
 
 	 
 	if (!renegotiate_seen
 		&& !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)
 		&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
 		{
 		*al = SSL_AD_HANDSHAKE_FAILURE;
 		SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,
 				SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
 		return 0;
 		}
 
 	return 1;
 	}","[75, 79, 80, 81, 82, 83, 84, 85, 86, 87, 72, 73, 74, 77, 78, 89, 90]","Race condition in the ssl_parse_serverhello_tlsext function in t1_lib.c in OpenSSL 1.0.0 before 1.0.0n and 1.0.1 before 1.0.1i, when multithreading and session resumption are used, allows remote SSL servers to cause a denial of service (memory overwrite and client application crash) or possibly have unspecified other impact by sending Elliptic Curve (EC) Supported Point Formats Extension data."
199048," static int __init ipip_init(void)
 {
 	int err;
  
  	printk(banner);
  
	if (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {
 	err = register_pernet_device(&ipip_net_ops);
 	if (err < 0)
 		return err;
 	err = xfrm4_tunnel_register(&ipip_handler, AF_INET);
 	if (err < 0) {
 		unregister_pernet_device(&ipip_net_ops);
  		printk(KERN_INFO ""ipip init: can't register tunnel\n"");
		return -EAGAIN;
  	}
	err = register_pernet_device(&ipip_net_ops);
	if (err)
		xfrm4_tunnel_deregister(&ipip_handler, AF_INET);
  	return err;
  }","[8, 9, 10, 11, 12, 13, 7, 15, 17, 18, 19]","The tunnels implementation in the Linux kernel before 2.6.34, when tunnel functionality is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading."
198912,"  unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,
  		      const nodemask_t *nodemask, unsigned long totalpages)
  {
	int points;
 	long points;
  
  	if (oom_unkillable_task(p, mem, nodemask))
  		return 0;
 
 	p = find_lock_task_mm(p);
 	if (!p)
 		return 0;
 
 	 
 	if (atomic_read(&p->mm->oom_disable_count)) {
 		task_unlock(p);
 		return 0;
 	}
 
 	 
 	if (!totalpages)
 		totalpages = 1;
 
 	 
 	points = get_mm_rss(p->mm) + p->mm->nr_ptes;
 	points += get_mm_counter(p->mm, MM_SWAPENTS);
 
 	points *= 1000;
 	points /= totalpages;
 	task_unlock(p);
 
 	 
 	if (has_capability_noaudit(p, CAP_SYS_ADMIN))
 		points -= 30;
 
 	 
 	points += p->signal->oom_score_adj;
 
 	 
 	if (points <= 0)
 		return 1;
 	return (points < 1000) ? points : 1000;
 }","[5, 4]",Integer overflow in the oom_badness function in mm/oom_kill.c in the Linux kernel before 3.1.8 on 64-bit platforms allows local users to cause a denial of service (memory consumption or process termination) by using a certain large amount of memory.
6097,"static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)
{
u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
unsigned long flags;
u64 expires;


raw_spin_lock_irqsave(&cfs_b->lock, flags);
cfs_b->slack_started = false;
if (cfs_b->distribute_running) {
raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
return;
}

if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {
raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
return;
}

if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)
runtime = cfs_b->runtime;

expires = cfs_b->runtime_expires;
if (runtime)
cfs_b->distribute_running = 1;

raw_spin_unlock_irqrestore(&cfs_b->lock, flags);

if (!runtime)
return;

runtime = distribute_cfs_runtime(cfs_b, runtime, expires);

raw_spin_lock_irqsave(&cfs_b->lock, flags);
if (expires == cfs_b->runtime_expires)
lsub_positive(&cfs_b->runtime, runtime);
cfs_b->distribute_running = 0;
raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
}","[5, 23, 32, 35, 36]","kernel/sched/fair.c in the Linux kernel before 5.3.9, when cpu.cfs_quota_us is used (e.g., with Kubernetes), allows attackers to cause a denial of service against non-cpu-bound applications by generating a workload that triggers unwanted slice expiration, aka CID-de53fd7aedb1. (In other words, although this slice expiration would typically be seen with benign workloads, it is possible that an attacker could calculate how many stray requests are required to force an entire Kubernetes cluster into a low-performance state caused by slice expiration, and ensure that a DDoS attack sent that number of stray requests. An attack does not affect the stability of the kernel; it only causes mismanagement of application execution.)"
207331," xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
 				 xmlNodePtr node,
  				 xsltCompMatchPtr countPat,
  				 xsltCompMatchPtr fromPat,
  				 double *array,
				 int max,
				 xmlDocPtr doc,
				 xmlNodePtr elem)
 				 int max)
  {
      int amount = 0;
      int cnt;
     xmlNodePtr ancestor;
     xmlNodePtr preceding;
     xmlXPathParserContextPtr parser;
 
     context->xpathCtxt->node = node;
     parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
     if (parser) {
 	 
 	for (ancestor = node;
 	     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
 	     ancestor = xmlXPathNextAncestor(parser, ancestor)) {
 
 	    if ((fromPat != NULL) &&
  		xsltTestCompMatchList(context, ancestor, fromPat))
  		break;  
  
	    if ((countPat == NULL && node->type == ancestor->type &&
		xmlStrEqual(node->name, ancestor->name)) ||
		xsltTestCompMatchList(context, ancestor, countPat)) {
 	    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
  		 
		cnt = 0;
		for (preceding = ancestor;
 		cnt = 1;
 		for (preceding =
                         xmlXPathNextPrecedingSibling(parser, ancestor);
  		     preceding != NULL;
  		     preceding =
  		        xmlXPathNextPrecedingSibling(parser, preceding)) {
		    if (countPat == NULL) {
			if ((preceding->type == ancestor->type) &&
			    xmlStrEqual(preceding->name, ancestor->name)){
			    if ((preceding->ns == ancestor->ns) ||
			        ((preceding->ns != NULL) &&
				 (ancestor->ns != NULL) &&
			         (xmlStrEqual(preceding->ns->href,
			             ancestor->ns->href) )))
			        cnt++;
			}
		    } else {
			if (xsltTestCompMatchList(context, preceding,
				                  countPat))
			    cnt++;
		    }
 
 	            if (xsltTestCompMatchCount(context, preceding, countPat,
                                                node))
 			cnt++;
  		}
  		array[amount++] = (double)cnt;
  		if (amount >= max)
 		    break;  
 	    }
 	}
 	xmlXPathFreeParserContext(parser);
     }
     return amount;
 }","[9, 32, 36, 37, 38, 57, 58, 59, 60, 6, 7, 8, 29, 30, 31, 34, 35, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
207276," HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(
     const CompactHTMLToken& token,
     HTMLTokenizer* tokenizer) {
   SimulatedToken simulated_token = kOtherToken;
 
   if (token.GetType() == HTMLToken::kStartTag) {
     const String& tag_name = token.Data();
     if (ThreadSafeMatch(tag_name, SVGNames::svgTag))
       namespace_stack_.push_back(SVG);
     if (ThreadSafeMatch(tag_name, MathMLNames::mathTag))
        namespace_stack_.push_back(kMathML);
      if (InForeignContent() && TokenExitsForeignContent(token))
        namespace_stack_.pop_back();
    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||
        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))
     if (IsHTMLIntegrationPointForStartTag(token) ||
         (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {
        namespace_stack_.push_back(HTML);
    if (!InForeignContent()) {
     } else if (!InForeignContent()) {
        if (ThreadSafeMatch(tag_name, textareaTag) ||
           ThreadSafeMatch(tag_name, titleTag)) {
         tokenizer->SetState(HTMLTokenizer::kRCDATAState);
       } else if (ThreadSafeMatch(tag_name, scriptTag)) {
         tokenizer->SetState(HTMLTokenizer::kScriptDataState);
         simulated_token = kScriptStart;
       } else if (ThreadSafeMatch(tag_name, linkTag)) {
         simulated_token = kLink;
       } else if (!in_select_insertion_mode_) {
         if (ThreadSafeMatch(tag_name, plaintextTag) &&
             !in_select_insertion_mode_) {
           tokenizer->SetState(HTMLTokenizer::kPLAINTEXTState);
         } else if (ThreadSafeMatch(tag_name, styleTag) ||
                    ThreadSafeMatch(tag_name, iframeTag) ||
                    ThreadSafeMatch(tag_name, xmpTag) ||
                    (ThreadSafeMatch(tag_name, noembedTag) &&
                     options_.plugins_enabled) ||
                    ThreadSafeMatch(tag_name, noframesTag) ||
                    (ThreadSafeMatch(tag_name, noscriptTag) &&
                     options_.script_enabled)) {
           tokenizer->SetState(HTMLTokenizer::kRAWTEXTState);
         }
       }
 
       if (ThreadSafeMatch(tag_name, selectTag)) {
         in_select_insertion_mode_ = true;
       } else if (in_select_insertion_mode_ && TokenExitsInSelect(token)) {
         in_select_insertion_mode_ = false;
       }
     }
   }
 
   if (token.GetType() == HTMLToken::kEndTag ||
       (token.GetType() == HTMLToken::kStartTag && token.SelfClosing() &&
        InForeignContent())) {
     const String& tag_name = token.Data();
     if ((namespace_stack_.back() == SVG &&
           ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||
          (namespace_stack_.back() == kMathML &&
           ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||
        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&
         TokenExitsSVG(token)) ||
         IsHTMLIntegrationPointForEndTag(token) ||
          (namespace_stack_.Contains(kMathML) &&
           namespace_stack_.back() == HTML && TokenExitsMath(token))) {
        namespace_stack_.pop_back();
     }
     if (ThreadSafeMatch(tag_name, scriptTag)) {
       if (!InForeignContent())
         tokenizer->SetState(HTMLTokenizer::kDataState);
       return kScriptEnd;
     } else if (ThreadSafeMatch(tag_name, selectTag)) {
       in_select_insertion_mode_ = false;
     }
     if (ThreadSafeMatch(tag_name, styleTag))
       simulated_token = kStyleEnd;
   }
 
   tokenizer->SetForceNullCharacterReplacement(InForeignContent());
   tokenizer->SetShouldAllowCDATA(InForeignContent());
    return simulated_token;
  }","[16, 17, 20, 63, 14, 15, 19, 61, 62]",Insufficient data validation in HTML parser in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to bypass same origin policy via a crafted HTML page.
204038,"  static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod12(ExecState* exec)
  {
      if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      const String& type(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
      if (exec->hadException())
          return JSValue::encode(jsUndefined());
     TestObj::overloadedMethod1(type);
     return JSValue::encode(jsUndefined());
 }","[5, 4]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
206150," png_set_IHDR(png_structp png_ptr, png_infop info_ptr,
    png_uint_32 width, png_uint_32 height, int bit_depth,
    int color_type, int interlace_type, int compression_type,
    int filter_type)
 {
    png_debug1(1, ""in %s storage function"", ""IHDR"");
 
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
    info_ptr->width = width;
    info_ptr->height = height;
    info_ptr->bit_depth = (png_byte)bit_depth;
    info_ptr->color_type = (png_byte)color_type;
    info_ptr->compression_type = (png_byte)compression_type;
    info_ptr->filter_type = (png_byte)filter_type;
    info_ptr->interlace_type = (png_byte)interlace_type;
 
    png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
        info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
        info_ptr->compression_type, info_ptr->filter_type);
 
    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       info_ptr->channels = 1;
    else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
       info_ptr->channels = 3;
    else
       info_ptr->channels = 1;
    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
       info_ptr->channels++;
    info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);
 
     
    if (width > (PNG_UINT_32_MAX
                  >> 3)       
                  - 64        
                   - 1         
                   - 7*8       
                   - 8)        
    {
        info_ptr->rowbytes = (png_size_t)0;
       png_error(png_ptr, ""Image width is too large for this architecture"");
    }
     else
        info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
  }","[40, 42, 43]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
202853," int ipmi_si_mem_setup(struct si_sm_io *io)
 {
 	unsigned long addr = io->addr_data;
 	int           mapsize, idx;
 
  	if (!addr)
  		return -ENODEV;
  
	io->io_cleanup = mem_cleanup;
  	 
 	switch (io->regsize) {
 	case 1:
 		io->inputb = intf_mem_inb;
 		io->outputb = intf_mem_outb;
 		break;
 	case 2:
 		io->inputb = intf_mem_inw;
 		io->outputb = intf_mem_outw;
 		break;
 	case 4:
 		io->inputb = intf_mem_inl;
 		io->outputb = intf_mem_outl;
 		break;
 #ifdef readq
 	case 8:
 		io->inputb = mem_inq;
 		io->outputb = mem_outq;
 		break;
 #endif
 	default:
 		dev_warn(io->dev, ""Invalid register size: %d\n"",
 			 io->regsize);
 		return -EINVAL;
 	}
 
 	 
 	for (idx = 0; idx < io->io_size; idx++) {
 		if (request_mem_region(addr + idx * io->regspacing,
 				       io->regsize, DEVICE_NAME) == NULL) {
 			 
 			mem_region_cleanup(io, idx);
 			return -EIO;
 		}
 	}
 
 	 
 	mapsize = ((io->io_size * io->regspacing)
 		   - (io->regspacing - io->regsize));
 	io->addr = ioremap(addr, mapsize);
 	if (io->addr == NULL) {
  		mem_region_cleanup(io, io->io_size);
  		return -EIO;
  	}
 
 	io->io_cleanup = mem_cleanup;
 
  	return 0;
  }","[54, 55, 56, 9]","An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c."
199618,"  cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,
    const cdf_stream_t *sst, const uint64_t clsid[2])
     const cdf_stream_t *sst, const cdf_directory_t *root_storage)
  {
          cdf_summary_info_header_t si;
          cdf_property_info_t *info;
         size_t count;
         int m;
 
         if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)
                 return -1;
 
         if (NOTMIME(ms)) {
 		const char *str;
 
                 if (file_printf(ms, ""Composite Document File V2 Document"")
 		    == -1)
                         return -1;
 
                 if (file_printf(ms, "", %s Endian"",
                     si.si_byte_order == 0xfffe ?  ""Little"" : ""Big"") == -1)
                         return -2;
                 switch (si.si_os) {
                 case 2:
                         if (file_printf(ms, "", Os: Windows, Version %d.%d"",
                             si.si_os_version & 0xff,
                             (uint32_t)si.si_os_version >> 8) == -1)
                                 return -2;
                         break;
                 case 1:
                         if (file_printf(ms, "", Os: MacOS, Version %d.%d"",
                             (uint32_t)si.si_os_version >> 8,
                             si.si_os_version & 0xff) == -1)
                                 return -2;
                         break;
                 default:
                         if (file_printf(ms, "", Os %d, Version: %d.%d"", si.si_os,
                             si.si_os_version & 0xff,
                             (uint32_t)si.si_os_version >> 8) == -1)
                                  return -2;
                          break;
                  }
		str = cdf_clsid_to_mime(clsid, clsid2desc);
		if (str)
                        if (file_printf(ms, "", %s"", str) == -1)
				return -2;
        }
 		if (root_storage) {
 			str = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);
 			if (str)
 				if (file_printf(ms, "", %s"", str) == -1)
 					return -2;
 			}
 		}
  
        m = cdf_file_property_info(ms, info, count, clsid);
         m = cdf_file_property_info(ms, info, count, root_storage);
          free(info);
  
          return m == -1 ? -2 : m;
 }","[3, 48, 49, 50, 51, 52, 53, 54, 57, 2, 43, 44, 45, 46, 47, 56]","The cdf_read_short_sector function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted CDF file."
200733,"  static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
  {
  	int start = 0;
 	int i;
  	u32 prev_legacy, cur_legacy;
  	mutex_lock(&kvm->arch.vpit->pit_state.lock);
  	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
 	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
 	if (!prev_legacy && cur_legacy)
 		start = 1;
  	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
  	       sizeof(kvm->arch.vpit->pit_state.channels));
  	kvm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
 	for (i = 0; i < 3; i++)
 		kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);
  	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
  	return 0;
  }","[4, 15, 16, 14]","arch/x86/kvm/x86.c in the Linux kernel before 4.4 does not reset the PIT counter values during state restoration, which allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via a zero value, related to the kvm_vm_ioctl_set_pit and kvm_vm_ioctl_set_pit2 functions."
206167,"  void UserSelectionScreen::FillMultiProfileUserPrefs(
    user_manager::User* user,
     const user_manager::User* user,
      base::DictionaryValue* user_dict,
      bool is_signin_to_add) {
    if (!is_signin_to_add) {
     user_dict->SetBoolean(kKeyMultiProfilesAllowed, true);
     return;
   }
 
   bool is_user_allowed;
   ash::mojom::MultiProfileUserBehavior policy;
   GetMultiProfilePolicy(user, &is_user_allowed, &policy);
   user_dict->SetBoolean(kKeyMultiProfilesAllowed, is_user_allowed);
   user_dict->SetInteger(kKeyMultiProfilesPolicy, static_cast<int>(policy));
 }","[3, 2]",Use-after-free vulnerability in browser/extensions/api/webrtc_audio_private/webrtc_audio_private_api.cc in the WebRTC Audio Private API implementation in Google Chrome before 49.0.2623.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging incorrect reliance on the resource context pointer.
203263," static void copy_asoundrc(void) {
 	char *src = RUN_ASOUNDRC_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
  		exit(1);
  	}
  
	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
 	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);
 	fs_logger2(""clone"", dest);
  
  	unlink(src);
 }","[26, 27, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]","Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180."
200155," void perf_event_enable(struct perf_event *event)
 static void _perf_event_enable(struct perf_event *event)
  {
  	struct perf_event_context *ctx = event->ctx;
  	struct task_struct *task = ctx->task;
 
 	if (!task) {
 		 
 		cpu_function_call(event->cpu, __perf_event_enable, event);
 		return;
 	}
 
 	raw_spin_lock_irq(&ctx->lock);
 	if (event->state >= PERF_EVENT_STATE_INACTIVE)
 		goto out;
 
 	 
 	if (event->state == PERF_EVENT_STATE_ERROR)
 		event->state = PERF_EVENT_STATE_OFF;
 
 retry:
 	if (!ctx->is_active) {
 		__perf_event_mark_enabled(event);
 		goto out;
 	}
 
 	raw_spin_unlock_irq(&ctx->lock);
 
 	if (!task_function_call(task, __perf_event_enable, event))
 		return;
 
 	raw_spin_lock_irq(&ctx->lock);
 
 	 
 	if (ctx->is_active && event->state == PERF_EVENT_STATE_OFF) {
 		 
 		task = ctx->task;
 		goto retry;
 	}
 
  out:
  	raw_spin_unlock_irq(&ctx->lock);
  }",[2],"kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 31095224."
204899," PassRefPtr<Attr> Element::setAttributeNode(Attr* attrNode, ExceptionCode& ec)
 {
     if (!attrNode) {
         ec = TYPE_MISMATCH_ERR;
         return 0;
     }
 
     RefPtr<Attr> oldAttrNode = attrIfExists(attrNode->qualifiedName());
     if (oldAttrNode.get() == attrNode)
         return attrNode;  
 
     if (attrNode->ownerElement()) {
         ec = INUSE_ATTRIBUTE_ERR;
         return 0;
     }
 
     synchronizeAllAttributes();
     UniqueElementData* elementData = ensureUniqueElementData();
 
     size_t index = elementData->getAttributeItemIndex(attrNode->qualifiedName());
     if (index != notFound) {
         if (oldAttrNode)
             detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData->attributeItem(index)->value());
         else
             oldAttrNode = Attr::create(document(), attrNode->qualifiedName(), elementData->attributeItem(index)->value());
     }
 
      setAttributeInternal(index, attrNode->qualifiedName(), attrNode->value(), NotInSynchronizationOfLazyAttribute);
  
      attrNode->attachToElement(this);
     treeScope()->adoptIfNeeded(attrNode);
      ensureAttrNodeListForElement(this)->append(attrNode);
  
      return oldAttrNode.release();
 }",[31],Use-after-free vulnerability in the DOM implementation in Google Chrome before 28.0.1500.95 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to improper tracking of which document owns an Attr object.
201408," struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {
 	struct reloc_t *relocs;
 	int i = 0, len;
 	ulebr ur = {NULL};
 	int wordsize = MACH0_(get_bits)(bin) / 8;
 	if (bin->dyld_info) {
 		ut8 *opcodes,*end, type = 0, rel_type = 0;
 		int lib_ord, seg_idx = -1, sym_ord = -1;
 		size_t j, count, skip, bind_size, lazy_size;
 		st64 addend = 0;
 		ut64 segmentAddress = 0LL;
 		ut64 addr = 0LL;
 		ut8 done = 0;
 
 #define CASE(T) case (T / 8): rel_type = R_BIN_RELOC_ ## T; break
 		switch (wordsize) {
 		CASE(8);
 		CASE(16);
 		CASE(32);
 		CASE(64);
 		default: return NULL;
 		}
 #undef CASE
 		bind_size = bin->dyld_info->bind_size;
 		lazy_size = bin->dyld_info->lazy_bind_size;
 
 		if (!bind_size || !lazy_size) {
 			return NULL;
 		}
 
  		if ((bind_size + lazy_size)<1) {
  			return NULL;
  		}
		if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)
 		if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {
  			return NULL;
 		}
  		if (bin->dyld_info->lazy_bind_off > bin->size || \
			bin->dyld_info->lazy_bind_off + lazy_size > bin->size)
 			bin->dyld_info->lazy_bind_off + lazy_size > bin->size) {
  			return NULL;
		if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)
 		}
 		if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {
  			return NULL;
		if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))
 		}
 		if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {
  			return NULL;
 		}
  		opcodes = calloc (1, bind_size + lazy_size + 1);
  		if (!opcodes) {
  			free (relocs);
 			return NULL;
 		}
 		len = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);
 		i = r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);
 		if (len < 1 || i < 1) {
 			bprintf (""Error: read (dyld_info bind) at 0x%08""PFMT64x""\n"",
 			(ut64)(size_t)bin->dyld_info->bind_off);
 			free (opcodes);
 			relocs[i].last = 1;
 			return relocs;
 		}
 		i = 0;
 		for (ur.p = opcodes, end = opcodes + bind_size + lazy_size ; (ur.p+2 < end) && !done; ) {
 			ut8 imm = *ur.p & BIND_IMMEDIATE_MASK, op = *ur.p & BIND_OPCODE_MASK;
 			++ur.p;
 			switch (op) {
 #define ULEB() read_uleb128 (&ur,end)
 #define SLEB() read_sleb128 (&ur,end)
 			case BIND_OPCODE_DONE:
 				done = 1;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
 				lib_ord = imm;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
 				lib_ord = ULEB();
 				break;
 			case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
 				lib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;
 				break;
 			case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {
 				char *sym_name = (char*)ur.p;
 				while (*ur.p++ && ur.p<end) {
 					 
 				}
 				sym_ord = -1;
 				if (bin->symtab && bin->dysymtab.nundefsym < 0xffff)
 				for (j = 0; j < bin->dysymtab.nundefsym; j++) {
 					int stridx = 0;
 					int iundefsym = bin->dysymtab.iundefsym;
 					if (iundefsym>=0 && iundefsym < bin->nsymtab) {
 						int sidx = iundefsym +j;
 						if (sidx<0 || sidx>= bin->nsymtab)
 							continue;
 						stridx = bin->symtab[sidx].n_strx;
 						if (stridx < 0 || stridx >= bin->symstrlen)
 							continue;
 					}
 					if (!strcmp ((char *)bin->symstr + stridx, sym_name)) {
 						sym_ord = j;
 						break;
 					}
 				}
 				break;
 			}
 			case BIND_OPCODE_SET_TYPE_IMM:
 				type = imm;
 				break;
 			case BIND_OPCODE_SET_ADDEND_SLEB:
 				addend = SLEB();
 				break;
 			case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
 				seg_idx = imm;
 				if (seg_idx < 0 || seg_idx >= bin->nsegs) {
 					bprintf (""Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB""
 						"" has unexistent segment %d\n"", seg_idx);
 					addr = 0LL;
 					return 0;  
 				} else {
 					addr = bin->segs[seg_idx].vmaddr + ULEB();
 					segmentAddress = bin->segs[seg_idx].vmaddr \
 							+ bin->segs[seg_idx].vmsize;
 				}
 				break;
 			case BIND_OPCODE_ADD_ADDR_ULEB:
 				addr += ULEB();
 				break;
 #define DO_BIND() do {\
 if (sym_ord < 0 || seg_idx < 0 ) break;\
 if (i >= (bind_size + lazy_size)) break;\
 relocs[i].addr = addr;\
 relocs[i].offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\
 if (type == BIND_TYPE_TEXT_PCREL32)\
 	relocs[i].addend = addend - (bin->baddr + addr);\
 else relocs[i].addend = addend;\
   \
 relocs[i].ord = lib_ord;\
 relocs[i].ord = sym_ord;\
 relocs[i].type = rel_type;\
 relocs[i++].last = 0;\
 } while (0)
 			case BIND_OPCODE_DO_BIND:
 				if (addr >= segmentAddress) {
 					bprintf (""Error: Malformed DO bind opcode\n"");
 					goto beach;
 				}
 				DO_BIND();
 				addr += wordsize;
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
 				if (addr >= segmentAddress) {
 					bprintf (""Error: Malformed ADDR ULEB bind opcode\n"");
 					goto beach;
 				}
 				DO_BIND();
 				addr += ULEB() + wordsize;
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
 				if (addr >= segmentAddress) {
 					bprintf (""Error: Malformed IMM SCALED bind opcode\n"");
 					goto beach;
 				}
 				DO_BIND();
 				addr += (ut64)imm * (ut64)wordsize + wordsize;
 				break;
 			case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
 				count = ULEB();
 				skip = ULEB();
 				for (j = 0; j < count; j++) {
 					if (addr >= segmentAddress) {
 						bprintf (""Error: Malformed ULEB TIMES bind opcode\n"");
 						goto beach;
 					}
 					DO_BIND();
 					addr += skip + wordsize;
 				}
 				break;
 #undef DO_BIND
 #undef ULEB
 #undef SLEB
 			default:
 				bprintf (""Error: unknown bind opcode 0x%02x in dyld_info\n"", *ur.p);
 				free (opcodes);
 				relocs[i].last = 1;
 				return relocs;
 			}
 		}
  		free (opcodes);
  	} else {
  		int j;
		if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)
 		if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {
  			return NULL;
		if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))
 		}
 		if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {
  			return NULL;
 		}
  		for (j = 0; j < bin->dysymtab.nundefsym; j++) {
			if (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {
 			if (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {
  				relocs[i].ord = j;
  				relocs[i++].last = 0;
  			}
 		}
 	}
 beach:
 	relocs[i].last = 1;
 
 	return relocs;
 }","[35, 37, 40, 43, 44, 47, 48, 50, 195, 198, 199, 201, 204, 34, 39, 42, 46, 194, 197, 203]",The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.
7808,"static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)
{


ASSERT(!(n < 4));
auto predecessor = n.minus({ 1 });
auto d = predecessor;
size_t r = 0;

{
auto div_result = d.divided_by(2);
while (div_result.remainder == 0) {
d = div_result.quotient;
div_result = d.divided_by(2);
++r;
}
}
if (r == 0) {

return n == 2;
}

for (auto a : tests) {

ASSERT(a < n);
auto x = ModularPower(a, d, n);
if (x == 1 || x == predecessor)
continue;
bool skip_this_witness = false;

for (size_t i = 0; i < r - 1; ++i) {
x = ModularPower(x, 2, n);
if (x == predecessor) {
skip_this_witness = true;
break;
}
}
if (skip_this_witness)
continue;
return false;
}

return true;
}",[23],SerenityOS Unspecified is affected by: Buffer Overflow. The impact is: obtain sensitive information (context-dependent). The component is: /Userland/Libraries/LibCrypto/ASN1/DER.h Crypto::der_decode_sequence() function. The attack vector is: Parsing RSA Key ASN.1.
204262," void ThreadableBlobRegistry::registerStreamURL(const KURL& url, const String& type)
 void BlobRegistry::registerStreamURL(const KURL& url, const String& type)
  {
      if (isMainThread()) {
        blobRegistry().registerStreamURL(url, type);
         if (WebBlobRegistry* registry = blobRegistry())
             registry->registerStreamURL(url, type);
      } else {
          OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, type));
          callOnMainThread(&registerStreamURLTask, context.leakPtr());
     }
 }","[2, 6, 7, 5]","Google Chrome before 23.0.1271.91 on Mac OS X does not properly mitigate improper rendering behavior in the Intel GPU driver, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
201364," static int mailimf_group_parse(const char * message, size_t length,
 			       size_t * indx,
 			       struct mailimf_group ** result)
 {
   size_t cur_token;
   char * display_name;
   struct mailimf_mailbox_list * mailbox_list;
    struct mailimf_group * group;
    int r;
    int res;
   clist * list;
  
    cur_token = * indx;
  
   mailbox_list = NULL;
 
   r = mailimf_display_name_parse(message, length, &cur_token, &display_name);
   if (r != MAILIMF_NO_ERROR) {
     res = r;
     goto err;
   }
 
   r = mailimf_colon_parse(message, length, &cur_token);
   if (r != MAILIMF_NO_ERROR) {
     res = r;
     goto free_display_name;
   }
 
   r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);
   switch (r) {
   case MAILIMF_NO_ERROR:
     break;
   case MAILIMF_ERROR_PARSE:
     r = mailimf_cfws_parse(message, length, &cur_token);
     if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {
        res = r;
        goto free_display_name;
      }
     list = clist_new();
     if (list == NULL) {
       res = MAILIMF_ERROR_MEMORY;
       goto free_display_name;
     }
     mailbox_list = mailimf_mailbox_list_new(list);
     if (mailbox_list == NULL) {
       res = MAILIMF_ERROR_MEMORY;
       clist_free(list);
       goto free_display_name;
     }
      break;
    default:
      res = r;
     goto free_display_name;
   }
 
   r = mailimf_semi_colon_parse(message, length, &cur_token);
   if (r != MAILIMF_NO_ERROR) {
     res = r;
     goto free_mailbox_list;
   }
 
   group = mailimf_group_new(display_name, mailbox_list);
   if (group == NULL) {
     res = MAILIMF_ERROR_MEMORY;
     goto free_mailbox_list;
   }
 
   * indx = cur_token;
   * result = group;
 
   return MAILIMF_NO_ERROR;
 
  free_mailbox_list:
   if (mailbox_list != NULL) {
     mailimf_mailbox_list_free(mailbox_list);
   }
  free_display_name:
   mailimf_display_name_free(display_name);
  err:
   return res;
 }","[11, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]","A null dereference vulnerability has been found in the MIME handling component of LibEtPan before 1.8, as used in MailCore and MailCore 2. A crash can occur in low-level/imf/mailimf.c during a failed parse of a Cc header containing multiple e-mail addresses."
201862," static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)
 static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val)
  {
  	int i;
  	int c;
 	for (i = n; i > 0; --i) {
 		c = (val >> (8 * (i - 1))) & 0xff;
 		if (jas_stream_putc(out, c) == EOF)
 			return -1;
 	}
  	return 0;
  }",[2],Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
197892," static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)
  {
      const unsigned char *p;
      int plen;
    if (alg == NULL)
     if (alg == NULL || alg->parameter == NULL)
          return NULL;
      if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)
          return NULL;
     if (alg->parameter->type != V_ASN1_SEQUENCE)
         return NULL;
 
     p = alg->parameter->value.sequence->data;
     plen = alg->parameter->value.sequence->length;
     return d2i_X509_ALGOR(NULL, &p, plen);
 }","[6, 5]",crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.
202144," int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)
 {
     uint32_t flags, bps = 0;
     uint32_t chan_mask = config->channel_mask;
      int num_chans = config->num_channels;
      int i;
  
     if (!config->sample_rate) {
         strcpy (wpc->error_message, ""sample rate cannot be zero!"");
         return FALSE;
     }
 
      wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;
  
      if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {
 #ifdef ENABLE_DSD
         wpc->dsd_multiplier = 1;
         flags = DSD_FLAG;
 
         for (i = 14; i >= 0; --i)
             if (config->sample_rate % sample_rates [i] == 0) {
                 int divisor = config->sample_rate / sample_rates [i];
 
                 if (divisor && (divisor & (divisor - 1)) == 0) {
                     config->sample_rate /= divisor;
                     wpc->dsd_multiplier = divisor;
                     break;
                 }
             }
 
         if (config->flags & CONFIG_HYBRID_FLAG) {
             strcpy (wpc->error_message, ""hybrid mode not available for DSD!"");
             return FALSE;
         }
 
         config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);
         config->float_norm_exp = config->xmode = 0;
 #else
         strcpy (wpc->error_message, ""libwavpack not configured for DSD!"");
         return FALSE;
 #endif
     }
     else
         flags = config->bytes_per_sample - 1;
 
     wpc->total_samples = total_samples;
     wpc->config.sample_rate = config->sample_rate;
     wpc->config.num_channels = config->num_channels;
     wpc->config.channel_mask = config->channel_mask;
     wpc->config.bits_per_sample = config->bits_per_sample;
     wpc->config.bytes_per_sample = config->bytes_per_sample;
     wpc->config.block_samples = config->block_samples;
     wpc->config.flags = config->flags;
     wpc->config.qmode = config->qmode;
 
     if (config->flags & CONFIG_VERY_HIGH_FLAG)
         wpc->config.flags |= CONFIG_HIGH_FLAG;
 
     for (i = 0; i < 15; ++i)
         if (wpc->config.sample_rate == sample_rates [i])
             break;
 
     flags |= i << SRATE_LSB;
 
 
     if (!(flags & DSD_FLAG)) {
         if (config->float_norm_exp) {
             wpc->config.float_norm_exp = config->float_norm_exp;
             wpc->config.flags |= CONFIG_FLOAT_DATA;
             flags |= FLOAT_DATA;
         }
         else
             flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;
 
         if (config->flags & CONFIG_HYBRID_FLAG) {
             flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;
 
             if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {
                 wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;
                 flags |= HYBRID_SHAPE | NEW_SHAPING;
             }
             else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {
                 wpc->config.shaping_weight = config->shaping_weight;
                 flags |= HYBRID_SHAPE | NEW_SHAPING;
             }
 
             if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))
                 flags |= CROSS_DECORR;
 
             if (config->flags & CONFIG_BITRATE_KBPS) {
                 bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);
 
                 if (bps > (64 << 8))
                     bps = 64 << 8;
             }
             else
                 bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);
         }
         else
             flags |= CROSS_DECORR;
 
         if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))
             flags |= JOINT_STEREO;
 
         if (config->flags & CONFIG_CREATE_WVC)
             wpc->wvc_flag = TRUE;
     }
 
 
     if (chan_ids) {
         int lastchan = 0, mask_copy = chan_mask;
 
         if ((int) strlen ((char *) chan_ids) > num_chans) {           
             strcpy (wpc->error_message, ""chan_ids longer than num channels!"");
             return FALSE;
         }
 
 
         while (*chan_ids)
             if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {
                 mask_copy &= ~(1 << (*chan_ids-1));
                 lastchan = *chan_ids++;
             }
             else
                 break;
 
 
         for (i = 0; chan_ids [i]; i++)
             if (chan_ids [i] != 0xff) {
                 wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);
                 break;
             }
     }
 
 
     for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {
         WavpackStream *wps = malloc (sizeof (WavpackStream));
         unsigned char left_chan_id = 0, right_chan_id = 0;
         int pos, chans = 1;
 
         wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));
         wpc->streams [wpc->current_stream] = wps;
         CLEAR (*wps);
 
         if (chan_mask)
             for (pos = 0; pos < 32; ++pos)
                 if (chan_mask & (1 << pos)) {
                     if (left_chan_id) {
                         right_chan_id = pos + 1;
                         break;
                     }
                     else {
                         chan_mask &= ~(1 << pos);
                         left_chan_id = pos + 1;
                     }
                 }
 
         while (!right_chan_id && chan_ids && *chan_ids)
             if (left_chan_id)
                 right_chan_id = *chan_ids;
             else
                 left_chan_id = *chan_ids++;
 
         if (!left_chan_id)
             left_chan_id = right_chan_id = 0xff;
         else if (!right_chan_id)
             right_chan_id = 0xff;
 
         if (num_chans >= 2) {
             if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)
                 chans = 2;
             else
                 for (i = 0; i < NUM_STEREO_PAIRS; ++i)
                     if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||
                         (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {
                             if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))
                                 chan_mask &= ~(1 << (right_chan_id-1));
                             else if (chan_ids && *chan_ids == right_chan_id)
                                 chan_ids++;
 
                             chans = 2;
                             break;
                         }
         }
 
         num_chans -= chans;
 
         if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)
             break;
 
         memcpy (wps->wphdr.ckID, ""wvpk"", 4);
         wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;
         SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);
         wps->wphdr.version = wpc->stream_version;
         wps->wphdr.flags = flags;
         wps->bits = bps;
 
         if (!wpc->current_stream)
             wps->wphdr.flags |= INITIAL_BLOCK;
 
         if (!num_chans)
             wps->wphdr.flags |= FINAL_BLOCK;
 
         if (chans == 1) {
             wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);
             wps->wphdr.flags |= MONO_FLAG;
         }
     }
 
     wpc->num_streams = wpc->current_stream;
     wpc->current_stream = 0;
 
     if (num_chans) {
         strcpy (wpc->error_message, ""too many channels!"");
         return FALSE;
     }
 
     if (config->flags & CONFIG_EXTRA_MODE)
         wpc->config.xmode = config->xmode ? config->xmode : 1;
 
     return TRUE;
 }","[8, 9, 10, 11, 12]",The function WavpackPackInit in pack_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (resource exhaustion caused by an infinite loop) via a crafted wav audio file because WavpackSetConfiguration64 mishandles a sample rate of zero.
198811," initpyfribidi (void)
 init_pyfribidi (void)
  {
	PyObject *module;
	 
	module = Py_InitModule3 (""pyfribidi"", PyfribidiMethods,
				 _pyfribidi__doc__);
         PyObject *module = Py_InitModule (""_pyfribidi"", PyfribidiMethods);
  	PyModule_AddIntConstant (module, ""RTL"", (long) FRIBIDI_TYPE_RTL);
  	PyModule_AddIntConstant (module, ""LTR"", (long) FRIBIDI_TYPE_LTR);
  	PyModule_AddIntConstant (module, ""ON"", (long) FRIBIDI_TYPE_ON);
	PyModule_AddStringConstant (module, ""__author__"",
				    ""Yaacov Zamir and Nir Soffer"");
  }","[2, 8, 4, 5, 6, 7, 12, 13]",Buffer overflow in the fribidi_utf8_to_unicode function in PyFriBidi before 0.11.0 allows remote attackers to cause a denial of service (application crash) via a 4-byte utf-8 sequence.
204839," void AppLauncherHandler::FillAppDictionary(base::DictionaryValue* dictionary) {
   base::AutoReset<bool> auto_reset(&ignore_changes_, true);
 
   base::ListValue* list = new base::ListValue();
   Profile* profile = Profile::FromWebUI(web_ui());
   PrefService* prefs = profile->GetPrefs();
 
   for (std::set<std::string>::iterator it = visible_apps_.begin();
        it != visible_apps_.end(); ++it) {
     const Extension* extension = extension_service_->GetInstalledExtension(*it);
     if (extension && extensions::ui_util::ShouldDisplayInNewTabPage(
             extension, profile)) {
       base::DictionaryValue* app_info = GetAppInfo(extension);
       list->Append(app_info);
     }
   }
  
    dictionary->Set(""apps"", list);
  
#if defined(OS_MACOSX)
  dictionary->SetBoolean(""disableAppWindowLaunch"", true);
  dictionary->SetBoolean(""disableCreateAppShortcut"", true);
#endif
#if defined(OS_CHROMEOS)
  dictionary->SetBoolean(""disableCreateAppShortcut"", true);
#endif
    const base::ListValue* app_page_names =
        prefs->GetList(prefs::kNtpAppPageNames);
    if (!app_page_names || !app_page_names->GetSize()) {
     ListPrefUpdate update(prefs, prefs::kNtpAppPageNames);
     base::ListValue* list = update.Get();
     list->Set(0, new base::StringValue(
         l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME)));
     dictionary->Set(""appPageNames"",
                     static_cast<base::ListValue*>(list->DeepCopy()));
   } else {
     dictionary->Set(""appPageNames"",
                     static_cast<base::ListValue*>(app_page_names->DeepCopy()));
   }
 }","[20, 21, 22, 23, 24, 25, 26]","Use-after-free vulnerability in the HTMLMediaElement::didMoveToNewDocument function in core/html/HTMLMediaElement.cpp in Blink, as used in Google Chrome before 31.0.1650.48, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving the movement of a media element between documents."
7385,"explicit DataFormatDimMapOp(OpKernelConstruction* context)
: OpKernel(context) {
string src_format;
OP_REQUIRES_OK(context, context->GetAttr(""src_format"", &src_format));
string dst_format;
OP_REQUIRES_OK(context, context->GetAttr(""dst_format"", &dst_format));
OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,
errors::InvalidArgument(strings::StrCat(
""Source format must of length 4 or 5, received ""
""src_format = "",
src_format)));
OP_REQUIRES(
context, dst_format.size() == 4 || dst_format.size() == 5,
errors::InvalidArgument(strings::StrCat(
""Destination format must of length 4 or 5, received dst_format = "",
dst_format)));
dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});
for (int i = 0; i < src_format.size(); ++i) {
for (int j = 0; j < dst_format.size(); ++j) {
if (dst_format[j] == src_format[i]) {
dst_idx_.vec<int>()(i) = j;
break;
}
}
}
}","[8, 9, 11, 13, 14, 15, 16]","In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0."
204946,"  void SocketStream::DoLoop(int result) {
  if (!context_.get())
   if (!context_)
      next_state_ = STATE_CLOSE;
  
    if (next_state_ == STATE_NONE)
     return;
 
   do {
     State state = next_state_;
     next_state_ = STATE_NONE;
     switch (state) {
       case STATE_BEFORE_CONNECT:
         DCHECK_EQ(OK, result);
         result = DoBeforeConnect();
         break;
       case STATE_BEFORE_CONNECT_COMPLETE:
         result = DoBeforeConnectComplete(result);
         break;
       case STATE_RESOLVE_PROXY:
         DCHECK_EQ(OK, result);
         result = DoResolveProxy();
         break;
       case STATE_RESOLVE_PROXY_COMPLETE:
         result = DoResolveProxyComplete(result);
         break;
       case STATE_RESOLVE_HOST:
         DCHECK_EQ(OK, result);
         result = DoResolveHost();
         break;
       case STATE_RESOLVE_HOST_COMPLETE:
         result = DoResolveHostComplete(result);
         break;
       case STATE_RESOLVE_PROTOCOL:
         result = DoResolveProtocol(result);
         break;
       case STATE_RESOLVE_PROTOCOL_COMPLETE:
         result = DoResolveProtocolComplete(result);
         break;
       case STATE_TCP_CONNECT:
         result = DoTcpConnect(result);
         break;
       case STATE_TCP_CONNECT_COMPLETE:
         result = DoTcpConnectComplete(result);
         break;
       case STATE_GENERATE_PROXY_AUTH_TOKEN:
         result = DoGenerateProxyAuthToken();
         break;
       case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:
         result = DoGenerateProxyAuthTokenComplete(result);
         break;
       case STATE_WRITE_TUNNEL_HEADERS:
         DCHECK_EQ(OK, result);
         result = DoWriteTunnelHeaders();
         break;
       case STATE_WRITE_TUNNEL_HEADERS_COMPLETE:
         result = DoWriteTunnelHeadersComplete(result);
         break;
       case STATE_READ_TUNNEL_HEADERS:
         DCHECK_EQ(OK, result);
         result = DoReadTunnelHeaders();
         break;
       case STATE_READ_TUNNEL_HEADERS_COMPLETE:
         result = DoReadTunnelHeadersComplete(result);
         break;
       case STATE_SOCKS_CONNECT:
         DCHECK_EQ(OK, result);
         result = DoSOCKSConnect();
         break;
       case STATE_SOCKS_CONNECT_COMPLETE:
         result = DoSOCKSConnectComplete(result);
         break;
       case STATE_SECURE_PROXY_CONNECT:
         DCHECK_EQ(OK, result);
         result = DoSecureProxyConnect();
         break;
       case STATE_SECURE_PROXY_CONNECT_COMPLETE:
         result = DoSecureProxyConnectComplete(result);
         break;
       case STATE_SECURE_PROXY_HANDLE_CERT_ERROR:
         result = DoSecureProxyHandleCertError(result);
         break;
       case STATE_SECURE_PROXY_HANDLE_CERT_ERROR_COMPLETE:
         result = DoSecureProxyHandleCertErrorComplete(result);
         break;
       case STATE_SSL_CONNECT:
         DCHECK_EQ(OK, result);
         result = DoSSLConnect();
         break;
       case STATE_SSL_CONNECT_COMPLETE:
         result = DoSSLConnectComplete(result);
         break;
       case STATE_SSL_HANDLE_CERT_ERROR:
         result = DoSSLHandleCertError(result);
         break;
       case STATE_SSL_HANDLE_CERT_ERROR_COMPLETE:
         result = DoSSLHandleCertErrorComplete(result);
         break;
       case STATE_READ_WRITE:
         result = DoReadWrite(result);
         break;
       case STATE_AUTH_REQUIRED:
         Finish(result);
         return;
       case STATE_CLOSE:
         DCHECK_LE(result, OK);
         Finish(result);
         return;
       default:
         NOTREACHED() << ""bad state "" << state;
         Finish(result);
         return;
     }
     if (state == STATE_RESOLVE_PROTOCOL && result == ERR_PROTOCOL_SWITCHED)
       continue;
     if (state != STATE_READ_WRITE && result < ERR_IO_PENDING) {
       net_log_.EndEventWithNetErrorCode(
           NetLog::TYPE_SOCKET_STREAM_CONNECT, result);
     }
   } while (result != ERR_IO_PENDING);
 }","[3, 2]",Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote servers to execute arbitrary code via crafted response traffic after a URL request.
200529,"  static int digi_startup(struct usb_serial *serial)
  {
 	struct device *dev = &serial->interface->dev;
  	struct digi_serial *serial_priv;
  	int ret;
 	int i;
 
 	 
 	if (serial->num_port_pointers < serial->type->num_ports + 1) {
 		dev_err(dev, ""OOB endpoints missing\n"");
 		return -ENODEV;
 	}
 
 	for (i = 0; i < serial->type->num_ports + 1 ; i++) {
 		if (!serial->port[i]->read_urb) {
 			dev_err(dev, ""bulk-in endpoint missing\n"");
 			return -ENODEV;
 		}
 		if (!serial->port[i]->write_urb) {
 			dev_err(dev, ""bulk-out endpoint missing\n"");
 			return -ENODEV;
 		}
 	}
  
  	serial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);
  	if (!serial_priv)
 		return -ENOMEM;
 
 	spin_lock_init(&serial_priv->ds_serial_lock);
 	serial_priv->ds_oob_port_num = serial->type->num_ports;
 	serial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];
 
 	ret = digi_port_init(serial_priv->ds_oob_port,
 						serial_priv->ds_oob_port_num);
 	if (ret) {
 		kfree(serial_priv);
 		return ret;
 	}
 
 	usb_set_serial_data(serial, serial_priv);
 
 	return 0;
 }","[3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]",The digi_port_init function in drivers/usb/serial/digi_acceleport.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.
198055," ZEND_API void zend_ts_hash_graceful_destroy(TsHashTable *ht)
 {
 	begin_write(ht);
 	zend_hash_graceful_destroy(TS_HASH(ht));
 	end_write(ht);
  
  #ifdef ZTS
         tsrm_mutex_free(ht->mx_reader);
       tsrm_mutex_free(ht->mx_reader);
        tsrm_mutex_free(ht->mx_writer);
  #endif
  }","[10, 9]",Double free vulnerability in the zend_ts_hash_graceful_destroy function in zend_ts_hash.c in the Zend Engine in PHP through 5.5.20 and 5.6.x through 5.6.4 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
208046,"  static void copyTrespass(
          short *  ,
        const int *const *  ,
         const int *[FLACParser::kMaxChannels]  ,
          unsigned  ,
          unsigned  ) {
      TRESPASS();
 }","[4, 3]","A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788."
199895," static int attach_child_main(void* data)
  {
  	struct attach_clone_payload* payload = (struct attach_clone_payload*)data;
  	int ipc_socket = payload->ipc_socket;
 	int procfd = payload->procfd;
  	lxc_attach_options_t* options = payload->options;
  	struct lxc_proc_context_info* init_ctx = payload->init_ctx;
  #if HAVE_SYS_PERSONALITY_H
 	long new_personality;
 #endif
 	int ret;
 	int status;
 	int expected;
 	long flags;
 	int fd;
 	uid_t new_uid;
 	gid_t new_gid;
 
 	 
 	expected = 0;
 	status = -1;
 	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
 	if (ret <= 0) {
 		ERROR(""error using IPC to receive notification from initial process (0)"");
 		shutdown(ipc_socket, SHUT_RDWR);
 		rexit(-1);
 	}
 
 	 
 	if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {
 		ret = lxc_attach_remount_sys_proc();
 		if (ret < 0) {
 			shutdown(ipc_socket, SHUT_RDWR);
 			rexit(-1);
 		}
 	}
 
 	 
 #if HAVE_SYS_PERSONALITY_H
 	if (options->personality < 0)
 		new_personality = init_ctx->personality;
 	else
 		new_personality = options->personality;
 
 	if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {
 		ret = personality(new_personality);
 		if (ret < 0) {
 			SYSERROR(""could not ensure correct architecture"");
 			shutdown(ipc_socket, SHUT_RDWR);
 			rexit(-1);
 		}
 	}
 #endif
 
 	if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {
 		ret = lxc_attach_drop_privs(init_ctx);
 		if (ret < 0) {
 			ERROR(""could not drop privileges"");
 			shutdown(ipc_socket, SHUT_RDWR);
 			rexit(-1);
 		}
 	}
 
 	 
 	ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);
 	if (ret < 0) {
 		ERROR(""could not set initial environment for attached process"");
 		shutdown(ipc_socket, SHUT_RDWR);
 		rexit(-1);
 	}
 
 	 
 	new_uid = 0;
 	new_gid = 0;
 	 
 	if (options->namespaces & CLONE_NEWUSER)
 		lxc_attach_get_init_uidgid(&new_uid, &new_gid);
 
 	if (options->uid != (uid_t)-1)
 		new_uid = options->uid;
 	if (options->gid != (gid_t)-1)
 		new_gid = options->gid;
 
 	 
 	if (options->stdin_fd && isatty(options->stdin_fd)) {
 		if (setsid() < 0) {
 			SYSERROR(""unable to setsid"");
 			shutdown(ipc_socket, SHUT_RDWR);
 			rexit(-1);
 		}
 
 		if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {
 			SYSERROR(""unable to TIOCSTTY"");
 			shutdown(ipc_socket, SHUT_RDWR);
 			rexit(-1);
 		}
 	}
 
 	 
 	if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {
 		if (setgid(new_gid) || setgroups(0, NULL)) {
 			SYSERROR(""switching to container gid"");
 			shutdown(ipc_socket, SHUT_RDWR);
 			rexit(-1);
 		}
 	}
 	if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {
 		SYSERROR(""switching to container uid"");
 		shutdown(ipc_socket, SHUT_RDWR);
 		rexit(-1);
 	}
 
 	 
 	status = 1;
 	ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));
 	if (ret != sizeof(status)) {
 		ERROR(""error using IPC to notify initial process for initialization (1)"");
 		shutdown(ipc_socket, SHUT_RDWR);
 		rexit(-1);
 	}
 
 	 
 	expected = 2;
 	status = -1;
 	ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
 	if (ret <= 0) {
 		ERROR(""error using IPC to receive final notification from initial process (2)"");
 		shutdown(ipc_socket, SHUT_RDWR);
 		rexit(-1);
 	}
 
 	shutdown(ipc_socket, SHUT_RDWR);
  	close(ipc_socket);
  
  	 
	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {
 	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
  		int on_exec;
		int proc_mounted;
  
  		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
		proc_mounted = mount_proc_if_needed(""/"");
		if (proc_mounted == -1) {
			ERROR(""Error mounting a sane /proc"");
			rexit(-1);
		}
		ret = lsm_process_label_set(init_ctx->lsm_label,
				init_ctx->container->lxc_conf, 0, on_exec);
		if (proc_mounted)
			umount(""/proc"");
		if (ret < 0) {
 		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
  			rexit(-1);
  		}
  	}
 
 	if (init_ctx->container && init_ctx->container->lxc_conf &&
 			lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {
 		ERROR(""Loading seccomp policy"");
 		rexit(-1);
 	}
 
 	lxc_proc_put_context_info(init_ctx);
 
 	 
 
 	 
 	if (options->stdin_fd >= 0 && options->stdin_fd != 0)
 		dup2(options->stdin_fd, 0);
 	if (options->stdout_fd >= 0 && options->stdout_fd != 1)
 		dup2(options->stdout_fd, 1);
 	if (options->stderr_fd >= 0 && options->stderr_fd != 2)
 		dup2(options->stderr_fd, 2);
 
 	 
 	if (options->stdin_fd > 2)
 		close(options->stdin_fd);
 	if (options->stdout_fd > 2)
 		close(options->stdout_fd);
 	if (options->stderr_fd > 2)
 		close(options->stderr_fd);
 
 	 
 	for (fd = 0; fd <= 2; fd++) {
 		flags = fcntl(fd, F_GETFL);
 		if (flags < 0)
 			continue;
 		if (flags & FD_CLOEXEC) {
 			if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) {
 				SYSERROR(""Unable to clear CLOEXEC from fd"");
 			}
  		}
  	}
  
 	 
 	close(procfd);
 
  	 
  	rexit(payload->exec_function(payload->exec_payload));
  }","[5, 137, 152, 195, 196, 197, 136, 139, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151]","attach.c in LXC 1.1.2 and earlier uses the proc filesystem in a container, which allows local container users to escape AppArmor or SELinux confinement by mounting a proc filesystem with a crafted (1) AppArmor profile or (2) SELinux label."
201254," grub_ext2_iterate_dir (grub_fshelp_node_t dir,
 		       int (*hook) (const char *filename,
 				    enum grub_fshelp_filetype filetype,
 				    grub_fshelp_node_t node,
 				    void *closure),
 		       void *closure)
 {
   unsigned int fpos = 0;
   struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;
 
   if (! diro->inode_read)
     {
       grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);
       if (grub_errno)
 	return 0;
     }
 
    
   if (hook)
   while (fpos < grub_le_to_cpu32 (diro->inode.size))
     {
       struct ext2_dirent dirent;
 
       grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),
 			   (char *) &dirent);
       if (grub_errno)
 	return 0;
 
       if (dirent.direntlen == 0)
         return 0;
  
        if (dirent.namelen != 0)
  	{
#ifndef _MSC_VER
	  char filename[dirent.namelen + 1]; 
#else
  	  char * filename = grub_malloc (dirent.namelen + 1);
#endif
  	  struct grub_fshelp_node *fdiro;
  	  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;
  
 if (!filename) {
 break;
 }
  	  grub_ext2_read_file (diro, 0, 0, 0,
  			       fpos + sizeof (struct ext2_dirent),
  			       dirent.namelen, filename);
	  if (grub_errno)
 	  if (grub_errno) {
             free (filename);
  	    return 0;
 	  }
  
  	  fdiro = grub_malloc (sizeof (struct grub_fshelp_node));
	  if (! fdiro)
 	  if (! fdiro) {
             free (filename);
  	    return 0;
           }
  
  	  fdiro->data = diro->data;
  	  fdiro->ino = grub_le_to_cpu32 (dirent.inode);
 
 	  filename[dirent.namelen] = '\0';
 
 	  if (dirent.filetype != FILETYPE_UNKNOWN)
 	    {
 	      fdiro->inode_read = 0;
 
 	      if (dirent.filetype == FILETYPE_DIRECTORY)
 		type = GRUB_FSHELP_DIR;
 	      else if (dirent.filetype == FILETYPE_SYMLINK)
 		type = GRUB_FSHELP_SYMLINK;
 	      else if (dirent.filetype == FILETYPE_REG)
 		type = GRUB_FSHELP_REG;
 	    }
 	  else
 	    {
 	       
  	      grub_ext2_read_inode (diro->data,
                                      grub_le_to_cpu32 (dirent.inode),
  				    &fdiro->inode);
	      if (grub_errno)
		{
 	      if (grub_errno) {
                   free (filename);
  		  grub_free (fdiro);
  		  return 0;
  		}
 
 	      fdiro->inode_read = 1;
 
 	      if ((grub_le_to_cpu16 (fdiro->inode.mode)
 		   & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)
 		type = GRUB_FSHELP_DIR;
 	      else if ((grub_le_to_cpu16 (fdiro->inode.mode)
 			& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)
 		type = GRUB_FSHELP_SYMLINK;
 	      else if ((grub_le_to_cpu16 (fdiro->inode.mode)
 			& FILETYPE_INO_MASK) == FILETYPE_INO_REG)
  		type = GRUB_FSHELP_REG;
  	    }
  
	  if (hook (filename, type, fdiro, closure))
 	  if (hook (filename, type, fdiro, closure)) {
             free (filename);
  	    return 1;
           }
           free (filename);
  	}
  
        fpos += grub_le_to_cpu16 (dirent.direntlen);
     }
 
   return 0;
 }","[42, 43, 44, 49, 50, 52, 56, 57, 59, 85, 86, 105, 106, 108, 109, 34, 35, 36, 38, 48, 55, 83, 84, 104]","The grub_memmove function in shlr/grub/kern/misc.c in radare2 1.5.0 allows remote attackers to cause a denial of service (stack-based buffer underflow and application crash) or possibly have unspecified other impact via a crafted binary file, possibly related to a buffer underflow in fs/ext2.c in GNU GRUB 2.02."
201471," static int DefragMfIpv4Test(void)
 {
     int retval = 0;
     int ip_id = 9;
     Packet *p = NULL;
  
      DefragInit();
  
    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
     Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
     Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
     Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
      if (p1 == NULL || p2 == NULL || p3 == NULL) {
          goto end;
      }
 
     p = Defrag(NULL, NULL, p1, NULL);
     if (p != NULL) {
         goto end;
     }
 
     p = Defrag(NULL, NULL, p2, NULL);
     if (p != NULL) {
         goto end;
     }
 
      
     p = Defrag(NULL, NULL, p3, NULL);
     if (p == NULL) {
         goto end;
     }
 
      
     if (IPV4_GET_IPLEN(p) != 36) {
         goto end;
     }
 
     retval = 1;
 end:
     if (p1 != NULL) {
         SCFree(p1);
     }
     if (p2 != NULL) {
         SCFree(p2);
     }
     if (p3 != NULL) {
         SCFree(p3);
     }
     if (p != NULL) {
         SCFree(p);
     }
     DefragDestroy();
     return retval;
 }","[12, 13, 14, 9, 10, 11]",Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.
201840," void pdo_stmt_init(TSRMLS_D)
 {
 	zend_class_entry ce;
 
 	INIT_CLASS_ENTRY(ce, ""PDOStatement"", pdo_dbstmt_functions);
 	pdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);
 	pdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;
 	pdo_dbstmt_ce->create_object = pdo_dbstmt_new;
 	zend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);
 	zend_declare_property_null(pdo_dbstmt_ce, ""queryString"", sizeof(""queryString"")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
 
 	memcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));
 	pdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;
 	pdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;
 	pdo_dbstmt_object_handlers.get_method = dbstmt_method_get;
 	pdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;
 	pdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;
 
 	INIT_CLASS_ENTRY(ce, ""PDORow"", pdo_row_functions);
 	pdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);
  	pdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS;  
  	pdo_row_ce->create_object = pdo_row_new;
  	pdo_row_ce->serialize = pdo_row_serialize;
 	pdo_row_ce->unserialize = zend_class_unserialize_deny;
  }",[24],"ext/wddx/wddx.c in PHP before 5.6.28 and 7.x before 7.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via crafted serialized data in a wddxPacket XML document, as demonstrated by a PDORow string."
207489," static void *sock_poll_thread(void *arg)
 {
  struct pollfd pfds[MAX_POLL];
     memset(pfds, 0, sizeof(pfds));
  int h = (intptr_t)arg;
 
      for(;;)
      {
          prepare_poll_fds(h, pfds);
        int ret = poll(pfds, ts[h].poll_count, -1);
         int ret = TEMP_FAILURE_RETRY(poll(pfds, ts[h].poll_count, -1));
          if(ret == -1)
          {
              APPL_TRACE_ERROR(""poll ret -1, exit the thread, errno:%d, err:%s"", errno, strerror(errno));
  break;
  }
  if(ret != 0)
  {
  int need_process_data_fd = TRUE;
  if(pfds[0].revents)  
  {
                 asrt(pfds[0].fd == ts[h].cmd_fdr);
  if(!process_cmd_sock(h))
  {
                     APPL_TRACE_DEBUG(""h:%d, process_cmd_sock return false, exit..."", h);
  break;
  }
  if(ret == 1)
                     need_process_data_fd = FALSE;
  else ret--;  
  }
  if(need_process_data_fd)
                 process_data_sock(h, pfds, ret);
  }
  else {APPL_TRACE_DEBUG(""no data, select ret: %d"", ret)};
  }
     ts[h].thread_id = -1;
     APPL_TRACE_DEBUG(""socket poll thread exiting, h:%d"", h);
  return 0;
 }","[11, 10]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
200494," int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)
 {
 	int ret;
 	int size;
 
 	if (ud->side == USBIP_STUB) {
 		 
 		if (usb_pipein(urb->pipe))
 			return 0;
 
 		size = urb->transfer_buffer_length;
 	} else {
 		 
 		if (usb_pipeout(urb->pipe))
 			return 0;
 
 		size = urb->actual_length;
 	}
 
 	 
  	if (!(size > 0))
  		return 0;
  
 	if (size > urb->transfer_buffer_length) {
 		 
 		if (ud->side == USBIP_STUB) {
 			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
 			return 0;
 		} else {
 			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 			return -EPIPE;
 		}
 	}
 
  	ret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);
  	if (ret != size) {
  		dev_err(&urb->dev->dev, ""recv xbuf, %d\n"", ret);
 		if (ud->side == USBIP_STUB) {
 			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
 		} else {
 			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 			return -EPIPE;
 		}
 	}
 
 	return ret;
 }","[24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34]",The usbip_recv_xbuff function in drivers/usb/usbip/usbip_common.c in the Linux kernel before 4.5.3 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted length value in a USB/IP packet.
202871," static void Sp_replace_regexp(js_State *J)
 {
 	js_Regexp *re;
 	const char *source, *s, *r;
 	js_Buffer *sb = NULL;
 	int n, x;
 	Resub m;
 
  	source = checkstring(J, 0);
  	re = js_toregexp(J, 1);
  
	if (js_regexec(re->prog, source, &m, 0)) {
 	if (js_doregexec(J, re->prog, source, &m, 0)) {
  		js_copy(J, 0);
  		return;
  	}
 
 	re->last = 0;
 
 loop:
 	s = m.sub[0].sp;
 	n = m.sub[0].ep - m.sub[0].sp;
 
 	if (js_iscallable(J, 2)) {
 		js_copy(J, 2);
 		js_pushundefined(J);
 		for (x = 0; m.sub[x].sp; ++x)  
 			js_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);
 		js_pushnumber(J, s - source);  
 		js_copy(J, 0);  
 		js_call(J, 2 + x);
 		r = js_tostring(J, -1);
 		js_putm(J, &sb, source, s);
 		js_puts(J, &sb, r);
 		js_pop(J, 1);
 	} else {
 		r = js_tostring(J, 2);
 		js_putm(J, &sb, source, s);
 		while (*r) {
 			if (*r == '$') {
 				switch (*(++r)) {
 				case 0: --r;  
 				 
 				case '$': js_putc(J, &sb, '$'); break;
 				case '`': js_putm(J, &sb, source, s); break;
 				case '\'': js_puts(J, &sb, s + n); break;
 				case '&':
 					js_putm(J, &sb, s, s + n);
 					break;
 				case '0': case '1': case '2': case '3': case '4':
 				case '5': case '6': case '7': case '8': case '9':
 					x = *r - '0';
 					if (r[1] >= '0' && r[1] <= '9')
 						x = x * 10 + *(++r) - '0';
 					if (x > 0 && x < m.nsub) {
 						js_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);
 					} else {
 						js_putc(J, &sb, '$');
 						if (x > 10) {
 							js_putc(J, &sb, '0' + x / 10);
 							js_putc(J, &sb, '0' + x % 10);
 						} else {
 							js_putc(J, &sb, '0' + x);
 						}
 					}
 					break;
 				default:
 					js_putc(J, &sb, '$');
 					js_putc(J, &sb, *r);
 					break;
 				}
 				++r;
 			} else {
 				js_putc(J, &sb, *r++);
 			}
 		}
 	}
 
 	if (re->flags & JS_REGEXP_G) {
 		source = m.sub[0].ep;
 		if (n == 0) {
 			if (*source)
 				js_putc(J, &sb, *source++);
  			else
  				goto end;
  		}
		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
 		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
  			goto loop;
  	}
  
 end:
 	js_puts(J, &sb, s + n);
 	js_putc(J, &sb, 0);
 
 	if (js_try(J)) {
 		js_free(J, sb);
 		js_throw(J);
 	}
 	js_pushstring(J, sb ? sb->s : """");
 	js_endtry(J);
 	js_free(J, sb);
 }","[13, 88, 12, 87]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.
202416," int git_delta_apply(
 	void **out,
 	size_t *out_len,
 	const unsigned char *base,
 	size_t base_len,
 	const unsigned char *delta,
 	size_t delta_len)
 {
 	const unsigned char *delta_end = delta + delta_len;
 	size_t base_sz, res_sz, alloc_sz;
 	unsigned char *res_dp;
 
 	*out = NULL;
 	*out_len = 0;
 
 	 
 	if ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {
 		giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data"");
 		return -1;
 	}
 
 	if (hdr_sz(&res_sz, &delta, delta_end) < 0) {
 		giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data"");
 		return -1;
 	}
 
 	GITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);
 	res_dp = git__malloc(alloc_sz);
 	GITERR_CHECK_ALLOC(res_dp);
 
 	res_dp[res_sz] = '\0';
 	*out = res_dp;
 	*out_len = res_sz;
 
 	while (delta < delta_end) {
 		unsigned char cmd = *delta++;
 		if (cmd & 0x80) {
  			 
  			size_t off = 0, len = 0;
  
			if (cmd & 0x01) off = *delta++;
			if (cmd & 0x02) off |= *delta++ << 8UL;
			if (cmd & 0x04) off |= *delta++ << 16UL;
			if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);
			if (cmd & 0x10) len = *delta++;
			if (cmd & 0x20) len |= *delta++ << 8UL;
			if (cmd & 0x40) len |= *delta++ << 16UL;
 #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }
 			if (cmd & 0x01) ADD_DELTA(off, 0UL);
 			if (cmd & 0x02) ADD_DELTA(off, 8UL);
 			if (cmd & 0x04) ADD_DELTA(off, 16UL);
 			if (cmd & 0x08) ADD_DELTA(off, 24UL);
 
 			if (cmd & 0x10) ADD_DELTA(len, 0UL);
 			if (cmd & 0x20) ADD_DELTA(len, 8UL);
 			if (cmd & 0x40) ADD_DELTA(len, 16UL);
  			if (!len)       len = 0x10000;
 #undef ADD_DELTA
  
  			if (base_len < off + len || res_sz < len)
  				goto fail;
 			memcpy(res_dp, base + off, len);
 			res_dp += len;
 			res_sz -= len;
 
 		} else if (cmd) {
 			 
 			if (delta_end - delta < cmd || res_sz < cmd)
 				goto fail;
 			memcpy(res_dp, delta, cmd);
 			delta += cmd;
 			res_dp += cmd;
 			res_sz -= cmd;
 
 		} else {
 			 
 			goto fail;
 		}
 	}
 
 	if (delta != delta_end || res_sz)
 		goto fail;
 	return 0;
 
 fail:
 	git__free(*out);
 
 	*out = NULL;
 	*out_len = 0;
 
 	giterr_set(GITERR_INVALID, ""failed to apply delta"");
 	return -1;
 }","[48, 49, 50, 51, 52, 53, 54, 55, 56, 58, 41, 42, 43, 44, 45, 46, 47]","A flaw was found in libgit2 before version 0.27.3. A missing check in git_delta_apply function in delta.c file, may lead to an out-of-bound read while reading a binary delta file. An attacker may use this flaw to cause a Denial of Service."
202646,"  static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,
  				 struct param_mem *mem)
  {
 	size_t req_size = 0;
  	uint64_t shm_ref = READ_ONCE(rmem->shm_ref);
  
  	mem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);
 	if (!mem->mobj)
 		return TEE_ERROR_BAD_PARAMETERS;
 
  	mem->offs = READ_ONCE(rmem->offs);
  	mem->size = READ_ONCE(rmem->size);
  
 	 
 	if (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||
 	    mem->mobj->size < req_size)
 		return TEE_ERROR_SECURITY;
 
  	return TEE_SUCCESS;
  }","[4, 14, 15, 16, 17, 18]",Linaro/OP-TEE OP-TEE Prior to version v3.4.0 is affected by: Boundary checks. The impact is: This could lead to corruption of any memory which the TA can access. The component is: optee_os. The fixed version is: v3.4.0.
198683," main(int argc, char **argv)
 {
    int i, valgrind_mode = 0;
    int valgrind_tool = 0;
    int valgrind_gdbserver = 0;
    char buf[16384], **args, *home;
    char valgrind_path[PATH_MAX] = """";
    const char *valgrind_log = NULL;
    Eina_Bool really_know = EINA_FALSE;
    struct sigaction action;
    pid_t child = -1;
 #ifdef E_CSERVE
    pid_t cs_child = -1;
    Eina_Bool cs_use = EINA_FALSE;
 #endif
 #if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) && \
    !defined(__FreeBSD_kernel__) && !(defined (__MACH__) && defined (__APPLE__))
    Eina_Bool restart = EINA_TRUE;
 #endif
 
    unsetenv(""NOTIFY_SOCKET"");
 
     
    action.sa_sigaction = _sigusr1;
    action.sa_flags = SA_RESETHAND;
    sigemptyset(&action.sa_mask);
    sigaction(SIGUSR1, &action, NULL);
 
    eina_init();
 
     
    if ((!getenv(""DBUS_SESSION_BUS_ADDRESS"")) &&
        (!getenv(""DBUS_LAUNCHD_SESSION_BUS_SOCKET"")))
      {
         char **dbus_argv;
 
         dbus_argv = alloca((argc + 3) * sizeof (char *));
         dbus_argv[0] = ""dbus-launch"";
         dbus_argv[1] = ""--exit-with-session"";
         copy_args(dbus_argv + 2, argv, argc);
         dbus_argv[2 + argc] = NULL;
         execvp(""dbus-launch"", dbus_argv);
      }
 
    prefix_determine(argv[0]);
 
    env_set(""E_START"", argv[0]);
 
    for (i = 1; i < argc; i++)
      {
         if (!strcmp(argv[i], ""-valgrind-gdb""))
           valgrind_gdbserver = 1;
         else if (!strncmp(argv[i], ""-valgrind"", sizeof(""-valgrind"") - 1))
           {
              const char *val = argv[i] + sizeof(""-valgrind"") - 1;
 
              if (*val == '\0') valgrind_mode = 1;
              else if (*val == '-')
                {
                   val++;
                   if (!strncmp(val, ""log-file="", sizeof(""log-file="") - 1))
                     {
                        valgrind_log = val + sizeof(""log-file="") - 1;
                        if (*valgrind_log == '\0') valgrind_log = NULL;
                     }
                }
              else if (*val == '=')
                {
                   val++;
                   if (!strcmp(val, ""all"")) valgrind_mode = VALGRIND_MODE_ALL;
                   else valgrind_mode = atoi(val);
                }
              else
                printf(""Unknown valgrind option: %s\n"", argv[i]);
           }
         else if (!strcmp(argv[i], ""-display""))
           {
              i++;
              env_set(""DISPLAY"", argv[i]);
           }
         else if (!strcmp(argv[i], ""-massif""))
           valgrind_tool = 1;
         else if (!strcmp(argv[i], ""-callgrind""))
           valgrind_tool = 2;
         else if ((!strcmp(argv[i], ""-h"")) ||
                  (!strcmp(argv[i], ""-help"")) ||
                  (!strcmp(argv[i], ""--help"")))
           {
              printf
              (
                ""Options:\n""
                ""\t-valgrind[=MODE]\n""
                ""\t\tRun enlightenment from inside valgrind, mode is OR of:\n""
                ""\t\t   1 = plain valgrind to catch crashes (default)\n""
                ""\t\t   2 = trace children (thumbnailer, efm slaves, ...)\n""
                ""\t\t   4 = check leak\n""
                ""\t\t   8 = show reachable after processes finish.\n""
                ""\t\t all = all of above\n""
                ""\t-massif\n""
                ""\t\tRun enlightenment from inside massif valgrind tool.\n""
                ""\t-callgrind\n""
                ""\t\tRun enlightenment from inside callgrind valgrind tool.\n""
                ""\t-valgrind-log-file=<FILENAME>\n""
                ""\t\tSave valgrind log to file, see valgrind's --log-file for details.\n""
                ""\n""
                ""Please run:\n""
                ""\tenlightenment %s\n""
                ""for more options.\n"",
                argv[i]);
              exit(0);
           }
         else if (!strcmp(argv[i], ""-i-really-know-what-i-am-doing-and-accept-full-responsibility-for-it""))
           really_know = EINA_TRUE;
      }
 
    if (really_know)
      _env_path_append(""PATH"", eina_prefix_bin_get(pfx));
    else
      _env_path_prepend(""PATH"", eina_prefix_bin_get(pfx));
 
    if (valgrind_mode || valgrind_tool)
      {
         if (!find_valgrind(valgrind_path, sizeof(valgrind_path)))
           {
              printf(""E - valgrind required but no binary found! Ignoring request.\n"");
              valgrind_mode = 0;
           }
      }
 
    printf(""E - PID=%i, valgrind=%d"", getpid(), valgrind_mode);
    if (valgrind_mode)
      {
         printf("" valgrind-command='%s'"", valgrind_path);
         if (valgrind_log) printf("" valgrind-log-file='%s'"", valgrind_log);
      }
    putchar('\n');
 
     
    home = getenv(""HOME"");
    if (home)
      {
         FILE *f;
 
          
         snprintf(buf, sizeof(buf), ""%s/.e-mtrack"", home);
         f = fopen(buf, ""r"");
         if (f)
           {
              if (fgets(buf, sizeof(buf), f))
                {
                   int len = strlen(buf);
                   if ((len > 1) && (buf[len - 1] == '\n'))
                     {
                        buf[len - 1] = 0;
                        len--;
                     }
                   env_set(""LD_PRELOAD"", buf);
                   env_set(""MTRACK"", ""track"");
                   env_set(""E_START_MTRACK"", ""track"");
                   snprintf(buf, sizeof(buf), ""%s/.e-mtrack.log"", home);
                   env_set(""MTRACK_TRACE_FILE"", buf);
                }
              fclose(f);
           }
      }
 
     
    snprintf(buf, sizeof(buf), ""%s/enlightenment"", eina_prefix_bin_get(pfx));
 
    args = alloca((argc + 2 + VALGRIND_MAX_ARGS) * sizeof(char *));
    i = valgrind_append(args, valgrind_gdbserver, valgrind_mode, valgrind_tool, valgrind_path, valgrind_log);
    args[i++] = buf;
    copy_args(args + i, argv + 1, argc - 1);
    args[i + argc - 1] = NULL;
 
    if (valgrind_tool || valgrind_mode)
      really_know = EINA_TRUE;
 
 #if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || \
    defined(__FreeBSD_kernel__) || (defined (__MACH__) && defined (__APPLE__))
    execv(args[0], args);
 #endif
 
     
 
 #if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) && \
    !defined(__FreeBSD_kernel__) && !(defined (__MACH__) && defined (__APPLE__))
 
 #ifdef E_CSERVE
    if (getenv(""E_CSERVE""))
      {
         cs_use = EINA_TRUE;
         cs_child = _cserve2_start();
      }
 #endif
 
     
    while (restart)
      {
         stop_ptrace = EINA_FALSE;
 
         child = fork();
 
         if (child < 0)  
           return -1;
         else if (child == 0)
           {
 #ifdef HAVE_SYS_PTRACE_H
              if (!really_know)
                 
                ptrace(PT_TRACE_ME, 0, NULL, NULL);
 #endif
              execv(args[0], args);
              return 0;  
           }
         else
           {
              env_set(""E_RESTART"", ""1"");
               
              pid_t result;
              int status;
              Eina_Bool done = EINA_FALSE;
 
 #ifdef HAVE_SYS_PTRACE_H
              if (!really_know)
                ptrace(PT_ATTACH, child, NULL, NULL);
              result = waitpid(child, &status, 0);
              if ((!really_know) && (!stop_ptrace))
                {
                   if (WIFSTOPPED(status))
                     ptrace(PT_CONTINUE, child, NULL, NULL);
                }
 #endif
              while (!done)
                {
                   Eina_Bool remember_sigill = EINA_FALSE;
                   Eina_Bool remember_sigusr1 = EINA_FALSE;
 
                   result = waitpid(child, &status, WNOHANG);
                   if (!result)
                     {
                         
                        result = waitpid(-1, &status, 0);
                     }
 
                   if (result == child)
                     {
                        if ((WIFSTOPPED(status)) && (!stop_ptrace))
                          {
                             char buffer[4096];
                             char *backtrace_str = NULL;
                             siginfo_t sig;
                             int r = 0;
                             int back;
 
 #ifdef HAVE_SYS_PTRACE_H
                             if (!really_know)
                               r = ptrace(PT_GETSIGINFO, child, NULL, &sig);
 #endif
                             back = r == 0 &&
                               sig.si_signo != SIGTRAP ? sig.si_signo : 0;
 
                             if (sig.si_signo == SIGUSR1)
                               {
                                  if (remember_sigill)
                                    remember_sigusr1 = EINA_TRUE;
                               }
                             else if (sig.si_signo == SIGILL)
                               {
                                  remember_sigill = EINA_TRUE;
                               }
                             else
                               {
                                  remember_sigill = EINA_FALSE;
                               }
 
                             if (r != 0 ||
                                 (sig.si_signo != SIGSEGV &&
                                  sig.si_signo != SIGFPE &&
                                  sig.si_signo != SIGABRT))
                               {
 #ifdef HAVE_SYS_PTRACE_H
                                  if (!really_know)
                                    ptrace(PT_CONTINUE, child, NULL, back);
 #endif
                                  continue;
                               }
 #ifdef HAVE_SYS_PTRACE_H
                             if (!really_know)
                                
                               ptrace(PT_DETACH, child, NULL, back);
 #endif
                              
                             r = 0;
                             if (home)
                                {
                                    
                                   snprintf(buffer, 4096,
                                          ""%s/enlightenment/utils/enlightenment_sys gdb %i %s/.e-crashdump.txt"",
                                          eina_prefix_lib_get(pfx),
                                           ""gdb %i %s/.e-crashdump.txt"",
                                            child,
                                            home);
                                   r = system(buffer);
                                  r = system(buffer);
 
                                  fprintf(stderr, ""called gdb with '%s' = %i\n"",
                                          buffer, WEXITSTATUS(r));
 
                                  snprintf(buffer, 4096,
                                           ""%s/.e-crashdump.txt"",
                                           home);
 
                                  backtrace_str = strdup(buffer);
                                  r = WEXITSTATUS(r);
                               }
 
                              
                             snprintf(buffer, 4096,
                                      backtrace_str ?
                                      ""%s/enlightenment/utils/enlightenment_alert %i %i '%s' %i"" :
                                      ""%s/enlightenment/utils/enlightenment_alert %i %i '%s' %i"",
                                      eina_prefix_lib_get(pfx),
                                      sig.si_signo == SIGSEGV && remember_sigusr1 ? SIGILL : sig.si_signo,
                                      child,
                                      backtrace_str,
                                      r);
                             r = system(buffer);
 
                              
                             kill(child, SIGKILL);
 
                             if (WEXITSTATUS(r) != 1)
                               {
                                  restart = EINA_FALSE;
                               }
                          }
                        else if (!WIFEXITED(status))
                          {
                             done = EINA_TRUE;
                          }
                        else if (stop_ptrace)
                          {
                             done = EINA_TRUE;
                          }
                     }
                   else if (result == -1)
                     {
                        if (errno != EINTR)
                          {
                             done = EINA_TRUE;
                             restart = EINA_FALSE;
                          }
                        else
                          {
                             if (stop_ptrace)
                               {
                                  kill(child, SIGSTOP);
                                  usleep(200000);
 #ifdef HAVE_SYS_PTRACE_H
                                  if (!really_know)
                                    ptrace(PT_DETACH, child, NULL, NULL);
 #endif
                               }
                          }
                     }
 #ifdef E_CSERVE
                   else if (cs_use && (result == cs_child))
                     {
                        if (WIFSIGNALED(status))
                          {
                             printf(""E - cserve2 terminated with signal %d\n"",
                                    WTERMSIG(status));
                             cs_child = _cserve2_start();
                          }
                        else if (WIFEXITED(status))
                          {
                             printf(""E - cserve2 exited with code %d\n"",
                                    WEXITSTATUS(status));
                             cs_child = -1;
                          }
                     }
 #endif
                }
           }
      }
 #endif
 
 #ifdef E_CSERVE
    if (cs_child > 0)
      {
         pid_t result;
         int status;
 
         alarm(2);
         kill(cs_child, SIGINT);
         result = waitpid(cs_child, &status, 0);
         if (result != cs_child)
           {
              printf(""E - cserve2 did not shutdown in 2 seconds, killing!\n"");
              kill(cs_child, SIGKILL);
           }
      }
 #endif
 
    return -1;
 }","[301, 299, 300]",Enlightenment before 0.17.6 might allow local users to gain privileges via vectors involving the gdb method.
200418," MagickExport MagickBooleanType DrawPrimitive(Image *image,
   const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,
   ExceptionInfo *exception)
 {
   CacheView
     *image_view;
 
   MagickStatusType
     status;
 
   register ssize_t
     i,
     x;
 
   ssize_t
     y;
 
   if (image->debug != MagickFalse)
     {
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),
         ""  begin draw-primitive"");
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),
         ""    affine: %g %g %g %g %g %g"",draw_info->affine.sx,
         draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,
         draw_info->affine.tx,draw_info->affine.ty);
     }
   if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&
       ((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||
        (IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))
     (void) SetImageColorspace(image,sRGBColorspace,exception);
   status=MagickTrue;
   x=(ssize_t) ceil(primitive_info->point.x-0.5);
   y=(ssize_t) ceil(primitive_info->point.y-0.5);
   image_view=AcquireAuthenticCacheView(image,exception);
   switch (primitive_info->primitive)
   {
     case AlphaPrimitive:
     {
       if (image->alpha_trait == UndefinedPixelTrait)
         (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
       switch (primitive_info->method)
       {
         case PointMethod:
         default:
         {
           PixelInfo
             pixel;
 
           register Quantum
             *q;
 
           q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
           if (q == (Quantum *) NULL)
             break;
           GetFillColor(draw_info,x,y,&pixel,exception);
           SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
           (void) SyncCacheViewAuthenticPixels(image_view,exception);
           break;
         }
         case ReplaceMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel,
             target;
 
           (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
             exception);
           GetPixelInfo(image,&pixel);
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               GetPixelInfoPixel(image,q,&pixel);
               if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
         case FloodfillMethod:
         case FillToBorderMethod:
         {
           ChannelType
             channel_mask;
 
           PixelInfo
             target;
 
           (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
             &target,exception);
           if (primitive_info->method == FillToBorderMethod)
             {
               target.red=(double) draw_info->border_color.red;
               target.green=(double) draw_info->border_color.green;
               target.blue=(double) draw_info->border_color.blue;
             }
           channel_mask=SetImageChannelMask(image,AlphaChannel);
           status&=FloodfillPaintImage(image,draw_info,&target,x,y,
             primitive_info->method == FloodfillMethod ? MagickFalse :
             MagickTrue,exception);
           (void) SetImageChannelMask(image,channel_mask);
           break;
         }
         case ResetMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel;
 
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
       }
       break;
     }
     case ColorPrimitive:
     {
       switch (primitive_info->method)
       {
         case PointMethod:
         default:
         {
           PixelInfo
             pixel;
 
           register Quantum
             *q;
 
           q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
           if (q == (Quantum *) NULL)
             break;
           GetPixelInfo(image,&pixel);
           GetFillColor(draw_info,x,y,&pixel,exception);
           SetPixelViaPixelInfo(image,&pixel,q);
           (void) SyncCacheViewAuthenticPixels(image_view,exception);
           break;
         }
         case ReplaceMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel,
             target;
 
           (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
             exception);
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               GetPixelInfoPixel(image,q,&pixel);
               if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelViaPixelInfo(image,&pixel,q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
         case FloodfillMethod:
         case FillToBorderMethod:
         {
           PixelInfo
             target;
 
           (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
             &target,exception);
           if (primitive_info->method == FillToBorderMethod)
             {
               target.red=(double) draw_info->border_color.red;
               target.green=(double) draw_info->border_color.green;
               target.blue=(double) draw_info->border_color.blue;
             }
           status&=FloodfillPaintImage(image,draw_info,&target,x,y,
             primitive_info->method == FloodfillMethod ? MagickFalse :
             MagickTrue,exception);
           break;
         }
         case ResetMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel;
 
           GetPixelInfo(image,&pixel);
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelViaPixelInfo(image,&pixel,q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
       }
       break;
     }
     case ImagePrimitive:
     {
       AffineMatrix
         affine;
 
       char
         composite_geometry[MagickPathExtent];
 
       Image
         *composite_image;
 
       ImageInfo
         *clone_info;
 
       RectangleInfo
         geometry;
 
       ssize_t
         x1,
         y1;
 
       if (primitive_info->text == (char *) NULL)
         break;
       clone_info=AcquireImageInfo();
       if (LocaleNCompare(primitive_info->text,""data:"",5) == 0)
         composite_image=ReadInlineImage(clone_info,primitive_info->text,
           exception);
       else
         {
           (void) CopyMagickString(clone_info->filename,primitive_info->text,
             MagickPathExtent);
           composite_image=ReadImage(clone_info,exception);
         }
       clone_info=DestroyImageInfo(clone_info);
       if (composite_image == (Image *) NULL)
         break;
       (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)
         NULL,(void *) NULL);
       x1=(ssize_t) ceil(primitive_info[1].point.x-0.5);
       y1=(ssize_t) ceil(primitive_info[1].point.y-0.5);
       if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||
           ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))
         {
            
           (void) FormatLocaleString(composite_geometry,MagickPathExtent,
             ""%gx%g!"",primitive_info[1].point.x,primitive_info[1].point.y);
           composite_image->filter=image->filter;
           (void) TransformImage(&composite_image,(char *) NULL,
             composite_geometry,exception);
         }
       if (composite_image->alpha_trait == UndefinedPixelTrait)
         (void) SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,
           exception);
       if (draw_info->alpha != OpaqueAlpha)
         (void) SetImageAlpha(composite_image,draw_info->alpha,exception);
       SetGeometry(image,&geometry);
       image->gravity=draw_info->gravity;
       geometry.x=x;
       geometry.y=y;
       (void) FormatLocaleString(composite_geometry,MagickPathExtent,
         ""%.20gx%.20g%+.20g%+.20g"",(double) composite_image->columns,(double)
         composite_image->rows,(double) geometry.x,(double) geometry.y);
       (void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);
       affine=draw_info->affine;
       affine.tx=(double) geometry.x;
       affine.ty=(double) geometry.y;
       composite_image->interpolate=image->interpolate;
       if (draw_info->compose == OverCompositeOp)
         (void) DrawAffineImage(image,composite_image,&affine,exception);
       else
         (void) CompositeImage(image,composite_image,draw_info->compose,
           MagickTrue,geometry.x,geometry.y,exception);
       composite_image=DestroyImage(composite_image);
       break;
     }
     case PointPrimitive:
     {
       PixelInfo
         fill_color;
 
       register Quantum
         *q;
 
       if ((y < 0) || (y >= (ssize_t) image->rows))
         break;
       if ((x < 0) || (x >= (ssize_t) image->columns))
         break;
       q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
       if (q == (Quantum *) NULL)
         break;
       GetFillColor(draw_info,x,y,&fill_color,exception);
       CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,
         (double) GetPixelAlpha(image,q),q);
       (void) SyncCacheViewAuthenticPixels(image_view,exception);
       break;
     }
     case TextPrimitive:
     {
       char
         geometry[MagickPathExtent];
 
       DrawInfo
         *clone_info;
 
       if (primitive_info->text == (char *) NULL)
         break;
       clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
       (void) CloneString(&clone_info->text,primitive_info->text);
       (void) FormatLocaleString(geometry,MagickPathExtent,""%+f%+f"",
         primitive_info->point.x,primitive_info->point.y);
       (void) CloneString(&clone_info->geometry,geometry);
       status&=AnnotateImage(image,clone_info,exception);
       clone_info=DestroyDrawInfo(clone_info);
       break;
     }
     default:
     {
       double
         mid,
         scale;
 
       DrawInfo
         *clone_info;
 
       if (IsEventLogging() != MagickFalse)
         LogPrimitiveInfo(primitive_info);
       scale=ExpandAffine(&draw_info->affine);
       if ((draw_info->dash_pattern != (double *) NULL) &&
           (draw_info->dash_pattern[0] != 0.0) &&
           ((scale*draw_info->stroke_width) >= MagickEpsilon) &&
           (draw_info->stroke.alpha != (Quantum) TransparentAlpha))
         {
            
            clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
            clone_info->stroke_width=0.0;
          clone_info->stroke.alpha=(Quantum) TransparentAlpha;
           clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
            status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
              exception);
            clone_info=DestroyDrawInfo(clone_info);
           (void) DrawDashPolygon(draw_info,primitive_info,image,exception);
           break;
         }
       mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
       if ((mid > 1.0) &&
           ((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||
            (draw_info->stroke_pattern != (Image *) NULL)))
         {
           MagickBooleanType
             closed_path;
 
            
           for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;
           closed_path=
             (primitive_info[i-1].point.x == primitive_info[0].point.x) &&
             (primitive_info[i-1].point.y == primitive_info[0].point.y) ?
             MagickTrue : MagickFalse;
           i=(ssize_t) primitive_info[0].coordinates;
           if ((((draw_info->linecap == RoundCap) ||
                 (closed_path != MagickFalse)) &&
                (draw_info->linejoin == RoundJoin)) ||
                (primitive_info[i].primitive != UndefinedPrimitive))
             {
               (void) DrawPolygonPrimitive(image,draw_info,primitive_info,
                 exception);
               break;
              }
            clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
            clone_info->stroke_width=0.0;
          clone_info->stroke.alpha=(Quantum) TransparentAlpha;
           clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
            status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
              exception);
            clone_info=DestroyDrawInfo(clone_info);
           status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);
           break;
         }
       status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);
       break;
     }
   }
   image_view=DestroyCacheView(image_view);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),""  end draw-primitive"");
   return(status != 0 ? MagickTrue : MagickFalse);
 }","[403, 437, 402, 436]","The DrawImage function in MagickCore/draw.c in ImageMagick before 6.9.4-0 and 7.x before 7.0.1-2 makes an incorrect function call in attempting to locate the next token, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
201813," static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define SkipLinesOp  0x01
 #define SetColorOp  0x02
 #define SkipPixelsOp  0x03
 #define ByteDataOp  0x05
 #define RunDataOp  0x06
 #define EOFOp  0x07
 
   char
     magick[12];
 
   Image
     *image;
 
   IndexPacket
     index;
 
   int
     opcode,
     operand,
     status;
 
   MagickStatusType
     flags;
 
   MagickSizeType
     number_pixels;
 
   MemoryInfo
     *pixel_info;
 
   register IndexPacket
     *indexes;
 
   register ssize_t
     x;
 
   register PixelPacket
     *q;
 
   register ssize_t
     i;
 
   register unsigned char
     *p;
 
   size_t
     bits_per_pixel,
     map_length,
     number_colormaps,
     number_planes,
     number_planes_filled,
     one,
     offset,
     pixel_info_length;
 
   ssize_t
     count,
     y;
 
   unsigned char
     background_color[256],
     *colormap,
     pixel,
     plane,
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(DestroyImageList(image));
    
   count=ReadBlob(image,2,(unsigned char *) magick);
   if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   do
   {
      
     image->page.x=ReadBlobLSBShort(image);
     image->page.y=ReadBlobLSBShort(image);
     image->columns=ReadBlobLSBShort(image);
     image->rows=ReadBlobLSBShort(image);
     flags=(MagickStatusType) ReadBlobByte(image);
     image->matte=flags & 0x04 ? MagickTrue : MagickFalse;
     number_planes=(size_t) ReadBlobByte(image);
     bits_per_pixel=(size_t) ReadBlobByte(image);
     number_colormaps=(size_t) ReadBlobByte(image);
     map_length=(unsigned char) ReadBlobByte(image);
     if (map_length >= 32)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     one=1;
     map_length=one << map_length;
     if ((number_planes == 0) || (number_planes == 2) ||
         ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
         (image->columns == 0))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     if (flags & 0x02)
       {
          
         for (i=0; i < (ssize_t) number_planes; i++)
           background_color[i]=0;
         (void) ReadBlobByte(image);
       }
     else
       {
          
         p=background_color;
         for (i=0; i < (ssize_t) number_planes; i++)
           *p++=(unsigned char) ReadBlobByte(image);
       }
     if ((number_planes & 0x01) == 0)
       (void) ReadBlobByte(image);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
     colormap=(unsigned char *) NULL;
     if (number_colormaps != 0)
       {
          
         colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
           3*map_length*sizeof(*colormap));
         if (colormap == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         p=colormap;
         for (i=0; i < (ssize_t) number_colormaps; i++)
           for (x=0; x < (ssize_t) map_length; x++)
             *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
       }
     if ((flags & 0x08) != 0)
       {
         char
           *comment;
 
         size_t
           length;
 
          
         length=ReadBlobLSBShort(image);
         if (length != 0)
           {
             comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
             if (comment == (char *) NULL)
               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
             (void) ReadBlob(image,length-1,(unsigned char *) comment);
             comment[length-1]='\0';
             (void) SetImageProperty(image,""comment"",comment);
             comment=DestroyString(comment);
             if ((length & 0x01) == 0)
               (void) ReadBlobByte(image);
           }
       }
     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }
      
     if (image->matte != MagickFalse)
       number_planes++;
     number_pixels=(MagickSizeType) image->columns*image->rows;
     number_planes_filled=(number_planes % 2 == 0) ? number_planes :
       number_planes+1;
     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
           number_planes_filled))
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      number_planes_filled*sizeof(*pixels));
       MagickMax(number_planes_filled,4)*sizeof(*pixels));
      if (pixel_info == (MemoryInfo *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info_length=image->columns*image->rows*number_planes_filled;
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
      pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
      if ((flags & 0x01) && !(flags & 0x02))
        {
         ssize_t
           j;
 
          
         p=pixels;
         for (i=0; i < (ssize_t) number_pixels; i++)
         {
           if (image->matte == MagickFalse)
             for (j=0; j < (ssize_t) number_planes; j++)
               *p++=background_color[j];
           else
             {
               for (j=0; j < (ssize_t) (number_planes-1); j++)
                 *p++=background_color[j];
               *p++=0;   
             }
         }
       }
      
     plane=0;
     x=0;
     y=0;
     opcode=ReadBlobByte(image);
     do
     {
       switch (opcode & 0x3f)
       {
         case SkipLinesOp:
         {
           operand=ReadBlobByte(image);
           if (opcode & 0x40)
             operand=ReadBlobLSBSignedShort(image);
           x=0;
           y+=operand;
           break;
         }
         case SetColorOp:
         {
           operand=ReadBlobByte(image);
           plane=(unsigned char) operand;
           if (plane == 255)
             plane=(unsigned char) (number_planes-1);
           x=0;
           break;
         }
         case SkipPixelsOp:
         {
           operand=ReadBlobByte(image);
           if (opcode & 0x40)
             operand=ReadBlobLSBSignedShort(image);
           x+=operand;
           break;
         }
         case ByteDataOp:
         {
           operand=ReadBlobByte(image);
           if (opcode & 0x40)
             operand=ReadBlobLSBSignedShort(image);
           offset=((image->rows-y-1)*image->columns*number_planes)+x*
             number_planes+plane;
           operand++;
           if (offset+((size_t) operand*number_planes) > pixel_info_length)
             {
               if (number_colormaps != 0)
                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);
               pixel_info=RelinquishVirtualMemory(pixel_info);
               ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
             }
           p=pixels+offset;
           for (i=0; i < (ssize_t) operand; i++)
           {
             pixel=(unsigned char) ReadBlobByte(image);
             if ((y < (ssize_t) image->rows) &&
                 ((x+i) < (ssize_t) image->columns))
               *p=pixel;
             p+=number_planes;
           }
           if (operand & 0x01)
             (void) ReadBlobByte(image);
           x+=operand;
           break;
         }
         case RunDataOp:
         {
           operand=ReadBlobByte(image);
           if (opcode & 0x40)
             operand=ReadBlobLSBSignedShort(image);
           pixel=(unsigned char) ReadBlobByte(image);
           (void) ReadBlobByte(image);
           operand++;
           offset=((image->rows-y-1)*image->columns*number_planes)+x*
             number_planes+plane;
           p=pixels+offset;
           if (offset+((size_t) operand*number_planes) > pixel_info_length)
             {
               if (number_colormaps != 0)
                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);
               pixel_info=RelinquishVirtualMemory(pixel_info);
               ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
             }
           for (i=0; i < (ssize_t) operand; i++)
           {
             if ((y < (ssize_t) image->rows) &&
                 ((x+i) < (ssize_t) image->columns))
               *p=pixel;
             p+=number_planes;
           }
           x+=operand;
           break;
         }
         default:
           break;
       }
       opcode=ReadBlobByte(image);
     } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
     if (number_colormaps != 0)
       {
         MagickStatusType
           mask;
 
          
         mask=(MagickStatusType) (map_length-1);
         p=pixels;
         x=(ssize_t) number_planes;
         if (number_colormaps == 1)
           for (i=0; i < (ssize_t) number_pixels; i++)
           {
             if (IsValidColormapIndex(image,*p & mask,&index,exception) ==
                 MagickFalse)
               break;
             *p=colormap[(ssize_t) index];
             p++;
           }
         else
           if ((number_planes >= 3) && (number_colormaps >= 3))
             for (i=0; i < (ssize_t) number_pixels; i++)
               for (x=0; x < (ssize_t) number_planes; x++)
               {
                 if (IsValidColormapIndex(image,(size_t) (x*map_length+
                     (*p & mask)),&index,exception) == MagickFalse)
                   break;
                 *p=colormap[(ssize_t) index];
                 p++;
               }
         if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
           {
             colormap=(unsigned char *) RelinquishMagickMemory(colormap);
             pixel_info=RelinquishVirtualMemory(pixel_info);
             ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
           }
       }
      
     if (number_planes >= 3)
       {
          
         p=pixels;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(q,ScaleCharToQuantum(*p++));
             SetPixelGreen(q,ScaleCharToQuantum(*p++));
             SetPixelBlue(q,ScaleCharToQuantum(*p++));
             if (image->matte != MagickFalse)
               SetPixelAlpha(q,ScaleCharToQuantum(*p++));
             q++;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
       }
     else
       {
          
         if (number_colormaps == 0)
           map_length=256;
         if (AcquireImageColormap(image,map_length) == MagickFalse)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         p=colormap;
         if (number_colormaps == 1)
           for (i=0; i < (ssize_t) image->colors; i++)
           {
              
             image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);
             image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);
             image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);
           }
         else
           if (number_colormaps > 1)
             for (i=0; i < (ssize_t) image->colors; i++)
             {
               image->colormap[i].red=ScaleCharToQuantum(*p);
               image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));
               image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));
               p++;
             }
         p=pixels;
         if (image->matte == MagickFalse)
           {
              
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (PixelPacket *) NULL)
                 break;
               indexes=GetAuthenticIndexQueue(image);
               for (x=0; x < (ssize_t) image->columns; x++)
                 SetPixelIndex(indexes+x,*p++);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             (void) SyncImage(image);
           }
         else
           {
              
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (PixelPacket *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 if (IsValidColormapIndex(image,*p++,&index,exception) ==
                     MagickFalse)
                   break;
                 SetPixelRed(q,image->colormap[(ssize_t) index].red);
                 if (IsValidColormapIndex(image,*p++,&index,exception) ==
                     MagickFalse)
                   break;
                 SetPixelGreen(q,image->colormap[(ssize_t) index].green);
                 if (IsValidColormapIndex(image,*p++,&index,exception) ==
                     MagickFalse)
                   break;
                 SetPixelBlue(q,image->colormap[(ssize_t) index].blue);
                 SetPixelAlpha(q,ScaleCharToQuantum(*p++));
                 q++;
               }
               if (x < (ssize_t) image->columns)
                 break;
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             image->colormap=(PixelPacket *) RelinquishMagickMemory(
               image->colormap);
             image->storage_class=DirectClass;
             image->colors=0;
           }
       }
     if (number_colormaps != 0)
       colormap=(unsigned char *) RelinquishMagickMemory(colormap);
     pixel_info=RelinquishVirtualMemory(pixel_info);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     (void) ReadBlobByte(image);
     count=ReadBlob(image,2,(unsigned char *) magick);
     if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
       {
          
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[184, 188, 189, 183, 187]",Buffer overflow in the ReadRLEImage function in coders/rle.c in ImageMagick before 6.9.4-4 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted RLE file.
197769," int recv_files(int f_in, int f_out, char *local_name)
 {
 	int fd1,fd2;
 	STRUCT_STAT st;
 	int iflags, xlen;
 	char *fname, fbuf[MAXPATHLEN];
 	char xname[MAXPATHLEN];
 	char fnametmp[MAXPATHLEN];
 	char *fnamecmp, *partialptr;
 	char fnamecmpbuf[MAXPATHLEN];
 	uchar fnamecmp_type;
 	struct file_struct *file;
 	int itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;
 	enum logcode log_code = log_before_transfer ? FLOG : FINFO;
 	int max_phase = protocol_version >= 29 ? 2 : 1;
 	int dflt_perms = (ACCESSPERMS & ~orig_umask);
 #ifdef SUPPORT_ACLS
 	const char *parent_dirname = """";
 #endif
 	int ndx, recv_ok;
 
 	if (DEBUG_GTE(RECV, 1))
 		rprintf(FINFO, ""recv_files(%d) starting\n"", cur_flist->used);
 
 	if (delay_updates)
 		delayed_bits = bitbag_create(cur_flist->used + 1);
 
 	while (1) {
 		cleanup_disable();
 
 		 
 		ndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,
 					 xname, &xlen);
 		if (ndx == NDX_DONE) {
 			if (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {
 				set_current_file_index(NULL, 0);
 				end_progress(0);
 			}
 			if (inc_recurse && first_flist) {
 				if (read_batch) {
 					ndx = first_flist->used + first_flist->ndx_start;
 					gen_wants_ndx(ndx, first_flist->flist_num);
 				}
 				flist_free(first_flist);
 				if (first_flist)
 					continue;
 			} else if (read_batch && first_flist) {
 				ndx = first_flist->used;
 				gen_wants_ndx(ndx, first_flist->flist_num);
 			}
 			if (++phase > max_phase)
 				break;
 			if (DEBUG_GTE(RECV, 1))
 				rprintf(FINFO, ""recv_files phase=%d\n"", phase);
 			if (phase == 2 && delay_updates)
 				handle_delayed_updates(local_name);
 			write_int(f_out, NDX_DONE);
 			continue;
 		}
 
 		if (ndx - cur_flist->ndx_start >= 0)
 			file = cur_flist->files[ndx - cur_flist->ndx_start];
 		else
 			file = dir_flist->files[cur_flist->parent_ndx];
 		fname = local_name ? local_name : f_name(file, fbuf);
 
 		if (daemon_filter_list.head
 		    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {
 			rprintf(FERROR, ""attempt to hack rsync failed.\n"");
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		if (DEBUG_GTE(RECV, 1))
 			rprintf(FINFO, ""recv_files(%s)\n"", fname);
 
 #ifdef SUPPORT_XATTRS
 		if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers
 		 && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))
 			recv_xattr_request(file, f_in);
 #endif
 
 		if (!(iflags & ITEM_TRANSFER)) {
 			maybe_log_item(file, iflags, itemizing, xname);
 #ifdef SUPPORT_XATTRS
 			if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers
 			 && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))
 				set_file_attrs(fname, file, NULL, fname, 0);
 #endif
 			if (iflags & ITEM_IS_NEW) {
 				stats.created_files++;
 				if (S_ISREG(file->mode)) {
 					 
 				} else if (S_ISDIR(file->mode))
 					stats.created_dirs++;
 #ifdef SUPPORT_LINKS
 				else if (S_ISLNK(file->mode))
 					stats.created_symlinks++;
 #endif
 				else if (IS_DEVICE(file->mode))
 					stats.created_devices++;
 				else
 					stats.created_specials++;
 			}
 			continue;
 		}
 		if (phase == 2) {
 			rprintf(FERROR,
 				""got transfer request in phase 2 [%s]\n"",
 				who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		if (file->flags & FLAG_FILE_SENT) {
 			if (csum_length == SHORT_SUM_LENGTH) {
 				if (keep_partial && !partial_dir)
 					make_backups = -make_backups;  
 				if (append_mode)
 					sparse_files = -sparse_files;
 				append_mode = -append_mode;
 				csum_length = SUM_LENGTH;
 				redoing = 1;
 			}
 		} else {
 			if (csum_length != SHORT_SUM_LENGTH) {
 				if (keep_partial && !partial_dir)
 					make_backups = -make_backups;
 				if (append_mode)
 					sparse_files = -sparse_files;
 				append_mode = -append_mode;
 				csum_length = SHORT_SUM_LENGTH;
 				redoing = 0;
 			}
 			if (iflags & ITEM_IS_NEW)
 				stats.created_files++;
 		}
 
 		if (!am_server && INFO_GTE(PROGRESS, 1))
 			set_current_file_index(file, ndx);
 		stats.xferred_files++;
 		stats.total_transferred_size += F_LENGTH(file);
 
 		cleanup_got_literal = 0;
 
 		if (read_batch) {
 			int wanted = redoing
 				   ? we_want_redo(ndx)
 				   : gen_wants_ndx(ndx, cur_flist->flist_num);
 			if (!wanted) {
 				rprintf(FINFO,
 					""(Skipping batched update for%s \""%s\"")\n"",
 					redoing ? "" resend of"" : """",
 					fname);
 				discard_receive_data(f_in, F_LENGTH(file));
 				file->flags |= FLAG_FILE_SENT;
 				continue;
 			}
 		}
 
 		remember_initial_stats();
 
 		if (!do_xfers) {  
 			log_item(FCLIENT, file, iflags, NULL);
 			if (read_batch)
 				discard_receive_data(f_in, F_LENGTH(file));
 			continue;
 		}
 		if (write_batch < 0) {
 			log_item(FCLIENT, file, iflags, NULL);
 			if (!am_server)
 				discard_receive_data(f_in, F_LENGTH(file));
 			if (inc_recurse)
 				send_msg_int(MSG_SUCCESS, ndx);
 			continue;
 		}
 
 		partialptr = partial_dir ? partial_dir_fname(fname) : fname;
 
 		if (protocol_version >= 29) {
 			switch (fnamecmp_type) {
 			case FNAMECMP_FNAME:
 				fnamecmp = fname;
 				break;
 			case FNAMECMP_PARTIAL_DIR:
 				fnamecmp = partialptr;
 				break;
 			case FNAMECMP_BACKUP:
 				fnamecmp = get_backup_name(fname);
 				break;
 			case FNAMECMP_FUZZY:
 				if (file->dirname) {
 					pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);
 					fnamecmp = fnamecmpbuf;
 				} else
 					fnamecmp = xname;
 				break;
 			default:
 				if (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {
 					fnamecmp_type -= FNAMECMP_FUZZY + 1;
 					if (file->dirname) {
 						stringjoin(fnamecmpbuf, sizeof fnamecmpbuf,
 							   basis_dir[fnamecmp_type], ""/"", file->dirname, ""/"", xname, NULL);
 					} else
 						pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);
 				} else if (fnamecmp_type >= basis_dir_cnt) {
 					rprintf(FERROR,
 						""invalid basis_dir index: %d.\n"",
 						fnamecmp_type);
 					exit_cleanup(RERR_PROTOCOL);
 				} else
 					pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);
 				fnamecmp = fnamecmpbuf;
                                 break;
                         }
                         if (!fnamecmp || (daemon_filter_list.head
                         && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {
                          && check_filter(&daemon_filter_list, FLOG, fnamecmp, 0) < 0)) {
                                 fnamecmp = fname;
                                 fnamecmp_type = FNAMECMP_FNAME;
                         }
 		} else {
 			 
 			if (inplace && make_backups > 0) {
 				if (!(fnamecmp = get_backup_name(fname)))
 					fnamecmp = fname;
 				else
 					fnamecmp_type = FNAMECMP_BACKUP;
 			} else if (partial_dir && partialptr)
 				fnamecmp = partialptr;
 			else
 				fnamecmp = fname;
 		}
 
 		 
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
 		if (fd1 == -1 && protocol_version < 29) {
 			if (fnamecmp != fname) {
 				fnamecmp = fname;
 				fd1 = do_open(fnamecmp, O_RDONLY, 0);
 			}
 
 			if (fd1 == -1 && basis_dir[0]) {
 				 
 				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
 					 basis_dir[0], fname);
 				fnamecmp = fnamecmpbuf;
 				fd1 = do_open(fnamecmp, O_RDONLY, 0);
 			}
 		}
 
 		updating_basis_or_equiv = inplace
 		    && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP);
 
 		if (fd1 == -1) {
 			st.st_mode = 0;
 			st.st_size = 0;
 		} else if (do_fstat(fd1,&st) != 0) {
 			rsyserr(FERROR_XFER, errno, ""fstat %s failed"",
 				full_fname(fnamecmp));
 			discard_receive_data(f_in, F_LENGTH(file));
 			close(fd1);
 			if (inc_recurse)
 				send_msg_int(MSG_NO_SEND, ndx);
 			continue;
 		}
 
 		if (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {
 			 
 			rprintf(FERROR_XFER, ""recv_files: %s is a directory\n"",
 				full_fname(fnamecmp));
 			discard_receive_data(f_in, F_LENGTH(file));
 			close(fd1);
 			if (inc_recurse)
 				send_msg_int(MSG_NO_SEND, ndx);
 			continue;
 		}
 
 		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
 			close(fd1);
 			fd1 = -1;
 		}
 
 		 
 		if (!preserve_perms) {
 			int exists = fd1 != -1;
 #ifdef SUPPORT_ACLS
 			const char *dn = file->dirname ? file->dirname : ""."";
 			if (parent_dirname != dn
 			 && strcmp(parent_dirname, dn) != 0) {
 				dflt_perms = default_perms_for_dir(dn);
 				parent_dirname = dn;
 			}
 #endif
 			file->mode = dest_mode(file->mode, st.st_mode,
 					       dflt_perms, exists);
 		}
 
 		 
 		if (inplace)  {
 			fd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);
 			if (fd2 == -1) {
 				rsyserr(FERROR_XFER, errno, ""open %s failed"",
 					full_fname(fname));
 			} else if (updating_basis_or_equiv)
 				cleanup_set(NULL, NULL, file, fd1, fd2);
 		} else {
 			fd2 = open_tmpfile(fnametmp, fname, file);
 			if (fd2 != -1)
 				cleanup_set(fnametmp, partialptr, file, fd1, fd2);
 		}
 
 		if (fd2 == -1) {
 			discard_receive_data(f_in, F_LENGTH(file));
 			if (fd1 != -1)
 				close(fd1);
 			if (inc_recurse)
 				send_msg_int(MSG_NO_SEND, ndx);
 			continue;
 		}
 
 		 
 		if (log_before_transfer)
 			log_item(FCLIENT, file, iflags, NULL);
 		else if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))
 			rprintf(FINFO, ""%s\n"", fname);
 
 		 
 		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
 				       fname, fd2, F_LENGTH(file));
 
 		log_item(log_code, file, iflags, NULL);
 
 		if (fd1 != -1)
 			close(fd1);
 		if (close(fd2) < 0) {
 			rsyserr(FERROR, errno, ""close failed on %s"",
 				full_fname(fnametmp));
 			exit_cleanup(RERR_FILEIO);
 		}
 
 		if ((recv_ok && (!delay_updates || !partialptr)) || inplace) {
 			if (partialptr == fname)
 				partialptr = NULL;
 			if (!finish_transfer(fname, fnametmp, fnamecmp,
 					     partialptr, file, recv_ok, 1))
 				recv_ok = -1;
 			else if (fnamecmp == partialptr) {
 				do_unlink(partialptr);
 				handle_partial_dir(partialptr, PDIR_DELETE);
 			}
 		} else if (keep_partial && partialptr) {
 			if (!handle_partial_dir(partialptr, PDIR_CREATE)) {
 				rprintf(FERROR,
 				    ""Unable to create partial-dir for %s -- discarding %s.\n"",
 				    local_name ? local_name : f_name(file, NULL),
 				    recv_ok ? ""completed file"" : ""partial file"");
 				do_unlink(fnametmp);
 				recv_ok = -1;
 			} else if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,
 						    file, recv_ok, !partial_dir))
 				recv_ok = -1;
 			else if (delay_updates && recv_ok) {
 				bitbag_set_bit(delayed_bits, ndx);
 				recv_ok = 2;
 			} else
 				partialptr = NULL;
 		} else
 			do_unlink(fnametmp);
 
 		cleanup_disable();
 
 		if (read_batch)
 			file->flags |= FLAG_FILE_SENT;
 
 		switch (recv_ok) {
 		case 2:
 			break;
 		case 1:
 			if (remove_source_files || inc_recurse
 			 || (preserve_hard_links && F_IS_HLINKED(file)))
 				send_msg_int(MSG_SUCCESS, ndx);
 			break;
 		case 0: {
 			enum logcode msgtype = redoing ? FERROR_XFER : FWARNING;
 			if (msgtype == FERROR_XFER || INFO_GTE(NAME, 1)) {
 				char *errstr, *redostr, *keptstr;
 				if (!(keep_partial && partialptr) && !inplace)
 					keptstr = ""discarded"";
 				else if (partial_dir)
 					keptstr = ""put into partial-dir"";
 				else
 					keptstr = ""retained"";
 				if (msgtype == FERROR_XFER) {
 					errstr = ""ERROR"";
 					redostr = """";
 				} else {
 					errstr = ""WARNING"";
 					redostr = read_batch ? "" (may try again)""
 							     : "" (will try again)"";
 				}
 				rprintf(msgtype,
 					""%s: %s failed verification -- update %s%s.\n"",
 					errstr, local_name ? f_name(file, NULL) : fname,
 					keptstr, redostr);
 			}
 			if (!redoing) {
 				if (read_batch)
 					flist_ndx_push(&batch_redo_list, ndx);
 				send_msg_int(MSG_REDO, ndx);
 				file->flags |= FLAG_FILE_SENT;
 			} else if (inc_recurse)
 				send_msg_int(MSG_NO_SEND, ndx);
 			break;
 		    }
 		case -1:
 			if (inc_recurse)
 				send_msg_int(MSG_NO_SEND, ndx);
 			break;
 		}
 	}
 	if (make_backups < 0)
 		make_backups = -make_backups;
 
 	if (phase == 2 && delay_updates)  
 		handle_delayed_updates(local_name);
 
 	if (DEBUG_GTE(RECV, 1))
 		rprintf(FINFO,""recv_files finished\n"");
 
 	return 0;
 }","[216, 215]","The daemon in rsync 3.1.2, and 3.1.3-development before 2017-12-03, does not check for fnamecmp filenames in the daemon_filter_list data structure (in the recv_files function in receiver.c) and also does not apply the sanitize_paths protection mechanism to pathnames found in ""xname follows"" strings (in the read_ndx_and_attrs function in rsync.c), which allows remote attackers to bypass intended access restrictions."
199495," bool inode_capable(const struct inode *inode, int cap)
 bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)
  {
  	struct user_namespace *ns = current_user_ns();
  
	return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);
 	return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&
 		kgid_has_mapping(ns, inode->i_gid);
  }","[2, 7, 8, 6]","The capabilities implementation in the Linux kernel before 3.14.8 does not properly consider that namespaces are inapplicable to inodes, which allows local users to bypass intended chmod restrictions by first creating a user namespace, as demonstrated by setting the setgid bit on a file with group ownership of root."
5031,"local void init_block(s)
deflate_state *s;
{
int n;


for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

s->dyn_ltree[END_BLOCK].Freq = 1;
s->opt_len = s->static_len = 0L;
s->last_lit = s->matches = 0;
}",[13],"zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches."
206652," void WebGL2RenderingContextBase::texImage3D(
     GLenum target,
     GLint level,
     GLint internalformat,
     GLsizei width,
     GLsizei height,
     GLsizei depth,
     GLint border,
      GLenum format,
      GLenum type,
      MaybeShared<DOMArrayBufferView> pixels) {
   if ((unpack_flip_y_ || unpack_premultiply_alpha_) && pixels) {
     SynthesizeGLError(
         GL_INVALID_OPERATION, ""texImage3D"",
         ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
     return;
   }
    TexImageHelperDOMArrayBufferView(kTexImage3D, target, level, internalformat,
                                     width, height, depth, border, format, type,
                                     0, 0, 0, pixels.View(), kNullAllowed, 0);
 }","[12, 13, 14, 15, 16, 17]",Heap buffer overflow in WebGL in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
6341,"xfs_agf_verify(
struct xfs_buf  *bp)
{
struct xfs_mount *mp = bp->b_mount;
struct xfs_agf  *agf = XFS_BUF_TO_AGF(bp);

if (xfs_sb_version_hascrc(&mp->m_sb)) {
if (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))
return __this_address;
if (!xfs_log_check_lsn(mp,
be64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn)))
return __this_address;
}

if (!xfs_verify_magic(bp, agf->agf_magicnum))
return __this_address;

if (!(XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&
be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&
be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size(mp) &&
be32_to_cpu(agf->agf_fllast) < xfs_agfl_size(mp) &&
be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp)))
return __this_address;

if (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||
be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||
be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||
be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)
return __this_address;

if (xfs_sb_version_hasrmapbt(&mp->m_sb) &&
(be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||
be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))
return __this_address;







if (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)
return __this_address;

if (xfs_sb_version_haslazysbcount(&mp->m_sb) &&
be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))
return __this_address;

if (xfs_sb_version_hasreflink(&mp->m_sb) &&
(be32_to_cpu(agf->agf_refcount_level) < 1 ||
be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))
return __this_address;

return NULL;

}","[25, 42, 49]","An issue was discovered in xfs_agf_verify in fs/xfs/libxfs/xfs_alloc.c in the Linux kernel through 5.6.10. Attackers may trigger a sync of excessive duration via an XFS v5 image with crafted metadata, aka CID-d0c7feaf8767."
1271,"Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {
if (!getSSLManager()) {
return Status(ErrorCodes::ProtocolError,
""SSL support is required for the MONGODB-X509 mechanism."");
}
if(user.getDB() != ""$external"") {
return Status(ErrorCodes::ProtocolError,
""X.509 authentication must always use the $external database."");
}

ClientBasic *client = ClientBasic::getCurrent();
AuthorizationSession* authorizationSession = client->getAuthorizationSession();
std::string subjectName = client->port()->getX509SubjectName();

if (user.getUser() != subjectName) {
return Status(ErrorCodes::AuthenticationFailed,
""There is no x.509 client certificate matching the user."");
}
else {
std::string srvSubjectName = getSSLManager()->getServerSubjectName();
std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find("",OU=""));
std::string peerClusterId = subjectName.substr(subjectName.find("",OU=""));

fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);


int clusterAuthMode = serverGlobalParams.clusterAuthMode.load();
if (srvClusterId == peerClusterId) {
if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||
clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {
return Status(ErrorCodes::AuthenticationFailed, ""The provided certificate ""
""can only be used for cluster authentication, not client ""
""authentication. The current configuration does not allow ""
""x.509 cluster authentication, check the --clusterAuthMode flag"");
}
authorizationSession->grantInternalAuthorization();
}

else {
if (_isX509AuthDisabled) {
return Status(ErrorCodes::BadValue,
_x509AuthenticationDisabledMessage);
}
Status status = authorizationSession->addAndAuthorizeUser(user);
if (!status.isOK()) {
return status;
}
}
return Status::OK();
}
}","[21, 22, 24, 28]",The CmdAuthenticate::_authenticateX509 function in db/commands/authentication_commands.cpp in mongod in MongoDB 2.6.x before 2.6.2 allows remote attackers to cause a denial of service (daemon crash) by attempting authentication with an invalid X.509 client certificate.
208171,"  static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
  {
      const char *perm = ""add"";
 
     if (uid >= AID_APP) {
         return 0;  
     }
 
      return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
  }","[4, 5, 6, 7, 8]","cmds/servicemanager/service_manager.c in ServiceManager in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not properly restrict service registration, which allows attackers to gain privileges via a crafted application, aka internal bug 29431260."
3434,"std::string queueloader::get_filename(const std::string& str) {
std::string fn = ctrl->get_dlpath();

if (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])
fn.append(NEWSBEUTER_PATH_SEP);
char buf[1024];
snprintf(buf, sizeof(buf), ""%s"", str.c_str());
char * base = basename(buf);
if (!base || strlen(base) == 0) {
char lbuf[128];
time_t t = time(nullptr);
strftime(lbuf, sizeof(lbuf), ""%Y-%b-%d-%H%M%S.unknown"", localtime(&t));
fn.append(lbuf);
} else {
fn.append(base);
}
return fn;
}",[15],"Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904."
206989," bool DoCanonicalizePathComponent(const CHAR* source,
 template <typename CHAR, typename UCHAR>
 void DoCanonicalizePathComponent(const CHAR* source,
                                   const Component& component,
                                   char separator,
                                   CanonOutput* output,
                                   Component* new_component) {
  bool success = true;
    if (component.is_valid()) {
      if (separator)
        output->push_back(separator);
     new_component->begin = output->length();
     int end = component.end();
      for (int i = component.begin; i < end; i++) {
        UCHAR uch = static_cast<UCHAR>(source[i]);
        if (uch < 0x20 || uch >= 0x80)
        success &= AppendUTF8EscapedChar(source, &i, end, output);
         AppendUTF8EscapedChar(source, &i, end, output);
        else
          output->push_back(static_cast<char>(uch));
      }
     new_component->len = output->length() - new_component->begin;
   } else {
      new_component->reset();
    }
  return success;
  }","[2, 3, 18, 8, 17, 26]",Excessive data validation in URL parser in Google Chrome prior to 75.0.3770.80 allowed a remote attacker who convinced a user to input a URL to bypass website URL validation via a crafted URL.
200537," static int mark_source_chains(const struct xt_table_info *newinfo,
 			      unsigned int valid_hooks, void *entry0)
 {
 	unsigned int hook;
 
 	 
 	for (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {
 		unsigned int pos = newinfo->hook_entry[hook];
 		struct arpt_entry *e
 			= (struct arpt_entry *)(entry0 + pos);
 
 		if (!(valid_hooks & (1 << hook)))
 			continue;
 
 		 
 		e->counters.pcnt = pos;
 
 		for (;;) {
 			const struct xt_standard_target *t
 				= (void *)arpt_get_target_c(e);
 			int visited = e->comefrom & (1 << hook);
 
 			if (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {
 				pr_notice(""arptables: loop hook %u pos %u %08X.\n"",
 				       hook, pos, e->comefrom);
 				return 0;
 			}
 			e->comefrom
  				|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));
  
  			 
			if ((e->target_offset == sizeof(struct arpt_entry) &&
 			if ((unconditional(e) &&
  			     (strcmp(t->target.u.user.name,
  				     XT_STANDARD_TARGET) == 0) &&
			     t->verdict < 0 && unconditional(&e->arp)) ||
			    visited) {
 			     t->verdict < 0) || visited) {
  				unsigned int oldpos, size;
  
  				if ((strcmp(t->target.u.user.name,
 					    XT_STANDARD_TARGET) == 0) &&
 				    t->verdict < -NF_MAX_VERDICT - 1) {
 					duprintf(""mark_source_chains: bad ""
 						""negative verdict (%i)\n"",
 								t->verdict);
 					return 0;
 				}
 
 				 
 				do {
 					e->comefrom ^= (1<<NF_ARP_NUMHOOKS);
 					oldpos = pos;
 					pos = e->counters.pcnt;
 					e->counters.pcnt = 0;
 
 					 
 					if (pos == oldpos)
 						goto next;
 
 					e = (struct arpt_entry *)
 						(entry0 + pos);
 				} while (oldpos == pos + e->next_offset);
 
 				 
 				size = e->next_offset;
 				e = (struct arpt_entry *)
 					(entry0 + pos + size);
 				e->counters.pcnt = pos;
 				pos += size;
 			} else {
 				int newpos = t->verdict;
 
 				if (strcmp(t->target.u.user.name,
 					   XT_STANDARD_TARGET) == 0 &&
 				    newpos >= 0) {
 					if (newpos > newinfo->size -
 						sizeof(struct arpt_entry)) {
 						duprintf(""mark_source_chains: ""
 							""bad verdict (%i)\n"",
 								newpos);
 						return 0;
 					}
 
 					 
 					duprintf(""Jump rule %u -> %u\n"",
 						 pos, newpos);
 				} else {
 					 
 					newpos = pos + e->next_offset;
 				}
 				e = (struct arpt_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
 				pos = newpos;
 			}
 		}
 next:
 		duprintf(""Finished chain %u\n"", hook);
 	}
 	return 1;
 }","[33, 38, 32, 36, 37]","The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call."
201400," static int t220_frontend_attach(struct dvb_usb_adapter *d)
 static int t220_frontend_attach(struct dvb_usb_adapter *adap)
  {
	u8 obuf[3] = { 0xe, 0x87, 0 };
	u8 ibuf[] = { 0 };
 	struct dvb_usb_device *d = adap->dev;
 	struct dw2102_state *state = d->priv;
 
 	mutex_lock(&d->data_mutex);
  
	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
 	state->data[0] = 0xe;
 	state->data[1] = 0x87;
 	state->data[2] = 0x0;
 
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
  		err(""command 0x0e transfer failed."");
  
	obuf[0] = 0xe;
	obuf[1] = 0x86;
	obuf[2] = 1;
 	state->data[0] = 0xe;
 	state->data[1] = 0x86;
 	state->data[2] = 1;
  
	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
  		err(""command 0x0e transfer failed."");
  
	obuf[0] = 0xe;
	obuf[1] = 0x80;
	obuf[2] = 0;
 	state->data[0] = 0xe;
 	state->data[1] = 0x80;
 	state->data[2] = 0;
  
	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
  		err(""command 0x0e transfer failed."");
  
  	msleep(50);
  
	obuf[0] = 0xe;
	obuf[1] = 0x80;
	obuf[2] = 1;
 	state->data[0] = 0xe;
 	state->data[1] = 0x80;
 	state->data[2] = 1;
  
	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
 	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
  		err(""command 0x0e transfer failed."");
  
	obuf[0] = 0x51;
 	state->data[0] = 0x51;
  
	if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)
 	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
  		err(""command 0x51 transfer failed."");
  
	d->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
					&d->dev->i2c_adap, NULL);
	if (d->fe_adap[0].fe != NULL) {
		if (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,
					&d->dev->i2c_adap, &tda18271_config)) {
 	mutex_unlock(&d->data_mutex);
 
 	adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
 					&d->i2c_adap, NULL);
 	if (adap->fe_adap[0].fe != NULL) {
 		if (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
 					&d->i2c_adap, &tda18271_config)) {
  			info(""Attached TDA18271HD/CXD2820R!"");
  			return 0;
  		}
 	}
 
 	info(""Failed to attach TDA18271HD/CXD2820R!"");
  	return -EIO;
  }","[2, 6, 7, 8, 9, 12, 13, 14, 15, 16, 22, 23, 24, 27, 33, 34, 35, 38, 46, 47, 48, 51, 55, 58, 66, 67, 68, 69, 70, 71, 72, 4, 5, 11, 19, 20, 21, 26, 30, 31, 32, 37, 43, 44, 45, 50, 54, 57, 61, 62, 63, 64, 65]","drivers/media/usb/dvb-usb/dw2102.c in the Linux kernel 4.9.x and 4.10.x before 4.10.4 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
203060," xfs_acl_from_disk(struct xfs_acl *aclp)
 {
  	struct posix_acl_entry *acl_e;
  	struct posix_acl *acl;
  	struct xfs_acl_entry *ace;
	int count, i;
 	unsigned int count, i;
  
  	count = be32_to_cpu(aclp->acl_cnt);
  	if (count > XFS_ACL_MAX_ENTRIES)
 		return ERR_PTR(-EFSCORRUPTED);
 
 	acl = posix_acl_alloc(count, GFP_KERNEL);
 	if (!acl)
 		return ERR_PTR(-ENOMEM);
 
 	for (i = 0; i < count; i++) {
 		acl_e = &acl->a_entries[i];
 		ace = &aclp->acl_entry[i];
 
 		 
 		acl_e->e_tag = be32_to_cpu(ace->ae_tag);
 		acl_e->e_perm = be16_to_cpu(ace->ae_perm);
 
 		switch (acl_e->e_tag) {
 		case ACL_USER:
 		case ACL_GROUP:
 			acl_e->e_id = be32_to_cpu(ace->ae_id);
 			break;
 		case ACL_USER_OBJ:
 		case ACL_GROUP_OBJ:
 		case ACL_MASK:
 		case ACL_OTHER:
 			acl_e->e_id = ACL_UNDEFINED_ID;
 			break;
 		default:
 			goto fail;
 		}
 	}
 	return acl;
 
 fail:
 	posix_acl_release(acl);
 	return ERR_PTR(-EINVAL);
 }","[7, 6]","Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow."
9490,"Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,
string* init_op_name) {
const auto& sig_def_map = meta_graph_def.signature_def();
const auto& init_op_sig_it =
meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);
if (init_op_sig_it != sig_def_map.end()) {
*init_op_name = init_op_sig_it->second.outputs()
.find(kSavedModelInitOpSignatureKey)
->second.name();
return Status::OK();
}

const auto& collection_def_map = meta_graph_def.collection_def();
string init_op_collection_key;
if (collection_def_map.find(kSavedModelMainOpKey) !=
collection_def_map.end()) {
init_op_collection_key = kSavedModelMainOpKey;
} else {
init_op_collection_key = kSavedModelLegacyInitOpKey;
}

const auto init_op_it = collection_def_map.find(init_op_collection_key);
if (init_op_it != collection_def_map.end()) {
if (init_op_it->second.node_list().value_size() != 1) {
return errors::FailedPrecondition(
strings::StrCat(""Expected exactly one main op in : "", export_dir));
}
*init_op_name = init_op_it->second.node_list().value(0);
}
return Status::OK();
}","[7, 8, 9]","Tensorflow is an Open Source Machine Learning Framework. The implementation of `GetInitOp` is vulnerable to a crash caused by dereferencing a null pointer. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
8887,"gen_hash(codegen_scope *s, node *tree, int val, int limit)
{
int slimit = GEN_VAL_STACK_MAX;
if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;
int len = 0;
mrb_bool update = FALSE;

while (tree) {
if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {
if (len > 0) {
pop_n(len*2);
if (!update) {
genop_2(s, OP_HASH, cursp(), len);
}
else {
pop();
genop_2(s, OP_HASHADD, cursp(), len);
}
push();
}
codegen(s, tree->car->cdr, val);
if (len > 0 || update) {
pop(); pop();
genop_1(s, OP_HASHCAT, cursp());
push();
}
update = TRUE;
len = 0;
}
else {
codegen(s, tree->car->car, val);
codegen(s, tree->car->cdr, val);
len++;
}
tree = tree->cdr;
if (val && cursp() >= slimit) {
pop_n(len*2);
if (!update) {
genop_2(s, OP_HASH, cursp(), len);
}
else {
pop();
genop_2(s, OP_HASHADD, cursp(), len);
}
push();
update = TRUE;
len = 0;
}
}
if (update) {
if (len > 0) {
pop_n(len*2+1);
genop_2(s, OP_HASHADD, cursp(), len);
push();
}
return -1;
}
if (update) return -1;
return len;
}","[51, 58]",NULL Pointer Dereference in Homebrew mruby prior to 3.2.
202540," ParseNameValue(const char * buffer, int bufsize,
                 struct NameValueParserData * data)
  {
  	struct xmlparser parser;
	data->l_head = NULL;
	data->portListing = NULL;
	data->portListingLength = 0;
 	memset(data, 0, sizeof(struct NameValueParserData));
  	 
  	parser.xmlstart = buffer;
  	parser.xmlsize = bufsize;
 	parser.data = data;
 	parser.starteltfunc = NameValueParserStartElt;
 	parser.endeltfunc = NameValueParserEndElt;
 	parser.datafunc = NameValueParserGetData;
 	parser.attfunc = 0;
 	parsexml(&parser);
 }","[8, 5, 6, 7]",Uninitialized stack variable vulnerability in NameValueParserEndElt (upnpreplyparse.c) in miniupnpd < 2.0 allows an attacker to cause Denial of Service (Segmentation fault and Memory Corruption) or possibly have unspecified other impact
207625," static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 static double abserr(const png_modifier *pm, int in_depth, int out_depth)
  {
      
  if (pm->assume_16_bit_calculations ||
  (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
  return pm->maxabs16;
  else
 
        return pm->maxabs8;
  }",[2],"Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
205794," bool AXNodeObject::isModal() const {
   if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
     return false;
  
    if (hasAttribute(aria_modalAttr)) {
      const AtomicString& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
     if (equalIgnoringASCIICase(modal, ""true""))
        return true;
    if (equalIgnoringCase(modal, ""false""))
     if (equalIgnoringASCIICase(modal, ""false""))
        return false;
    }
  
   if (getNode() && isHTMLDialogElement(*getNode()))
     return toElement(getNode())->isInTopLayer();
 
   return false;
 }","[8, 11, 7, 10]","Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc."
5950,"static int fsl_lpspi_probe(struct platform_device *pdev)
{
struct device_node *np = pdev->dev.of_node;
struct fsl_lpspi_data *fsl_lpspi;
struct spi_controller *controller;
struct spi_imx_master *lpspi_platform_info =
dev_get_platdata(&pdev->dev);
struct resource *res;
int i, ret, irq;
u32 temp;
bool is_slave;

is_slave = of_property_read_bool((&pdev->dev)->of_node, ""spi-slave"");
if (is_slave)
controller = spi_alloc_slave(&pdev->dev,
sizeof(struct fsl_lpspi_data));
else
controller = spi_alloc_master(&pdev->dev,
sizeof(struct fsl_lpspi_data));

if (!controller)
return -ENOMEM;

platform_set_drvdata(pdev, controller);

fsl_lpspi = spi_controller_get_devdata(controller);
fsl_lpspi->dev = &pdev->dev;
fsl_lpspi->is_slave = is_slave;

if (!fsl_lpspi->is_slave) {
for (i = 0; i < controller->num_chipselect; i++) {
int cs_gpio = of_get_named_gpio(np, ""cs-gpios"", i);

if (!gpio_is_valid(cs_gpio) && lpspi_platform_info)
cs_gpio = lpspi_platform_info->chipselect[i];

fsl_lpspi->chipselect[i] = cs_gpio;
if (!gpio_is_valid(cs_gpio))
continue;

ret = devm_gpio_request(&pdev->dev,
fsl_lpspi->chipselect[i],
DRIVER_NAME);
if (ret) {
dev_err(&pdev->dev, ""can't get cs gpios\n"");
goto out_controller_put;
}
}
controller->cs_gpios = fsl_lpspi->chipselect;
controller->prepare_message = fsl_lpspi_prepare_message;
}

controller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);
controller->transfer_one = fsl_lpspi_transfer_one;
controller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;
controller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;
controller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
controller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;
controller->dev.of_node = pdev->dev.of_node;
controller->bus_num = pdev->id;
controller->slave_abort = fsl_lpspi_slave_abort;

init_completion(&fsl_lpspi->xfer_done);

res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
fsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);
if (IS_ERR(fsl_lpspi->base)) {
ret = PTR_ERR(fsl_lpspi->base);
goto out_controller_put;
}
fsl_lpspi->base_phys = res->start;

irq = platform_get_irq(pdev, 0);
if (irq < 0) {
ret = irq;
goto out_controller_put;
}

ret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,
dev_name(&pdev->dev), fsl_lpspi);
if (ret) {
dev_err(&pdev->dev, ""can't get irq%d: %d\n"", irq, ret);
goto out_controller_put;
}

fsl_lpspi->clk_per = devm_clk_get(&pdev->dev, ""per"");
if (IS_ERR(fsl_lpspi->clk_per)) {
ret = PTR_ERR(fsl_lpspi->clk_per);
goto out_controller_put;
}

fsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, ""ipg"");
if (IS_ERR(fsl_lpspi->clk_ipg)) {
ret = PTR_ERR(fsl_lpspi->clk_ipg);
goto out_controller_put;
}


ret = fsl_lpspi_init_rpm(fsl_lpspi);
if (ret)
goto out_controller_put;

ret = pm_runtime_get_sync(fsl_lpspi->dev);
if (ret < 0) {
dev_err(fsl_lpspi->dev, ""failed to enable clock\n"");
return ret;
}

temp = readl(fsl_lpspi->base + IMX7ULP_PARAM);
fsl_lpspi->txfifosize = 1 << (temp & 0x0f);
fsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);

ret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);
if (ret == -EPROBE_DEFER)
goto out_controller_put;

if (ret < 0)
dev_err(&pdev->dev, ""dma setup error %d, use pio\n"", ret);

ret = devm_spi_register_controller(&pdev->dev, controller);
if (ret < 0) {
dev_err(&pdev->dev, ""spi_register_controller error.\n"");
goto out_controller_put;
}

return 0;

out_controller_put:
spi_controller_put(controller);

return ret;
}",[106],"** DISPUTED ** A memory leak in the fsl_lpspi_probe() function in drivers/spi/spi-fsl-lpspi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering pm_runtime_get_sync() failures, aka CID-057b8945f78f. NOTE: third parties dispute the relevance of this because an attacker cannot realistically control these failures at probe time."
205799," static Element* siblingWithAriaRole(String role, Node* node) {
   Node* parent = node->parentNode();
   if (!parent)
     return 0;
 
   for (Element* sibling = ElementTraversal::firstChild(*parent); sibling;
         sibling = ElementTraversal::nextSibling(*sibling)) {
      const AtomicString& siblingAriaRole =
          AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);
    if (equalIgnoringCase(siblingAriaRole, role))
     if (equalIgnoringASCIICase(siblingAriaRole, role))
        return sibling;
    }
  
   return 0;
 }","[11, 10]","Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc."
206858," void MojoVideoEncodeAcceleratorService::UseOutputBitstreamBuffer(
     int32_t bitstream_buffer_id,
     mojo::ScopedSharedBufferHandle buffer) {
   DVLOG(2) << __func__ << "" bitstream_buffer_id="" << bitstream_buffer_id;
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
   if (!encoder_)
     return;
   if (!buffer.is_valid()) {
     DLOG(ERROR) << __func__ << "" invalid |buffer|."";
     NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);
     return;
   }
   if (bitstream_buffer_id < 0) {
     DLOG(ERROR) << __func__ << "" bitstream_buffer_id="" << bitstream_buffer_id
                 << "" must be >= 0"";
     NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);
     return;
   }
  
    base::SharedMemoryHandle handle;
    size_t memory_size = 0;
  bool read_only = false;
    auto result = mojo::UnwrapSharedMemoryHandle(std::move(buffer), &handle,
                                               &memory_size, &read_only);
                                                &memory_size, nullptr);
    if (result != MOJO_RESULT_OK || memory_size == 0u) {
      DLOG(ERROR) << __func__ << "" mojo::UnwrapSharedMemoryHandle() failed"";
      NotifyError(::media::VideoEncodeAccelerator::kPlatformFailureError);
     return;
   }
 
   if (memory_size < output_buffer_size_) {
     DLOG(ERROR) << __func__ << "" bitstream_buffer_id="" << bitstream_buffer_id
                 << "" has a size of "" << memory_size
                 << ""B, different from expected "" << output_buffer_size_ << ""B"";
     NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);
     return;
   }
 
   encoder_->UseOutputBitstreamBuffer(
       BitstreamBuffer(bitstream_buffer_id, handle, memory_size));
 }","[26, 23, 25]",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
200770,"  void unix_notinflight(struct file *fp)
  {
  	struct sock *s = unix_get_socket(fp);
  
 	spin_lock(&unix_gc_lock);
 
  	if (s) {
  		struct unix_sock *u = unix_sk(s);
  
		spin_lock(&unix_gc_lock);
  		BUG_ON(list_empty(&u->link));
  
  		if (atomic_long_dec_and_test(&u->inflight))
  			list_del_init(&u->link);
  		unix_tot_inflight--;
		spin_unlock(&unix_gc_lock);
  	}
 	fp->f_cred->user->unix_inflight--;
 	spin_unlock(&unix_gc_lock);
  }","[5, 6, 18, 19, 10, 16]","The Linux kernel before 4.4.1 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by sending each descriptor over a UNIX socket before closing it, related to net/unix/af_unix.c and net/unix/garbage.c."
200132," static int php_var_unserialize_internal(UNSERIALIZE_PARAMETER)
 {
 	const unsigned char *cursor, *limit, *marker, *start;
 	zval *rval_ref;
 
 	limit = max;
 	cursor = *p;
 
 	if (YYCURSOR >= YYLIMIT) {
 		return 0;
 	}
 
 	if (var_hash && (*p)[0] != 'R') {
 		var_push(var_hash, rval);
 	}
 
 	start = cursor;
 
 
 #line 554 ""ext/standard/var_unserializer.c""
 {
 	YYCTYPE yych;
 	static const unsigned char yybm[] = {
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		128, 128, 128, 128, 128, 128, 128, 128, 
 		128, 128,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 		  0,   0,   0,   0,   0,   0,   0,   0, 
 	};
 
 	if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
 	yych = *YYCURSOR;
 	switch (yych) {
 	case 'C':
 	case 'O':	goto yy13;
 	case 'N':	goto yy5;
 	case 'R':	goto yy2;
 	case 'S':	goto yy10;
 	case 'a':	goto yy11;
 	case 'b':	goto yy6;
 	case 'd':	goto yy8;
 	case 'i':	goto yy7;
 	case 'o':	goto yy12;
 	case 'r':	goto yy4;
 	case 's':	goto yy9;
 	case '}':	goto yy14;
 	default:	goto yy16;
 	}
 yy2:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy95;
 yy3:
 #line 884 ""ext/standard/var_unserializer.re""
 	{ return 0; }
 #line 580 ""ext/standard/var_unserializer.c""
 yy4:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy89;
 	goto yy3;
 yy5:
 	yych = *++YYCURSOR;
 	if (yych == ';') goto yy87;
 	goto yy3;
 yy6:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy83;
 	goto yy3;
 yy7:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy77;
 	goto yy3;
 yy8:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy53;
 	goto yy3;
 yy9:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy46;
 	goto yy3;
 yy10:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy39;
 	goto yy3;
 yy11:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy32;
 	goto yy3;
 yy12:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy25;
 	goto yy3;
 yy13:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy17;
 	goto yy3;
 yy14:
 	++YYCURSOR;
 #line 878 ""ext/standard/var_unserializer.re""
 	{
 	 
 	php_error_docref(NULL, E_NOTICE, ""Unexpected end of serialized data"");
 	return 0;  
 }
 #line 629 ""ext/standard/var_unserializer.c""
 yy16:
 	yych = *++YYCURSOR;
 	goto yy3;
 yy17:
 	yych = *++YYCURSOR;
 	if (yybm[0+yych] & 128) {
 		goto yy20;
 	}
 	if (yych == '+') goto yy19;
 yy18:
 	YYCURSOR = YYMARKER;
 	goto yy3;
 yy19:
 	yych = *++YYCURSOR;
 	if (yybm[0+yych] & 128) {
 		goto yy20;
 	}
 	goto yy18;
 yy20:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
 	yych = *YYCURSOR;
  	if (yybm[0+yych] & 128) {
  		goto yy20;
  	}
	if (yych != ':') goto yy18;
 	if (yych <= '/') goto yy18;
 	if (yych >= ';') goto yy18;
  	yych = *++YYCURSOR;
  	if (yych != '""') goto yy18;
  	++YYCURSOR;
 #line 733 ""ext/standard/var_unserializer.re""
 	{
 	size_t len, len2, len3, maxlen;
 	zend_long elements;
 	char *str;
 	zend_string *class_name;
 	zend_class_entry *ce;
 	int incomplete_class = 0;
 
 	int custom_object = 0;
 
 	zval user_func;
 	zval retval;
 	zval args[1];
 
     if (!var_hash) return 0;
 	if (*start == 'C') {
 		custom_object = 1;
 	}
 
 	len2 = len = parse_uiv(start + 2);
 	maxlen = max - YYCURSOR;
 	if (maxlen < len || len == 0) {
 		*p = start + 2;
 		return 0;
 	}
 
 	str = (char*)YYCURSOR;
 
 	YYCURSOR += len;
 
 	if (*(YYCURSOR) != '""') {
 		*p = YYCURSOR;
 		return 0;
 	}
 	if (*(YYCURSOR+1) != ':') {
 		*p = YYCURSOR+1;
 		return 0;
 	}
 
 	len3 = strspn(str, ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377\\"");
 	if (len3 != len)
 	{
 		*p = YYCURSOR + len3 - len;
 		return 0;
 	}
 
 	class_name = zend_string_init(str, len, 0);
 
 	do {
 		if(!unserialize_allowed_class(class_name, classes)) {
 			incomplete_class = 1;
 			ce = PHP_IC_ENTRY;
 			break;
 		}
 
 		 
 		BG(serialize_lock)++;
 		ce = zend_lookup_class(class_name);
 		if (ce) {
 			BG(serialize_lock)--;
 			if (EG(exception)) {
 				zend_string_release(class_name);
 				return 0;
 			}
 			break;
 		}
 		BG(serialize_lock)--;
 
 		if (EG(exception)) {
 			zend_string_release(class_name);
 			return 0;
 		}
 
 		 
 		if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\0')) {
 			incomplete_class = 1;
 			ce = PHP_IC_ENTRY;
 			break;
 		}
 
 		 
 		ZVAL_STRING(&user_func, PG(unserialize_callback_func));
 
 		ZVAL_STR_COPY(&args[0], class_name);
 		BG(serialize_lock)++;
 		if (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {
 			BG(serialize_lock)--;
 			if (EG(exception)) {
 				zend_string_release(class_name);
 				zval_ptr_dtor(&user_func);
 				zval_ptr_dtor(&args[0]);
 				return 0;
 			}
 			php_error_docref(NULL, E_WARNING, ""defined (%s) but not found"", Z_STRVAL(user_func));
 			incomplete_class = 1;
 			ce = PHP_IC_ENTRY;
 			zval_ptr_dtor(&user_func);
 			zval_ptr_dtor(&args[0]);
 			break;
 		}
 		BG(serialize_lock)--;
 		zval_ptr_dtor(&retval);
 		if (EG(exception)) {
 			zend_string_release(class_name);
 			zval_ptr_dtor(&user_func);
 			zval_ptr_dtor(&args[0]);
 			return 0;
 		}
 
 		 
 		if ((ce = zend_lookup_class(class_name)) == NULL) {
 			php_error_docref(NULL, E_WARNING, ""Function %s() hasn't defined the class it was called for"", Z_STRVAL(user_func));
 			incomplete_class = 1;
 			ce = PHP_IC_ENTRY;
 		}
 
 		zval_ptr_dtor(&user_func);
 		zval_ptr_dtor(&args[0]);
 		break;
 	} while (1);
 
 	*p = YYCURSOR;
 
 	if (custom_object) {
 		int ret;
 
 		ret = object_custom(UNSERIALIZE_PASSTHRU, ce);
 
 		if (ret && incomplete_class) {
 			php_store_class_name(rval, ZSTR_VAL(class_name), len2);
 		}
 		zend_string_release(class_name);
 		return ret;
 	}
 
 	elements = object_common1(UNSERIALIZE_PASSTHRU, ce);
 
 	if (incomplete_class) {
 		php_store_class_name(rval, ZSTR_VAL(class_name), len2);
 	}
 	zend_string_release(class_name);
  
  	return object_common2(UNSERIALIZE_PASSTHRU, elements);
  }
#line 804 ""ext/standard/var_unserializer.c""
 #line 805 ""ext/standard/var_unserializer.c""
  yy25:
  	yych = *++YYCURSOR;
  	if (yych <= ',') {
 		if (yych != '+') goto yy18;
 	} else {
 		if (yych <= '-') goto yy26;
 		if (yych <= '/') goto yy18;
 		if (yych <= '9') goto yy27;
 		goto yy18;
 	}
 yy26:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy27:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy27;
 	if (yych >= ';') goto yy18;
 	yych = *++YYCURSOR;
 	if (yych != '""') goto yy18;
 	++YYCURSOR;
 #line 726 ""ext/standard/var_unserializer.re""
 	{
     if (!var_hash) return 0;
 
  	return object_common2(UNSERIALIZE_PASSTHRU,
  			object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR));
  }
#line 836 ""ext/standard/var_unserializer.c""
 #line 837 ""ext/standard/var_unserializer.c""
  yy32:
  	yych = *++YYCURSOR;
  	if (yych == '+') goto yy33;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy34;
 	goto yy18;
 yy33:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy34:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy34;
 	if (yych >= ';') goto yy18;
 	yych = *++YYCURSOR;
 	if (yych != '{') goto yy18;
 	++YYCURSOR;
 #line 702 ""ext/standard/var_unserializer.re""
 	{
 	zend_long elements = parse_iv(start + 2);
 	 
 	*p = YYCURSOR;
     if (!var_hash) return 0;
 
 	if (elements < 0) {
 		return 0;
 	}
 
 	array_init_size(rval, elements);
 	if (elements) {
 		 
 		zend_hash_real_init(Z_ARRVAL_P(rval), 0);
 	}
 
 	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {
 		return 0;
 	}
  
  	return finish_nested_data(UNSERIALIZE_PASSTHRU);
  }
#line 881 ""ext/standard/var_unserializer.c""
 #line 882 ""ext/standard/var_unserializer.c""
  yy39:
  	yych = *++YYCURSOR;
  	if (yych == '+') goto yy40;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy41;
 	goto yy18;
 yy40:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy41:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy41;
 	if (yych >= ';') goto yy18;
 	yych = *++YYCURSOR;
 	if (yych != '""') goto yy18;
 	++YYCURSOR;
 #line 668 ""ext/standard/var_unserializer.re""
 	{
 	size_t len, maxlen;
 	zend_string *str;
 
 	len = parse_uiv(start + 2);
 	maxlen = max - YYCURSOR;
 	if (maxlen < len) {
 		*p = start + 2;
 		return 0;
 	}
 
 	if ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {
 		return 0;
 	}
 
 	if (*(YYCURSOR) != '""') {
 		zend_string_free(str);
 		*p = YYCURSOR;
 		return 0;
 	}
 
 	if (*(YYCURSOR + 1) != ';') {
 		efree(str);
 		*p = YYCURSOR + 1;
 		return 0;
 	}
 
 	YYCURSOR += 2;
 	*p = YYCURSOR;
 
  	ZVAL_STR(rval, str);
  	return 1;
  }
#line 936 ""ext/standard/var_unserializer.c""
 #line 937 ""ext/standard/var_unserializer.c""
  yy46:
  	yych = *++YYCURSOR;
  	if (yych == '+') goto yy47;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy48;
 	goto yy18;
 yy47:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy48:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy48;
 	if (yych >= ';') goto yy18;
 	yych = *++YYCURSOR;
 	if (yych != '""') goto yy18;
 	++YYCURSOR;
 #line 636 ""ext/standard/var_unserializer.re""
 	{
 	size_t len, maxlen;
 	char *str;
 
 	len = parse_uiv(start + 2);
 	maxlen = max - YYCURSOR;
 	if (maxlen < len) {
 		*p = start + 2;
 		return 0;
 	}
 
 	str = (char*)YYCURSOR;
 
 	YYCURSOR += len;
 
 	if (*(YYCURSOR) != '""') {
 		*p = YYCURSOR;
 		return 0;
 	}
 
 	if (*(YYCURSOR + 1) != ';') {
 		*p = YYCURSOR + 1;
 		return 0;
 	}
 
 	YYCURSOR += 2;
 	*p = YYCURSOR;
 
  	ZVAL_STRINGL(rval, str, len);
  	return 1;
  }
#line 989 ""ext/standard/var_unserializer.c""
 #line 990 ""ext/standard/var_unserializer.c""
  yy53:
  	yych = *++YYCURSOR;
  	if (yych <= '/') {
 		if (yych <= ',') {
 			if (yych == '+') goto yy57;
 			goto yy18;
 		} else {
 			if (yych <= '-') goto yy55;
 			if (yych <= '.') goto yy60;
 			goto yy18;
 		}
 	} else {
 		if (yych <= 'I') {
 			if (yych <= '9') goto yy58;
 			if (yych <= 'H') goto yy18;
 			goto yy56;
 		} else {
 			if (yych != 'N') goto yy18;
 		}
 	}
 	yych = *++YYCURSOR;
 	if (yych == 'A') goto yy76;
 	goto yy18;
 yy55:
 	yych = *++YYCURSOR;
 	if (yych <= '/') {
 		if (yych == '.') goto yy60;
 		goto yy18;
 	} else {
 		if (yych <= '9') goto yy58;
 		if (yych != 'I') goto yy18;
 	}
 yy56:
 	yych = *++YYCURSOR;
 	if (yych == 'N') goto yy72;
 	goto yy18;
 yy57:
 	yych = *++YYCURSOR;
 	if (yych == '.') goto yy60;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy58:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
 	yych = *YYCURSOR;
 	if (yych <= ':') {
 		if (yych <= '.') {
 			if (yych <= '-') goto yy18;
 			goto yy70;
 		} else {
 			if (yych <= '/') goto yy18;
 			if (yych <= '9') goto yy58;
 			goto yy18;
 		}
 	} else {
 		if (yych <= 'E') {
 			if (yych <= ';') goto yy63;
 			if (yych <= 'D') goto yy18;
 			goto yy65;
 		} else {
 			if (yych == 'e') goto yy65;
 			goto yy18;
 		}
 	}
 yy60:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy61:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
 	yych = *YYCURSOR;
 	if (yych <= ';') {
 		if (yych <= '/') goto yy18;
 		if (yych <= '9') goto yy61;
 		if (yych <= ':') goto yy18;
 	} else {
 		if (yych <= 'E') {
 			if (yych <= 'D') goto yy18;
 			goto yy65;
 		} else {
 			if (yych == 'e') goto yy65;
 			goto yy18;
 		}
 	}
 yy63:
 	++YYCURSOR;
 #line 627 ""ext/standard/var_unserializer.re""
 	{
 #if SIZEOF_ZEND_LONG == 4
 use_double:
 #endif
 	*p = YYCURSOR;
  	ZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));
  	return 1;
  }
#line 1086 ""ext/standard/var_unserializer.c""
 #line 1087 ""ext/standard/var_unserializer.c""
  yy65:
  	yych = *++YYCURSOR;
  	if (yych <= ',') {
 		if (yych != '+') goto yy18;
 	} else {
 		if (yych <= '-') goto yy66;
 		if (yych <= '/') goto yy18;
 		if (yych <= '9') goto yy67;
 		goto yy18;
 	}
 yy66:
 	yych = *++YYCURSOR;
 	if (yych <= ',') {
 		if (yych == '+') goto yy69;
 		goto yy18;
 	} else {
 		if (yych <= '-') goto yy69;
 		if (yych <= '/') goto yy18;
 		if (yych >= ':') goto yy18;
 	}
 yy67:
 	++YYCURSOR;
 	if (YYLIMIT <= YYCURSOR) YYFILL(1);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy67;
 	if (yych == ';') goto yy63;
 	goto yy18;
 yy69:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy67;
 	goto yy18;
 yy70:
 	++YYCURSOR;
 	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
 	yych = *YYCURSOR;
 	if (yych <= ';') {
 		if (yych <= '/') goto yy18;
 		if (yych <= '9') goto yy70;
 		if (yych <= ':') goto yy18;
 		goto yy63;
 	} else {
 		if (yych <= 'E') {
 			if (yych <= 'D') goto yy18;
 			goto yy65;
 		} else {
 			if (yych == 'e') goto yy65;
 			goto yy18;
 		}
 	}
 yy72:
 	yych = *++YYCURSOR;
 	if (yych != 'F') goto yy18;
 yy73:
 	yych = *++YYCURSOR;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
 #line 611 ""ext/standard/var_unserializer.re""
 	{
 	*p = YYCURSOR;
 
 	if (!strncmp((char*)start + 2, ""NAN"", 3)) {
 		ZVAL_DOUBLE(rval, php_get_nan());
 	} else if (!strncmp((char*)start + 2, ""INF"", 3)) {
 		ZVAL_DOUBLE(rval, php_get_inf());
 	} else if (!strncmp((char*)start + 2, ""-INF"", 4)) {
 		ZVAL_DOUBLE(rval, -php_get_inf());
 	} else {
 		ZVAL_NULL(rval);
 	}
  
  	return 1;
  }
#line 1161 ""ext/standard/var_unserializer.c""
 #line 1162 ""ext/standard/var_unserializer.c""
  yy76:
  	yych = *++YYCURSOR;
  	if (yych == 'N') goto yy73;
 	goto yy18;
 yy77:
 	yych = *++YYCURSOR;
 	if (yych <= ',') {
 		if (yych != '+') goto yy18;
 	} else {
 		if (yych <= '-') goto yy78;
 		if (yych <= '/') goto yy18;
 		if (yych <= '9') goto yy79;
 		goto yy18;
 	}
 yy78:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy79:
 	++YYCURSOR;
 	if (YYLIMIT <= YYCURSOR) YYFILL(1);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy79;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
 #line 585 ""ext/standard/var_unserializer.re""
 	{
 #if SIZEOF_ZEND_LONG == 4
 	int digits = YYCURSOR - start - 3;
 
 	if (start[2] == '-' || start[2] == '+') {
 		digits--;
 	}
 
 	 
 	if (digits >= MAX_LENGTH_OF_LONG - 1) {
 		if (digits == MAX_LENGTH_OF_LONG - 1) {
 			int cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);
 
 			if (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {
 				goto use_double;
 			}
 		} else {
 			goto use_double;
 		}
 	}
 #endif
 	*p = YYCURSOR;
  	ZVAL_LONG(rval, parse_iv(start + 2));
  	return 1;
  }
#line 1214 ""ext/standard/var_unserializer.c""
 #line 1215 ""ext/standard/var_unserializer.c""
  yy83:
  	yych = *++YYCURSOR;
  	if (yych <= '/') goto yy18;
 	if (yych >= '2') goto yy18;
 	yych = *++YYCURSOR;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
 #line 579 ""ext/standard/var_unserializer.re""
 	{
 	*p = YYCURSOR;
  	ZVAL_BOOL(rval, parse_iv(start + 2));
  	return 1;
  }
#line 1228 ""ext/standard/var_unserializer.c""
 #line 1229 ""ext/standard/var_unserializer.c""
  yy87:
  	++YYCURSOR;
  #line 573 ""ext/standard/var_unserializer.re""
 	{
 	*p = YYCURSOR;
  	ZVAL_NULL(rval);
  	return 1;
  }
#line 1237 ""ext/standard/var_unserializer.c""
 #line 1238 ""ext/standard/var_unserializer.c""
  yy89:
  	yych = *++YYCURSOR;
  	if (yych <= ',') {
 		if (yych != '+') goto yy18;
 	} else {
 		if (yych <= '-') goto yy90;
 		if (yych <= '/') goto yy18;
 		if (yych <= '9') goto yy91;
 		goto yy18;
 	}
 yy90:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy91:
 	++YYCURSOR;
 	if (YYLIMIT <= YYCURSOR) YYFILL(1);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy91;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
 #line 548 ""ext/standard/var_unserializer.re""
 	{
 	zend_long id;
 
  	*p = YYCURSOR;
 	if (!var_hash) return 0;
 
 	id = parse_iv(start + 2) - 1;
 	if (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {
 		return 0;
 	}
 
 	if (rval_ref == rval) {
 		return 0;
 	}
 
 	if (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {
 		ZVAL_UNDEF(rval);
 		return 1;
 	}
 
 	ZVAL_COPY(rval, rval_ref);
  
  	return 1;
  }
#line 1285 ""ext/standard/var_unserializer.c""
 #line 1286 ""ext/standard/var_unserializer.c""
  yy95:
  	yych = *++YYCURSOR;
  	if (yych <= ',') {
 		if (yych != '+') goto yy18;
 	} else {
 		if (yych <= '-') goto yy96;
 		if (yych <= '/') goto yy18;
 		if (yych <= '9') goto yy97;
 		goto yy18;
 	}
 yy96:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych >= ':') goto yy18;
 yy97:
 	++YYCURSOR;
 	if (YYLIMIT <= YYCURSOR) YYFILL(1);
 	yych = *YYCURSOR;
 	if (yych <= '/') goto yy18;
 	if (yych <= '9') goto yy97;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
 #line 522 ""ext/standard/var_unserializer.re""
 	{
 	zend_long id;
 
  	*p = YYCURSOR;
 	if (!var_hash) return 0;
 
 	id = parse_iv(start + 2) - 1;
 	if (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {
 		return 0;
 	}
 
 	zval_ptr_dtor(rval);
 	if (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {
 		ZVAL_UNDEF(rval);
 		return 1;
 	}
 	if (Z_ISREF_P(rval_ref)) {
 		ZVAL_COPY(rval, rval_ref);
 	} else {
 		ZVAL_NEW_REF(rval_ref, rval_ref);
 		ZVAL_COPY(rval, rval_ref);
 	}
  
  	return 1;
  }
#line 1334 ""ext/standard/var_unserializer.c""
 #line 1335 ""ext/standard/var_unserializer.c""
  }
  #line 886 ""ext/standard/var_unserializer.re""
  
 
 	return 0;
 }","[158, 159, 309, 342, 387, 443, 497, 595, 671, 725, 740, 750, 799, 849, 157, 308, 341, 386, 442, 496, 594, 670, 724, 739, 749, 798, 848]","ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call."
198907," int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)
 {
     struct net_device *dev;
     struct ar_virtual_interface *arApDev;
 
     dev = alloc_etherdev(sizeof(struct ar_virtual_interface));
     if (dev == NULL) {
         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(""ar6000_create_ap_interface: can't alloc etherdev\n""));
         return A_ERROR;
     } 
      
      ether_setup(dev);
      init_netdev(dev, ap_ifname);
     dev->priv_flags &= ~IFF_TX_SKB_SHARING;
  
      if (register_netdev(dev)) {
          AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(""ar6000_create_ap_interface: register_netdev failed\n""));
         return A_ERROR;
     }
 
     arApDev = netdev_priv(dev);
     arApDev->arDev = ar;
     arApDev->arNetDev = dev;
     arApDev->arStaNetDev = ar->arNetDev;
 
     ar->arApDev = arApDev;
     arApNetDev = dev;
 
      
     memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);
 
     return 0;
 }",[14],"The net subsystem in the Linux kernel before 3.1 does not properly restrict use of the IFF_TX_SKB_SHARING flag, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability to access /proc/net/pktgen/pgctrl, and then using the pktgen package in conjunction with a bridge device for a VLAN interface."
201228," char *my_asctime(time_t t)
 {
 	struct tm *tm;
 	char *str;
          int len;
  
  	tm = localtime(&t);
 	if (tm == NULL)
 	    return g_strdup(""???"");
 
  	str = g_strdup(asctime(tm));
  
  	len = strlen(str);
 	if (len > 0) str[len-1] = '\0';
         return str;
 }","[8, 9, 10]","An issue was discovered in Irssi before 1.0.4. While updating the internal nick list, Irssi could incorrectly use the GHashTable interface and free the nick while updating it. This would then result in use-after-free conditions on each access of the hash table."
206833,"    void CallCompositorWithSuccess(mojom::PdfCompositorPtr ptr) {
      auto handle = CreateMSKPInSharedMemory();
      ASSERT_TRUE(handle.IsValid());
    mojo::ScopedSharedBufferHandle buffer_handle =
        mojo::WrapSharedMemoryHandle(handle, handle.GetSize(), true);
     mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(
         handle, handle.GetSize(),
         mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);
      ASSERT_TRUE(buffer_handle->is_valid());
      EXPECT_CALL(*this, CallbackOnSuccess(testing::_)).Times(1);
      ptr->CompositePdf(std::move(buffer_handle),
                       base::BindOnce(&PdfCompositorServiceTest::OnCallback,
                                      base::Unretained(this)));
     run_loop_->Run();
   }","[6, 7, 8, 4, 5]",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
202490," int blkcg_init_queue(struct request_queue *q)
 {
 	struct blkcg_gq *new_blkg, *blkg;
 	bool preloaded;
 	int ret;
 
 	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
 	if (!new_blkg)
 		return -ENOMEM;
 
 	preloaded = !radix_tree_preload(GFP_KERNEL);
 
 	 
 	rcu_read_lock();
 	spin_lock_irq(q->queue_lock);
 	blkg = blkg_create(&blkcg_root, q, new_blkg);
 	spin_unlock_irq(q->queue_lock);
 	rcu_read_unlock();
 
  	if (preloaded)
  		radix_tree_preload_end();
  
	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
 	if (IS_ERR(blkg))
  		return PTR_ERR(blkg);
	}
  
  	q->root_blkg = blkg;
  	q->root_rl.blkg = blkg;
 
 	ret = blk_throtl_init(q);
 	if (ret) {
 		spin_lock_irq(q->queue_lock);
 		blkg_destroy_all(q);
 		spin_unlock_irq(q->queue_lock);
 	}
 	return ret;
 }","[25, 23, 24, 27]",The blkcg_init_queue function in block/blk-cgroup.c in the Linux kernel before 4.11 allows local users to cause a denial of service (double free) or possibly have unspecified other impact by triggering a creation failure.
200879," static void request_key_auth_describe(const struct key *key,
 				      struct seq_file *m)
 {
 	struct request_key_auth *rka = key->payload.data[0];
  
  	seq_puts(m, ""key:"");
  	seq_puts(m, key->description);
	if (key_is_instantiated(key))
 	if (key_is_positive(key))
  		seq_printf(m, "" pid:%d ci:%zu"", rka->pid, rka->callout_len);
  }","[9, 8]","The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the *negative* state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."
6332,"mptctl_replace_fw (unsigned long arg)
{
struct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;
struct mpt_ioctl_replace_fw  karg;
MPT_ADAPTER   *ioc;
int    iocnum;
int    newFwSize;

if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {
printk(KERN_ERR MYNAM ""%s@%d::mptctl_replace_fw - ""
""Unable to read in mpt_ioctl_replace_fw struct @ %p\n"",
__FILE__, __LINE__, uarg);
return -EFAULT;
}

if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
(ioc == NULL)) {
printk(KERN_DEBUG MYNAM ""%s::mptctl_replace_fw() @%d - ioc%d not found!\n"",
__FILE__, __LINE__, iocnum);
return -ENODEV;
}

dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT ""mptctl_replace_fw called.\n"",
ioc->name));


if (ioc->cached_fw == NULL)
return 0;

mpt_free_fw_memory(ioc);



newFwSize = ALIGN(karg.newImageSize, 4);

mpt_alloc_fw_memory(ioc, newFwSize);
if (ioc->cached_fw == NULL)
return -ENOMEM;



if (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {
printk(MYIOC_s_ERR_FMT ""%s@%d::mptctl_replace_fw - ""
""Unable to read in mpt_ioctl_replace_fw image ""
""@ %p\n"", ioc->name, __FILE__, __LINE__, uarg);
mpt_free_fw_memory(ioc);
return -EFAULT;
}



ioc->facts.FWImageSize = newFwSize;
return 0;
}","[5, 6, 16, 17, 18, 19, 20]","The __mptctl_ioctl function in drivers/message/fusion/mptctl.c in the Linux kernel before 5.4.14 allows local users to hold an incorrect lock during the ioctl operation and trigger a race condition, i.e., a ""double fetch"" vulnerability, aka CID-28d76df18f0a. NOTE: the vendor states ""The security impact of this bug is not as bad as it could have been because these operations are all privileged and root already has enormous destructive power."""
1357,"static int bad_format_imginfo(
char *fmt)
{
char     *ptr;
int       n = 0;

ptr = fmt;
while (*ptr != '\0')
if (*ptr++ == '%') {


if (*ptr == '\0')
return 1;

if (*ptr == '%')
ptr++;

else if (*ptr == 's' || *ptr == 'S') {
n = 1;
ptr++;
}


else {

if (*ptr == ' ')
ptr++;

while (*ptr >= '0' && *ptr <= '9')
ptr++;

if (*ptr++ != 'l')
return 1;
if (*ptr == 'u')
ptr++;
else
return 1;
n++;
}
}

return (n != 3);
}",[42],"Multiple format string vulnerabilities in the python module in RRDtool, as used in Zenoss Core before 4.2.5 and other products, allow remote attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted third argument to the rrdtool.graph function, aka ZEN-15415, a related issue to CVE-2013-2131."
198642," static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)
 {
      int i;
      VncDisplay *vd = ds->opaque;
      struct VncSurface *s = &vd->guest;
     int width = ds_get_width(ds);
     int height = ds_get_height(ds);
  
      h += y;
  
        two 16-pixel blocks but we only mark the first as dirty
     */
     w += (x % 16);
     x -= (x % 16);
      w += (x % 16);
      x -= (x % 16);
  
    x = MIN(x, s->ds->width);
    y = MIN(y, s->ds->height);
    w = MIN(x + w, s->ds->width) - x;
    h = MIN(h, s->ds->height);
     x = MIN(x, width);
     y = MIN(y, height);
     w = MIN(x + w, width) - x;
     h = MIN(h, height);
  
      for (; y < h; y++)
          for (i = 0; i < w; i += 16)
 
 void vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,
                             int32_t encoding)
 {
     vnc_write_u16(vs, x);
     vnc_write_u16(vs, y);
     vnc_write_u16(vs, w);
     vnc_write_u16(vs, h);
 
     vnc_write_s32(vs, encoding);
 }
 
 void buffer_reserve(Buffer *buffer, size_t len)
 {
     if ((buffer->capacity - buffer->offset) < len) {
         buffer->capacity += (len + 1024);
         buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);
         if (buffer->buffer == NULL) {
             fprintf(stderr, ""vnc: out of memory\n"");
             exit(1);
         }
     }
 }
 
 int buffer_empty(Buffer *buffer)
 {
     return buffer->offset == 0;
 }
 
 uint8_t *buffer_end(Buffer *buffer)
 {
     return buffer->buffer + buffer->offset;
 }
 
 void buffer_reset(Buffer *buffer)
 {
         buffer->offset = 0;
 }
 
 void buffer_free(Buffer *buffer)
 {
     g_free(buffer->buffer);
     buffer->offset = 0;
     buffer->capacity = 0;
     buffer->buffer = NULL;
 }
 
 void buffer_append(Buffer *buffer, const void *data, size_t len)
 {
     memcpy(buffer->buffer + buffer->offset, data, len);
     buffer->offset += len;
 }
 
 static void vnc_desktop_resize(VncState *vs)
 {
     DisplayState *ds = vs->ds;
 
     if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {
         return;
     }
     if (vs->client_width == ds_get_width(ds) &&
         vs->client_height == ds_get_height(ds)) {
         return;
     }
     vs->client_width = ds_get_width(ds);
     vs->client_height = ds_get_height(ds);
     vnc_lock_output(vs);
     vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);
     vnc_write_u8(vs, 0);
     vnc_write_u16(vs, 1);  
     vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,
                            VNC_ENCODING_DESKTOPRESIZE);
     vnc_unlock_output(vs);
     vnc_flush(vs);
 }
 
 static void vnc_abort_display_jobs(VncDisplay *vd)
 {
     VncState *vs;
 
     QTAILQ_FOREACH(vs, &vd->clients, next) {
         vnc_lock_output(vs);
         vs->abort = true;
         vnc_unlock_output(vs);
     }
     QTAILQ_FOREACH(vs, &vd->clients, next) {
         vnc_jobs_join(vs);
     }
     QTAILQ_FOREACH(vs, &vd->clients, next) {
         vnc_lock_output(vs);
         vs->abort = false;
         vnc_unlock_output(vs);
     }
 }
      }","[6, 7, 22, 23, 24, 25, 18, 19, 20, 21]",An out-of-bounds memory access issue was found in Quick Emulator (QEMU) before 1.7.2 in the VNC display driver. This flaw could occur while refreshing the VNC display surface area in the 'vnc_refresh_server_surface'. A user inside a guest could use this flaw to crash the QEMU process.
200164," void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)
 {
 	struct perf_event_context *src_ctx;
 	struct perf_event_context *dst_ctx;
 	struct perf_event *event, *tmp;
 	LIST_HEAD(events);
 
  	src_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;
  	dst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;
  
	mutex_lock(&src_ctx->mutex);
 	 
 	mutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);
  	list_for_each_entry_safe(event, tmp, &src_ctx->event_list,
  				 event_entry) {
  		perf_remove_from_context(event, false);
  		unaccount_event_cpu(event, src_cpu);
  		put_ctx(src_ctx);
  		list_add(&event->migrate_entry, &events);
  	}
	mutex_unlock(&src_ctx->mutex);
  
  	synchronize_rcu();
  
	mutex_lock(&dst_ctx->mutex);
  	list_for_each_entry_safe(event, tmp, &events, migrate_entry) {
  		list_del(&event->migrate_entry);
  		if (event->state >= PERF_EVENT_STATE_OFF)
 			event->state = PERF_EVENT_STATE_INACTIVE;
 		account_event_cpu(event, dst_cpu);
 		perf_install_in_context(dst_ctx, event, dst_cpu);
  		get_ctx(dst_ctx);
  	}
  	mutex_unlock(&dst_ctx->mutex);
 	mutex_unlock(&src_ctx->mutex);
  }","[12, 13, 35, 11, 21, 25]","kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 31095224."
199464," int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)
  {
  	struct snd_ctl_elem_id id;
  	unsigned int idx;
 	unsigned int count;
  	int err = -EINVAL;
  
  	if (! kcontrol)
 		return err;
 	if (snd_BUG_ON(!card || !kcontrol->info))
 		goto error;
 	id = kcontrol->id;
 	down_write(&card->controls_rwsem);
 	if (snd_ctl_find_id(card, &id)) {
 		up_write(&card->controls_rwsem);
 		dev_err(card->dev, ""control %i:%i:%i:%s:%i is already present\n"",
 					id.iface,
 					id.device,
 					id.subdevice,
 					id.name,
 					id.index);
 		err = -EBUSY;
 		goto error;
 	}
 	if (snd_ctl_find_hole(card, kcontrol->count) < 0) {
 		up_write(&card->controls_rwsem);
 		err = -ENOMEM;
 		goto error;
 	}
 	list_add_tail(&kcontrol->list, &card->controls);
  	card->controls_count += kcontrol->count;
  	kcontrol->id.numid = card->last_numid + 1;
  	card->last_numid += kcontrol->count;
 	count = kcontrol->count;
  	up_write(&card->controls_rwsem);
	for (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)
 	for (idx = 0; idx < count; idx++, id.index++, id.numid++)
  		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
  	return 0;
  
  error:
 	snd_ctl_free_one(kcontrol);
 	return err;
 }","[5, 34, 37, 36]","sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not ensure possession of a read/write lock, which allows local users to cause a denial of service (use-after-free) and obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access."
205638," bool InputMethodController::FinishComposingText(
     ConfirmCompositionBehavior confirm_behavior) {
   if (!HasComposition())
     return false;
 
   const bool is_too_long = IsTextTooLongAt(composition_range_->StartPosition());
 
   const String& composing = ComposingText();
 
   if (confirm_behavior == kKeepSelection) {
     const bool is_handle_visible = GetFrame().Selection().IsHandleVisible();
 
     const PlainTextRange& old_offsets = GetSelectionOffsets();
     Editor::RevealSelectionScope reveal_selection_scope(&GetEditor());
 
     if (is_too_long) {
       ReplaceComposition(ComposingText());
     } else {
       Clear();
       DispatchCompositionEndEvent(GetFrame(), composing);
     }
 
     GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();
 
     const EphemeralRange& old_selection_range =
         EphemeralRangeForOffsets(old_offsets);
     if (old_selection_range.IsNull())
       return false;
      const SelectionInDOMTree& selection =
          SelectionInDOMTree::Builder()
              .SetBaseAndExtent(old_selection_range)
            .SetIsHandleVisible(is_handle_visible)
              .Build();
      GetFrame().Selection().SetSelection(
        selection,
        SetSelectionData::Builder().SetShouldCloseTyping(true).Build());
         selection, SetSelectionData::Builder()
                        .SetShouldCloseTyping(true)
                        .SetShouldShowHandle(is_handle_visible)
                        .Build());
      return true;
    }
  
   Element* root_editable_element =
       GetFrame()
           .Selection()
           .ComputeVisibleSelectionInDOMTreeDeprecated()
           .RootEditableElement();
   if (!root_editable_element)
     return false;
   PlainTextRange composition_range =
       PlainTextRange::Create(*root_editable_element, *composition_range_);
   if (composition_range.IsNull())
     return false;
 
   if (is_too_long) {
     ReplaceComposition(ComposingText());
   } else {
     Clear();
   }
 
   if (!MoveCaret(composition_range.End()))
     return false;
 
   DispatchCompositionEndEvent(GetFrame(), composing);
   return true;
 }","[37, 38, 39, 40, 32, 35, 36]","The convolution implementation in Skia, as used in Google Chrome before 47.0.2526.73, does not properly constrain row lengths, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via crafted graphics data."
203358," static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {
 	RBinInfo *info = r_bin_get_info (r->bin);
 	RList *entries = r_bin_get_entries (r->bin);
 	RBinSymbol *symbol;
 	RBinAddr *entry;
 	RListIter *iter;
 	bool firstexp = true;
 	bool printHere = false;
 	int i = 0, lastfs = 's';
 	bool bin_demangle = r_config_get_i (r->config, ""bin.demangle"");
 	if (!info) {
 		return 0;
 	}
 
 	if (args && *args == '.') {
 		printHere = true;
 	}
 
 	bool is_arm = info && info->arch && !strncmp (info->arch, ""arm"", 3);
 	const char *lang = bin_demangle ? r_config_get (r->config, ""bin.lang"") : NULL;
 
 	RList *symbols = r_bin_get_symbols (r->bin);
 	r_spaces_push (&r->anal->meta_spaces, ""bin"");
 
 	if (IS_MODE_JSON (mode) && !printHere) {
 		r_cons_printf (""["");
 	} else if (IS_MODE_SET (mode)) {
 		r_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);
 	} else if (!at && exponly) {
 		if (IS_MODE_RAD (mode)) {
 			r_cons_printf (""fs exports\n"");
 		} else if (IS_MODE_NORMAL (mode)) {
 			r_cons_printf (printHere ? """" : ""[Exports]\n"");
 		}
 	} else if (!at && !exponly) {
 		if (IS_MODE_RAD (mode)) {
 			r_cons_printf (""fs symbols\n"");
 		} else if (IS_MODE_NORMAL (mode)) {
 			r_cons_printf (printHere ? """" : ""[Symbols]\n"");
 		}
 	}
 	if (IS_MODE_NORMAL (mode)) {
 		r_cons_printf (""Num Paddr      Vaddr      Bind     Type Size Name\n"");
 	}
 
 
 	size_t count = 0;
 	r_list_foreach (symbols, iter, symbol) {
 		if (!symbol->name) {
 			continue;
 		}
 		char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);
 		ut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);
 		int len = symbol->size ? symbol->size : 32;
 		SymName sn = {0};
 
 		if (exponly && !isAnExport (symbol)) {
 			free (r_symbol_name);
 			continue;
 		}
 		if (name && strcmp (r_symbol_name, name)) {
 			free (r_symbol_name);
 			continue;
 		}
 		if (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {
 			free (r_symbol_name);
 			continue;
 		}
 		if ((printHere && !is_in_range (r->offset, symbol->paddr, len))
 				&& (printHere && !is_in_range (r->offset, addr, len))) {
 			free (r_symbol_name);
 			continue;
 		}
 		count ++;
 		snInit (r, &sn, symbol, lang);
 
 		if (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {
 			 
 		} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {
 			if (is_arm) {
 				handle_arm_special_symbol (r, symbol, va);
 			}
 		} else if (IS_MODE_SET (mode)) {
 			if (is_arm) {
 				handle_arm_symbol (r, symbol, info, va);
 			}
 			select_flag_space (r, symbol);
 			 
 			if (sn.classname) {
 				RFlagItem *fi = r_flag_get (r->flags, sn.methflag);
 				if (r->bin->prefix) {
 					char *prname = r_str_newf (""%s.%s"", r->bin->prefix, sn.methflag);
 					r_name_filter (sn.methflag, -1);
 					free (sn.methflag);
 					sn.methflag = prname;
 				}
 				if (fi) {
 					r_flag_item_set_realname (fi, sn.methname);
 					if ((fi->offset - r->flags->base) == addr) {
 						r_flag_unset (r->flags, fi);
 					}
 				} else {
 					fi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);
 					char *comment = fi->comment ? strdup (fi->comment) : NULL;
 					if (comment) {
 						r_flag_item_set_comment (fi, comment);
 						R_FREE (comment);
 					}
 				}
 			} else {
 				const char *n = sn.demname ? sn.demname : sn.name;
 				const char *fn = sn.demflag ? sn.demflag : sn.nameflag;
 				char *fnp = (r->bin->prefix) ?
 					r_str_newf (""%s.%s"", r->bin->prefix, fn):
 					strdup (fn);
 				RFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);
 				if (fi) {
 					r_flag_item_set_realname (fi, n);
 					fi->demangled = (bool)(size_t)sn.demname;
 				} else {
 					if (fn) {
 						eprintf (""[Warning] Can't find flag (%s)\n"", fn);
 					}
 				}
 				free (fnp);
 			}
 			if (sn.demname) {
 				r_meta_add (r->anal, R_META_TYPE_COMMENT,
 					addr, symbol->size, sn.demname);
 			}
 			r_flag_space_pop (r->flags);
 		} else if (IS_MODE_JSON (mode)) {
 			char *str = r_str_escape_utf8_for_json (r_symbol_name, -1);
 			r_cons_printf (""%s{\""name\"":\""%s\"",""
 				""\""demname\"":\""%s\"",""
 				""\""flagname\"":\""%s\"",""
 				""\""ordinal\"":%d,""
 				""\""bind\"":\""%s\"",""
 				""\""size\"":%d,""
 				""\""type\"":\""%s\"",""
 				""\""vaddr\"":%""PFMT64d"",""
 				""\""paddr\"":%""PFMT64d""}"",
 				((exponly && firstexp) || printHere) ? """" : (iter->p ? "","" : """"),
 				str,
 				sn.demname? sn.demname: """",
 				sn.nameflag,
 				symbol->ordinal,
 				symbol->bind,
 				(int)symbol->size,
 				symbol->type,
 				(ut64)addr, (ut64)symbol->paddr);
 			free (str);
 		} else if (IS_MODE_SIMPLE (mode)) {
 			const char *name = sn.demname? sn.demname: r_symbol_name;
 			r_cons_printf (""0x%08""PFMT64x"" %d %s\n"",
 				addr, (int)symbol->size, name);
 		} else if (IS_MODE_SIMPLEST (mode)) {
 			const char *name = sn.demname? sn.demname: r_symbol_name;
 			r_cons_printf (""%s\n"", name);
 		} else if (IS_MODE_RAD (mode)) {
 			 
 			if (is_special_symbol (symbol)) {
 				goto next;
 			}
 			RBinFile *binfile;
 			RBinPlugin *plugin;
 			const char *name = sn.demname? sn.demname: r_symbol_name;
 			if (!name) {
 				goto next;
 			}
 			if (!strncmp (name, ""imp."", 4)) {
 				if (lastfs != 'i') {
 					r_cons_printf (""fs imports\n"");
 				}
 				lastfs = 'i';
 			} else {
 				if (lastfs != 's') {
 					const char *fs = exponly? ""exports"": ""symbols"";
 					r_cons_printf (""fs %s\n"", fs);
 				}
 				lastfs = 's';
 			}
 			if (r->bin->prefix || *name) {  
 				char *flagname = construct_symbol_flagname (""sym"", name, MAXFLAG_LEN_DEFAULT);
 				if (!flagname) {
 					goto next;
 				}
 				r_cons_printf (""\""f %s%s%s %u 0x%08"" PFMT64x ""\""\n"",
 					r->bin->prefix ? r->bin->prefix : """", r->bin->prefix ? ""."" : """",
 					flagname, symbol->size, addr);
 				free (flagname);
 			}
 			binfile = r_bin_cur (r->bin);
 			plugin = r_bin_file_cur_plugin (binfile);
 			if (plugin && plugin->name) {
 				if (r_str_startswith (plugin->name, ""pe"")) {
 					char *module = strdup (r_symbol_name);
 					char *p = strstr (module, "".dll_"");
 					if (p && strstr (module, ""imp."")) {
 						char *symname = __filterShell (p + 5);
  						char *m = __filterShell (module);
  						*p = 0;
  						if (r->bin->prefix) {
							r_cons_printf (""k bin/pe/%s/%d=%s.%s\n"",
 							r_cons_printf (""\""k bin/pe/%s/%d=%s.%s\""\n"",
  								module, symbol->ordinal, r->bin->prefix, symname);
  						} else {
							r_cons_printf (""k bin/pe/%s/%d=%s\n"",
 							r_cons_printf (""\""k bin/pe/%s/%d=%s\""\n"",
  								module, symbol->ordinal, symname);
  						}
  						free (symname);
 						free (m);
 					}
 					free (module);
 				}
 			}
 		} else {
 			const char *bind = symbol->bind? symbol->bind: ""NONE"";
 			const char *type = symbol->type? symbol->type: ""NONE"";
 			const char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);
 			r_cons_printf (""%03u"", symbol->ordinal);
 			if (symbol->paddr == UT64_MAX) {
 				r_cons_printf ("" ----------"");
 			} else {
 				r_cons_printf ("" 0x%08""PFMT64x, symbol->paddr);
 			}
 			r_cons_printf ("" 0x%08""PFMT64x"" %6s %6s %4d%s%s\n"",
 			               addr, bind, type, symbol->size, *name? "" "": """", name);
 		}
 next:
 		snFini (&sn);
 		i++;
 		free (r_symbol_name);
 		if (exponly && firstexp) {
 			firstexp = false;
 		}
 		if (printHere) {
 			break;
 		}
 	}
 	if (count == 0 && IS_MODE_JSON (mode)) {
 		r_cons_printf (""{}"");
 	}
 
 
 	if (is_arm) {
 		r_list_foreach (entries, iter, entry) {
 			if (IS_MODE_SET (mode)) {
 				handle_arm_entry (r, entry, info, va);
 			}
 		}
 	}
 	if (IS_MODE_JSON (mode) && !printHere) {
 		r_cons_printf (""]"");
 	}
 
 	r_spaces_pop (&r->anal->meta_spaces);
 	return true;
 }","[205, 209, 204, 208]","In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables."
204335,"   InternalWebIntentsDispatcherTest() {
    replied_ = 0;
   InternalWebIntentsDispatcherTest()
       : replied_(0),
         notified_reply_type_(webkit_glue::WEB_INTENT_REPLY_INVALID) {
    }","[3, 4, 5, 2]",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
207264,"  void DevToolsAgentHostImpl::AttachClient(DevToolsAgentHostClient* client) {
    if (SessionByClient(client))
      return;
  InnerAttachClient(client);
   InnerAttachClient(client, false  );
 }
 
 bool DevToolsAgentHostImpl::AttachRestrictedClient(
     DevToolsAgentHostClient* client) {
   if (SessionByClient(client))
     return false;
   return InnerAttachClient(client, true  );
  }","[5, 6, 7, 8, 9, 10, 11, 12, 4]",Allowing the chrome.debugger API to attach to Web UI pages in DevTools in Google Chrome prior to 67.0.3396.62 allowed an attacker who convinced a user to install a malicious extension to execute arbitrary code via a crafted Chrome Extension.
205310,"   PepperDeviceEnumerationHostHelperTest()
        : ppapi_host_(&sink_, ppapi::PpapiPermissions()),
          resource_host_(&ppapi_host_, 12345, 67890),
          device_enumeration_(&resource_host_,
                            &delegate_,
                             delegate_.AsWeakPtr(),
                              PP_DEVICETYPE_DEV_AUDIOCAPTURE,
                              GURL(""http:example.com"")) {}","[6, 5]",Use-after-free vulnerability in the Pepper plugins in Google Chrome before 39.0.2171.65 allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted Flash content that triggers an attempted PepperMediaDeviceManager access outside of the object's lifetime.
208394," long long Block::GetTrackNumber() const
{
    return m_track;
 bool Block::IsKey() const {
   return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);
  }","[4, 5, 2, 3]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
198462," PHP_METHOD(Phar, webPhar)
 {
 	zval *mimeoverride = NULL, *rewrite = NULL;
 	char *alias = NULL, *error, *index_php = NULL, *f404 = NULL, *ru = NULL;
 	int alias_len = 0, ret, f404_len = 0, free_pathinfo = 0, ru_len = 0;
 	char *fname, *path_info, *mime_type = NULL, *entry, *pt;
 	const char *basename;
 	int fname_len, entry_len, code, index_php_len = 0, not_cgi;
 	phar_archive_data *phar = NULL;
 	phar_entry_info *info = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|s!s!saz"", &alias, &alias_len, &index_php, &index_php_len, &f404, &f404_len, &mimeoverride, &rewrite) == FAILURE) {
 		return;
 	}
 
 	phar_request_initialize(TSRMLS_C);
 	fname = (char*)zend_get_executed_filename(TSRMLS_C);
 	fname_len = strlen(fname);
 
 	if (phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) != SUCCESS) {
 		if (error) {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
 			efree(error);
 		}
 		return;
 	}
 
 	 
 	if (!(SG(request_info).request_method && SG(request_info).request_uri && (!strcmp(SG(request_info).request_method, ""GET"") || !strcmp(SG(request_info).request_method, ""POST"")))) {
 		return;
 	}
 
 #ifdef PHP_WIN32
 	fname = estrndup(fname, fname_len);
 	phar_unixify_path_separators(fname, fname_len);
 #endif
 	basename = zend_memrchr(fname, '/', fname_len);
 
 	if (!basename) {
 		basename = fname;
 	} else {
 		++basename;
 	}
 
 	if ((strlen(sapi_module.name) == sizeof(""cgi-fcgi"")-1 && !strncmp(sapi_module.name, ""cgi-fcgi"", sizeof(""cgi-fcgi"")-1))
 		|| (strlen(sapi_module.name) == sizeof(""fpm-fcgi"")-1 && !strncmp(sapi_module.name, ""fpm-fcgi"", sizeof(""fpm-fcgi"")-1))
 		|| (strlen(sapi_module.name) == sizeof(""cgi"")-1 && !strncmp(sapi_module.name, ""cgi"", sizeof(""cgi"")-1))) {
 
 		if (PG(http_globals)[TRACK_VARS_SERVER]) {
 			HashTable *_server = Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]);
 			zval **z_script_name, **z_path_info;
 
 			if (SUCCESS != zend_hash_find(_server, ""SCRIPT_NAME"", sizeof(""SCRIPT_NAME""), (void**)&z_script_name) ||
 				IS_STRING != Z_TYPE_PP(z_script_name) ||
 				!strstr(Z_STRVAL_PP(z_script_name), basename)) {
 				return;
 			}
 
 			if (SUCCESS == zend_hash_find(_server, ""PATH_INFO"", sizeof(""PATH_INFO""), (void**)&z_path_info) &&
 				IS_STRING == Z_TYPE_PP(z_path_info)) {
 				entry_len = Z_STRLEN_PP(z_path_info);
 				entry = estrndup(Z_STRVAL_PP(z_path_info), entry_len);
 				path_info = emalloc(Z_STRLEN_PP(z_script_name) + entry_len + 1);
 				memcpy(path_info, Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));
 				memcpy(path_info + Z_STRLEN_PP(z_script_name), entry, entry_len + 1);
 				free_pathinfo = 1;
 			} else {
 				entry_len = 0;
 				entry = estrndup("""", 0);
 				path_info = Z_STRVAL_PP(z_script_name);
 			}
 
 			pt = estrndup(Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));
 
 		} else {
 			char *testit;
 
 			testit = sapi_getenv(""SCRIPT_NAME"", sizeof(""SCRIPT_NAME"")-1 TSRMLS_CC);
 			if (!(pt = strstr(testit, basename))) {
 				efree(testit);
 				return;
 			}
 
 			path_info = sapi_getenv(""PATH_INFO"", sizeof(""PATH_INFO"")-1 TSRMLS_CC);
 
 			if (path_info) {
 				entry = path_info;
 				entry_len = strlen(entry);
 				spprintf(&path_info, 0, ""%s%s"", testit, path_info);
 				free_pathinfo = 1;
 			} else {
 				path_info = testit;
 				free_pathinfo = 1;
 				entry = estrndup("""", 0);
 				entry_len = 0;
 			}
 
 			pt = estrndup(testit, (pt - testit) + (fname_len - (basename - fname)));
 		}
 		not_cgi = 0;
 	} else {
 		path_info = SG(request_info).request_uri;
 
 		if (!(pt = strstr(path_info, basename))) {
 			 
 			return;
 		}
 
 		entry_len = strlen(path_info);
 		entry_len -= (pt - path_info) + (fname_len - (basename - fname));
 		entry = estrndup(pt + (fname_len - (basename - fname)), entry_len);
 
 		pt = estrndup(path_info, (pt - path_info) + (fname_len - (basename - fname)));
 		not_cgi = 1;
 	}
 
 	if (rewrite) {
 		zend_fcall_info fci;
 		zend_fcall_info_cache fcc;
 		zval *params, *retval_ptr, **zp[1];
 
 		MAKE_STD_ZVAL(params);
 		ZVAL_STRINGL(params, entry, entry_len, 1);
 		zp[0] = &params;
 
 #if PHP_VERSION_ID < 50300
 		if (FAILURE == zend_fcall_info_init(rewrite, &fci, &fcc TSRMLS_CC)) {
 #else
 		if (FAILURE == zend_fcall_info_init(rewrite, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {
 #endif
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: invalid rewrite callback"");
 
 			if (free_pathinfo) {
 				efree(path_info);
 			}
 
 			return;
 		}
 
 		fci.param_count = 1;
 		fci.params = zp;
 #if PHP_VERSION_ID < 50300
 		++(params->refcount);
 #else
 		Z_ADDREF_P(params);
 #endif
 		fci.retval_ptr_ptr = &retval_ptr;
 
 		if (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {
 			if (!EG(exception)) {
 				zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: failed to call rewrite callback"");
 			}
 
 			if (free_pathinfo) {
 				efree(path_info);
 			}
 
 			return;
 		}
 
 		if (!fci.retval_ptr_ptr || !retval_ptr) {
 			if (free_pathinfo) {
 				efree(path_info);
 			}
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: rewrite callback must return a string or false"");
 			return;
 		}
 
 		switch (Z_TYPE_P(retval_ptr)) {
 #if PHP_VERSION_ID >= 60000
 			case IS_UNICODE:
 				zval_unicode_to_string(retval_ptr TSRMLS_CC);
 				 
 #endif
 			case IS_STRING:
 				efree(entry);
 
 				if (fci.retval_ptr_ptr != &retval_ptr) {
 					entry = estrndup(Z_STRVAL_PP(fci.retval_ptr_ptr), Z_STRLEN_PP(fci.retval_ptr_ptr));
 					entry_len = Z_STRLEN_PP(fci.retval_ptr_ptr);
 				} else {
 					entry = Z_STRVAL_P(retval_ptr);
 					entry_len = Z_STRLEN_P(retval_ptr);
 				}
 
 				break;
 			case IS_BOOL:
 				phar_do_403(entry, entry_len TSRMLS_CC);
 
 				if (free_pathinfo) {
 					efree(path_info);
 				}
 
 				zend_bailout();
 				return;
 			default:
 				efree(retval_ptr);
 
 				if (free_pathinfo) {
 					efree(path_info);
 				}
 
 				zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: rewrite callback must return a string or false"");
 				return;
 		}
 	}
 
 	if (entry_len) {
 		phar_postprocess_ru_web(fname, fname_len, &entry, &entry_len, &ru, &ru_len TSRMLS_CC);
 	}
 
 	if (!entry_len || (entry_len == 1 && entry[0] == '/')) {
 		efree(entry);
 		 
 		if (index_php_len) {
 			entry = index_php;
 			entry_len = index_php_len;
 			if (entry[0] != '/') {
 				spprintf(&entry, 0, ""/%s"", index_php);
 				++entry_len;
 			}
 		} else {
 			 
 			entry = estrndup(""/index.php"", sizeof(""/index.php""));
 			entry_len = sizeof(""/index.php"")-1;
 		}
 
 		if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||
 			(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {
 			phar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);
 
 			if (free_pathinfo) {
 				efree(path_info);
 			}
 
 			zend_bailout();
 		} else {
 			char *tmp = NULL, sa = '\0';
 			sapi_header_line ctr = {0};
 			ctr.response_code = 301;
 			ctr.line_len = sizeof(""HTTP/1.1 301 Moved Permanently"")-1;
 			ctr.line = ""HTTP/1.1 301 Moved Permanently"";
 			sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);
 
 			if (not_cgi) {
 				tmp = strstr(path_info, basename) + fname_len;
 				sa = *tmp;
 				*tmp = '\0';
 			}
 
 			ctr.response_code = 0;
 
 			if (path_info[strlen(path_info)-1] == '/') {
 				ctr.line_len = spprintf(&(ctr.line), 4096, ""Location: %s%s"", path_info, entry + 1);
 			} else {
 				ctr.line_len = spprintf(&(ctr.line), 4096, ""Location: %s%s"", path_info, entry);
 			}
 
 			if (not_cgi) {
 				*tmp = sa;
 			}
 
 			if (free_pathinfo) {
 				efree(path_info);
 			}
 
 			sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);
 			sapi_send_headers(TSRMLS_C);
 			efree(ctr.line);
 			zend_bailout();
 		}
 	}
 
 	if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||
 		(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {
 		phar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);
 #ifdef PHP_WIN32
 		efree(fname);
 #endif
 		zend_bailout();
 	}
 
 	if (mimeoverride && zend_hash_num_elements(Z_ARRVAL_P(mimeoverride))) {
 		const char *ext = zend_memrchr(entry, '.', entry_len);
 		zval **val;
 
 		if (ext) {
 			++ext;
 
 			if (SUCCESS == zend_hash_find(Z_ARRVAL_P(mimeoverride), ext, strlen(ext)+1, (void **) &val)) {
 				switch (Z_TYPE_PP(val)) {
 					case IS_LONG:
 						if (Z_LVAL_PP(val) == PHAR_MIME_PHP || Z_LVAL_PP(val) == PHAR_MIME_PHPS) {
 							mime_type = """";
 							code = Z_LVAL_PP(val);
 						} else {
 							zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown mime type specifier used, only Phar::PHP, Phar::PHPS and a mime type string are allowed"");
 #ifdef PHP_WIN32
 							efree(fname);
 #endif
 							RETURN_FALSE;
 						}
 						break;
 					case IS_STRING:
 						mime_type = Z_STRVAL_PP(val);
 						code = PHAR_MIME_OTHER;
 						break;
 					default:
 						zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown mime type specifier used (not a string or int), only Phar::PHP, Phar::PHPS and a mime type string are allowed"");
 #ifdef PHP_WIN32
 						efree(fname);
 #endif
 						RETURN_FALSE;
 				}
 			}
 		}
 	}
 
 	if (!mime_type) {
 		code = phar_file_type(&PHAR_G(mime_types), entry, &mime_type TSRMLS_CC);
 	}
 	ret = phar_file_action(phar, info, mime_type, code, entry, entry_len, fname, pt, ru, ru_len TSRMLS_CC);
 }
  
 
  
 PHP_METHOD(Phar, mungServer)
 {
 	zval *mungvalues;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""a"", &mungvalues) == FAILURE) {
 		return;
 	}
 
 	if (!zend_hash_num_elements(Z_ARRVAL_P(mungvalues))) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""No values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME"");
 		return;
 	}
 
 	if (zend_hash_num_elements(Z_ARRVAL_P(mungvalues)) > 4) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Too many values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME"");
 		return;
 	}
 
 	phar_request_initialize(TSRMLS_C);
 
 	for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(mungvalues)); SUCCESS == zend_hash_has_more_elements(Z_ARRVAL_P(mungvalues)); zend_hash_move_forward(Z_ARRVAL_P(mungvalues))) {
 		zval **data = NULL;
 
 		if (SUCCESS != zend_hash_get_current_data(Z_ARRVAL_P(mungvalues), (void **) &data)) {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""unable to retrieve array value in Phar::mungServer()"");
 			return;
 		}
 
 		if (Z_TYPE_PP(data) != IS_STRING) {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Non-string value passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME"");
 			return;
 		}
 
 		if (Z_STRLEN_PP(data) == sizeof(""PHP_SELF"")-1 && !strncmp(Z_STRVAL_PP(data), ""PHP_SELF"", sizeof(""PHP_SELF"")-1)) {
 			PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_PHP_SELF;
 		}
 
 		if (Z_STRLEN_PP(data) == sizeof(""REQUEST_URI"")-1) {
 			if (!strncmp(Z_STRVAL_PP(data), ""REQUEST_URI"", sizeof(""REQUEST_URI"")-1)) {
 				PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_REQUEST_URI;
 			}
 			if (!strncmp(Z_STRVAL_PP(data), ""SCRIPT_NAME"", sizeof(""SCRIPT_NAME"")-1)) {
 				PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_NAME;
 			}
 		}
 
 		if (Z_STRLEN_PP(data) == sizeof(""SCRIPT_FILENAME"")-1 && !strncmp(Z_STRVAL_PP(data), ""SCRIPT_FILENAME"", sizeof(""SCRIPT_FILENAME"")-1)) {
 			PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_FILENAME;
 		}
 	}
 }
  
 
  
 PHP_METHOD(Phar, interceptFileFuncs)
 {
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
 	phar_intercept_functions(TSRMLS_C);
 }
  
 
  
 PHP_METHOD(Phar, createDefaultStub)
 {
 	char *index = NULL, *webindex = NULL, *stub, *error;
 	int index_len = 0, webindex_len = 0;
 	size_t stub_len;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|ss"", &index, &index_len, &webindex, &webindex_len) == FAILURE) {
 		return;
 	}
 
 	stub = phar_create_default_stub(index, webindex, &stub_len, &error TSRMLS_CC);
 
 	if (error) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
 		efree(error);
 		return;
 	}
 	RETURN_STRINGL(stub, stub_len, 0);
 }
  
 
  
 PHP_METHOD(Phar, mapPhar)
 {
 	char *alias = NULL, *error;
 	int alias_len = 0;
 	long dataoffset = 0;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|s!l"", &alias, &alias_len, &dataoffset) == FAILURE) {
 		return;
 	}
 
 	phar_request_initialize(TSRMLS_C);
 
 	RETVAL_BOOL(phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) == SUCCESS);
 
 	if (error) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
 		efree(error);
 	}
 }  
 
  
 PHP_METHOD(Phar, loadPhar)
 {
 	char *fname, *alias = NULL, *error;
 	int fname_len, alias_len = 0;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|s!"", &fname, &fname_len, &alias, &alias_len) == FAILURE) {
 		return;
 	}
 
 	phar_request_initialize(TSRMLS_C);
 
 	RETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error TSRMLS_CC) == SUCCESS);
 
 	if (error) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
 		efree(error);
 	}
 }  
 
  
 PHP_METHOD(Phar, apiVersion)
 {
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
 	RETURN_STRINGL(PHP_PHAR_API_VERSION, sizeof(PHP_PHAR_API_VERSION)-1, 1);
 }
  
 
  
 PHP_METHOD(Phar, canCompress)
 {
 	long method = 0;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|l"", &method) == FAILURE) {
 		return;
 	}
 
 	phar_request_initialize(TSRMLS_C);
 	switch (method) {
 	case PHAR_ENT_COMPRESSED_GZ:
 		if (PHAR_G(has_zlib)) {
 			RETURN_TRUE;
 		} else {
 			RETURN_FALSE;
 		}
 	case PHAR_ENT_COMPRESSED_BZ2:
 		if (PHAR_G(has_bz2)) {
 			RETURN_TRUE;
 		} else {
 			RETURN_FALSE;
 		}
 	default:
 		if (PHAR_G(has_zlib) || PHAR_G(has_bz2)) {
 			RETURN_TRUE;
 		} else {
 			RETURN_FALSE;
 		}
 	}
 }
  
 
  
 PHP_METHOD(Phar, canWrite)
 {
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
 	RETURN_BOOL(!PHAR_G(readonly));
 }
  
 
  
 PHP_METHOD(Phar, isValidPharFilename)
 {
 	char *fname;
 	const char *ext_str;
 	int fname_len, ext_len, is_executable;
 	zend_bool executable = 1;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|b"", &fname, &fname_len, &executable) == FAILURE) {
 		return;
 	}
 
 	is_executable = executable;
 	RETVAL_BOOL(phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, is_executable, 2, 1 TSRMLS_CC) == SUCCESS);
 }
  
 
 #if HAVE_SPL
  
 static void phar_spl_foreign_dtor(spl_filesystem_object *object TSRMLS_DC)  
 {
 	phar_archive_data *phar = (phar_archive_data *) object->oth;
 
 	if (!phar->is_persistent) {
 		phar_archive_delref(phar TSRMLS_CC);
 	}
 
 	object->oth = NULL;
 }
  
 
  
 static void phar_spl_foreign_clone(spl_filesystem_object *src, spl_filesystem_object *dst TSRMLS_DC)  
 {
 	phar_archive_data *phar_data = (phar_archive_data *) dst->oth;
 
 	if (!phar_data->is_persistent) {
 		++(phar_data->refcount);
 	}
 }
  
 
 static spl_other_handler phar_spl_foreign_handler = {
 	phar_spl_foreign_dtor,
 	phar_spl_foreign_clone
 };
 #endif  
 
  
 PHP_METHOD(Phar, __construct)
 {
 #if !HAVE_SPL
 	zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Cannot instantiate Phar object without SPL extension"");
 #else
 	char *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;
 	int fname_len, alias_len = 0, arch_len, entry_len, is_data;
 #if PHP_VERSION_ID < 50300
 	long flags = 0;
 #else
 	long flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;
 #endif
 	long format = 0;
 	phar_archive_object *phar_obj;
 	phar_archive_data   *phar_data;
 	zval *zobj = getThis(), arg1, arg2;
 
 	phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 
 	is_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data TSRMLS_CC);
 
 	if (is_data) {
 		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|ls!l"", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {
 			return;
 		}
 	} else {
 		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|ls!"", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {
 			return;
 		}
 	}
 
 	if (phar_obj->arc.archive) {
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Cannot call constructor twice"");
 		return;
 	}
 
 	save_fname = fname;
 	if (SUCCESS == phar_split_fname(fname, fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2 TSRMLS_CC)) {
 		 
 		 
 #ifdef PHP_WIN32
 		phar_unixify_path_separators(arch, arch_len);
 #endif
 		fname = arch;
 		fname_len = arch_len;
 #ifdef PHP_WIN32
 	} else {
 		arch = estrndup(fname, fname_len);
 		arch_len = fname_len;
 		fname = arch;
 		phar_unixify_path_separators(arch, arch_len);
 #endif
 	}
 
 	if (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error TSRMLS_CC) == FAILURE) {
 
 		if (fname == arch && fname != save_fname) {
 			efree(arch);
 			fname = save_fname;
 		}
 
 		if (entry) {
 			efree(entry);
 		}
 
 		if (error) {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""%s"", error);
 			efree(error);
 		} else {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""Phar creation or opening failed"");
 		}
 
 		return;
 	}
 
 	if (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {
 		phar_data->is_zip = 1;
 		phar_data->is_tar = 0;
 	}
 
 	if (fname == arch) {
 		efree(arch);
 		fname = save_fname;
 	}
 
 	if ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {
 		if (is_data) {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""PharData class can only be used for non-executable tar and zip archives"");
 		} else {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""Phar class can only be used for executable tar and zip archives"");
 		}
 		efree(entry);
 		return;
 	}
 
 	is_data = phar_data->is_data;
 
 	if (!phar_data->is_persistent) {
 		++(phar_data->refcount);
 	}
 
 	phar_obj->arc.archive = phar_data;
 	phar_obj->spl.oth_handler = &phar_spl_foreign_handler;
 
 	if (entry) {
 		fname_len = spprintf(&fname, 0, ""phar:%s%s"", phar_data->fname, entry);
 		efree(entry);
 	} else {
 		fname_len = spprintf(&fname, 0, ""phar:%s"", phar_data->fname);
 	}
 
 	INIT_PZVAL(&arg1);
 	ZVAL_STRINGL(&arg1, fname, fname_len, 0);
         INIT_PZVAL(&arg2);
         ZVAL_LONG(&arg2, flags);
  
       zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj), 
        zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj),
                 &spl_ce_RecursiveDirectoryIterator->constructor, ""__construct"", NULL, &arg1, &arg2);
  
         if (!phar_data->is_persistent) {
 		phar_obj->arc.archive->is_data = is_data;
 	} else if (!EG(exception)) {
 		 
 		zend_hash_add(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive), (void *) &phar_obj, sizeof(phar_archive_object **), NULL);
 	}
 
 	phar_obj->spl.info_class = phar_ce_entry;
 	efree(fname);
 #endif  
 }
  
 
  
 PHP_METHOD(Phar, getSupportedSignatures)
 {
         if (zend_parse_parameters_none() == FAILURE) {
                 return;
         }
 
         array_init(return_value);
  
         add_next_index_stringl(return_value, ""MD5"", 3, 1);
 	add_next_index_stringl(return_value, ""SHA-1"", 5, 1);
 #ifdef PHAR_HASH_OK
 	add_next_index_stringl(return_value, ""SHA-256"", 7, 1);
 	add_next_index_stringl(return_value, ""SHA-512"", 7, 1);
 #endif
 #if PHAR_HAVE_OPENSSL
 	add_next_index_stringl(return_value, ""OpenSSL"", 7, 1);
 #else
 	if (zend_hash_exists(&module_registry, ""openssl"", sizeof(""openssl""))) {
 		add_next_index_stringl(return_value, ""OpenSSL"", 7, 1);
 	}
 #endif
 }
  
 
  
 PHP_METHOD(Phar, getSupportedCompression)
 {
         if (zend_parse_parameters_none() == FAILURE) {
                 return;
         }
 
         array_init(return_value);
         phar_request_initialize(TSRMLS_C);
  
 	if (PHAR_G(has_zlib)) {
 		add_next_index_stringl(return_value, ""GZ"", 2, 1);
 	}
 
 	if (PHAR_G(has_bz2)) {
 		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
 	}
 }
  
 
  
 PHP_METHOD(Phar, unlinkArchive)
 {
 	char *fname, *error, *zname, *arch, *entry;
 	int fname_len, zname_len, arch_len, entry_len;
 	phar_archive_data *phar;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &fname, &fname_len) == FAILURE) {
 		RETURN_FALSE;
 	}
 
 	if (!fname_len) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown phar archive \""\"""");
 		return;
 	}
 
 	if (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error TSRMLS_CC)) {
 		if (error) {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown phar archive \""%s\"": %s"", fname, error);
 			efree(error);
 		} else {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown phar archive \""%s\"""", fname);
 		}
 		return;
 	}
 
 	zname = (char*)zend_get_executed_filename(TSRMLS_C);
 	zname_len = strlen(zname);
 
 	if (zname_len > 7 && !memcmp(zname, ""phar:"", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0 TSRMLS_CC)) {
 		if (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar archive \""%s\"" cannot be unlinked from within itself"", fname);
 			efree(arch);
 			efree(entry);
 			return;
 		}
 		efree(arch);
 		efree(entry);
 	}
 
 	if (phar->is_persistent) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar archive \""%s\"" is in phar.cache_list, cannot unlinkArchive()"", fname);
 		return;
 	}
 
 	if (phar->refcount) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar archive \""%s\"" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()"", fname);
 		return;
 	}
 
 	fname = estrndup(phar->fname, phar->fname_len);
 
 	 
 	PHAR_G(last_phar) = NULL;
 	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;
 
 	phar_archive_delref(phar TSRMLS_CC);
 	unlink(fname);
 	efree(fname);
 	RETURN_TRUE;
 }
  
 
 #if HAVE_SPL
 
 #define PHAR_ARCHIVE_OBJECT() \
 	phar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \
 	if (!phar_obj->arc.archive) { \
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \
 			""Cannot call method on an uninitialized Phar object""); \
 		return; \
 	}
 
  
 PHP_METHOD(Phar, __destruct)
 {
 	phar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 
 	if (phar_obj->arc.archive && phar_obj->arc.archive->is_persistent) {
 		zend_hash_del(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive));
 	}
 }
  
 
 struct _phar_t {
 	phar_archive_object *p;
 	zend_class_entry *c;
 	char *b;
 	uint l;
 	zval *ret;
 	int count;
 	php_stream *fp;
 };
 
 static int phar_build(zend_object_iterator *iter, void *puser TSRMLS_DC)  
 {
 	zval **value;
 	zend_uchar key_type;
 	zend_bool close_fp = 1;
 	ulong int_key;
 	struct _phar_t *p_obj = (struct _phar_t*) puser;
 	uint str_key_len, base_len = p_obj->l, fname_len;
 	phar_entry_data *data;
 	php_stream *fp;
 	size_t contents_len;
 	char *fname, *error = NULL, *base = p_obj->b, *opened, *save = NULL, *temp = NULL;
 	phar_zstr key;
 	char *str_key;
 	zend_class_entry *ce = p_obj->c;
 	phar_archive_object *phar_obj = p_obj->p;
 	char *str = ""[stream]"";
 
 	iter->funcs->get_current_data(iter, &value TSRMLS_CC);
 
 	if (EG(exception)) {
 		return ZEND_HASH_APPLY_STOP;
 	}
 
 	if (!value) {
 		 
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned no value"", ce->name);
 		return ZEND_HASH_APPLY_STOP;
 	}
 
 	switch (Z_TYPE_PP(value)) {
 #if PHP_VERSION_ID >= 60000
 		case IS_UNICODE:
 			zval_unicode_to_string(*(value) TSRMLS_CC);
 			 
 #endif
 		case IS_STRING:
 			break;
 		case IS_RESOURCE:
 			php_stream_from_zval_no_verify(fp, value);
 
 			if (!fp) {
 				zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Iterator %v returned an invalid stream handle"", ce->name);
 				return ZEND_HASH_APPLY_STOP;
 			}
 
 			if (iter->funcs->get_current_key) {
 				key_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);
 
 				if (EG(exception)) {
 					return ZEND_HASH_APPLY_STOP;
 				}
 
 				if (key_type == HASH_KEY_IS_LONG) {
 					zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
 					return ZEND_HASH_APPLY_STOP;
 				}
 
 				if (key_type > 9) {  
 #if PHP_VERSION_ID < 60000
  
 					spprintf(&str_key, 0, ""%s"", key);
 #else
 					spprintf(&str_key, 0, ""%v"", key);
 					ezfree(key);
 #endif
 				} else {
 					PHAR_STR(key, str_key);
 				}
 
 				save = str_key;
 
 				if (str_key[str_key_len - 1] == '\0') {
 					str_key_len--;
 				}
 
 			} else {
 				zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
 				return ZEND_HASH_APPLY_STOP;
 			}
 
 			close_fp = 0;
 			opened = (char *) estrndup(str, sizeof(""[stream]"") - 1);
 			goto after_open_fp;
 		case IS_OBJECT:
 			if (instanceof_function(Z_OBJCE_PP(value), spl_ce_SplFileInfo TSRMLS_CC)) {
 				char *test = NULL;
 				zval dummy;
 				spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(*value TSRMLS_CC);
 
 				if (!base_len) {
 					zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Iterator %v returns an SplFileInfo object, so base directory must be specified"", ce->name);
 					return ZEND_HASH_APPLY_STOP;
 				}
 
 				switch (intern->type) {
 					case SPL_FS_DIR:
 #if PHP_VERSION_ID >= 60000
 						test = spl_filesystem_object_get_path(intern, NULL, NULL TSRMLS_CC).s;
 #elif PHP_VERSION_ID >= 50300
 						test = spl_filesystem_object_get_path(intern, NULL TSRMLS_CC);
 #else
 						test = intern->path;
 #endif
 						fname_len = spprintf(&fname, 0, ""%s%c%s"", test, DEFAULT_SLASH, intern->u.dir.entry.d_name);
 						php_stat(fname, fname_len, FS_IS_DIR, &dummy TSRMLS_CC);
 
 						if (Z_BVAL(dummy)) {
 							 
 							efree(fname);
 							return ZEND_HASH_APPLY_KEEP;
 						}
 
 						test = expand_filepath(fname, NULL TSRMLS_CC);
 						efree(fname);
 
 						if (test) {
 							fname = test;
 							fname_len = strlen(fname);
 						} else {
 							zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Could not resolve file path"");
 							return ZEND_HASH_APPLY_STOP;
 						}
 
 						save = fname;
 						goto phar_spl_fileinfo;
 					case SPL_FS_INFO:
 					case SPL_FS_FILE:
 #if PHP_VERSION_ID >= 60000
 						if (intern->file_name_type == IS_UNICODE) {
 							zval zv;
 
 							INIT_ZVAL(zv);
 							Z_UNIVAL(zv) = intern->file_name;
 							Z_UNILEN(zv) = intern->file_name_len;
 							Z_TYPE(zv) = IS_UNICODE;
 
 							zval_copy_ctor(&zv);
 							zval_unicode_to_string(&zv TSRMLS_CC);
 							fname = expand_filepath(Z_STRVAL(zv), NULL TSRMLS_CC);
 							ezfree(Z_UNIVAL(zv));
 						} else {
 							fname = expand_filepath(intern->file_name.s, NULL TSRMLS_CC);
 						}
 #else
 						fname = expand_filepath(intern->file_name, NULL TSRMLS_CC);
 #endif
 						if (!fname) {
 							zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Could not resolve file path"");
 							return ZEND_HASH_APPLY_STOP;
 						}
 
 						fname_len = strlen(fname);
 						save = fname;
 						goto phar_spl_fileinfo;
 				}
 			}
 			 
 		default:
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid value (must return a string)"", ce->name);
 			return ZEND_HASH_APPLY_STOP;
 	}
 
 	fname = Z_STRVAL_PP(value);
 	fname_len = Z_STRLEN_PP(value);
 
 phar_spl_fileinfo:
 	if (base_len) {
 		temp = expand_filepath(base, NULL TSRMLS_CC);
 		if (!temp) {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Could not resolve file path"");
 			if (save) {
 				efree(save);
                         }
                         return ZEND_HASH_APPLY_STOP;
                 }
 
                 base = temp;
                 base_len = strlen(base);
  
 		if (strstr(fname, base)) {
 			str_key_len = fname_len - base_len;
 
 			if (str_key_len <= 0) {
 				if (save) {
 					efree(save);
 					efree(temp);
 				}
 				return ZEND_HASH_APPLY_KEEP;
 			}
 
 			str_key = fname + base_len;
 
 			if (*str_key == '/' || *str_key == '\\') {
 				str_key++;
 				str_key_len--;
 			}
 
 		} else {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a path \""%s\"" that is not in the base directory \""%s\"""", ce->name, fname, base);
 
 			if (save) {
 				efree(save);
 				efree(temp);
 			}
 
 			return ZEND_HASH_APPLY_STOP;
 		}
 	} else {
 		if (iter->funcs->get_current_key) {
 			key_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);
 
 			if (EG(exception)) {
 				return ZEND_HASH_APPLY_STOP;
 			}
 
 			if (key_type == HASH_KEY_IS_LONG) {
 				zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
 				return ZEND_HASH_APPLY_STOP;
 			}
 
 			if (key_type > 9) {  
 #if PHP_VERSION_ID < 60000
  
 				spprintf(&str_key, 0, ""%s"", key);
 #else
 				spprintf(&str_key, 0, ""%v"", key);
 				ezfree(key);
 #endif
 			} else {
 				PHAR_STR(key, str_key);
 			}
 
 			save = str_key;
 
 			if (str_key[str_key_len - 1] == '\0') str_key_len--;
 		} else {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
 			return ZEND_HASH_APPLY_STOP;
 		}
 	}
 #if PHP_API_VERSION < 20100412
 	if (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a path \""%s\"" that safe mode prevents opening"", ce->name, fname);
 
 		if (save) {
 			efree(save);
 		}
 
 		if (temp) {
 			efree(temp);
 		}
 
 		return ZEND_HASH_APPLY_STOP;
 	}
 #endif
 
 	if (php_check_open_basedir(fname TSRMLS_CC)) {
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a path \""%s\"" that open_basedir prevents opening"", ce->name, fname);
 
 		if (save) {
 			efree(save);
 		}
 
 		if (temp) {
 			efree(temp);
 		}
 
 		return ZEND_HASH_APPLY_STOP;
 	}
 
 	 
 	fp = php_stream_open_wrapper(fname, ""rb"", STREAM_MUST_SEEK|0, &opened);
 
 	if (!fp) {
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a file that could not be opened \""%s\"""", ce->name, fname);
 
 		if (save) {
 			efree(save);
 		}
 
 		if (temp) {
 			efree(temp);
 		}
 
 		return ZEND_HASH_APPLY_STOP;
 	}
 after_open_fp:
 	if (str_key_len >= sizeof("".phar"")-1 && !memcmp(str_key, "".phar"", sizeof("".phar"")-1)) {
 		 
 		if (save) {
 			efree(save);
 		}
 
 		if (temp) {
 			efree(temp);
 		}
 
 		if (opened) {
 			efree(opened);
 		}
 
 		if (close_fp) {
 			php_stream_close(fp);
 		}
 
 		return ZEND_HASH_APPLY_KEEP;
 	}
 
 	if (!(data = phar_get_or_create_entry_data(phar_obj->arc.archive->fname, phar_obj->arc.archive->fname_len, str_key, str_key_len, ""w+b"", 0, &error, 1 TSRMLS_CC))) {
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Entry %s cannot be created: %s"", str_key, error);
 		efree(error);
 
 		if (save) {
 			efree(save);
 		}
 
 		if (opened) {
 			efree(opened);
 		}
 
 		if (temp) {
 			efree(temp);
 		}
 
 		if (close_fp) {
 			php_stream_close(fp);
 		}
 
 		return ZEND_HASH_APPLY_STOP;
 
 	} else {
 		if (error) {
 			efree(error);
 		}
 		 
 		if (data->internal_file->fp_type == PHAR_MOD) {
 			php_stream_close(data->internal_file->fp);
 		}
 
 		data->internal_file->fp = NULL;
 		data->internal_file->fp_type = PHAR_UFP;
 		data->internal_file->offset_abs = data->internal_file->offset = php_stream_tell(p_obj->fp);
 		data->fp = NULL;
 		phar_stream_copy_to_stream(fp, p_obj->fp, PHP_STREAM_COPY_ALL, &contents_len);
 		data->internal_file->uncompressed_filesize = data->internal_file->compressed_filesize =
 			php_stream_tell(p_obj->fp) - data->internal_file->offset;
 	}
 
 	if (close_fp) {
 		php_stream_close(fp);
 	}
 
 	add_assoc_string(p_obj->ret, str_key, opened, 0);
 
 	if (save) {
 		efree(save);
 	}
 
 	if (temp) {
 		efree(temp);
 	}
 
 	data->internal_file->compressed_filesize = data->internal_file->uncompressed_filesize = contents_len;
 	phar_entry_delref(data TSRMLS_CC);
 
 	return ZEND_HASH_APPLY_KEEP;
 }
  
 
   
  PHP_METHOD(Phar, buildFromDirectory)
 {
 	char *dir, *error, *regex = NULL;
 	int dir_len, regex_len = 0;
 	zend_bool apply_reg = 0;
 	zval arg, arg2, *iter, *iteriter, *regexiter = NULL;
 	struct _phar_t pass;
 
 	PHAR_ARCHIVE_OBJECT();
 
 	if (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 			""Cannot write to archive - write operations restricted by INI setting"");
 		return;
 	}
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"", &dir, &dir_len, &regex, &regex_len) == FAILURE) {
 		RETURN_FALSE;
 	}
 
 	MAKE_STD_ZVAL(iter);
 
 	if (SUCCESS != object_init_ex(iter, spl_ce_RecursiveDirectoryIterator)) {
 		zval_ptr_dtor(&iter);
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate directory iterator for %s"", phar_obj->arc.archive->fname);
 		RETURN_FALSE;
 	}
 
 	INIT_PZVAL(&arg);
 	ZVAL_STRINGL(&arg, dir, dir_len, 0);
 	INIT_PZVAL(&arg2);
 #if PHP_VERSION_ID < 50300
 	ZVAL_LONG(&arg2, 0);
 #else
         ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);
  #endif
  
       zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator, 
        zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator,
                         &spl_ce_RecursiveDirectoryIterator->constructor, ""__construct"", NULL, &arg, &arg2);
  
         if (EG(exception)) {
 		zval_ptr_dtor(&iter);
 		RETURN_FALSE;
 	}
 
 	MAKE_STD_ZVAL(iteriter);
 
 	if (SUCCESS != object_init_ex(iteriter, spl_ce_RecursiveIteratorIterator)) {
 		zval_ptr_dtor(&iter);
 		zval_ptr_dtor(&iteriter);
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate directory iterator for %s"", phar_obj->arc.archive->fname);
                 RETURN_FALSE;
         }
  
       zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator, 
        zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator,
                         &spl_ce_RecursiveIteratorIterator->constructor, ""__construct"", NULL, iter);
  
         if (EG(exception)) {
 		zval_ptr_dtor(&iter);
 		zval_ptr_dtor(&iteriter);
 		RETURN_FALSE;
 	}
 
 	zval_ptr_dtor(&iter);
 
 	if (regex_len > 0) {
 		apply_reg = 1;
 		MAKE_STD_ZVAL(regexiter);
 
 		if (SUCCESS != object_init_ex(regexiter, spl_ce_RegexIterator)) {
 			zval_ptr_dtor(&iteriter);
 			zval_dtor(regexiter);
 			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate regex iterator for %s"", phar_obj->arc.archive->fname);
 			RETURN_FALSE;
 		}
 
                 INIT_PZVAL(&arg2);
                 ZVAL_STRINGL(&arg2, regex, regex_len, 0);
  
               zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator, 
                zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator,
                         &spl_ce_RegexIterator->constructor, ""__construct"", NULL, iteriter, &arg2);
         }
  
 	array_init(return_value);
 
 	pass.c = apply_reg ? Z_OBJCE_P(regexiter) : Z_OBJCE_P(iteriter);
 	pass.p = phar_obj;
 	pass.b = dir;
 	pass.l = dir_len;
 	pass.count = 0;
 	pass.ret = return_value;
 	pass.fp = php_stream_fopen_tmpfile();
 	if (pass.fp == NULL) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"" unable to create temporary file"", phar_obj->arc.archive->fname);
 		return;
 	}
 
 	if (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {
 		zval_ptr_dtor(&iteriter);
 		if (apply_reg) {
 			zval_ptr_dtor(&regexiter);
 		}
 		php_stream_close(pass.fp);
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"" is persistent, unable to copy on write"", phar_obj->arc.archive->fname);
 		return;
 	}
 
 	if (SUCCESS == spl_iterator_apply((apply_reg ? regexiter : iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {
 		zval_ptr_dtor(&iteriter);
 
 		if (apply_reg) {
 			zval_ptr_dtor(&regexiter);
 		}
 
 		phar_obj->arc.archive->ufp = pass.fp;
 		phar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);
 
 		if (error) {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
 			efree(error);
 		}
 
 	} else {
 		zval_ptr_dtor(&iteriter);
 		if (apply_reg) {
 			zval_ptr_dtor(&regexiter);
 		}
 		php_stream_close(pass.fp);
 	}
 }
  
 
  
 PHP_METHOD(Phar, buildFromIterator)
 {
 	zval *obj;
 	char *error;
 	uint base_len = 0;
 	char *base = NULL;
 	struct _phar_t pass;
 
 	PHAR_ARCHIVE_OBJECT();
 
 	if (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 			""Cannot write out phar archive, phar is read-only"");
 		return;
 	}
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O|s"", &obj, zend_ce_traversable, &base, &base_len) == FAILURE) {
 		RETURN_FALSE;
 	}
 
 	if (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"" is persistent, unable to copy on write"", phar_obj->arc.archive->fname);
 		return;
 	}
 
 	array_init(return_value);
 
 	pass.c = Z_OBJCE_P(obj);
 	pass.p = phar_obj;
 	pass.b = base;
 	pass.l = base_len;
 	pass.ret = return_value;
 	pass.count = 0;
 	pass.fp = php_stream_fopen_tmpfile();
 	if (pass.fp == NULL) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"": unable to create temporary file"", phar_obj->arc.archive->fname);
 		return;
 	}
 
 	if (SUCCESS == spl_iterator_apply(obj, (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {
 		phar_obj->arc.archive->ufp = pass.fp;
 		phar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);
 		if (error) {
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
 			efree(error);
 		}
 	} else {
 		php_stream_close(pass.fp);
 	}
 }
  
 
  
  PHP_METHOD(Phar, count)
  {
         PHAR_ARCHIVE_OBJECT();
 
         if (zend_parse_parameters_none() == FAILURE) {
                 return;
         }
 
 	RETURN_LONG(zend_hash_num_elements(&phar_obj->arc.archive->manifest));
 }
  
 
  
 PHP_METHOD(Phar, isFileFormat)
 {
 	long type;
 	PHAR_ARCHIVE_OBJECT();
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &type) == FAILURE) {
 		RETURN_FALSE;
 	}
 
 	switch (type) {
 		case PHAR_FORMAT_TAR:
 			RETURN_BOOL(phar_obj->arc.archive->is_tar);
 		case PHAR_FORMAT_ZIP:
 			RETURN_BOOL(phar_obj->arc.archive->is_zip);
 		case PHAR_FORMAT_PHAR:
 			RETURN_BOOL(!phar_obj->arc.archive->is_tar && !phar_obj->arc.archive->is_zip);
 		default:
 			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown file format specified"");
 	}
 }
  
 
 static int phar_copy_file_contents(phar_entry_info *entry, php_stream *fp TSRMLS_DC)  
 {
 	char *error;
 	off_t offset;
 	phar_entry_info *link;
 
 	if (FAILURE == phar_open_entry_fp(entry, &error, 1 TSRMLS_CC)) {
 		if (error) {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""Cannot convert phar archive \""%s\"", unable to open entry \""%s\"" contents: %s"", entry->phar->fname, entry->filename, error);
 			efree(error);
 		} else {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""Cannot convert phar archive \""%s\"", unable to open entry \""%s\"" contents"", entry->phar->fname, entry->filename);
 		}
 		return FAILURE;
 	}
 
 	 
 	phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);
 	offset = php_stream_tell(fp);
 	link = phar_get_link_source(entry TSRMLS_CC);
 
 	if (!link) {
 		link = entry;
 	}
 
 	if (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {
 		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 			""Cannot convert phar archive \""%s\"", unable to copy entry \""%s\"" contents"", entry->phar->fname, entry->filename);
 		return FAILURE;
 	}
 
 	if (entry->fp_type == PHAR_MOD) {
 		 
 		entry->cfp = entry->fp;
 		entry->fp = NULL;
 	}
 
 	 
 	entry->fp_type = PHAR_FP;
 	entry->offset = offset;
 	return SUCCESS;
 }
  
 
 static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC)  
 {
 	const char *oldname = NULL;
 	char *oldpath = NULL;
 	char *basename = NULL, *basepath = NULL;
 	char *newname = NULL, *newpath = NULL;
 	zval *ret, arg1;
 	zend_class_entry *ce;
 	char *error;
 	const char *pcr_error;
 	int ext_len = ext ? strlen(ext) : 0;
 	int oldname_len;
 	phar_archive_data **pphar = NULL;
 	php_stream_statbuf ssb;
 
 	if (!ext) {
 		if (phar->is_zip) {
 
 			if (phar->is_data) {
 				ext = ""zip"";
 			} else {
 				ext = ""phar.zip"";
 			}
 
 		} else if (phar->is_tar) {
 
 			switch (phar->flags) {
 				case PHAR_FILE_COMPRESSED_GZ:
 					if (phar->is_data) {
 						ext = ""tar.gz"";
 					} else {
 						ext = ""phar.tar.gz"";
 					}
 					break;
 				case PHAR_FILE_COMPRESSED_BZ2:
 					if (phar->is_data) {
 						ext = ""tar.bz2"";
 					} else {
 						ext = ""phar.tar.bz2"";
 					}
 					break;
 				default:
 					if (phar->is_data) {
 						ext = ""tar"";
 					} else {
 						ext = ""phar.tar"";
 					}
 			}
 		} else {
 
 			switch (phar->flags) {
 				case PHAR_FILE_COMPRESSED_GZ:
 					ext = ""phar.gz"";
 					break;
 				case PHAR_FILE_COMPRESSED_BZ2:
 					ext = ""phar.bz2"";
 					break;
 				default:
 					ext = ""phar"";
 			}
 		}
 	} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {
 
 		if (phar->is_data) {
 			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""data phar converted from \""%s\"" has invalid extension %s"", phar->fname, ext);
 		} else {
 			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar converted from \""%s\"" has invalid extension %s"", phar->fname, ext);
 		}
 		return NULL;
 	}
 
 	if (ext[0] == '.') {
 		++ext;
 	}
 
 	oldpath = estrndup(phar->fname, phar->fname_len);
 	oldname = zend_memrchr(phar->fname, '/', phar->fname_len);
 	++oldname;
 	oldname_len = strlen(oldname);
 
 	basename = estrndup(oldname, oldname_len);
         spprintf(&newname, 0, ""%s.%s"", strtok(basename, "".""), ext);
         efree(basename);
  
 
  
         basepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));
         phar->fname_len = spprintf(&newpath, 0, ""%s%s"", basepath, newname);
 	phar->fname = newpath;
 	phar->ext = newpath + phar->fname_len - strlen(ext) - 1;
 	efree(basepath);
 	efree(newname);
 
 	if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {
 		efree(oldpath);
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars, new phar name is in phar.cache_list"", phar->fname);
 		return NULL;
 	}
 
 	if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {
 		if ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {
 			if (!zend_hash_num_elements(&phar->manifest)) {
 				(*pphar)->is_tar = phar->is_tar;
 				(*pphar)->is_zip = phar->is_zip;
 				(*pphar)->is_data = phar->is_data;
 				(*pphar)->flags = phar->flags;
 				(*pphar)->fp = phar->fp;
 				phar->fp = NULL;
 				phar_destroy_phar_data(phar TSRMLS_CC);
 				phar = *pphar;
 				phar->refcount++;
 				newpath = oldpath;
 				goto its_ok;
 			}
 		}
 
 		efree(oldpath);
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars, a phar with that name already exists"", phar->fname);
 		return NULL;
 	}
 its_ok:
 	if (SUCCESS == php_stream_stat_path(newpath, &ssb)) {
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar \""%s\"" exists and must be unlinked prior to conversion"", newpath);
 		efree(oldpath);
 		return NULL;
 	}
 	if (!phar->is_data) {
 		if (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {
 			efree(oldpath);
 			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar \""%s\"" has invalid extension %s"", phar->fname, ext);
 			return NULL;
 		}
 
 		if (phar->alias) {
 			if (phar->is_temporary_alias) {
 				phar->alias = NULL;
 				phar->alias_len = 0;
 			} else {
 				phar->alias = estrndup(newpath, strlen(newpath));
 				phar->alias_len = strlen(newpath);
 				phar->is_temporary_alias = 1;
 				zend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);
 			}
 		}
 
 	} else {
 
 		if (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {
 			efree(oldpath);
 			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""data phar \""%s\"" has invalid extension %s"", phar->fname, ext);
 			return NULL;
 		}
 
 		phar->alias = NULL;
 		phar->alias_len = 0;
 	}
 
 	if ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {
 		efree(oldpath);
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars"", phar->fname);
 		return NULL;
 	}
 
 	phar_flush(phar, 0, 0, 1, &error TSRMLS_CC);
 
 	if (error) {
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""%s"", error);
 		efree(error);
 		efree(oldpath);
 		return NULL;
 	}
 
 	efree(oldpath);
 
 	if (phar->is_data) {
 		ce = phar_ce_data;
 	} else {
 		ce = phar_ce_archive;
 	}
 
 	MAKE_STD_ZVAL(ret);
 
 	if (SUCCESS != object_init_ex(ret, ce)) {
 		zval_dtor(ret);
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate phar object when converting archive \""%s\"""", phar->fname);
 		return NULL;
 	}
 
 	INIT_PZVAL(&arg1);
 	ZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);
 
 	zend_call_method_with_1_params(&ret, ce, &ce->constructor, ""__construct"", NULL, &arg1);
 	return ret;
 }
  
 
 static zval *phar_convert_to_other(phar_archive_data *source, int convert, char *ext, php_uint32 flags TSRMLS_DC)  
 {
 	phar_archive_data *phar;
 	phar_entry_info *entry, newentry;
 	zval *ret;
 
 	 
 	PHAR_G(last_phar) = NULL;
 	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;
 
 	phar = (phar_archive_data *) ecalloc(1, sizeof(phar_archive_data));
 	 
 	phar->flags = flags;
 	phar->is_data = source->is_data;
 
 	switch (convert) {
 		case PHAR_FORMAT_TAR:
 			phar->is_tar = 1;
 			break;
 		case PHAR_FORMAT_ZIP:
 			phar->is_zip = 1;
 			break;
 		default:
 			phar->is_data = 0;
 			break;
 	}
 
 	zend_hash_init(&(phar->manifest), sizeof(phar_entry_info),
 		zend_get_hash_value, destroy_phar_manifest_entry, 0);
 	zend_hash_init(&phar->mounted_dirs, sizeof(char *),
 		zend_get_hash_value, NULL, 0);
 	zend_hash_init(&phar->virtual_dirs, sizeof(char *),
 		zend_get_hash_value, NULL, 0);
 
 	phar->fp = php_stream_fopen_tmpfile();
 	if (phar->fp == NULL) {
 		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""unable to create temporary file"");
 		return NULL;
 	}
 	phar->fname = source->fname;
 	phar->fname_len = source->fname_len;
 	phar->is_temporary_alias = source->is_temporary_alias;
 	phar->alias = source->alias;
 
 	if (source->metadata) {
 		zval *t;
 
 		t = source->metadata;
 		ALLOC_ZVAL(phar->metadata);
 		*phar->metadata = *t;
 		zval_copy_ctor(phar->metadata);
 #if PHP_VERSION_ID < 50300
 		phar->metadata->refcount = 1;
 #else
 		Z_SET_REFCOUNT_P(phar->metadata, 1);
 #endif
 
 		phar->metadata_len = 0;
 	}
 
 	 
 	for (zend_hash_internal_pointer_reset(&source->manifest); SUCCESS == zend_hash_has_more_elements(&source->manifest); zend_hash_move_forward(&source->manifest)) {
 
 		if (FAILURE == zend_hash_get_current_data(&source->manifest, (void **) &entry)) {
 			zend_hash_destroy(&(phar->manifest));
 			php_stream_close(phar->fp);
 			efree(phar);
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""Cannot convert phar archive \""%s\"""", source->fname);
 			return NULL;
 		}
 
 		newentry = *entry;
 
 		if (newentry.link) {
 			newentry.link = estrdup(newentry.link);
 			goto no_copy;
 		}
 
 		if (newentry.tmp) {
 			newentry.tmp = estrdup(newentry.tmp);
 			goto no_copy;
 		}
 
 		newentry.metadata_str.c = 0;
 
 		if (FAILURE == phar_copy_file_contents(&newentry, phar->fp TSRMLS_CC)) {
 			zend_hash_destroy(&(phar->manifest));
 			php_stream_close(phar->fp);
 			efree(phar);
 			 
 			return NULL;
 		}
 no_copy:
 		newentry.filename = estrndup(newentry.filename, newentry.filename_len);
 
 		if (newentry.metadata) {
 			zval *t;
 
 			t = newentry.metadata;
 			ALLOC_ZVAL(newentry.metadata);
 			*newentry.metadata = *t;
 			zval_copy_ctor(newentry.metadata);
 #if PHP_VERSION_ID < 50300
 			newentry.metadata->refcount = 1;
 #else
 			Z_SET_REFCOUNT_P(newentry.metadata, 1);
 #endif
 
 			newentry.metadata_str.c = NULL;
 			newentry.metadata_str.len = 0;
 		}
 
 		newentry.is_zip = phar->is_zip;
 		newentry.is_tar = phar->is_tar;
 
 		if (newentry.is_tar) {
 			newentry.tar_type = (entry->is_dir ? TAR_DIR : TAR_FILE);
 		}
 
 		newentry.is_modified = 1;
 		newentry.phar = phar;
 		newentry.old_flags = newentry.flags & ~PHAR_ENT_COMPRESSION_MASK;  
 		phar_set_inode(&newentry TSRMLS_CC);
 		zend_hash_add(&(phar->manifest), newentry.filename, newentry.filename_len, (void*)&newentry, sizeof(phar_entry_info), NULL);
 		phar_add_virtual_dirs(phar, newentry.filename, newentry.filename_len TSRMLS_CC);
 	}
 
 	if ((ret = phar_rename_archive(phar, ext, 0 TSRMLS_CC))) {
 		return ret;
 	} else {
                 zend_hash_destroy(&(phar->manifest));
                 zend_hash_destroy(&(phar->mounted_dirs));
                 zend_hash_destroy(&(phar->virtual_dirs));
               php_stream_close(phar->fp);
                if (phar->fp) {
                        php_stream_close(phar->fp);
                }
                 efree(phar->fname);
                 efree(phar);
                 return NULL;
  ","[676, 698, 723, 1007, 1240, 1258, 1284, 1394, 1556, 1803, 1804, 1805, 675, 1239, 1257, 1283, 1802]","The phar_convert_to_other function in ext/phar/phar_object.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 does not validate a file pointer before a close operation, which allows remote attackers to cause a denial of service (segmentation fault) or possibly have unspecified other impact via a crafted TAR archive that is mishandled in a Phar::convertToData call."
9144,"static RList *symbols(RBinFile *bf) {
RList *res = r_list_newf ((RListFree)r_bin_symbol_free);
r_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);
RCoreSymCacheElement *element = bf->o->bin_obj;
size_t i;
HtUU *hash = ht_uu_new0 ();
if (!hash) {
return res;
}
bool found = false;
for (i = 0; i < element->hdr->n_lined_symbols; i++) {
RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
if (!sym) {
break;
}
ht_uu_find (hash, sym->paddr, &found);
if (found) {
continue;
}
RBinSymbol *s = bin_symbol_from_symbol (element, sym);
if (s) {
r_list_append (res, s);
ht_uu_insert (hash, sym->paddr, 1);
}
}
if (element->symbols) {
for (i = 0; i < element->hdr->n_symbols; i++) {
RCoreSymCacheElementSymbol *sym = &element->symbols[i];
ht_uu_find (hash, sym->paddr, &found);
if (found) {
continue;
}
RBinSymbol *s = bin_symbol_from_symbol (element, sym);
if (s) {
r_list_append (res, s);
}
}
}
ht_uu_free (hash);
return res;
}","[2, 3, 8, 10, 11, 12, 13, 14, 16, 17, 18, 20, 21, 22, 23]","Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash."
203217," static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                                 const uint8_t *buf, int buf_size)
 {
     ParseContext *pc = &dctx->pc;
     uint64_t state = pc->state64;
     int pic_found = pc->frame_start_found;
     int i = 0;
 
     if (!pic_found) {
         for (i = 0; i < buf_size; i++) {
             state = (state << 8) | buf[i];
             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
                 i++;
                 pic_found = 1;
                 dctx->cur_byte = 0;
                 dctx->remaining = 0;
                 break;
             }
         }
     }
 
     if (pic_found && !dctx->remaining) {
         if (!buf_size)  
             return 0;
         for (; i < buf_size; i++) {
             dctx->cur_byte++;
             state = (state << 8) | buf[i];
 
             if (dctx->cur_byte == 24) {
                 dctx->h = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 26) {
                  dctx->w = (state >> 32) & 0xFFFF;
              } else if (dctx->cur_byte == 42) {
                  int cid = (state >> 32) & 0xFFFFFFFF;
                 int remaining;
  
                  if (cid <= 0)
                      continue;
  
                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
                 remaining = avpriv_dnxhd_get_frame_size(cid);
                 if (remaining <= 0) {
                     remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                     if (remaining <= 0)
                         continue;
                  }
                 dctx->remaining = remaining;
                  if (buf_size - i + 47 >= dctx->remaining) {
                      int remaining = dctx->remaining;
  
                     pc->frame_start_found = 0;
                     pc->state64 = -1;
                     dctx->cur_byte = 0;
                     dctx->remaining = 0;
                     return remaining;
                 } else {
                     dctx->remaining -= buf_size;
                 }
             }
         }
     } else if (pic_found) {
         if (dctx->remaining > buf_size) {
             dctx->remaining -= buf_size;
         } else {
             int remaining = dctx->remaining;
 
             pc->frame_start_found = 0;
             pc->state64 = -1;
             dctx->cur_byte = 0;
             dctx->remaining = 0;
             return remaining;
         }
     }
     pc->frame_start_found = pic_found;
     pc->state64 = state;
     return END_NOT_FOUND;
 }","[35, 45, 46, 47, 48, 49, 51, 40, 41, 42, 43, 44]","The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file."
207870," long ContentEncoding::ParseCompressionEntry(long long start, long long size,
  IMkvReader* pReader,
  ContentCompression* compression) {
   assert(pReader);
   assert(compression);
 
  long long pos = start;
  const long long stop = start + size;
 
  bool valid = false;
 
  while (pos < stop) {
  long long id, size;
  const long status = ParseElementHeader(pReader, pos, stop, id, size);
  if (status < 0)  
  return status;
 
  if (id == 0x254) {
  long long algo = UnserializeUInt(pReader, pos, size);
  if (algo < 0)
  return E_FILE_FORMAT_INVALID;
       compression->algo = algo;
       valid = true;
  } else if (id == 0x255) {
  if (size <= 0)
 
          return E_FILE_FORMAT_INVALID;
  
        const size_t buflen = static_cast<size_t>(size);
      typedef unsigned char* buf_t;
      const buf_t buf = new (std::nothrow) unsigned char[buflen];
       unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);
        if (buf == NULL)
          return -1;
  
  const int read_status =
           pReader->Read(pos, static_cast<long>(buflen), buf);
  if (read_status) {
  delete[] buf;
  return status;
  }
 
       compression->settings = buf;
       compression->settings_len = buflen;
 
      }
  
      pos += size;   
    assert(pos <= stop);
     if (pos > stop)
       return E_FILE_FORMAT_INVALID;
    }
  
  if (!valid)
  return E_FILE_FORMAT_INVALID;
 
  return 0;
 }","[32, 50, 51, 30, 31, 49]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
201618," static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,
 				  void (*get)(struct x86_emulate_ctxt *ctxt,
 					      struct desc_ptr *ptr))
 {
 	struct desc_ptr desc_ptr;
 
 	if (ctxt->mode == X86EMUL_MODE_PROT64)
 		ctxt->op_bytes = 8;
 	get(ctxt, &desc_ptr);
 	if (ctxt->op_bytes == 2) {
 		ctxt->op_bytes = 4;
 		desc_ptr.address &= 0x00ffffff;
  	}
  	 
  	ctxt->dst.type = OP_NONE;
	return segmented_write(ctxt, ctxt->dst.addr.mem,
			       &desc_ptr, 2 + ctxt->op_bytes);
 	return segmented_write_std(ctxt, ctxt->dst.addr.mem,
 				   &desc_ptr, 2 + ctxt->op_bytes);
  }","[18, 19, 16, 17]","arch/x86/kvm/emulate.c in the Linux kernel through 4.9.3 allows local users to obtain sensitive information from kernel memory or cause a denial of service (use-after-free) via a crafted application that leverages instruction emulation for fxrstor, fxsave, sgdt, and sidt."
8643,"TEST(CudnnRNNOpsTest, ForwardLstm_ShapeFn) {
int seq_length = 2;
int batch_size = 3;
int num_units = 4;
int num_layers = 5;
int dir_count = 1;
std::vector<int> input_shape = {seq_length, batch_size, num_units};
std::vector<int> input_h_shape = {num_layers * dir_count, batch_size,
num_units};
std::vector<int> output_shape = {seq_length, batch_size,
num_units * dir_count};
auto shape_to_str = [](const std::vector<int>& v) {
return strings::StrCat(""["", absl::StrJoin(v, "",""), ""]"");
};
string input_shapes_desc = strings::StrCat(
shape_to_str(input_shape), "";"", shape_to_str(input_h_shape), "";"",
shape_to_str(input_h_shape), "";"", ""[?]"");
string output_shapes_desc = ""[d0_0,d0_1,d1_2];in1;in1;?"";

ShapeInferenceTestOp op(""CudnnRNN"");
TF_ASSERT_OK(NodeDefBuilder(""test"", ""CudnnRNN"")
.Input({""input"", 0, DT_FLOAT})
.Input({""input_h"", 0, DT_FLOAT})
.Input({""input_c"", 0, DT_FLOAT})
.Input({""params"", 0, DT_FLOAT})
.Attr(""rnn_mode"", ""lstm"")
.Attr(""input_mode"", ""auto_select"")
.Attr(""direction"", ""unidirectional"")
.Finalize(&op.node_def));
INFER_OK(op, input_shapes_desc, output_shapes_desc);
}",[29],"TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for the `Cudnn*` operations in TensorFlow can be tricked into accessing invalid memory, via a heap buffer overflow. This occurs because the ranks of the `input`, `input_h` and `input_c` parameters are not validated, but code assumes they have certain values. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."
207538," WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
   
 
  dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);
 
     WORD32 i4_err_status = 0;
     UWORD8 *pu1_buf = NULL;
     WORD32 buflen;
     UWORD32 u4_max_ofst, u4_length_of_start_code = 0;
 
     UWORD32 bytes_consumed = 0;
     UWORD32 cur_slice_is_nonref = 0;
     UWORD32 u4_next_is_aud;
     UWORD32 u4_first_start_code_found = 0;
     WORD32 ret = 0,api_ret_value = IV_SUCCESS;
     WORD32 header_data_left = 0,frame_data_left = 0;
     UWORD8 *pu1_bitstrm_buf;
  ivd_video_decode_ip_t *ps_dec_ip;
  ivd_video_decode_op_t *ps_dec_op;
 
     ithread_set_name((void*)""Parse_thread"");
 
     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;
 
  {
         UWORD32 u4_size;
         u4_size = ps_dec_op->u4_size;
         memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
         ps_dec_op->u4_size = u4_size;
  }
 
     ps_dec->pv_dec_out = ps_dec_op;
  if(ps_dec->init_done != 1)
  {
  return IV_FAIL;
  }
 
   
     DATA_SYNC();
 
  if(0 == ps_dec->u1_flushfrm)
  {
  if(ps_dec_ip->pv_stream_buffer == NULL)
  {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
  return IV_FAIL;
  }
  if(ps_dec_ip->u4_num_Bytes <= 0)
  {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
  return IV_FAIL;
 
  }
  }
     ps_dec->u1_pic_decode_done = 0;
 
     ps_dec_op->u4_num_bytes_consumed = 0;
 
     ps_dec->ps_out_buffer = NULL;
 
  if(ps_dec_ip->u4_size
  >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
         ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
 
     ps_dec->u4_fmt_conv_cur_row = 0;
 
     ps_dec->u4_output_present = 0;
     ps_dec->s_disp_op.u4_error_code = 1;
     ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
  if(0 == ps_dec->u4_share_disp_buf
  && ps_dec->i4_decode_header == 0)
  {
         UWORD32 i;
  if(ps_dec->ps_out_buffer->u4_num_bufs == 0)
  {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
  return IV_FAIL;
  }
 
  for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
  {
  if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
  {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
  return IV_FAIL;
  }
 
  if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
  {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |=
                                 IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
  return IV_FAIL;
  }
  }
  }
 
  if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
  {
         ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
  return IV_FAIL;
  }
 
   
     ps_dec->u4_ts = ps_dec_ip->u4_ts;
 
     ps_dec_op->u4_error_code = 0;
     ps_dec_op->e_pic_type = -1;
     ps_dec_op->u4_output_present = 0;
     ps_dec_op->u4_frame_decoded_flag = 0;
 
     ps_dec->i4_frametype = -1;
     ps_dec->i4_content_type = -1;
   
  {
  if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
  {
             ps_dec->u1_top_bottom_decoded = 0;
  }
  }
     ps_dec->u4_slice_start_code_found = 0;
 
   
 
  if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
  && ps_dec->u1_flushfrm == 0)
  {
         UWORD32 i;
 
         WORD32 disp_avail = 0, free_id;
 
   
   
  for(i = 0; i < ps_dec->u1_pic_bufs; i++)
  {
  if(0 == ps_dec->u4_disp_buf_mapping[i]
  || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
  {
                 disp_avail = 1;
  break;
  }
 
  }
 
  if(0 == disp_avail)
  {
   
 
             ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
  return (IV_FAIL);
  }
 
  while(1)
  {
  pic_buffer_t *ps_pic_buf;
             ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);
 
  if(ps_pic_buf == NULL)
  {
                 UWORD32 i, display_queued = 0;
 
   
  for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
  {
  if(0 != ps_dec->u4_disp_buf_mapping[i])
  {
                         display_queued = 1;
  break;
  }
  }
   
 
  if(1 == display_queued)
  {
   
                     ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                     ps_dec_op->u4_error_code |= (1
  << IVD_UNSUPPORTEDPARAM);
  return (IV_FAIL);
  }
  }
  else
  {
   
  if(1 == ps_dec->u4_disp_buf_mapping[free_id])
  {
                     ih264_buf_mgr_set_status(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                     free_id,
                                     BUF_MGR_IO);
  }
  else
  {
   
                     ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                           free_id,
                                           BUF_MGR_IO);
  break;
  }
  }
  }
 
  }
 
  if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)
  {
 
         ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
  if(0 == ps_dec->s_disp_op.u4_error_code)
  {
             ps_dec->u4_fmt_conv_cur_row = 0;
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                   ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
             ps_dec->u4_output_present = 1;
 
  }
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 
         ps_dec_op->u4_new_seq = 0;
 
         ps_dec_op->u4_output_present = ps_dec->u4_output_present;
         ps_dec_op->u4_progressive_frame_flag =
                         ps_dec->s_disp_op.u4_progressive_frame_flag;
         ps_dec_op->e_output_format =
                         ps_dec->s_disp_op.e_output_format;
         ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
         ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
         ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
         ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
 
   
         ps_dec_op->u4_is_ref_flag = -1;
         ps_dec_op->e_pic_type = IV_NA_FRAME;
         ps_dec_op->u4_frame_decoded_flag = 0;
 
  if(0 == ps_dec->s_disp_op.u4_error_code)
  {
  return (IV_SUCCESS);
  }
  else
  return (IV_FAIL);
 
  }
  if(ps_dec->u1_res_changed == 1)
  {
   
         ih264d_init_decoder(ps_dec);
  }
 
     ps_dec->u4_prev_nal_skipped = 0;
 
     ps_dec->u2_cur_mb_addr = 0;
     ps_dec->u2_total_mbs_coded = 0;
     ps_dec->u2_cur_slice_num = 0;
     ps_dec->cur_dec_mb_num = 0;
     ps_dec->cur_recon_mb_num = 0;
     ps_dec->u4_first_slice_in_pic = 2;
     ps_dec->u1_slice_header_done = 0;
     ps_dec->u1_dangling_field = 0;
 
     ps_dec->u4_dec_thread_created = 0;
     ps_dec->u4_bs_deblk_thread_created = 0;
     ps_dec->u4_cur_bs_mb_num = 0;
     ps_dec->u4_start_recon_deblk  = 0;
 
     DEBUG_THREADS_PRINTF("" Starting process call\n"");
 
 
     ps_dec->u4_pic_buf_got = 0;
 
  do
  {
         WORD32 buf_size;
 
         pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
  + ps_dec_op->u4_num_bytes_consumed;
 
         u4_max_ofst = ps_dec_ip->u4_num_Bytes
  - ps_dec_op->u4_num_bytes_consumed;
 
   
  if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
  (ps_dec->i4_header_decoded & 1))
  {
             WORD32 size;
 
  void *pv_buf;
  void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
             size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
             pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
             RETURN_IF((NULL == pv_buf), IV_FAIL);
             ps_dec->pu1_bits_buf_dynamic = pv_buf;
             ps_dec->u4_dynamic_bits_buf_size = size;
  }
 
  if(ps_dec->pu1_bits_buf_dynamic)
  {
             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
             buf_size = ps_dec->u4_dynamic_bits_buf_size;
  }
  else
  {
             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
             buf_size = ps_dec->u4_static_bits_buf_size;
  }
 
         u4_next_is_aud = 0;
 
         buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
  &u4_length_of_start_code,
  &u4_next_is_aud);
 
  if(buflen == -1)
             buflen = 0;
   
         buflen = MIN(buflen, buf_size);
 
         bytes_consumed = buflen + u4_length_of_start_code;
         ps_dec_op->u4_num_bytes_consumed += bytes_consumed;
 
  {
             UWORD8 u1_firstbyte, u1_nal_ref_idc;
 
  if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
  {
                 u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
                 u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
  if(u1_nal_ref_idc == 0)
  {
   
                     cur_slice_is_nonref = 1;
  continue;
  }
  else
  {
  if(1 == cur_slice_is_nonref)
  {
   
                         ps_dec_op->u4_num_bytes_consumed -=
                                         bytes_consumed;
                         ps_dec_op->e_pic_type = IV_B_FRAME;
                         ps_dec_op->u4_error_code =
                                         IVD_DEC_FRM_SKIPPED;
                         ps_dec_op->u4_error_code |= (1
  << IVD_UNSUPPORTEDPARAM);
                         ps_dec_op->u4_frame_decoded_flag = 0;
                         ps_dec_op->u4_size =
  sizeof(ivd_video_decode_op_t);
   
                         ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
                             ih264d_signal_bs_deblk_thread(ps_dec);
  }
 
  return (IV_FAIL);
  }
  }
 
  }
 
  }
 
 
  if(buflen)
  {
             memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                    buflen);
   
  if((buflen + 8) < buf_size)
  {
                 memset(pu1_bitstrm_buf + buflen, 0, 8);
  }
             u4_first_start_code_found = 1;
 
  }
  else
  {
   
 
  if(u4_first_start_code_found == 0)
  {
   
 
                 ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                 ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;
 
  if(ps_dec->u4_pic_buf_got == 0)
  {
 
                     ih264d_fill_output_struct_from_context(ps_dec,
                                                            ps_dec_op);
 
                     ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                     ps_dec_op->u4_frame_decoded_flag = 0;
 
  return (IV_FAIL);
  }
  else
  {
                     ps_dec->u1_pic_decode_done = 1;
  continue;
  }
  }
  else
  {
   
                 frame_data_left = 0;
  continue;
  }
 
  }
 
         ps_dec->u4_return_to_app = 0;
         ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                               pu1_bitstrm_buf, buflen);
  if(ret != OK)
  {
             UWORD32 error =  ih264d_map_error(ret);
             ps_dec_op->u4_error_code = error | ret;
             api_ret_value = IV_FAIL;
 
 
              if((ret == IVD_RES_CHANGED)
                              || (ret == IVD_MEM_ALLOC_FAILED)
                              || (ret == ERROR_UNAVAIL_PICBUF_T)
                            || (ret == ERROR_UNAVAIL_MVBUF_T))
                             || (ret == ERROR_UNAVAIL_MVBUF_T)
                             || (ret == ERROR_INV_SPS_PPS_T))
              {
                 ps_dec->u4_slice_start_code_found = 0;
                  break;
              }
  
  if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
  {
                 ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                 api_ret_value = IV_FAIL;
  break;
  }
 
  if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
  {
                 api_ret_value = IV_FAIL;
  break;
  }
 
  }
 
  if(ps_dec->u4_return_to_app)
  {
   
             ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
             ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
             ps_dec_op->u4_frame_decoded_flag = 0;
             ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
   
             ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
                 ih264d_signal_bs_deblk_thread(ps_dec);
  }
  return (IV_FAIL);
 
  }
 
 
 
         header_data_left = ((ps_dec->i4_decode_header == 1)
  && (ps_dec->i4_header_decoded != 3)
  && (ps_dec_op->u4_num_bytes_consumed
  < ps_dec_ip->u4_num_Bytes));
         frame_data_left = (((ps_dec->i4_decode_header == 0)
  && ((ps_dec->u1_pic_decode_done == 0)
  || (u4_next_is_aud == 1)))
  && (ps_dec_op->u4_num_bytes_consumed
  < ps_dec_ip->u4_num_Bytes));
  }
  while(( header_data_left == 1)||(frame_data_left == 1));
 
  if((ps_dec->u4_slice_start_code_found == 1)
  && (ret != IVD_MEM_ALLOC_FAILED)
  && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
         WORD32 num_mb_skipped;
         WORD32 prev_slice_err;
  pocstruct_t temp_poc;
         WORD32 ret1;
 
         num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  - ps_dec->u2_total_mbs_coded;
 
  if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
             prev_slice_err = 1;
  else
             prev_slice_err = 2;
 
         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
  &temp_poc, prev_slice_err);
 
  if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))
  {
  return IV_FAIL;
  }
  }
 
 
      if((ret == IVD_RES_CHANGED)
                      || (ret == IVD_MEM_ALLOC_FAILED)
                      || (ret == ERROR_UNAVAIL_PICBUF_T)
                    || (ret == ERROR_UNAVAIL_MVBUF_T))
                     || (ret == ERROR_UNAVAIL_MVBUF_T)
                     || (ret == ERROR_INV_SPS_PPS_T))
      {
  
           
         ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
             ih264d_signal_bs_deblk_thread(ps_dec);
  }
   
  if(ret == IVD_RES_CHANGED)
  {
             ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
  }
  return IV_FAIL;
  }
 
 
  if(ps_dec->u1_separate_parse)
  {
   
  if(ps_dec->u4_num_cores == 2)
  {
 
   
  if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
  {
                 UWORD32 u4_num_mbs,u4_max_addr;
  tfr_ctxt_t s_tfr_ctxt;
  tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
  pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;
 
   
                 u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                 ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;
 
 
                 ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                            ps_dec->u2_frm_wd_in_mbs, 0);
 
 
                 u4_num_mbs = u4_max_addr
  - ps_dec->u4_cur_deblk_mb_num + 1;
 
                 DEBUG_PERF_PRINTF(""mbs left for deblocking= %d \n"",u4_num_mbs);
 
  if(u4_num_mbs != 0)
                     ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                    ps_tfr_cxt,1);
 
                 ps_dec->u4_start_recon_deblk  = 0;
 
  }
 
  }
 
   
         ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
             ih264d_signal_bs_deblk_thread(ps_dec);
  }
  }
 
 
     DATA_SYNC();
 
 
  if((ps_dec_op->u4_error_code & 0xff)
  != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
  {
         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
  }
 
  if(ps_dec->i4_header_decoded != 3)
  {
         ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
 
  }
 
  if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
  {
         ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
 
  }
  if(ps_dec->u4_prev_nal_skipped)
  {
   
         ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
         ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
         ps_dec_op->u4_frame_decoded_flag = 0;
         ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
   
  if(ps_dec->u4_num_cores == 3)
  {
             ih264d_signal_bs_deblk_thread(ps_dec);
  }
  return (IV_FAIL);
 
  }
 
  if((ps_dec->u4_slice_start_code_found == 1)
  && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
  {
   
 
  if(ps_dec->ps_cur_slice->u1_field_pic_flag)
  {
  if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
  {
                 ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
  }
  else
  {
                 ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
  }
  }
 
   
  if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
  {
   
             ret = ih264d_deblock_display(ps_dec);
  if(ret != 0)
  {
  return IV_FAIL;
  }
  }
 
 
   
  if(ps_dec->i4_header_decoded == 3)
  {
             ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
  }
 
   
  if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
  {
             ps_dec->i4_frametype = IV_IDR_FRAME;
  }
  else if(ps_dec->i4_pic_type == B_SLICE)
  {
             ps_dec->i4_frametype = IV_B_FRAME;
  }
  else if(ps_dec->i4_pic_type == P_SLICE)
  {
             ps_dec->i4_frametype = IV_P_FRAME;
  }
  else if(ps_dec->i4_pic_type == I_SLICE)
  {
             ps_dec->i4_frametype = IV_I_FRAME;
  }
  else
  {
             H264_DEC_DEBUG_PRINT(""Shouldn't come here\n"");
  }
 
         ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
  - ps_dec->ps_cur_slice->u1_field_pic_flag;
 
  }
 
   
  if(ps_dec->u4_num_cores == 3)
  {
         ih264d_signal_bs_deblk_thread(ps_dec);
  }
 
 
  {
   
 
  if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
  && ps_dec->u1_init_dec_flag)
  {
 
             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
  if(0 == ps_dec->s_disp_op.u4_error_code)
  {
                 ps_dec->u4_fmt_conv_cur_row = 0;
                 ps_dec->u4_output_present = 1;
  }
  }
 
         ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);
 
   
  if(ps_dec->u4_output_present &&
  (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
  {
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
  - ps_dec->u4_fmt_conv_cur_row;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                   ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
  }
 
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
  }
 
  if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
  {
         ps_dec_op->u4_progressive_frame_flag = 1;
  if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
  {
  if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
  && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                 ps_dec_op->u4_progressive_frame_flag = 0;
 
  }
  }
 
   
     DATA_SYNC();
 
     H264_DEC_DEBUG_PRINT(""The num bytes consumed: %d\n"",
                          ps_dec_op->u4_num_bytes_consumed);
  return api_ret_value;
 }","[444, 445, 447, 530, 531, 443, 529]","decoder/ih264d_api.c in mediaserver in Android 6.x before 2016-08-01 mishandles invalid PPS and SPS NAL units, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28835995."
205655," WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(
     JNIEnv* env,
     jobject java_website_settings_pop,
     content::WebContents* web_contents) {
   content::NavigationEntry* nav_entry =
       web_contents->GetController().GetVisibleEntry();
   if (nav_entry == NULL)
     return;
 
   url_ = nav_entry->GetURL();
 
   popup_jobject_.Reset(env, java_website_settings_pop);
 
   presenter_.reset(new WebsiteSettings(
        this,
        Profile::FromBrowserContext(web_contents->GetBrowserContext()),
        TabSpecificContentSettings::FromWebContents(web_contents),
      InfoBarService::FromWebContents(web_contents),
       web_contents,
        nav_entry->GetURL(),
        nav_entry->GetSSL(),
        content::CertStore::GetInstance()));
 }","[19, 18]","Use-after-free vulnerability in the Infobars implementation in Google Chrome before 47.0.2526.73 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted web site, related to browser/ui/views/website_settings/website_settings_popup_view.cc."
198117," int vrend_create_shader(struct vrend_context *ctx,
                         uint32_t handle,
                         const struct pipe_stream_output_info *so_info,
                         const char *shd_text, uint32_t offlen, uint32_t num_tokens,
                         uint32_t type, uint32_t pkt_length)
 {
    struct vrend_shader_selector *sel = NULL;
    int ret_handle;
    bool new_shader = true, long_shader = false;
    bool finished = false;
    int ret;
 
    if (type > PIPE_SHADER_GEOMETRY)
       return EINVAL;
 
    if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)
       new_shader = false;
    else if (((offlen + 3) / 4) > pkt_length)
       long_shader = true;
 
     
    if (ctx->sub->long_shader_in_progress_handle[type]) {
       if (new_shader == true)
          return EINVAL;
       if (handle != ctx->sub->long_shader_in_progress_handle[type])
          return EINVAL;
    }
 
    if (new_shader) {
      sel = vrend_create_shader_state(ctx, so_info, type);
      if (sel == NULL)
        return ENOMEM;
 
      if (long_shader) {
         sel->buf_len = ((offlen + 3) / 4) * 4;  
         sel->tmp_buf = malloc(sel->buf_len);
         if (!sel->tmp_buf) {
            ret = ENOMEM;
            goto error;
         }
         memcpy(sel->tmp_buf, shd_text, pkt_length * 4);
         sel->buf_offset = pkt_length * 4;
         ctx->sub->long_shader_in_progress_handle[type] = handle;
      } else
         finished = true;
    } else {
       sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);
       if (!sel) {
          fprintf(stderr, ""got continuation without original shader %d\n"", handle);
          ret = EINVAL;
          goto error;
       }
 
       offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;
       if (offlen != sel->buf_offset) {
          fprintf(stderr, ""Got mismatched shader continuation %d vs %d\n"",
                  offlen, sel->buf_offset);
           ret = EINVAL;
           goto error;
        }
 
        
       if (pkt_length * 4 < pkt_length ||
           pkt_length * 4 + sel->buf_offset < pkt_length * 4 ||
           pkt_length * 4 + sel->buf_offset < sel->buf_offset) {
             ret = EINVAL;
             goto error;
           }
 
        if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {
           fprintf(stderr, ""Got too large shader continuation %d vs %d\n"",
                   pkt_length * 4 + sel->buf_offset, sel->buf_len);
          shd_text = sel->tmp_buf;
       }
    }
 
    if (finished) {
       struct tgsi_token *tokens;
 
       tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));
       if (!tokens) {
          ret = ENOMEM;
          goto error;
       }
 
       if (vrend_dump_shaders)
          fprintf(stderr,""shader\n%s\n"", shd_text);
       if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {
          free(tokens);
          ret = EINVAL;
          goto error;
       }
 
       if (vrend_finish_shader(ctx, sel, tokens)) {
          free(tokens);
          ret = EINVAL;
          goto error;
       } else {
          free(sel->tmp_buf);
          sel->tmp_buf = NULL;
       }
       free(tokens);
       ctx->sub->long_shader_in_progress_handle[type] = 0;
    }
 
    if (new_shader) {
       ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);
       if (ret_handle == 0) {
          ret = ENOMEM;
          goto error;
       }
    }
 
    return 0;
 
 error:
    if (new_shader)
       vrend_destroy_shader_selector(sel);
    else
       vrend_renderer_object_destroy(ctx, handle);
 
    return ret;
 }","[61, 62, 63, 64, 65, 66, 67, 68, 69]","Integer overflow in the vrend_create_shader function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (process crash) via crafted pkt_length and offlen values, which trigger an out-of-bounds access."
199748," static noinline void key_gc_unused_keys(struct list_head *keys)
 {
 	while (!list_empty(keys)) {
 		struct key *key =
 			list_entry(keys->next, struct key, graveyard_link);
 		list_del(&key->graveyard_link);
 
  		kdebug(""- %u"", key->serial);
  		key_check(key);
  
 		 
		if (key->type->destroy)
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
 		    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&
 		    key->type->destroy)
  			key->type->destroy(key);
  
  		security_key_free(key);
 
 		 
 		if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {
 			spin_lock(&key->user->lock);
 			key->user->qnkeys--;
 			key->user->qnbytes -= key->quotalen;
 			spin_unlock(&key->user->lock);
 		}
 
 		atomic_dec(&key->user->nkeys);
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
 		key_user_put(key->user);
 
 		kfree(key->description);
 
 #ifdef KEY_DEBUGGING
 		key->magic = KEY_DEBUG_MAGIC_X;
 #endif
 		kmem_cache_free(key_jar, key);
 	}
 }","[13, 14, 15, 12]",The key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 4.2.6 allows local users to cause a denial of service (OOPS) via crafted keyctl commands.
201006," icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp, const u_char *ep)
 {
 	const struct icmp6_nodeinfo *ni6;
 	const struct icmp6_hdr *dp;
 	const u_char *cp;
 	size_t siz, i;
 	int needcomma;
 
 	if (ep < bp)
 		return;
 	dp = (const struct icmp6_hdr *)bp;
 	ni6 = (const struct icmp6_nodeinfo *)bp;
 	siz = ep - bp;
 
 	switch (ni6->ni_type) {
 	case ICMP6_NI_QUERY:
 		if (siz == sizeof(*dp) + 4) {
 			 
 			ND_PRINT((ndo,"" who-are-you request""));
 			break;
 		}
 		ND_PRINT((ndo,"" node information query""));
 
 		ND_TCHECK2(*dp, sizeof(*ni6));
 		ni6 = (const struct icmp6_nodeinfo *)dp;
 		ND_PRINT((ndo,"" (""));	 
 		switch (EXTRACT_16BITS(&ni6->ni_qtype)) {
 		case NI_QTYPE_NOOP:
 			ND_PRINT((ndo,""noop""));
 			break;
 		case NI_QTYPE_SUPTYPES:
 			ND_PRINT((ndo,""supported qtypes""));
 			i = EXTRACT_16BITS(&ni6->ni_flags);
 			if (i)
 				ND_PRINT((ndo,"" [%s]"", (i & 0x01) ? ""C"" : """"));
 			break;
 		case NI_QTYPE_FQDN:
 			ND_PRINT((ndo,""DNS name""));
 			break;
 		case NI_QTYPE_NODEADDR:
 			ND_PRINT((ndo,""node addresses""));
 			i = ni6->ni_flags;
 			if (!i)
 				break;
 			 
 			ND_PRINT((ndo,"" [%s%s%s%s%s%s]"",
 			    (i & NI_NODEADDR_FLAG_ANYCAST) ? ""a"" : """",
 			    (i & NI_NODEADDR_FLAG_GLOBAL) ? ""G"" : """",
 			    (i & NI_NODEADDR_FLAG_SITELOCAL) ? ""S"" : """",
 			    (i & NI_NODEADDR_FLAG_LINKLOCAL) ? ""L"" : """",
 			    (i & NI_NODEADDR_FLAG_COMPAT) ? ""C"" : """",
 			    (i & NI_NODEADDR_FLAG_ALL) ? ""A"" : """"));
 			break;
 		default:
 			ND_PRINT((ndo,""unknown""));
 			break;
 		}
 
 		if (ni6->ni_qtype == NI_QTYPE_NOOP ||
 		    ni6->ni_qtype == NI_QTYPE_SUPTYPES) {
 			if (siz != sizeof(*ni6))
 				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", invalid len""));
 			 
 			ND_PRINT((ndo,"")""));
 			break;
 		}
 
 
 		 
 		if (siz == sizeof(*ni6)) {
 			ND_PRINT((ndo,"", 03 draft""));
 			 
 			ND_PRINT((ndo,"")""));
 			break;
 		}
 
 		switch (ni6->ni_code) {
 		case ICMP6_NI_SUBJ_IPV6:
 			if (!ND_TTEST2(*dp,
 			    sizeof(*ni6) + sizeof(struct in6_addr)))
 				break;
 			if (siz != sizeof(*ni6) + sizeof(struct in6_addr)) {
 				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", invalid subject len""));
 				break;
 			}
 			ND_PRINT((ndo,"", subject=%s"",
                                   ip6addr_string(ndo, ni6 + 1)));
 			break;
 		case ICMP6_NI_SUBJ_FQDN:
 			ND_PRINT((ndo,"", subject=DNS name""));
 			cp = (const u_char *)(ni6 + 1);
 			if (cp[0] == ep - cp - 1) {
 				 
 				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", 03 draft""));
 				cp++;
 				ND_PRINT((ndo,"", \""""));
 				while (cp < ep) {
 					safeputchar(ndo, *cp);
 					cp++;
 				}
 				ND_PRINT((ndo,""\""""));
 			} else
 				dnsname_print(ndo, cp, ep);
 			break;
 		case ICMP6_NI_SUBJ_IPV4:
 			if (!ND_TTEST2(*dp, sizeof(*ni6) + sizeof(struct in_addr)))
 				break;
 			if (siz != sizeof(*ni6) + sizeof(struct in_addr)) {
 				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", invalid subject len""));
 				break;
 			}
 			ND_PRINT((ndo,"", subject=%s"",
                                   ipaddr_string(ndo, ni6 + 1)));
 			break;
 		default:
 			ND_PRINT((ndo,"", unknown subject""));
 			break;
 		}
 
 		 
 		ND_PRINT((ndo,"")""));
 		break;
 
 	case ICMP6_NI_REPLY:
 		if (icmp6len > siz) {
 			ND_PRINT((ndo,""[|icmp6: node information reply]""));
 			break;
 		}
  
  		needcomma = 0;
  
 		ND_TCHECK2(*dp, sizeof(*ni6));
  		ni6 = (const struct icmp6_nodeinfo *)dp;
  		ND_PRINT((ndo,"" node information reply""));
  		ND_PRINT((ndo,"" (""));	 
 		switch (ni6->ni_code) {
 		case ICMP6_NI_SUCCESS:
 			if (ndo->ndo_vflag) {
 				ND_PRINT((ndo,""success""));
 				needcomma++;
 			}
 			break;
 		case ICMP6_NI_REFUSED:
 			ND_PRINT((ndo,""refused""));
 			needcomma++;
 			if (siz != sizeof(*ni6))
 				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", invalid length""));
 			break;
 		case ICMP6_NI_UNKNOWN:
 			ND_PRINT((ndo,""unknown""));
 			needcomma++;
 			if (siz != sizeof(*ni6))
 				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", invalid length""));
 			break;
 		}
 
 		if (ni6->ni_code != ICMP6_NI_SUCCESS) {
 			 
 			ND_PRINT((ndo,"")""));
 			break;
 		}
 
 		switch (EXTRACT_16BITS(&ni6->ni_qtype)) {
 		case NI_QTYPE_NOOP:
 			if (needcomma)
 				ND_PRINT((ndo,"", ""));
 			ND_PRINT((ndo,""noop""));
 			if (siz != sizeof(*ni6))
 				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", invalid length""));
 			break;
 		case NI_QTYPE_SUPTYPES:
 			if (needcomma)
 				ND_PRINT((ndo,"", ""));
 			ND_PRINT((ndo,""supported qtypes""));
 			i = EXTRACT_16BITS(&ni6->ni_flags);
 			if (i)
 				ND_PRINT((ndo,"" [%s]"", (i & 0x01) ? ""C"" : """"));
 			break;
 		case NI_QTYPE_FQDN:
 			if (needcomma)
  				ND_PRINT((ndo,"", ""));
  			ND_PRINT((ndo,""DNS name""));
  			cp = (const u_char *)(ni6 + 1) + 4;
 			ND_TCHECK(cp[0]);
  			if (cp[0] == ep - cp - 1) {
  				 
  				if (ndo->ndo_vflag)
 					ND_PRINT((ndo,"", 03 draft""));
 				cp++;
 				ND_PRINT((ndo,"", \""""));
 				while (cp < ep) {
 					safeputchar(ndo, *cp);
 					cp++;
 				}
 				ND_PRINT((ndo,""\""""));
 			} else
 				dnsname_print(ndo, cp, ep);
 			if ((EXTRACT_16BITS(&ni6->ni_flags) & 0x01) != 0)
 				ND_PRINT((ndo,"" [TTL=%u]"", EXTRACT_32BITS(ni6 + 1)));
 			break;
 		case NI_QTYPE_NODEADDR:
 			if (needcomma)
 				ND_PRINT((ndo,"", ""));
 			ND_PRINT((ndo,""node addresses""));
 			i = sizeof(*ni6);
 			while (i < siz) {
 				if (i + sizeof(struct in6_addr) + sizeof(int32_t) > siz)
 					break;
 				ND_PRINT((ndo,"" %s"", ip6addr_string(ndo, bp + i)));
 				i += sizeof(struct in6_addr);
 				ND_PRINT((ndo,""(%d)"", (int32_t)EXTRACT_32BITS(bp + i)));
 				i += sizeof(int32_t);
 			}
 			i = ni6->ni_flags;
 			if (!i)
 				break;
 			ND_PRINT((ndo,"" [%s%s%s%s%s%s%s]"",
                                   (i & NI_NODEADDR_FLAG_ANYCAST) ? ""a"" : """",
                                   (i & NI_NODEADDR_FLAG_GLOBAL) ? ""G"" : """",
                                   (i & NI_NODEADDR_FLAG_SITELOCAL) ? ""S"" : """",
                                   (i & NI_NODEADDR_FLAG_LINKLOCAL) ? ""L"" : """",
                                   (i & NI_NODEADDR_FLAG_COMPAT) ? ""C"" : """",
                                   (i & NI_NODEADDR_FLAG_ALL) ? ""A"" : """",
                                   (i & NI_NODEADDR_FLAG_TRUNCATE) ? ""T"" : """"));
 			break;
 		default:
 			if (needcomma)
 				ND_PRINT((ndo,"", ""));
 			ND_PRINT((ndo,""unknown""));
 			break;
 		}
 
 		 
 		ND_PRINT((ndo,"")""));
 		break;
 	}
 	return;
 
 trunc:
 	ND_PRINT((ndo, ""[|icmp6]""));
 }","[136, 191]",The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_nodeinfo_print().
6157,"PackLinuxElf64::elf_find_dynamic(unsigned int key) const
{
Elf64_Dyn const *dynp= dynseg;
if (dynp)
for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
&& Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));
if (t) {
return &((unsigned char const *)file_image)[(size_t)t];
}
break;
}
return 0;
}","[8, 9]",p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.
198447," mysqlnd_switch_to_ssl_if_needed(
 			MYSQLND_CONN_DATA * conn,
 			const MYSQLND_PACKET_GREET * const greet_packet,
 			const MYSQLND_OPTIONS * const options,
 			unsigned long mysql_flags
 			TSRMLS_DC
 		)
 {
 	enum_func_status ret = FAIL;
 	const MYSQLND_CHARSET * charset;
 	MYSQLND_PACKET_AUTH * auth_packet;
 	DBG_ENTER(""mysqlnd_switch_to_ssl_if_needed"");
 
 	auth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);
 	if (!auth_packet) {
 		SET_OOM_ERROR(*conn->error_info);
 		goto end;
 	}
 	auth_packet->client_flags = mysql_flags;
 	auth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;
 
 	if (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {
 		auth_packet->charset_no	= charset->nr;
 	} else {
 #if MYSQLND_UNICODE
 		auth_packet->charset_no	= 200; 
 #else
 		auth_packet->charset_no	= greet_packet->charset_no;
 #endif
         }
  
  #ifdef MYSQLND_SSL_SUPPORTED
       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {
               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
               DBG_INF(""Switching to SSL"");
               if (!PACKET_WRITE(auth_packet, conn)) {
                       CONN_SET_STATE(conn, CONN_QUIT_SENT);
                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
                       goto end;
               }
        if (mysql_flags & CLIENT_SSL) {
                zend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;
                if (server_has_ssl == FALSE) {
                        goto close_conn;
                } else {
                        zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;
                        DBG_INF(""Switching to SSL"");
                        if (!PACKET_WRITE(auth_packet, conn)) {
                                goto close_conn;
                        }
  
               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
                        conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);
  
               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                       goto end;
                        if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {
                                goto end;
                        }
                 }
         }
 #else
        auth_packet->client_flags &= ~CLIENT_SSL;
        if (!PACKET_WRITE(auth_packet, conn)) {
                goto close_conn;
        }
  #endif
         ret = PASS;
  end:
         PACKET_FREE(auth_packet);
         DBG_RETURN(ret);
 
 close_conn:
        CONN_SET_STATE(conn, CONN_QUIT_SENT);
        conn->m->send_close(conn TSRMLS_CC);
        SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);
        PACKET_FREE(auth_packet);
        DBG_RETURN(ret);
  }","[41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 53, 57, 58, 59, 62, 63, 64, 65, 66, 72, 73, 74, 75, 76, 77, 78, 33, 34, 35, 36, 37, 38, 39, 40, 52, 55, 56]","ext/mysqlnd/mysqlnd.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 uses a client SSL option to mean that SSL is optional, which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152."
202915," bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer,
 				struct stream *s, struct attr *attr,
 				struct bpacket_attr_vec_arr *vecarr,
 				struct prefix *p, afi_t afi, safi_t safi,
 				struct peer *from, struct prefix_rd *prd,
 				mpls_label_t *label, uint32_t num_labels,
 				int addpath_encode, uint32_t addpath_tx_id)
 {
 	size_t cp;
 	size_t aspath_sizep;
 	struct aspath *aspath;
 	int send_as4_path = 0;
 	int send_as4_aggregator = 0;
 	int use32bit = (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) ? 1 : 0;
 
 	if (!bgp)
 		bgp = peer->bgp;
 
 	 
 	cp = stream_get_endp(s);
 
 	if (p
 	    && !((afi == AFI_IP && safi == SAFI_UNICAST)
 		 && !peer_cap_enhe(peer, afi, safi))) {
 		size_t mpattrlen_pos = 0;
 
 		mpattrlen_pos = bgp_packet_mpattr_start(s, peer, afi, safi,
 							vecarr, attr);
 		bgp_packet_mpattr_prefix(s, afi, safi, p, prd, label,
 					 num_labels, addpath_encode,
 					 addpath_tx_id, attr);
 		bgp_packet_mpattr_end(s, mpattrlen_pos);
 	}
 
 	 
 	stream_putc(s, BGP_ATTR_FLAG_TRANS);
 	stream_putc(s, BGP_ATTR_ORIGIN);
 	stream_putc(s, 1);
 	stream_putc(s, attr->origin);
 
 	 
 
 	 
 	if (peer->sort == BGP_PEER_EBGP
 	    && (!CHECK_FLAG(peer->af_flags[afi][safi],
 			    PEER_FLAG_AS_PATH_UNCHANGED)
 		|| attr->aspath->segments == NULL)
 	    && (!CHECK_FLAG(peer->af_flags[afi][safi],
 			    PEER_FLAG_RSERVER_CLIENT))) {
 		aspath = aspath_dup(attr->aspath);
 
 		 
 		aspath = aspath_delete_confed_seq(aspath);
 
 		if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {
 			 
 			aspath = aspath_add_seq(aspath, bgp->confed_id);
 		} else {
 			if (peer->change_local_as) {
 				 
 				if (!CHECK_FLAG(
 					    peer->flags,
 					    PEER_FLAG_LOCAL_AS_REPLACE_AS)) {
 					aspath = aspath_add_seq(aspath,
 								peer->local_as);
 				}
 				aspath = aspath_add_seq(aspath,
 							peer->change_local_as);
 			} else {
 				aspath = aspath_add_seq(aspath, peer->local_as);
 			}
 		}
 	} else if (peer->sort == BGP_PEER_CONFED) {
 		 
 		aspath = aspath_dup(attr->aspath);
 		aspath = aspath_add_confed_seq(aspath, peer->local_as);
 	} else
 		aspath = attr->aspath;
 
 	 
 
 	stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);
 	stream_putc(s, BGP_ATTR_AS_PATH);
 	aspath_sizep = stream_get_endp(s);
 	stream_putw(s, 0);
 	stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, use32bit));
 
 	 
 	if (!use32bit && aspath_has_as4(aspath))
 		send_as4_path =
 			1;  
 
 	 
 	if (afi == AFI_IP && safi == SAFI_UNICAST
 	    && !peer_cap_enhe(peer, afi, safi)) {
 		if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) {
 			stream_putc(s, BGP_ATTR_FLAG_TRANS);
 			stream_putc(s, BGP_ATTR_NEXT_HOP);
 			bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,
 						     attr);
 			stream_putc(s, 4);
 			stream_put_ipv4(s, attr->nexthop.s_addr);
 		} else if (peer_cap_enhe(from, afi, safi)) {
 			 
 			stream_putc(s, BGP_ATTR_FLAG_TRANS);
 			stream_putc(s, BGP_ATTR_NEXT_HOP);
 			bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,
 						     NULL);
 			stream_putc(s, 4);
 			stream_put_ipv4(s, 0);
 		}
 	}
 
 	 
 	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)
 	    || bgp->maxmed_active) {
 		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
 		stream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);
 		stream_putc(s, 4);
 		stream_putl(s, (bgp->maxmed_active ? bgp->maxmed_value
 						   : attr->med));
 	}
 
 	 
 	if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) {
 		stream_putc(s, BGP_ATTR_FLAG_TRANS);
 		stream_putc(s, BGP_ATTR_LOCAL_PREF);
 		stream_putc(s, 4);
 		stream_putl(s, attr->local_pref);
 	}
 
 	 
 	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {
 		stream_putc(s, BGP_ATTR_FLAG_TRANS);
 		stream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);
 		stream_putc(s, 0);
 	}
 
 	 
 	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {
 		 
 		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
 		stream_putc(s, BGP_ATTR_AGGREGATOR);
 
 		if (use32bit) {
 			 
 			stream_putc(s, 8);
 			stream_putl(s, attr->aggregator_as);
 		} else {
 			 
 			stream_putc(s, 6);
 
 			 
 			if (attr->aggregator_as > 65535) {
 				stream_putw(s, BGP_AS_TRANS);
 
 				 
 				send_as4_aggregator = 1;
 			} else
 				stream_putw(s, (uint16_t)attr->aggregator_as);
 		}
 		stream_put_ipv4(s, attr->aggregator_addr.s_addr);
 	}
 
 	 
 	if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)
 	    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))) {
 		if (attr->community->size * 4 > 255) {
 			stream_putc(s,
 				    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS
 					    | BGP_ATTR_FLAG_EXTLEN);
 			stream_putc(s, BGP_ATTR_COMMUNITIES);
 			stream_putw(s, attr->community->size * 4);
 		} else {
 			stream_putc(s,
 				    BGP_ATTR_FLAG_OPTIONAL
 					    | BGP_ATTR_FLAG_TRANS);
 			stream_putc(s, BGP_ATTR_COMMUNITIES);
 			stream_putc(s, attr->community->size * 4);
 		}
 		stream_put(s, attr->community->val, attr->community->size * 4);
 	}
 
 	 
 	if (CHECK_FLAG(peer->af_flags[afi][safi],
 		       PEER_FLAG_SEND_LARGE_COMMUNITY)
 	    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES))) {
 		if (lcom_length(attr->lcommunity) > 255) {
 			stream_putc(s,
 				    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS
 					    | BGP_ATTR_FLAG_EXTLEN);
 			stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);
 			stream_putw(s, lcom_length(attr->lcommunity));
 		} else {
 			stream_putc(s,
 				    BGP_ATTR_FLAG_OPTIONAL
 					    | BGP_ATTR_FLAG_TRANS);
 			stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);
 			stream_putc(s, lcom_length(attr->lcommunity));
 		}
 		stream_put(s, attr->lcommunity->val,
 			   lcom_length(attr->lcommunity));
 	}
 
 	 
 	if (peer->sort == BGP_PEER_IBGP && from
 	    && from->sort == BGP_PEER_IBGP) {
 		 
 		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
 		stream_putc(s, BGP_ATTR_ORIGINATOR_ID);
 		stream_putc(s, 4);
 
 		if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
 			stream_put_in_addr(s, &attr->originator_id);
 		else
 			stream_put_in_addr(s, &from->remote_id);
 
 		 
 		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
 		stream_putc(s, BGP_ATTR_CLUSTER_LIST);
 
 		if (attr->cluster) {
 			stream_putc(s, attr->cluster->length + 4);
 			 
 			if (bgp->config & BGP_CONFIG_CLUSTER_ID)
 				stream_put_in_addr(s, &bgp->cluster_id);
 			else
 				stream_put_in_addr(s, &bgp->router_id);
 			stream_put(s, attr->cluster->list,
 				   attr->cluster->length);
 		} else {
 			stream_putc(s, 4);
 			 
 			if (bgp->config & BGP_CONFIG_CLUSTER_ID)
 				stream_put_in_addr(s, &bgp->cluster_id);
 			else
 				stream_put_in_addr(s, &bgp->router_id);
 		}
 	}
 
 	 
 	if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)
 	    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))) {
 		if (peer->sort == BGP_PEER_IBGP
 		    || peer->sort == BGP_PEER_CONFED) {
 			if (attr->ecommunity->size * 8 > 255) {
 				stream_putc(s,
 					    BGP_ATTR_FLAG_OPTIONAL
 						    | BGP_ATTR_FLAG_TRANS
 						    | BGP_ATTR_FLAG_EXTLEN);
 				stream_putc(s, BGP_ATTR_EXT_COMMUNITIES);
 				stream_putw(s, attr->ecommunity->size * 8);
 			} else {
 				stream_putc(s,
 					    BGP_ATTR_FLAG_OPTIONAL
 						    | BGP_ATTR_FLAG_TRANS);
 				stream_putc(s, BGP_ATTR_EXT_COMMUNITIES);
 				stream_putc(s, attr->ecommunity->size * 8);
 			}
 			stream_put(s, attr->ecommunity->val,
 				   attr->ecommunity->size * 8);
 		} else {
 			uint8_t *pnt;
 			int tbit;
 			int ecom_tr_size = 0;
 			int i;
 
 			for (i = 0; i < attr->ecommunity->size; i++) {
 				pnt = attr->ecommunity->val + (i * 8);
 				tbit = *pnt;
 
 				if (CHECK_FLAG(tbit,
 					       ECOMMUNITY_FLAG_NON_TRANSITIVE))
 					continue;
 
 				ecom_tr_size++;
 			}
 
 			if (ecom_tr_size) {
 				if (ecom_tr_size * 8 > 255) {
 					stream_putc(
 						s,
 						BGP_ATTR_FLAG_OPTIONAL
 							| BGP_ATTR_FLAG_TRANS
 							| BGP_ATTR_FLAG_EXTLEN);
 					stream_putc(s,
 						    BGP_ATTR_EXT_COMMUNITIES);
 					stream_putw(s, ecom_tr_size * 8);
 				} else {
 					stream_putc(
 						s,
 						BGP_ATTR_FLAG_OPTIONAL
 							| BGP_ATTR_FLAG_TRANS);
 					stream_putc(s,
 						    BGP_ATTR_EXT_COMMUNITIES);
 					stream_putc(s, ecom_tr_size * 8);
 				}
 
 				for (i = 0; i < attr->ecommunity->size; i++) {
 					pnt = attr->ecommunity->val + (i * 8);
 					tbit = *pnt;
 
 					if (CHECK_FLAG(
 						    tbit,
 						    ECOMMUNITY_FLAG_NON_TRANSITIVE))
 						continue;
 
 					stream_put(s, pnt, 8);
 				}
 			}
 		}
 	}
 
 	 
 	if (safi == SAFI_LABELED_UNICAST) {
 		if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {
 			uint32_t label_index;
 
 			label_index = attr->label_index;
 
 			if (label_index != BGP_INVALID_LABEL_INDEX) {
 				stream_putc(s,
 					    BGP_ATTR_FLAG_OPTIONAL
 						    | BGP_ATTR_FLAG_TRANS);
 				stream_putc(s, BGP_ATTR_PREFIX_SID);
 				stream_putc(s, 10);
 				stream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);
 				stream_putw(s,
 					    BGP_PREFIX_SID_LABEL_INDEX_LENGTH);
 				stream_putc(s, 0);  
 				stream_putw(s, 0);  
 				stream_putl(s, label_index);
 			}
 		}
 	}
 
 	if (send_as4_path) {
 		 
 		 
 
 		 
 		aspath = aspath_delete_confed_seq(aspath);
 
 		stream_putc(s,
 			    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL
 				    | BGP_ATTR_FLAG_EXTLEN);
 		stream_putc(s, BGP_ATTR_AS4_PATH);
 		aspath_sizep = stream_get_endp(s);
 		stream_putw(s, 0);
 		stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, 1));
 	}
 
 	if (aspath != attr->aspath)
 		aspath_free(aspath);
 
 	if (send_as4_aggregator) {
 		 
 		 
 		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
 		stream_putc(s, BGP_ATTR_AS4_AGGREGATOR);
 		stream_putc(s, 8);
 		stream_putl(s, attr->aggregator_as);
 		stream_put_ipv4(s, attr->aggregator_addr.s_addr);
 	}
 
 	if (((afi == AFI_IP || afi == AFI_IP6)
 	     && (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN))
 	    || (afi == AFI_L2VPN && safi == SAFI_EVPN)) {
  		 
  		bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);
  
#if ENABLE_BGP_VNC
 #if ENABLE_BGP_VNC_ATTR
  		 
  		bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC);
  #endif
 	}
 
 	 
 	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL)) {
 		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
 		stream_putc(s, BGP_ATTR_PMSI_TUNNEL);
 		stream_putc(s, 9);  
 		stream_putc(s, 0);  
 		stream_putc(s, PMSI_TNLTYPE_INGR_REPL);  
 		stream_put(s, &(attr->label),
 			   BGP_LABEL_BYTES);  
 		stream_put_ipv4(s, attr->nexthop.s_addr);
 	}
 
 	 
 	if (attr->transit)
 		stream_put(s, attr->transit->val, attr->transit->length);
 
 	 
 	return stream_get_endp(s) - cp;
 }","[373, 372]","bgpd in FRRouting FRR (aka Free Range Routing) 2.x and 3.x before 3.0.4, 4.x before 4.0.1, 5.x before 5.0.2, and 6.x before 6.0.2 (not affecting Cumulus Linux or VyOS), when ENABLE_BGP_VNC is used for Virtual Network Control, allows remote attackers to cause a denial of service (peering session flap) via attribute 255 in a BGP UPDATE packet. This occurred during Disco in January 2019 because FRR does not implement RFC 7606, and therefore the packets with 255 were considered invalid VNC data and the BGP session was closed."
3650,"_forceinline void Unpack::CopyString(uint Length,uint Distance)
{
size_t SrcPtr=UnpPtr-Distance;
if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)
{



byte *Src=Window+SrcPtr;
byte *Dest=Window+UnpPtr;
UnpPtr+=Length;

#ifdef FAST_MEMCPY
if (Distance<Length)
#endif
while (Length>=8)
{
Dest[0]=Src[0];
Dest[1]=Src[1];
Dest[2]=Src[2];
Dest[3]=Src[3];
Dest[4]=Src[4];
Dest[5]=Src[5];
Dest[6]=Src[6];
Dest[7]=Src[7];

Src+=8;
Dest+=8;
Length-=8;
}
#ifdef FAST_MEMCPY
else
while (Length>=8)
{







memcpy(Dest,Src,8);

Src+=8;
Dest+=8;
Length-=8;
}
#endif


if (Length>0) { Dest[0]=Src[0];
if (Length>1) { Dest[1]=Src[1];
if (Length>2) { Dest[2]=Src[2];
if (Length>3) { Dest[3]=Src[3];
if (Length>4) { Dest[4]=Src[4];
if (Length>5) { Dest[5]=Src[5];
if (Length>6) { Dest[6]=Src[6]; } } } } } } }
}
else
while (Length-- > 0)
{
Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];


UnpPtr=(UnpPtr+1) & MaxWinMask;
}
}",[4],UnRAR 5.6.1.2 and 5.6.1.3 has a heap-based buffer overflow in Unpack::CopyString (called from Unpack::Unpack5 and CmdExtract::ExtractCurrentFile).
207307," void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)
 {
     if (!m_provider) {
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, ""Failed to register a ServiceWorker: The document is in an invalid state.""));
         return;
     }
 
     RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();
     String errorMessage;
     if (!executionContext->isSecureContext(errorMessage)) {
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));
         return;
     }
 
     KURL pageURL = KURL(KURL(), documentOrigin->toString());
     if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the current origin ('"" + documentOrigin->toString() + ""') is not supported."")));
         return;
     }
 
     KURL scriptURL = rawScriptURL;
     scriptURL.removeFragmentIdentifier();
     if (!documentOrigin->canRequest(scriptURL)) {
         RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scriptURL ('"" + scriptOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
         return;
     }
     if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the script ('"" + scriptURL.getString() + ""') is not supported."")));
         return;
     }
 
     KURL patternURL = scope;
     patternURL.removeFragmentIdentifier();
 
     if (!documentOrigin->canRequest(patternURL)) {
         RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The origin of the provided scope ('"" + patternOrigin->toString() + ""') does not match the current origin ('"" + documentOrigin->toString() + ""')."")));
         return;
     }
     if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The URL protocol of the scope ('"" + patternURL.getString() + ""') is not supported."")));
         return;
     }
 
     WebString webErrorMessage;
     if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {
         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(""Failed to register a ServiceWorker: "" + webErrorMessage.utf8())));
          return;
      }
  
     ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();
     if (csp) {
         if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {
             callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(""Failed to register a ServiceWorker: The provided scriptURL ('"" + scriptURL.getString() + ""') violates the Content Security Policy."")));
             return;
         }
     }
 
      m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());
  }","[52, 53, 54, 55, 56, 57, 58, 59]","The ServiceWorkerContainer::registerServiceWorkerImpl function in WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp in Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Content Security Policy (CSP) protection mechanism via a ServiceWorker registration."
5029,"static int bpf_convert_filter(struct sock_filter *prog, int len,
struct bpf_prog *new_prog, int *new_len)
{
int new_flen = 0, pass = 0, target, i, stack_off;
struct bpf_insn *new_insn, *first_insn = NULL;
struct sock_filter *fp;
int *addrs = NULL;
u8 bpf_src;

BUILD_BUG_ON(BPF_MEMWORDS * sizeof(u32) > MAX_BPF_STACK);
BUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);

if (len <= 0 || len > BPF_MAXINSNS)
return -EINVAL;

if (new_prog) {
first_insn = new_prog->insnsi;
addrs = kcalloc(len, sizeof(*addrs),
GFP_KERNEL | __GFP_NOWARN);
if (!addrs)
return -ENOMEM;
}

do_pass:
new_insn = first_insn;
fp = prog;


if (new_prog) {



*new_insn++ = BPF_ALU32_REG(BPF_XOR, BPF_REG_A, BPF_REG_A);
*new_insn++ = BPF_ALU32_REG(BPF_XOR, BPF_REG_X, BPF_REG_X);





*new_insn++ = BPF_MOV64_REG(BPF_REG_CTX, BPF_REG_ARG1);
} else {
new_insn += 3;
}

for (i = 0; i < len; fp++, i++) {
struct bpf_insn tmp_insns[6] = { };
struct bpf_insn *insn = tmp_insns;

if (addrs)
addrs[i] = new_insn - first_insn;

switch (fp->code) {

case BPF_ALU | BPF_ADD | BPF_X:
case BPF_ALU | BPF_ADD | BPF_K:
case BPF_ALU | BPF_SUB | BPF_X:
case BPF_ALU | BPF_SUB | BPF_K:
case BPF_ALU | BPF_AND | BPF_X:
case BPF_ALU | BPF_AND | BPF_K:
case BPF_ALU | BPF_OR | BPF_X:
case BPF_ALU | BPF_OR | BPF_K:
case BPF_ALU | BPF_LSH | BPF_X:
case BPF_ALU | BPF_LSH | BPF_K:
case BPF_ALU | BPF_RSH | BPF_X:
case BPF_ALU | BPF_RSH | BPF_K:
case BPF_ALU | BPF_XOR | BPF_X:
case BPF_ALU | BPF_XOR | BPF_K:
case BPF_ALU | BPF_MUL | BPF_X:
case BPF_ALU | BPF_MUL | BPF_K:
case BPF_ALU | BPF_DIV | BPF_X:
case BPF_ALU | BPF_DIV | BPF_K:
case BPF_ALU | BPF_MOD | BPF_X:
case BPF_ALU | BPF_MOD | BPF_K:
case BPF_ALU | BPF_NEG:
case BPF_LD | BPF_ABS | BPF_W:
case BPF_LD | BPF_ABS | BPF_H:
case BPF_LD | BPF_ABS | BPF_B:
case BPF_LD | BPF_IND | BPF_W:
case BPF_LD | BPF_IND | BPF_H:
case BPF_LD | BPF_IND | BPF_B:




if (BPF_CLASS(fp->code) == BPF_LD &&
BPF_MODE(fp->code) == BPF_ABS &&
convert_bpf_extensions(fp, &insn))
break;

if (fp->code == (BPF_ALU | BPF_DIV | BPF_X) ||
fp->code == (BPF_ALU | BPF_MOD | BPF_X)) {
*insn++ = BPF_MOV32_REG(BPF_REG_X, BPF_REG_X);



*insn++ = BPF_JMP_IMM(BPF_JNE, BPF_REG_X, 0, 2);
*insn++ = BPF_ALU32_REG(BPF_XOR, BPF_REG_A, BPF_REG_A);
*insn++ = BPF_EXIT_INSN();
}

*insn = BPF_RAW_INSN(fp->code, BPF_REG_A, BPF_REG_X, 0, fp->k);
break;







#define BPF_EMIT_JMP							\
	do {								\
		if (target >= len || target < 0)			\
			goto err;					\
		insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0;	\
		/* Adjust pc relative offset for 2nd or 3rd insn. */	\
		insn->off -= insn - tmp_insns;				\
	} while (0)

case BPF_JMP | BPF_JA:
target = i + fp->k + 1;
insn->code = fp->code;
BPF_EMIT_JMP;
break;

case BPF_JMP | BPF_JEQ | BPF_K:
case BPF_JMP | BPF_JEQ | BPF_X:
case BPF_JMP | BPF_JSET | BPF_K:
case BPF_JMP | BPF_JSET | BPF_X:
case BPF_JMP | BPF_JGT | BPF_K:
case BPF_JMP | BPF_JGT | BPF_X:
case BPF_JMP | BPF_JGE | BPF_K:
case BPF_JMP | BPF_JGE | BPF_X:
if (BPF_SRC(fp->code) == BPF_K && (int) fp->k < 0) {




*insn++ = BPF_MOV32_IMM(BPF_REG_TMP, fp->k);

insn->dst_reg = BPF_REG_A;
insn->src_reg = BPF_REG_TMP;
bpf_src = BPF_X;
} else {
insn->dst_reg = BPF_REG_A;
insn->imm = fp->k;
bpf_src = BPF_SRC(fp->code);
insn->src_reg = bpf_src == BPF_X ? BPF_REG_X : 0;
}


if (fp->jf == 0) {
insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;
target = i + fp->jt + 1;
BPF_EMIT_JMP;
break;
}


if (fp->jt == 0) {
switch (BPF_OP(fp->code)) {
case BPF_JEQ:
insn->code = BPF_JMP | BPF_JNE | bpf_src;
break;
case BPF_JGT:
insn->code = BPF_JMP | BPF_JLE | bpf_src;
break;
case BPF_JGE:
insn->code = BPF_JMP | BPF_JLT | bpf_src;
break;
default:
goto jmp_rest;
}

target = i + fp->jf + 1;
BPF_EMIT_JMP;
break;
}
jmp_rest:

target = i + fp->jt + 1;
insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;
BPF_EMIT_JMP;
insn++;

insn->code = BPF_JMP | BPF_JA;
target = i + fp->jf + 1;
BPF_EMIT_JMP;
break;


case BPF_LDX | BPF_MSH | BPF_B:

*insn++ = BPF_MOV64_REG(BPF_REG_TMP, BPF_REG_A);

*insn++ = BPF_LD_ABS(BPF_B, fp->k);

*insn++ = BPF_ALU32_IMM(BPF_AND, BPF_REG_A, 0xf);

*insn++ = BPF_ALU32_IMM(BPF_LSH, BPF_REG_A, 2);

*insn++ = BPF_MOV64_REG(BPF_REG_X, BPF_REG_A);

*insn = BPF_MOV64_REG(BPF_REG_A, BPF_REG_TMP);
break;




case BPF_RET | BPF_A:
case BPF_RET | BPF_K:
if (BPF_RVAL(fp->code) == BPF_K)
*insn++ = BPF_MOV32_RAW(BPF_K, BPF_REG_0,
0, fp->k);
*insn = BPF_EXIT_INSN();
break;


case BPF_ST:
case BPF_STX:
stack_off = fp->k * 4  + 4;
*insn = BPF_STX_MEM(BPF_W, BPF_REG_FP, BPF_CLASS(fp->code) ==
BPF_ST ? BPF_REG_A : BPF_REG_X,
-stack_off);




if (new_prog && new_prog->aux->stack_depth < stack_off)
new_prog->aux->stack_depth = stack_off;
break;


case BPF_LD | BPF_MEM:
case BPF_LDX | BPF_MEM:
stack_off = fp->k * 4  + 4;
*insn = BPF_LDX_MEM(BPF_W, BPF_CLASS(fp->code) == BPF_LD  ?
BPF_REG_A : BPF_REG_X, BPF_REG_FP,
-stack_off);
break;


case BPF_LD | BPF_IMM:
case BPF_LDX | BPF_IMM:
*insn = BPF_MOV32_IMM(BPF_CLASS(fp->code) == BPF_LD ?
BPF_REG_A : BPF_REG_X, fp->k);
break;


case BPF_MISC | BPF_TAX:
*insn = BPF_MOV64_REG(BPF_REG_X, BPF_REG_A);
break;


case BPF_MISC | BPF_TXA:
*insn = BPF_MOV64_REG(BPF_REG_A, BPF_REG_X);
break;


case BPF_LD | BPF_W | BPF_LEN:
case BPF_LDX | BPF_W | BPF_LEN:
*insn = BPF_LDX_MEM(BPF_W, BPF_CLASS(fp->code) == BPF_LD ?
BPF_REG_A : BPF_REG_X, BPF_REG_CTX,
offsetof(struct sk_buff, len));
break;


case BPF_LDX | BPF_ABS | BPF_W:

*insn = BPF_LDX_MEM(BPF_W, BPF_REG_A, BPF_REG_CTX, fp->k);
break;


default:
goto err;
}

insn++;
if (new_prog)
memcpy(new_insn, tmp_insns,
sizeof(*insn) * (insn - tmp_insns));
new_insn += insn - tmp_insns;
}

if (!new_prog) {

*new_len = new_insn - first_insn;
return 0;
}

pass++;
if (new_flen != new_insn - first_insn) {
new_flen = new_insn - first_insn;
if (pass > 2)
goto err;
goto do_pass;
}

kfree(addrs);
BUG_ON(*new_len != new_flen);
return 0;
err:
kfree(addrs);
return -EINVAL;
}","[112, 114, 116]","The BPF subsystem in the Linux kernel before 4.17 mishandles situations with a long jump over an instruction sequence where inner instructions require substantial expansions into multiple BPF instructions, leading to an overflow. This affects kernel/bpf/core.c and net/core/filter.c."
199413," static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)
 {
 	struct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;
 	u8 b[] = { 0x00, 0xff, 0x00, 0x00,
  		   0x00, 0x00, 0x00, 0x00,
  		   0x00, 0x00 };
  
 	if (cmd->msg_len > sizeof(b) - 4)
 		return -EINVAL;
 
  	memcpy(&b[4], cmd->msg, cmd->msg_len);
  
  	state->config->send_command(fe, 0x72,
 				    sizeof(b) - (6 - cmd->msg_len), b,
 				    NULL, NULL);
 
 	return 0;
 }","[8, 9, 10]",Stack-based buffer overflow in the ttusbdecfe_dvbs_diseqc_send_master_cmd function in drivers/media/usb/ttusb-dec/ttusbdecfe.c in the Linux kernel before 3.17.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via a large message length in an ioctl call.
206756,"  Response StorageHandler::UntrackIndexedDBForOrigin(const std::string& origin) {
  if (!process_)
   if (!storage_partition_)
      return Response::InternalError();
  
    GURL origin_url(origin);
   if (!origin_url.is_valid())
     return Response::InvalidParams(origin + "" is not a valid URL"");
 
   GetIndexedDBObserver()->TaskRunner()->PostTask(
       FROM_HERE, base::BindOnce(&IndexedDBObserver::UntrackOriginOnIDBThread,
                                 base::Unretained(GetIndexedDBObserver()),
                                 url::Origin::Create(origin_url)));
   return Response::OK();
 }","[3, 2]",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
207456," void bta_hl_co_put_rx_data (UINT8 app_id, tBTA_HL_MDL_HANDLE mdl_handle,
                             UINT16 data_size, UINT8 *p_data, UINT16 evt)
 {
     UINT8 app_idx, mcl_idx, mdl_idx;
  btif_hl_mdl_cb_t *p_dcb;
     tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL;
  int            r;
     BTIF_TRACE_DEBUG(""%s app_id=%d mdl_handle=0x%x data_size=%d"",
                       __FUNCTION__,app_id, mdl_handle, data_size);
 
  if (btif_hl_find_mdl_idx_using_handle(mdl_handle, &app_idx, &mcl_idx, &mdl_idx))
  {
         p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);
 
  if ((p_dcb->p_rx_pkt = (UINT8 *)btif_hl_get_buf(data_size)) != NULL)
  {
             memcpy(p_dcb->p_rx_pkt, p_data, data_size);
  if (p_dcb->p_scb)
 
              {
                  BTIF_TRACE_DEBUG(""app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d"",
                                    app_idx, mcl_idx, mdl_idx, data_size);
                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);
                 r = TEMP_FAILURE_RETRY(send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0));
  
                  if (r == data_size)
                  {
                     BTIF_TRACE_DEBUG(""socket send success data_size=%d"",  data_size);
                     status = BTA_HL_STATUS_OK;
  }
  else
  {
                     BTIF_TRACE_ERROR(""socket send failed r=%d data_size=%d"",r, data_size);
  }
 
 
  }
             btif_hl_free_buf((void **) &p_dcb->p_rx_pkt);
  }
  }
 
     bta_hl_ci_put_rx_data(mdl_handle,  status, evt);
 }","[24, 23]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
199907," xfs_attr3_leaf_flipflags(
 	struct xfs_da_args	*args)
 {
 	struct xfs_attr_leafblock *leaf1;
 	struct xfs_attr_leafblock *leaf2;
 	struct xfs_attr_leaf_entry *entry1;
 	struct xfs_attr_leaf_entry *entry2;
 	struct xfs_attr_leaf_name_remote *name_rmt;
 	struct xfs_buf		*bp1;
 	struct xfs_buf		*bp2;
 	int error;
 #ifdef DEBUG
 	struct xfs_attr3_icleaf_hdr ichdr1;
 	struct xfs_attr3_icleaf_hdr ichdr2;
 	xfs_attr_leaf_name_local_t *name_loc;
 	int namelen1, namelen2;
 	char *name1, *name2;
 #endif  
 
 	trace_xfs_attr_leaf_flipflags(args);
 
 	 
 	error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);
 	if (error)
 		return error;
 
 	 
 	if (args->blkno2 != args->blkno) {
 		error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,
 					   -1, &bp2);
 		if (error)
 			return error;
 	} else {
 		bp2 = bp1;
 	}
 
 	leaf1 = bp1->b_addr;
 	entry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];
 
 	leaf2 = bp2->b_addr;
 	entry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];
 
 #ifdef DEBUG
 	xfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);
 	ASSERT(args->index < ichdr1.count);
 	ASSERT(args->index >= 0);
 
 	xfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);
 	ASSERT(args->index2 < ichdr2.count);
 	ASSERT(args->index2 >= 0);
 
 	if (entry1->flags & XFS_ATTR_LOCAL) {
 		name_loc = xfs_attr3_leaf_name_local(leaf1, args->index);
 		namelen1 = name_loc->namelen;
 		name1 = (char *)name_loc->nameval;
 	} else {
 		name_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);
 		namelen1 = name_rmt->namelen;
 		name1 = (char *)name_rmt->name;
 	}
 	if (entry2->flags & XFS_ATTR_LOCAL) {
 		name_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);
 		namelen2 = name_loc->namelen;
 		name2 = (char *)name_loc->nameval;
 	} else {
 		name_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);
 		namelen2 = name_rmt->namelen;
 		name2 = (char *)name_rmt->name;
 	}
 	ASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));
 	ASSERT(namelen1 == namelen2);
 	ASSERT(memcmp(name1, name2, namelen1) == 0);
 #endif  
 
 	ASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);
 	ASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);
 
 	entry1->flags &= ~XFS_ATTR_INCOMPLETE;
 	xfs_trans_log_buf(args->trans, bp1,
 			  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));
 	if (args->rmtblkno) {
  		ASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);
  		name_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);
  		name_rmt->valueblk = cpu_to_be32(args->rmtblkno);
		name_rmt->valuelen = cpu_to_be32(args->valuelen);
 		name_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);
  		xfs_trans_log_buf(args->trans, bp1,
  			 XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));
  	}
 
 	entry2->flags |= XFS_ATTR_INCOMPLETE;
 	xfs_trans_log_buf(args->trans, bp2,
 			  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));
 	if ((entry2->flags & XFS_ATTR_LOCAL) == 0) {
 		name_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);
 		name_rmt->valueblk = 0;
 		name_rmt->valuelen = 0;
 		xfs_trans_log_buf(args->trans, bp2,
 			 XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));
 	}
 
 	 
 	error = xfs_trans_roll(&args->trans, args->dp);
 
 	return error;
 }","[86, 85]","The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access."
208215," OMX_ERRORTYPE SoftAMR::internalSetParameter(
         OMX_INDEXTYPE index, const OMX_PTR params) {
  switch (index) {
  case OMX_IndexParamStandardComponentRole:
  {
 
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
             if (!isValidOMXParam(roleParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (mMode == MODE_NARROW) {
                  if (strncmp((const char *)roleParams->cRole,
                              ""audio_decoder.amrnb"",
                             OMX_MAX_STRINGNAME_SIZE - 1)) {
  return OMX_ErrorUndefined;
  }
  } else {
  if (strncmp((const char *)roleParams->cRole,
  ""audio_decoder.amrwb"",
                             OMX_MAX_STRINGNAME_SIZE - 1)) {
  return OMX_ErrorUndefined;
  }
  }
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioAmr:
  {
 
              const OMX_AUDIO_PARAM_AMRTYPE *aacParams =
                  (const OMX_AUDIO_PARAM_AMRTYPE *)params;
  
             if (!isValidOMXParam(aacParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (aacParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioPcm:
  {
 
              const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
             if (!isValidOMXParam(pcmParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
 
  return OMX_ErrorNone;
  }
 
  default:
  return SimpleSoftOMXComponent::internalSetParameter(index, params);
  }
 }","[10, 11, 12, 13, 37, 38, 39, 40, 54, 55, 56, 57]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
7345,"int LibarchivePlugin::extractionFlags() const
{
int result = ARCHIVE_EXTRACT_TIME;
result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;












return result;
}","[3, 4, 17]","In KDE Ark before 20.08.1, a crafted TAR archive with symlinks can install files outside the extraction directory, as demonstrated by a write operation to a user's home directory."
206318," const service_manager::Manifest& GetChromeContentBrowserOverlayManifest() {
   static base::NoDestructor<service_manager::Manifest> manifest {
     service_manager::ManifestBuilder()
         .ExposeCapability(""gpu"",
                           service_manager::Manifest::InterfaceList<
                               metrics::mojom::CallStackProfileCollector>())
         .ExposeCapability(""renderer"",
                           service_manager::Manifest::InterfaceList<
                               chrome::mojom::AvailableOfflineContentProvider,
                               chrome::mojom::CacheStatsRecorder,
                               chrome::mojom::NetBenchmarking,
                               data_reduction_proxy::mojom::DataReductionProxy,
                               metrics::mojom::CallStackProfileCollector,
 #if defined(OS_WIN)
                               mojom::ModuleEventSink,
 #endif
                               rappor::mojom::RapporRecorder,
                               safe_browsing::mojom::SafeBrowsing>())
         .RequireCapability(""ash"", ""system_ui"")
         .RequireCapability(""ash"", ""test"")
         .RequireCapability(""ash"", ""display"")
         .RequireCapability(""assistant"", ""assistant"")
         .RequireCapability(""assistant_audio_decoder"", ""assistant:audio_decoder"")
         .RequireCapability(""chrome"", ""input_device_controller"")
         .RequireCapability(""chrome_printing"", ""converter"")
         .RequireCapability(""cups_ipp_parser"", ""ipp_parser"")
         .RequireCapability(""device"", ""device:fingerprint"")
         .RequireCapability(""device"", ""device:geolocation_config"")
         .RequireCapability(""device"", ""device:geolocation_control"")
         .RequireCapability(""device"", ""device:ip_geolocator"")
         .RequireCapability(""ime"", ""input_engine"")
         .RequireCapability(""mirroring"", ""mirroring"")
         .RequireCapability(""nacl_broker"", ""browser"")
         .RequireCapability(""nacl_loader"", ""browser"")
         .RequireCapability(""noop"", ""noop"")
         .RequireCapability(""patch"", ""patch_file"")
         .RequireCapability(""preferences"", ""pref_client"")
         .RequireCapability(""preferences"", ""pref_control"")
         .RequireCapability(""profile_import"", ""import"")
         .RequireCapability(""removable_storage_writer"",
                            ""removable_storage_writer"")
         .RequireCapability(""secure_channel"", ""secure_channel"")
         .RequireCapability(""ui"", ""ime_registrar"")
         .RequireCapability(""ui"", ""input_device_controller"")
         .RequireCapability(""ui"", ""window_manager"")
         .RequireCapability(""unzip"", ""unzip_file"")
         .RequireCapability(""util_win"", ""util_win"")
         .RequireCapability(""xr_device_service"", ""xr_device_provider"")
         .RequireCapability(""xr_device_service"", ""xr_device_test_hook"")
 #if defined(OS_CHROMEOS)
         .RequireCapability(""multidevice_setup"", ""multidevice_setup"")
 #endif
         .ExposeInterfaceFilterCapability_Deprecated(
             ""navigation:frame"", ""renderer"",
             service_manager::Manifest::InterfaceList<
                 autofill::mojom::AutofillDriver,
                 autofill::mojom::PasswordManagerDriver,
                 chrome::mojom::OfflinePageAutoFetcher,
 #if defined(OS_CHROMEOS)
                  chromeos_camera::mojom::CameraAppHelper,
                  chromeos::cellular_setup::mojom::CellularSetup,
                  chromeos::crostini_installer::mojom::PageHandlerFactory,
                chromeos::crostini_upgrader::mojom::PageHandlerFactory,
                  chromeos::ime::mojom::InputEngineManager,
                  chromeos::machine_learning::mojom::PageHandler,
                  chromeos::media_perception::mojom::MediaPerception,
                 chromeos::multidevice_setup::mojom::MultiDeviceSetup,
                 chromeos::multidevice_setup::mojom::PrivilegedHostDeviceSetter,
                 chromeos::network_config::mojom::CrosNetworkConfig,
                 cros::mojom::CameraAppDeviceProvider,
 #endif
                 contextual_search::mojom::ContextualSearchJsApiService,
 #if BUILDFLAG(ENABLE_EXTENSIONS)
                 extensions::KeepAlive,
 #endif
                 media::mojom::MediaEngagementScoreDetailsProvider,
                 media_router::mojom::MediaRouter,
                 page_load_metrics::mojom::PageLoadMetrics,
                 translate::mojom::ContentTranslateDriver,
 
                 downloads::mojom::PageHandlerFactory,
                 feed_internals::mojom::PageHandler,
                 new_tab_page::mojom::PageHandlerFactory,
 #if defined(OS_ANDROID)
                 explore_sites_internals::mojom::PageHandler,
 #else
                 app_management::mojom::PageHandlerFactory,
 #endif
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
     defined(OS_CHROMEOS)
                 discards::mojom::DetailsProvider, discards::mojom::GraphDump,
 #endif
 #if defined(OS_CHROMEOS)
                 add_supervision::mojom::AddSupervisionHandler,
 #endif
                 mojom::BluetoothInternalsHandler,
                 mojom::InterventionsInternalsPageHandler,
                 mojom::OmniboxPageHandler, mojom::ResetPasswordHandler,
                 mojom::SiteEngagementDetailsProvider,
                 mojom::UsbInternalsPageHandler,
                 snippets_internals::mojom::PageHandlerFactory>())
         .PackageService(prefs::GetManifest())
 #if defined(OS_CHROMEOS)
         .PackageService(chromeos::multidevice_setup::GetManifest())
 #endif   
         .Build()
   };
   return *manifest;
 }",[63],"Inappropriate implementation of the web payments API on blob: and data: schemes in Web Payments in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to spoof the contents of the Omnibox via a crafted HTML page."
206353,"  void SaveCardBubbleControllerImpl::ShowBubbleForLocalSave(
      const CreditCard& card,
      const base::Closure& save_card_callback) {
    
   if (save_card_bubble_view_)
     return;
 
    is_uploading_ = false;
    is_reshow_ = false;
    should_cvc_be_requested_ = false;
   legal_message_lines_.clear();
 
   AutofillMetrics::LogSaveCardPromptMetric(
       AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,
       is_reshow_,
       pref_service_->GetInteger(
           prefs::kAutofillAcceptSaveCreditCardPromptState));
 
   card_ = card;
   save_card_callback_ = save_card_callback;
   ShowBubble();
 }","[4, 5, 6, 7]",A use after free in credit card autofill in Google Chrome prior to 59.0.3071.86 for Linux and Windows allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
198717," void inet_sock_destruct(struct sock *sk)
 {
 	struct inet_sock *inet = inet_sk(sk);
 
 	__skb_queue_purge(&sk->sk_receive_queue);
 	__skb_queue_purge(&sk->sk_error_queue);
 
 	sk_mem_reclaim(sk);
 
 	if (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {
 		pr_err(""Attempt to release TCP socket in state %d %p\n"",
 		       sk->sk_state, sk);
 		return;
 	}
 	if (!sock_flag(sk, SOCK_DEAD)) {
 		pr_err(""Attempt to release alive inet socket %p\n"", sk);
 		return;
 	}
 
 	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
 	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
  	WARN_ON(sk->sk_wmem_queued);
  	WARN_ON(sk->sk_forward_alloc);
  
	kfree(inet->opt);
 	kfree(rcu_dereference_protected(inet->inet_opt, 1));
  	dst_release(rcu_dereference_check(sk->sk_dst_cache, 1));
  	sk_refcnt_debug_dec(sk);
  }","[26, 25]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
7405,"static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
__Pyx_RefNannyDeclarations
__Pyx_RefNannySetupContext(""__Pyx_InitCachedConstants"", 0);








__pyx_tuple_ = PyTuple_Pack(5, __pyx_n_s_number, __pyx_n_s_buf, __pyx_n_s_i, __pyx_n_s_towrite, __pyx_n_s_num_buf); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 4, __pyx_L1_error)
__Pyx_GOTREF(__pyx_tuple_);
__Pyx_GIVEREF(__pyx_tuple_);
__pyx_codeobj__2 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple_, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_clickhouse_driver_varint_pyx, __pyx_n_s_write_varint, 4, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__2)) __PYX_ERR(0, 4, __pyx_L1_error)








__pyx_tuple__3 = PyTuple_Pack(5, __pyx_n_s_f, __pyx_n_s_shift, __pyx_n_s_result, __pyx_n_s_i, __pyx_n_s_read_one); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 29, __pyx_L1_error)
__Pyx_GOTREF(__pyx_tuple__3);
__Pyx_GIVEREF(__pyx_tuple__3);
__pyx_codeobj__4 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_clickhouse_driver_varint_pyx, __pyx_n_s_read_varint, 29, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__4)) __PYX_ERR(0, 29, __pyx_L1_error)
__Pyx_RefNannyFinishContext();
return 0;
__pyx_L1_error:;
__Pyx_RefNannyFinishContext();
return -1;
}","[12, 24, 27]","clickhouse-driver before 0.1.5 allows a malicious clickhouse server to trigger a crash or execute arbitrary code (on a database client) via a crafted server response, due to a buffer overflow."
207472," void close_uinput (void)
 
  {
      BTIF_TRACE_DEBUG(""%s"", __FUNCTION__);
      if (uinput_fd > 0) {
        ioctl(uinput_fd, UI_DEV_DESTROY);
         TEMP_FAILURE_RETRY(ioctl(uinput_fd, UI_DEV_DESTROY));
  
          close(uinput_fd);
          uinput_fd = -1;
  }
 }","[7, 6]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
197786," void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
 				int width, int height,
 				GfxImageColorMap *colorMap,
 				int *maskColors, GBool inlineImg) {
   double *ctm;
   SplashCoord mat[6];
   SplashOutImageData imgData;
   SplashColorMode srcMode;
   SplashImageSource src;
   GfxGray gray;
   GfxRGB rgb;
 #if SPLASH_CMYK
   GfxCMYK cmyk;
 #endif
   Guchar pix;
   int n, i;
 
   ctm = state->getCTM();
   mat[0] = ctm[0];
   mat[1] = ctm[1];
   mat[2] = -ctm[2];
   mat[3] = -ctm[3];
   mat[4] = ctm[2] + ctm[4];
   mat[5] = ctm[3] + ctm[5];
 
   imgData.imgStr = new ImageStream(str, width,
 				   colorMap->getNumPixelComps(),
 				   colorMap->getBits());
   imgData.imgStr->reset();
   imgData.colorMap = colorMap;
   imgData.maskColors = maskColors;
   imgData.colorMode = colorMode;
   imgData.width = width;
   imgData.height = height;
   imgData.y = 0;
 
   imgData.lookup = NULL;
   if (colorMap->getNumPixelComps() == 1) {
     n = 1 << colorMap->getBits();
     switch (colorMode) {
     case splashModeMono1:
     case splashModeMono8:
       imgData.lookup = (SplashColorPtr)gmalloc(n);
       for (i = 0; i < n; ++i) {
 	pix = (Guchar)i;
 	colorMap->getGray(&pix, &gray);
 	imgData.lookup[i] = colToByte(gray);
       }
        break;
      case splashModeRGB8:
      case splashModeBGR8:
      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);
       imgData.lookup = (SplashColorPtr)gmallocn(n, 3);
        for (i = 0; i < n; ++i) {
  	pix = (Guchar)i;
  	colorMap->getRGB(&pix, &rgb);
 	imgData.lookup[3*i] = colToByte(rgb.r);
 	imgData.lookup[3*i+1] = colToByte(rgb.g);
 	imgData.lookup[3*i+2] = colToByte(rgb.b);
        }
        break;
      case splashModeXBGR8:
      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);
       imgData.lookup = (SplashColorPtr)gmallocn(n, 3);
        for (i = 0; i < n; ++i) {
  	pix = (Guchar)i;
  	colorMap->getRGB(&pix, &rgb);
 	imgData.lookup[4*i] = colToByte(rgb.r);
 	imgData.lookup[4*i+1] = colToByte(rgb.g);
 	imgData.lookup[4*i+2] = colToByte(rgb.b);
 	imgData.lookup[4*i+3] = 255;
       }
        break;
  #if SPLASH_CMYK
      case splashModeCMYK8:
      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);
       imgData.lookup = (SplashColorPtr)gmallocn(n, 4);
        for (i = 0; i < n; ++i) {
  	pix = (Guchar)i;
  	colorMap->getCMYK(&pix, &cmyk);
 	imgData.lookup[4*i] = colToByte(cmyk.c);
 	imgData.lookup[4*i+1] = colToByte(cmyk.m);
 	imgData.lookup[4*i+2] = colToByte(cmyk.y);
 	imgData.lookup[4*i+3] = colToByte(cmyk.k);
       }
       break;
 #endif
       break;
     }
   }
 
   if (colorMode == splashModeMono1) {
     srcMode = splashModeMono8;
   } else {
     srcMode = colorMode;
   }
   src = maskColors ? &alphaImageSrc : &imageSrc;
   splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,
 		    width, height, mat);
   if (inlineImg) {
     while (imgData.y < height) {
       imgData.imgStr->getLine();
       ++imgData.y;
     }
   }
 
   gfree(imgData.lookup);
   delete imgData.imgStr;
   str->close();
 }","[53, 64, 77, 52, 63, 76]","Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791."
7617,"bool FromkLinuxSockAddr(const struct klinux_sockaddr *input,
socklen_t input_len, struct sockaddr *output,
socklen_t *output_len,
void (*abort_handler)(const char *)) {
if (!input || !output || !output_len || input_len == 0) {
output = nullptr;
return false;
}

int16_t klinux_family = input->klinux_sa_family;
if (klinux_family == kLinux_AF_UNIX) {
struct klinux_sockaddr_un *klinux_sockaddr_un_in =
const_cast<struct klinux_sockaddr_un *>(
reinterpret_cast<const struct klinux_sockaddr_un *>(input));

struct sockaddr_un sockaddr_un_out;
sockaddr_un_out.sun_family = AF_UNIX;
InitializeToZeroArray(sockaddr_un_out.sun_path);
ReinterpretCopyArray(
sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,
std::min(sizeof(sockaddr_un_out.sun_path),
sizeof(klinux_sockaddr_un_in->klinux_sun_path)));
CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);
} else if (klinux_family == kLinux_AF_INET) {
struct klinux_sockaddr_in *klinux_sockaddr_in_in =
const_cast<struct klinux_sockaddr_in *>(
reinterpret_cast<const struct klinux_sockaddr_in *>(input));

struct sockaddr_in sockaddr_in_out;
sockaddr_in_out.sin_family = AF_INET;
sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;
InitializeToZeroSingle(&sockaddr_in_out.sin_addr);
ReinterpretCopySingle(&sockaddr_in_out.sin_addr,
&klinux_sockaddr_in_in->klinux_sin_addr);
InitializeToZeroArray(sockaddr_in_out.sin_zero);
ReinterpretCopyArray(sockaddr_in_out.sin_zero,
klinux_sockaddr_in_in->klinux_sin_zero);
CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);
} else if (klinux_family == kLinux_AF_INET6) {
struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =
const_cast<struct klinux_sockaddr_in6 *>(
reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));

struct sockaddr_in6 sockaddr_in6_out;
sockaddr_in6_out.sin6_family = AF_INET6;
sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;
sockaddr_in6_out.sin6_flowinfo =
klinux_sockaddr_in6_in->klinux_sin6_flowinfo;
sockaddr_in6_out.sin6_scope_id =
klinux_sockaddr_in6_in->klinux_sin6_scope_id;
InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);
ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,
&klinux_sockaddr_in6_in->klinux_sin6_addr);
CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,
output_len);
} else if (klinux_family == kLinux_AF_UNSPEC) {
output = nullptr;
*output_len = 0;
} else {
if (abort_handler != nullptr) {
std::string message = absl::StrCat(
""Type conversion error - Unsupported AF family: "", klinux_family);
abort_handler(message.c_str());
} else {
abort();
}
}
return true;
}","[12, 25, 40]",An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to FromkLinuxSockAddr with attacker controlled content and size of klinux_addr which allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02
203008," METHODDEF(JDIMENSION)
 get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
  
  {
    bmp_source_ptr source = (bmp_source_ptr)sinfo;
    register JSAMPARRAY colormap = source->colormap;
   int cmaplen = source->cmap_length;
    JSAMPARRAY image_ptr;
    register int t;
    register JSAMPROW inptr, outptr;
   register JDIMENSION col;
 
   if (source->use_inversion_array) {
      
     source->source_row--;
     image_ptr = (*cinfo->mem->access_virt_sarray)
       ((j_common_ptr)cinfo, source->whole_image,
        source->source_row, (JDIMENSION)1, FALSE);
     inptr = image_ptr[0];
   } else {
     if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))
       ERREXIT(cinfo, JERR_INPUT_EOF);
     inptr = source->iobuffer;
   }
 
    
   outptr = source->pub.buffer[0];
    if (cinfo->in_color_space == JCS_GRAYSCALE) {
      for (col = cinfo->image_width; col > 0; col--) {
        t = GETJSAMPLE(*inptr++);
       if (t >= cmaplen)
         ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
        *outptr++ = colormap[0][t];
      }
    } else if (cinfo->in_color_space == JCS_CMYK) {
      for (col = cinfo->image_width; col > 0; col--) {
        t = GETJSAMPLE(*inptr++);
       if (t >= cmaplen)
         ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
        rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,
                    outptr + 1, outptr + 2, outptr + 3);
        outptr += 4;
     }
   } else {
     register int rindex = rgb_red[cinfo->in_color_space];
     register int gindex = rgb_green[cinfo->in_color_space];
     register int bindex = rgb_blue[cinfo->in_color_space];
     register int aindex = alpha_index[cinfo->in_color_space];
     register int ps = rgb_pixelsize[cinfo->in_color_space];
 
      if (aindex >= 0) {
        for (col = cinfo->image_width; col > 0; col--) {
          t = GETJSAMPLE(*inptr++);
         if (t >= cmaplen)
           ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
          outptr[rindex] = colormap[0][t];
          outptr[gindex] = colormap[1][t];
          outptr[bindex] = colormap[2][t];
         outptr[aindex] = 0xFF;
         outptr += ps;
       }
      } else {
        for (col = cinfo->image_width; col > 0; col--) {
          t = GETJSAMPLE(*inptr++);
         if (t >= cmaplen)
           ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
          outptr[rindex] = colormap[0][t];
          outptr[gindex] = colormap[1][t];
          outptr[bindex] = colormap[2][t];
         outptr += ps;
       }
     }
   }
 
   return 1;
 }","[7, 31, 32, 38, 39, 54, 55, 65, 66]",get_8bit_row in rdbmp.c in libjpeg-turbo through 1.5.90 and MozJPEG through 3.3.1 allows attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted 8-bit BMP in which one or more of the color indices is out of range for the number of palette entries.
199968," void __fput_sync(struct file *file)
  {
  	if (atomic_long_dec_and_test(&file->f_count)) {
  		struct task_struct *task = current;
		file_sb_list_del(file);
  		BUG_ON(!(task->flags & PF_KTHREAD));
  		__fput(file);
  	}
 }",[5],"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations."
207094," void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,
                                                               bool ask_user,
                                                               bool is_allowed) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   auto iter = sessions_.find(session_id);
   if (iter == sessions_.end())
     return;
 
   Session* session = iter->second.get();
 
   if (session->abort_requested)
     return;
 
    if (ask_user) {
      SpeechRecognitionSessionContext& context = session->context;
      context.label = media_stream_manager_->MakeMediaAccessRequest(
        context.render_process_id, context.render_frame_id, session_id,
        StreamControls(true, false), context.security_origin,
         context.render_process_id, context.render_frame_id, requester_id_,
         session_id, StreamControls(true, false), context.security_origin,
          base::BindOnce(
              &SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,
              weak_factory_.GetWeakPtr(), session_id));
     return;
   }
 
   if (is_allowed) {
     base::ThreadTaskRunnerHandle::Get()->PostTask(
         FROM_HERE,
         base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,
                        weak_factory_.GetWeakPtr(), session_id, EVENT_START));
   } else {
     OnRecognitionError(
         session_id, blink::mojom::SpeechRecognitionError(
                         blink::mojom::SpeechRecognitionErrorCode::kNotAllowed,
                         blink::mojom::SpeechAudioErrorDetails::kNone));
     base::ThreadTaskRunnerHandle::Get()->PostTask(
         FROM_HERE,
         base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,
                        weak_factory_.GetWeakPtr(), session_id, EVENT_ABORT));
   }
 }","[20, 21, 18, 19]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
7484,"static const char *vgacon_startup(void)
{
const char *display_desc = NULL;
u16 saved1, saved2;
volatile u16 *p;

if (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||
screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {
no_vga:
#ifdef CONFIG_DUMMY_CONSOLE
conswitchp = &dummy_con;
return conswitchp->con_startup();
#else
return NULL;
#endif
}


if ((screen_info.orig_video_lines == 0) ||
(screen_info.orig_video_cols  == 0))
goto no_vga;


if ((screen_info.orig_video_mode == 0x0D) ||
(screen_info.orig_video_mode == 0x0E) ||
(screen_info.orig_video_mode == 0x10) ||
(screen_info.orig_video_mode == 0x12) ||
(screen_info.orig_video_mode == 0x6A))
goto no_vga;

vga_video_num_lines = screen_info.orig_video_lines;
vga_video_num_columns = screen_info.orig_video_cols;
vgastate.vgabase = NULL;

if (screen_info.orig_video_mode == 7) {

vga_vram_base = 0xb0000;
vga_video_port_reg = VGA_CRT_IM;
vga_video_port_val = VGA_CRT_DM;
if ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {
static struct resource ega_console_resource =
{ .name = ""ega"",
.flags = IORESOURCE_IO,
.start = 0x3B0,
.end = 0x3BF };
vga_video_type = VIDEO_TYPE_EGAM;
vga_vram_size = 0x8000;
display_desc = ""EGA+"";
request_resource(&ioport_resource,
&ega_console_resource);
} else {
static struct resource mda1_console_resource =
{ .name = ""mda"",
.flags = IORESOURCE_IO,
.start = 0x3B0,
.end = 0x3BB };
static struct resource mda2_console_resource =
{ .name = ""mda"",
.flags = IORESOURCE_IO,
.start = 0x3BF,
.end = 0x3BF };
vga_video_type = VIDEO_TYPE_MDA;
vga_vram_size = 0x2000;
display_desc = ""*MDA"";
request_resource(&ioport_resource,
&mda1_console_resource);
request_resource(&ioport_resource,
&mda2_console_resource);
vga_video_font_height = 14;
}
} else {

vga_can_do_color = true;
vga_vram_base = 0xb8000;
vga_video_port_reg = VGA_CRT_IC;
vga_video_port_val = VGA_CRT_DC;
if ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {
int i;

vga_vram_size = 0x8000;

if (!screen_info.orig_video_isVGA) {
static struct resource ega_console_resource =
{ .name = ""ega"",
.flags = IORESOURCE_IO,
.start = 0x3C0,
.end = 0x3DF };
vga_video_type = VIDEO_TYPE_EGAC;
display_desc = ""EGA"";
request_resource(&ioport_resource,
&ega_console_resource);
} else {
static struct resource vga_console_resource =
{ .name = ""vga+"",
.flags = IORESOURCE_IO,
.start = 0x3C0,
.end = 0x3DF };
vga_video_type = VIDEO_TYPE_VGAC;
display_desc = ""VGA+"";
request_resource(&ioport_resource,
&vga_console_resource);







for (i = 0; i < 16; i++) {
inb_p(VGA_IS1_RC);
outb_p(i, VGA_ATT_W);
outb_p(i, VGA_ATT_W);
}
outb_p(0x20, VGA_ATT_W);





for (i = 0; i < 16; i++) {
outb_p(color_table[i], VGA_PEL_IW);
outb_p(default_red[i], VGA_PEL_D);
outb_p(default_grn[i], VGA_PEL_D);
outb_p(default_blu[i], VGA_PEL_D);
}
}
} else {
static struct resource cga_console_resource =
{ .name = ""cga"",
.flags = IORESOURCE_IO,
.start = 0x3D4,
.end = 0x3D5 };
vga_video_type = VIDEO_TYPE_CGA;
vga_vram_size = 0x2000;
display_desc = ""*CGA"";
request_resource(&ioport_resource,
&cga_console_resource);
vga_video_font_height = 8;
}
}

vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);
vga_vram_end = vga_vram_base + vga_vram_size;





p = (volatile u16 *) vga_vram_base;
saved1 = scr_readw(p);
saved2 = scr_readw(p + 1);
scr_writew(0xAA55, p);
scr_writew(0x55AA, p + 1);
if (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {
scr_writew(saved1, p);
scr_writew(saved2, p + 1);
goto no_vga;
}
scr_writew(0x55AA, p);
scr_writew(0xAA55, p + 1);
if (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {
scr_writew(saved1, p);
scr_writew(saved2, p + 1);
goto no_vga;
}
scr_writew(saved1, p);
scr_writew(saved2, p + 1);

if (vga_video_type == VIDEO_TYPE_EGAC
|| vga_video_type == VIDEO_TYPE_VGAC
|| vga_video_type == VIDEO_TYPE_EGAM) {
vga_hardscroll_enabled = vga_hardscroll_user_enable;
vga_default_font_height = screen_info.orig_video_points;
vga_video_font_height = screen_info.orig_video_points;

vga_scan_lines =
vga_video_font_height * vga_video_num_lines;
}

vgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;
vgacon_yres = vga_scan_lines;

if (!vga_init_done) {
vgacon_scrollback_startup();
vga_init_done = true;
}

return display_desc;
}","[183, 184, 185]","The vgacon subsystem in the Linux kernel before 5.8.10 mishandles software scrollback. There is a vgacon_scrolldelta out-of-bounds read, aka CID-973c096f6a85."
8159,"_hivex_get_children (hive_h *h, hive_node_h node,
hive_node_h **children_ret, size_t **blocks_ret,
int flags)
{
if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, ""nk"")) {
SET_ERRNO (EINVAL, ""invalid block or not an 'nk' block"");
return -1;
}

struct ntreg_nk_record *nk =
(struct ntreg_nk_record *) ((char *) h->addr + node);

size_t nr_subkeys_in_nk = le32toh (nk->nr_subkeys);

offset_list children, blocks;
_hivex_init_offset_list (h, &children);
_hivex_init_offset_list (h, &blocks);


if (nr_subkeys_in_nk == 0)
goto out;


if (nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS) {
SET_ERRNO (ERANGE,
""nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS (%zu > %d)"",
nr_subkeys_in_nk, HIVEX_MAX_SUBKEYS);
goto error;
}


_hivex_set_offset_list_limit (&children, nr_subkeys_in_nk);






_hivex_set_offset_list_limit (&blocks, HIVEX_MAX_SUBKEYS);


if (_hivex_grow_offset_list (&children, nr_subkeys_in_nk) == -1)
goto error;





size_t subkey_lf = le32toh (nk->subkey_lf);
subkey_lf += 0x1000;
if (!IS_VALID_BLOCK (h, subkey_lf)) {
SET_ERRNO (EFAULT,
""subkey_lf is not a valid block (0x%zx)"", subkey_lf);
goto error;
}

if (_get_children (h, subkey_lf, &children, &blocks, flags) == -1)
goto error;




size_t nr_children = _hivex_get_offset_list_length (&children);
if (nr_subkeys_in_nk != nr_children) {
if (!h->unsafe) {
SET_ERRNO (ENOTSUP,
""nr_subkeys_in_nk = %zu ""
""is not equal to number of children read %zu"",
nr_subkeys_in_nk, nr_children);
goto error;
} else {
DEBUG (2,
""nr_subkeys_in_nk = %zu ""
""is not equal to number of children read %zu"",
nr_subkeys_in_nk, nr_children);
}
}

out:
#if 0
if (h->msglvl >= 2) {
fprintf (stderr, ""%s: %s: children = "", ""hivex"", __func__);
_hivex_print_offset_list (&children, stderr);
fprintf (stderr, ""\n%s: %s: blocks = "", ""hivex"", __func__);
_hivex_print_offset_list (&blocks, stderr);
fprintf (stderr, ""\n"");
}
#endif

*children_ret = _hivex_return_offset_list (&children);
*blocks_ret = _hivex_return_offset_list (&blocks);
if (!*children_ret || !*blocks_ret)
goto error;
return 0;

error:
_hivex_free_offset_list (&children);
_hivex_free_offset_list (&blocks);
return -1;
}",[57],"A flaw was found in the hivex library. This flaw allows an attacker to input a specially crafted Windows Registry (hive) file, which would cause hivex to recursively call the _get_children() function, leading to a stack overflow. The highest threat from this vulnerability is to system availability."
8534,"setup_seccomp (FlatpakBwrap   *bwrap,
const char     *arch,
gulong          allowed_personality,
FlatpakRunFlags run_flags,
GError        **error)
{
gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;
gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;

__attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;






























struct
{
int                  scall;
struct scmp_arg_cmp *arg;
} syscall_blocklist[] = {

{SCMP_SYS (syslog)},

{SCMP_SYS (uselib)},

{SCMP_SYS (acct)},


{SCMP_SYS (modify_ldt)},

{SCMP_SYS (quotactl)},


{SCMP_SYS (add_key)},
{SCMP_SYS (keyctl)},
{SCMP_SYS (request_key)},


{SCMP_SYS (move_pages)},
{SCMP_SYS (mbind)},
{SCMP_SYS (get_mempolicy)},
{SCMP_SYS (set_mempolicy)},
{SCMP_SYS (migrate_pages)},


{SCMP_SYS (unshare)},
{SCMP_SYS (mount)},
{SCMP_SYS (pivot_root)},
#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)


{SCMP_SYS (clone), &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#else

{SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#endif


{SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},
};

struct
{
int                  scall;
struct scmp_arg_cmp *arg;
} syscall_nondevel_blocklist[] = {



{SCMP_SYS (perf_event_open)},

{SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},
{SCMP_SYS (ptrace)}
};

struct
{
int             family;
FlatpakRunFlags flags_mask;
} socket_family_allowlist[] = {

{ AF_UNSPEC, 0 },
{ AF_LOCAL, 0 },
{ AF_INET, 0 },
{ AF_INET6, 0 },
{ AF_NETLINK, 0 },
{ AF_CAN, FLATPAK_RUN_FLAG_CANBUS },
{ AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },
};
int last_allowed_family;
int i, r;
g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };

seccomp = seccomp_init (SCMP_ACT_ALLOW);
if (!seccomp)
return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Initialize seccomp failed""));

if (arch != NULL)
{
uint32_t arch_id = 0;
const uint32_t *extra_arches = NULL;

if (strcmp (arch, ""i386"") == 0)
{
arch_id = SCMP_ARCH_X86;
}
else if (strcmp (arch, ""x86_64"") == 0)
{
arch_id = SCMP_ARCH_X86_64;
extra_arches = seccomp_x86_64_extra_arches;
}
else if (strcmp (arch, ""arm"") == 0)
{
arch_id = SCMP_ARCH_ARM;
}
#ifdef SCMP_ARCH_AARCH64
else if (strcmp (arch, ""aarch64"") == 0)
{
arch_id = SCMP_ARCH_AARCH64;
extra_arches = seccomp_aarch64_extra_arches;
}
#endif



if (arch_id != 0)
{





r = seccomp_arch_add (seccomp, arch_id);
if (r < 0 && r != -EEXIST)
return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add architecture to seccomp filter""));

if (multiarch && extra_arches != NULL)
{
for (i = 0; extra_arches[i] != 0; i++)
{
r = seccomp_arch_add (seccomp, extra_arches[i]);
if (r < 0 && r != -EEXIST)
return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to add multiarch architecture to seccomp filter""));
}
}
}
}






for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)
{
int scall = syscall_blocklist[i].scall;
if (syscall_blocklist[i].arg)
r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blocklist[i].arg);
else
r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);
if (r < 0 && r == -EFAULT                      )
return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);
}

if (!devel)
{
for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)
{
int scall = syscall_nondevel_blocklist[i].scall;
if (syscall_nondevel_blocklist[i].arg)
r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blocklist[i].arg);
else
r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);

if (r < 0 && r == -EFAULT                      )
return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to block syscall %d""), scall);
}
}




last_allowed_family = -1;
for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)
{
int family = socket_family_allowlist[i].family;
int disallowed;

if (socket_family_allowlist[i].flags_mask != 0 &&
(socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)
continue;

for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)
{

seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));
}
last_allowed_family = family;
}

seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));

if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, ""/tmp"", &seccomp_tmpf, error))
return FALSE;

if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)
return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(""Failed to export bpf""));

lseek (seccomp_tmpf.fd, 0, SEEK_SET);

flatpak_bwrap_add_args_data_fd (bwrap,
""--seccomp"", glnx_steal_fd (&seccomp_tmpf.fd), NULL);

return TRUE;
}","[44, 47, 49, 51, 54, 56, 59, 60, 61, 64, 65, 66, 67, 68, 71, 72, 73, 77, 80, 84, 90, 95, 97, 98, 182, 183, 185, 195, 196, 198]","Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version."
203015," mfr_print(netdissect_options *ndo,
           register const u_char *p, u_int length)
 {
     u_int tlen,idx,hdr_len = 0;
     uint16_t sequence_num;
     uint8_t ie_type,ie_len;
     const uint8_t *tptr;
 
 
  
 
     ND_TCHECK2(*p, 4);  
 
     if ((p[0] & MFR_BEC_MASK) == MFR_CTRL_FRAME && p[1] == 0) {
         ND_PRINT((ndo, ""FRF.16 Control, Flags [%s], %s, length %u"",
                bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK)),
                tok2str(mfr_ctrl_msg_values,""Unknown Message (0x%02x)"",p[2]),
                length));
         tptr = p + 3;
         tlen = length -3;
         hdr_len = 3;
 
         if (!ndo->ndo_vflag)
             return hdr_len;
 
         while (tlen>sizeof(struct ie_tlv_header_t)) {
             ND_TCHECK2(*tptr, sizeof(struct ie_tlv_header_t));
             ie_type=tptr[0];
             ie_len=tptr[1];
 
             ND_PRINT((ndo, ""\n\tIE %s (%u), length %u: "",
                    tok2str(mfr_ctrl_ie_values,""Unknown"",ie_type),
                    ie_type,
                    ie_len));
 
              
             if (ie_type == 0 || ie_len <= sizeof(struct ie_tlv_header_t))
                 return hdr_len;
 
             ND_TCHECK2(*tptr, ie_len);
             tptr+=sizeof(struct ie_tlv_header_t);
              
             ie_len-=sizeof(struct ie_tlv_header_t);
             tlen-=sizeof(struct ie_tlv_header_t);
 
              switch (ie_type) {
  
              case MFR_CTRL_IE_MAGIC_NUM:
                  
                 if (ie_len != 4) {
                     ND_PRINT((ndo, ""(invalid length)""));
                     break;
                 }
                  ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));
                  break;
  
             case MFR_CTRL_IE_BUNDLE_ID:  
             case MFR_CTRL_IE_LINK_ID:
                 for (idx = 0; idx < ie_len && idx < MFR_ID_STRING_MAXLEN; idx++) {
                     if (*(tptr+idx) != 0)  
                         safeputchar(ndo, *(tptr + idx));
                     else
                         break;
                 }
                 break;
 
             case MFR_CTRL_IE_TIMESTAMP:
                 if (ie_len == sizeof(struct timeval)) {
                     ts_print(ndo, (const struct timeval *)tptr);
                     break;
                 }
                  
 
                  
 
             case MFR_CTRL_IE_VENDOR_EXT:
             case MFR_CTRL_IE_CAUSE:
 
             default:
                 if (ndo->ndo_vflag <= 1)
                     print_unknown_data(ndo, tptr, ""\n\t  "", ie_len);
                 break;
             }
 
              
             if (ndo->ndo_vflag > 1 )
                 print_unknown_data(ndo, tptr, ""\n\t  "", ie_len);
 
             tlen-=ie_len;
             tptr+=ie_len;
         }
         return hdr_len;
     }
  
 
     sequence_num = (p[0]&0x1e)<<7 | p[1];
      
     if ((p[0] & MFR_BEC_MASK) == MFR_FRAG_FRAME ||
         (p[0] & MFR_BEC_MASK) == MFR_B_BIT) {
         ND_PRINT((ndo, ""FRF.16 Frag, seq %u, Flags [%s], "",
                sequence_num,
                bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK))));
         hdr_len = 2;
         fr_print(ndo, p+hdr_len,length-hdr_len);
         return hdr_len;
     }
 
      
     ND_PRINT((ndo, ""FRF.16 Frag, seq %u, Flags [%s]"",
            sequence_num,
            bittok2str(frf_flag_values,""none"",(p[0] & MFR_BEC_MASK))));
     print_unknown_data(ndo, p, ""\n\t"", length);
 
     return hdr_len;
 
  trunc:
     ND_PRINT((ndo, ""[|mfr]""));
     return length;
 }","[49, 50, 51, 52, 53]",The FRF.16 parser in tcpdump before 4.9.3 has a buffer over-read in print-fr.c:mfr_print().
207639,"  image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,
    png_byte bit_depth, png_uint_32 x, store_palette palette)
     png_byte bit_depth, png_uint_32 x, store_palette palette,
     const image_pixel *format  )
  {
   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==
    const png_byte sample_depth = (png_byte)(colour_type ==
        PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);
   PNG_CONST unsigned int max = (1U<<sample_depth)-1;
    const unsigned int max = (1U<<sample_depth)-1;
    const int swap16 = (format != 0 && format->swap16);
    const int littleendian = (format != 0 && format->littleendian);
    const int sig_bits = (format != 0 && format->sig_bits);
  
      
     this->palette_index = this->red = this->green = this->blue =
      sample(row, colour_type, bit_depth, x, 0);
       sample(row, colour_type, bit_depth, x, 0, swap16, littleendian);
     this->alpha = max;
     this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =
        sample_depth;
 
   
  if (colour_type == 3)  
  {
 
         
        if (palette != 0)
        {
         PNG_CONST unsigned int i = this->palette_index;
          const unsigned int i = this->palette_index;
  
           this->red = palette[i].red;
           this->green = palette[i].green;
  this->blue = palette[i].blue;
  this->alpha = palette[i].alpha;
  }
  }
 
  else  
 
     {
        unsigned int i = 0;
  
       if ((colour_type & 4) != 0 && format != 0 && format->alpha_first)
       {
          this->alpha = this->red;
           
          this->palette_index = this->red = this->green = this->blue =
             sample(row, colour_type, bit_depth, x, 1, swap16, littleendian);
          i = 1;
       }
 
        if (colour_type & 2)
        {
         this->green = sample(row, colour_type, bit_depth, x, 1);
         this->blue = sample(row, colour_type, bit_depth, x, 2);
         i = 2;
           
          this->green = sample(row, colour_type, bit_depth, x, ++i, swap16,
                  littleendian);
 
          if (format != 0 && format->swap_rgb)  
              this->red = sample(row, colour_type, bit_depth, x, ++i, swap16,
                      littleendian);
          else
              this->blue = sample(row, colour_type, bit_depth, x, ++i, swap16,
                      littleendian);
        }
      if (colour_type & 4)
         this->alpha = sample(row, colour_type, bit_depth, x, ++i);
 
       else   if (format != 0 && format->mono_inverted)
          this->red = this->green = this->blue = this->red ^ max;
 
       if ((colour_type & 4) != 0)  
       {
          if (format == 0 || !format->alpha_first)
              this->alpha = sample(row, colour_type, bit_depth, x, ++i, swap16,
                      littleendian);
 
          if (format != 0 && format->alpha_inverted)
             this->alpha ^= max;
       }
     }
  
      
   image_pixel_setf(this, max);
    image_pixel_setf(this,
       sig_bits ? (1U << format->red_sBIT)-1 : max,
       sig_bits ? (1U << format->green_sBIT)-1 : max,
       sig_bits ? (1U << format->blue_sBIT)-1 : max,
       sig_bits ? (1U << format->alpha_sBIT)-1 : max);
  
      
  this->colour_type = colour_type;
 
     this->bit_depth = bit_depth;
     this->sample_depth = sample_depth;
     this->have_tRNS = 0;
    this->swap_rgb = 0;
    this->alpha_first = 0;
    this->alpha_inverted = 0;
    this->mono_inverted = 0;
    this->swap16 = 0;
    this->littleendian = 0;
    this->sig_bits = 0;
  }","[3, 4, 7, 10, 11, 12, 13, 18, 31, 45, 46, 47, 48, 49, 50, 51, 52, 53, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 89, 90, 91, 92, 93, 101, 102, 103, 104, 105, 106, 107, 2, 6, 9, 17, 30, 56, 57, 58, 70, 71, 88]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
7752,"PQconnectPoll(PGconn *conn)
{
bool  reset_connection_state_machine = false;
bool  need_new_connection = false;
PGresult   *res;
char  sebuf[PG_STRERROR_R_BUFLEN];
int   optval;

if (conn == NULL)
return PGRES_POLLING_FAILED;


switch (conn->status)
{




case CONNECTION_BAD:
return PGRES_POLLING_FAILED;
case CONNECTION_OK:
return PGRES_POLLING_OK;


case CONNECTION_AWAITING_RESPONSE:
case CONNECTION_AUTH_OK:
case CONNECTION_CHECK_WRITABLE:
case CONNECTION_CONSUME:
case CONNECTION_CHECK_STANDBY:
{

int   n = pqReadData(conn);

if (n < 0)
goto error_return;
if (n == 0)
return PGRES_POLLING_READING;

break;
}


case CONNECTION_STARTED:
case CONNECTION_MADE:
break;


case CONNECTION_SSL_STARTUP:
case CONNECTION_NEEDED:
case CONNECTION_GSS_STARTUP:
case CONNECTION_CHECK_TARGET:
break;

default:
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""invalid connection state, probably indicative of memory corruption\n""));
goto error_return;
}


keep_going:



if (conn->try_next_addr)
{
if (conn->addr_cur && conn->addr_cur->ai_next)
{
conn->addr_cur = conn->addr_cur->ai_next;
reset_connection_state_machine = true;
}
else
conn->try_next_host = true;
conn->try_next_addr = false;
}


if (conn->try_next_host)
{
pg_conn_host *ch;
struct addrinfo hint;
int   thisport;
int   ret;
char  portstr[MAXPGPATH];

if (conn->whichhost + 1 < conn->nconnhost)
conn->whichhost++;
else
{









if (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&
conn->nconnhost > 0)
{
conn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;
conn->whichhost = 0;
}
else
goto error_return;
}


release_conn_addrinfo(conn);






ch = &conn->connhost[conn->whichhost];


MemSet(&hint, 0, sizeof(hint));
hint.ai_socktype = SOCK_STREAM;
conn->addrlist_family = hint.ai_family = AF_UNSPEC;


if (ch->port == NULL || ch->port[0] == '\0')
thisport = DEF_PGPORT;
else
{
if (!parse_int_param(ch->port, &thisport, conn, ""port""))
goto error_return;

if (thisport < 1 || thisport > 65535)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""invalid port number: \""%s\""\n""),
ch->port);
goto keep_going;
}
}
snprintf(portstr, sizeof(portstr), ""%d"", thisport);


switch (ch->type)
{
case CHT_HOST_NAME:
ret = pg_getaddrinfo_all(ch->host, portstr, &hint,
&conn->addrlist);
if (ret || !conn->addrlist)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not translate host name \""%s\"" to address: %s\n""),
ch->host, gai_strerror(ret));
goto keep_going;
}
break;

case CHT_HOST_ADDRESS:
hint.ai_flags = AI_NUMERICHOST;
ret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,
&conn->addrlist);
if (ret || !conn->addrlist)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not parse network address \""%s\"": %s\n""),
ch->hostaddr, gai_strerror(ret));
goto keep_going;
}
break;

case CHT_UNIX_SOCKET:
#ifdef HAVE_UNIX_SOCKETS
conn->addrlist_family = hint.ai_family = AF_UNIX;
UNIXSOCK_PATH(portstr, thisport, ch->host);
if (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""Unix-domain socket path \""%s\"" is too long (maximum %d bytes)\n""),
portstr,
(int) (UNIXSOCK_PATH_BUFLEN - 1));
goto keep_going;
}





ret = pg_getaddrinfo_all(NULL, portstr, &hint,
&conn->addrlist);
if (ret || !conn->addrlist)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not translate Unix-domain socket path \""%s\"" to address: %s\n""),
portstr, gai_strerror(ret));
goto keep_going;
}
#else
Assert(false);
#endif
break;
}


conn->addr_cur = conn->addrlist;
reset_connection_state_machine = true;
conn->try_next_host = false;
}


if (reset_connection_state_machine)
{






conn->pversion = PG_PROTOCOL(3, 0);
conn->send_appname = true;
#ifdef USE_SSL

conn->allow_ssl_try = (conn->sslmode[0] != 'd');
conn->wait_ssl_try = (conn->sslmode[0] == 'a');
#endif
#ifdef ENABLE_GSS
conn->try_gss = (conn->gssencmode[0] != 'd');
#endif

reset_connection_state_machine = false;
need_new_connection = true;
}


if (need_new_connection)
{

pqDropConnection(conn, true);


pqDropServerData(conn);


conn->asyncStatus = PGASYNC_IDLE;
conn->xactStatus = PQTRANS_IDLE;
conn->pipelineStatus = PQ_PIPELINE_OFF;
pqClearAsyncResult(conn);


conn->status = CONNECTION_NEEDED;

need_new_connection = false;
}


switch (conn->status)
{
case CONNECTION_NEEDED:
{








{
struct addrinfo *addr_cur = conn->addr_cur;
char  host_addr[NI_MAXHOST];





if (addr_cur == NULL)
{
conn->try_next_host = true;
goto keep_going;
}


memcpy(&conn->raddr.addr, addr_cur->ai_addr,
addr_cur->ai_addrlen);
conn->raddr.salen = addr_cur->ai_addrlen;





if (conn->connip != NULL)
{
free(conn->connip);
conn->connip = NULL;
}
getHostaddr(conn, host_addr, NI_MAXHOST);
if (host_addr[0])
conn->connip = strdup(host_addr);


conn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);
if (conn->sock == PGINVALID_SOCKET)
{
int   errorno = SOCK_ERRNO;







if (addr_cur->ai_next != NULL ||
conn->whichhost + 1 < conn->nconnhost)
{
conn->try_next_addr = true;
goto keep_going;
}
emitHostIdentityInfo(conn, host_addr);
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not create socket: %s\n""),
SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));
goto error_return;
}








emitHostIdentityInfo(conn, host_addr);






if (!IS_AF_UNIX(addr_cur->ai_family))
{
if (!connectNoDelay(conn))
{

conn->try_next_addr = true;
goto keep_going;
}
}
if (!pg_set_noblock(conn->sock))
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not set socket to nonblocking mode: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
conn->try_next_addr = true;
goto keep_going;
}

#ifdef F_SETFD
if (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not set socket to close-on-exec mode: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
conn->try_next_addr = true;
goto keep_going;
}
#endif							/* F_SETFD */

if (!IS_AF_UNIX(addr_cur->ai_family))
{
#ifndef WIN32
int   on = 1;
#endif
int   usekeepalives = useKeepalives(conn);
int   err = 0;

if (usekeepalives < 0)
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""keepalives parameter must be an integer\n""));
err = 1;
}
else if (usekeepalives == 0)
{

}
#ifndef WIN32
else if (setsockopt(conn->sock,
SOL_SOCKET, SO_KEEPALIVE,
(char *) &on, sizeof(on)) < 0)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""%s(%s) failed: %s\n""),
""setsockopt"",
""SO_KEEPALIVE"",
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
err = 1;
}
else if (!setKeepalivesIdle(conn)
|| !setKeepalivesInterval(conn)
|| !setKeepalivesCount(conn))
err = 1;
#else							/* WIN32 */
#ifdef SIO_KEEPALIVE_VALS
else if (!setKeepalivesWin32(conn))
err = 1;
#endif							/* SIO_KEEPALIVE_VALS */
#endif							/* WIN32 */
else if (!setTCPUserTimeout(conn))
err = 1;

if (err)
{
conn->try_next_addr = true;
goto keep_going;
}
}
























conn->sigpipe_so = false;
#ifdef MSG_NOSIGNAL
conn->sigpipe_flag = true;
#else
conn->sigpipe_flag = false;
#endif							/* MSG_NOSIGNAL */

#ifdef SO_NOSIGPIPE
optval = 1;
if (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,
(char *) &optval, sizeof(optval)) == 0)
{
conn->sigpipe_so = true;
conn->sigpipe_flag = false;
}
#endif							/* SO_NOSIGPIPE */





if (connect(conn->sock, addr_cur->ai_addr,
addr_cur->ai_addrlen) < 0)
{
if (SOCK_ERRNO == EINPROGRESS ||
#ifdef WIN32
SOCK_ERRNO == EWOULDBLOCK ||
#endif
SOCK_ERRNO == EINTR)
{





conn->status = CONNECTION_STARTED;
return PGRES_POLLING_WRITING;
}

}
else
{





conn->status = CONNECTION_STARTED;
goto keep_going;
}





connectFailureMessage(conn, SOCK_ERRNO);
conn->try_next_addr = true;
goto keep_going;
}
}

case CONNECTION_STARTED:
{
ACCEPT_TYPE_ARG3 optlen = sizeof(optval);











if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,
(char *) &optval, &optlen) == -1)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not get socket error status: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}
else if (optval != 0)
{





connectFailureMessage(conn, optval);





conn->try_next_addr = true;
goto keep_going;
}


conn->laddr.salen = sizeof(conn->laddr.addr);
if (getsockname(conn->sock,
(struct sockaddr *) &conn->laddr.addr,
&conn->laddr.salen) < 0)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not get client address from socket: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}




conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}

case CONNECTION_MADE:
{
char    *startpacket;
int   packetlen;





if (conn->requirepeer && conn->requirepeer[0] &&
IS_AF_UNIX(conn->raddr.addr.ss_family))
{
#ifndef WIN32
char  pwdbuf[BUFSIZ];
struct passwd pass_buf;
struct passwd *pass;
int   passerr;
#endif
uid_t  uid;
gid_t  gid;

errno = 0;
if (getpeereid(conn->sock, &uid, &gid) != 0)
{




if (errno == ENOSYS)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""requirepeer parameter is not supported on this platform\n""));
else
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not get peer credentials: %s\n""),
strerror_r(errno, sebuf, sizeof(sebuf)));
goto error_return;
}

#ifndef WIN32
passerr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);
if (pass == NULL)
{
if (passerr != 0)
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not look up local user ID %d: %s\n""),
(int) uid,
strerror_r(passerr, sebuf, sizeof(sebuf)));
else
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""local user with ID %d does not exist\n""),
(int) uid);
goto error_return;
}

if (strcmp(pass->pw_name, conn->requirepeer) != 0)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""requirepeer specifies \""%s\"", but actual peer user name is \""%s\""\n""),
conn->requirepeer, pass->pw_name);
goto error_return;
}
#else							/* WIN32 */

Assert(false);
#endif							/* WIN32 */
}

if (IS_AF_UNIX(conn->raddr.addr.ss_family))
{

#ifdef USE_SSL
conn->allow_ssl_try = false;
#endif
#ifdef ENABLE_GSS
conn->try_gss = false;
#endif
}

#ifdef ENABLE_GSS









if (conn->try_gss && !conn->gctx)
conn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);
if (conn->try_gss && !conn->gctx)
{
ProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);

if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not send GSSAPI negotiation packet: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}


conn->status = CONNECTION_GSS_STARTUP;
return PGRES_POLLING_READING;
}
else if (!conn->gctx && conn->gssencmode[0] == 'r')
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\n""));
goto error_return;
}
#endif

#ifdef USE_SSL








if (pqsecure_initialize(conn, false, true) < 0)
goto error_return;






if (conn->allow_ssl_try && !conn->wait_ssl_try &&
!conn->ssl_in_use
#ifdef ENABLE_GSS
&& !conn->gssenc
#endif
)
{
ProtocolVersion pv;








pv = pg_hton32(NEGOTIATE_SSL_CODE);
if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not send SSL negotiation packet: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
goto error_return;
}

conn->status = CONNECTION_SSL_STARTUP;
return PGRES_POLLING_READING;
}
#endif							/* USE_SSL */




startpacket = pqBuildStartupPacket3(conn, &packetlen,
EnvironmentOptions);
if (!startpacket)
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""out of memory\n""));
goto error_return;
}







if (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""could not send startup packet: %s\n""),
SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
free(startpacket);
goto error_return;
}

free(startpacket);

conn->status = CONNECTION_AWAITING_RESPONSE;
return PGRES_POLLING_READING;
}





case CONNECTION_SSL_STARTUP:
{
#ifdef USE_SSL
PostgresPollingStatusType pollres;





if (!conn->ssl_in_use)
{





char  SSLok;
int   rdresult;

rdresult = pqReadData(conn);
if (rdresult < 0)
{

goto error_return;
}
if (rdresult == 0)
{

return PGRES_POLLING_READING;
}
if (pqGetc(&SSLok, conn) < 0)
{

return PGRES_POLLING_READING;
}
if (SSLok == 'S')
{

conn->inStart = conn->inCursor;







if (pqsecure_initialize(conn, true, false) != 0)
goto error_return;
}
else if (SSLok == 'N')
{

conn->inStart = conn->inCursor;

if (conn->sslmode[0] == 'r' ||
conn->sslmode[0] == 'v')

{

appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server does not support SSL, but SSL was required\n""));
goto error_return;
}

conn->allow_ssl_try = false;

conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
else if (SSLok == 'E')
{










conn->status = CONNECTION_AWAITING_RESPONSE;
goto keep_going;
}
else
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""received invalid response to SSL negotiation: %c\n""),
SSLok);
goto error_return;
}
}




pollres = pqsecure_open_client(conn);
if (pollres == PGRES_POLLING_OK)
{

conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
if (pollres == PGRES_POLLING_FAILED)
{




if (conn->sslmode[0] == 'p'
&& conn->allow_ssl_try
&& !conn->wait_ssl_try)
{

conn->allow_ssl_try = false;
need_new_connection = true;
goto keep_going;
}

goto error_return;
}

return pollres;
#else							/* !USE_SSL */

goto error_return;
#endif							/* USE_SSL */
}

case CONNECTION_GSS_STARTUP:
{
#ifdef ENABLE_GSS
PostgresPollingStatusType pollres;





if (conn->try_gss && !conn->gctx)
{
char  gss_ok;
int   rdresult = pqReadData(conn);

if (rdresult < 0)

goto error_return;
else if (rdresult == 0)

return PGRES_POLLING_READING;
if (pqGetc(&gss_ok, conn) < 0)

return PGRES_POLLING_READING;

if (gss_ok == 'E')
{







conn->try_gss = false;
need_new_connection = true;
goto keep_going;
}


conn->inStart = conn->inCursor;

if (gss_ok == 'N')
{

if (conn->gssencmode[0] == 'r')
{
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server doesn't support GSSAPI encryption, but it was required\n""));
goto error_return;
}

conn->try_gss = false;

conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
else if (gss_ok != 'G')
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""received invalid response to GSSAPI negotiation: %c\n""),
gss_ok);
goto error_return;
}
}


pollres = pqsecure_open_gss(conn);
if (pollres == PGRES_POLLING_OK)
{

conn->status = CONNECTION_MADE;
return PGRES_POLLING_WRITING;
}
else if (pollres == PGRES_POLLING_FAILED &&
conn->gssencmode[0] == 'p')
{




conn->try_gss = false;
need_new_connection = true;
goto keep_going;
}
return pollres;
#else							/* !ENABLE_GSS */

goto error_return;
#endif							/* ENABLE_GSS */
}





case CONNECTION_AWAITING_RESPONSE:
{
char  beresp;
int   msgLength;
int   avail;
AuthRequest areq;
int   res;






conn->inCursor = conn->inStart;


if (pqGetc(&beresp, conn))
{

return PGRES_POLLING_READING;
}






if (!(beresp == 'R' || beresp == 'E'))
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""expected authentication request from server, but received %c\n""),
beresp);
goto error_return;
}


if (pqGetInt(&msgLength, 4, conn))
{

return PGRES_POLLING_READING;
}











if (beresp == 'R' && (msgLength < 8 || msgLength > 2000))
{
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""expected authentication request from server, but received %c\n""),
beresp);
goto error_return;
}

if (beresp == 'E' && (msgLength < 8 || msgLength > 30000))
{

conn->inCursor = conn->inStart + 1;
if (pqGets_append(&conn->errorMessage, conn))
{

return PGRES_POLLING_READING;
}

conn->inStart = conn->inCursor;






if (conn->errorMessage.len == 0 ||
conn->errorMessage.data[conn->errorMessage.len - 1] != '\n')
{
appendPQExpBufferChar(&conn->errorMessage, '\n');
}

goto error_return;
}




msgLength -= 4;
avail = conn->inEnd - conn->inCursor;
if (avail < msgLength)
{





if (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,
conn))
goto error_return;

return PGRES_POLLING_READING;
}


if (beresp == 'E')
{
if (pqGetErrorNotice3(conn, true))
{

return PGRES_POLLING_READING;
}

conn->inStart = conn->inCursor;








if (strcmp(conn->last_sqlstate,
ERRCODE_CANNOT_CONNECT_NOW) == 0)
{
conn->try_next_host = true;
goto keep_going;
}


pgpassfileWarning(conn);

#ifdef ENABLE_GSS





if (conn->gssenc && conn->gssencmode[0] == 'p')
{

conn->try_gss = false;
need_new_connection = true;
goto keep_going;
}
#endif

#ifdef USE_SSL





if (conn->sslmode[0] == 'a'
&& !conn->ssl_in_use
&& conn->allow_ssl_try
&& conn->wait_ssl_try)
{

conn->wait_ssl_try = false;
need_new_connection = true;
goto keep_going;
}





if (conn->sslmode[0] == 'p'
&& conn->ssl_in_use
&& conn->allow_ssl_try
&& !conn->wait_ssl_try)
{

conn->allow_ssl_try = false;
need_new_connection = true;
goto keep_going;
}
#endif

goto error_return;
}


conn->auth_req_received = true;


if (pqGetInt((int *) &areq, 4, conn))
{

return PGRES_POLLING_READING;
}
msgLength -= 4;








res = pg_fe_sendauth(areq, msgLength, conn);


conn->inStart = conn->inCursor;

if (res != STATUS_OK)
goto error_return;






if (pqFlush(conn))
goto error_return;

if (areq == AUTH_REQ_OK)
{

conn->status = CONNECTION_AUTH_OK;






conn->asyncStatus = PGASYNC_BUSY;
}


goto keep_going;
}

case CONNECTION_AUTH_OK:
{












if (PQisBusy(conn))
return PGRES_POLLING_READING;

res = PQgetResult(conn);





if (res)
{
if (res->resultStatus != PGRES_FATAL_ERROR)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""unexpected message from server during startup\n""));
else if (conn->send_appname &&
(conn->appname || conn->fbappname))
{










const char *sqlstate;

sqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);
if (sqlstate &&
strcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)
{
PQclear(res);
conn->send_appname = false;
need_new_connection = true;
goto keep_going;
}
}







if (conn->errorMessage.len <= 0 ||
conn->errorMessage.data[conn->errorMessage.len - 1] != '\n')
appendPQExpBufferChar(&conn->errorMessage, '\n');
PQclear(res);
goto error_return;
}


conn->status = CONNECTION_CHECK_TARGET;
goto keep_going;
}

case CONNECTION_CHECK_TARGET:
{




if (conn->target_server_type == SERVER_TYPE_READ_WRITE ||
conn->target_server_type == SERVER_TYPE_READ_ONLY)
{
bool  read_only_server;








if (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||
conn->in_hot_standby == PG_BOOL_UNKNOWN)
{






conn->status = CONNECTION_OK;
if (!PQsendQueryContinue(conn,
""SHOW transaction_read_only""))
goto error_return;

conn->status = CONNECTION_CHECK_WRITABLE;
return PGRES_POLLING_READING;
}


read_only_server =
(conn->default_transaction_read_only == PG_BOOL_YES ||
conn->in_hot_standby == PG_BOOL_YES);

if ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?
read_only_server : !read_only_server)
{

if (conn->target_server_type == SERVER_TYPE_READ_WRITE)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""session is read-only\n""));
else
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""session is not read-only\n""));


conn->status = CONNECTION_OK;
sendTerminateConn(conn);





conn->try_next_host = true;
goto keep_going;
}
}
else if (conn->target_server_type == SERVER_TYPE_PRIMARY ||
conn->target_server_type == SERVER_TYPE_STANDBY ||
conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)
{








if (conn->sversion < 90000)
conn->in_hot_standby = PG_BOOL_NO;

if (conn->in_hot_standby == PG_BOOL_UNKNOWN)
{






conn->status = CONNECTION_OK;
if (!PQsendQueryContinue(conn,
""SELECT pg_catalog.pg_is_in_recovery()""))
goto error_return;

conn->status = CONNECTION_CHECK_STANDBY;
return PGRES_POLLING_READING;
}


if ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?
(conn->in_hot_standby == PG_BOOL_YES) :
(conn->in_hot_standby == PG_BOOL_NO))
{

if (conn->target_server_type == SERVER_TYPE_PRIMARY)
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server is in hot standby mode\n""));
else
appendPQExpBufferStr(&conn->errorMessage,
libpq_gettext(""server is not in hot standby mode\n""));


conn->status = CONNECTION_OK;
sendTerminateConn(conn);





conn->try_next_host = true;
goto keep_going;
}
}


release_conn_addrinfo(conn);






resetPQExpBuffer(&conn->errorMessage);


conn->status = CONNECTION_OK;
return PGRES_POLLING_OK;
}

case CONNECTION_CONSUME:
{








conn->status = CONNECTION_OK;
if (!PQconsumeInput(conn))
goto error_return;

if (PQisBusy(conn))
{
conn->status = CONNECTION_CONSUME;
return PGRES_POLLING_READING;
}


res = PQgetResult(conn);
if (res != NULL)
{
PQclear(res);
conn->status = CONNECTION_CONSUME;
return PGRES_POLLING_READING;
}

conn->status = CONNECTION_CHECK_TARGET;
goto keep_going;
}

case CONNECTION_CHECK_WRITABLE:
{





conn->status = CONNECTION_OK;
if (!PQconsumeInput(conn))
goto error_return;

if (PQisBusy(conn))
{
conn->status = CONNECTION_CHECK_WRITABLE;
return PGRES_POLLING_READING;
}

res = PQgetResult(conn);
if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&
PQntuples(res) == 1)
{
char    *val = PQgetvalue(res, 0, 0);










if (strncmp(val, ""on"", 2) == 0)
{
conn->default_transaction_read_only = PG_BOOL_YES;
conn->in_hot_standby = PG_BOOL_YES;
}
else
{
conn->default_transaction_read_only = PG_BOOL_NO;
conn->in_hot_standby = PG_BOOL_NO;
}
PQclear(res);


conn->status = CONNECTION_CONSUME;
goto keep_going;
}


if (res)
PQclear(res);


appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""\""%s\"" failed\n""),
""SHOW transaction_read_only"");


conn->status = CONNECTION_OK;
sendTerminateConn(conn);


conn->try_next_host = true;
goto keep_going;
}

case CONNECTION_CHECK_STANDBY:
{





conn->status = CONNECTION_OK;
if (!PQconsumeInput(conn))
goto error_return;

if (PQisBusy(conn))
{
conn->status = CONNECTION_CHECK_STANDBY;
return PGRES_POLLING_READING;
}

res = PQgetResult(conn);
if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&
PQntuples(res) == 1)
{
char    *val = PQgetvalue(res, 0, 0);

if (strncmp(val, ""t"", 1) == 0)
conn->in_hot_standby = PG_BOOL_YES;
else
conn->in_hot_standby = PG_BOOL_NO;
PQclear(res);


conn->status = CONNECTION_CONSUME;
goto keep_going;
}


if (res)
PQclear(res);


appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""\""%s\"" failed\n""),
""SELECT pg_is_in_recovery()"");


conn->status = CONNECTION_OK;
sendTerminateConn(conn);


conn->try_next_host = true;
goto keep_going;
}

default:
appendPQExpBuffer(&conn->errorMessage,
libpq_gettext(""invalid connection state %d, ""
""probably indicative of memory corruption\n""),
conn->status);
goto error_return;
}



error_return:








conn->status = CONNECTION_BAD;
return PGRES_POLLING_FAILED;
}","[856, 955]","A man-in-the-middle attacker can inject false responses to the client's first few queries, despite the use of SSL certificate verification and encryption."
201274," int yr_re_ast_create(
     RE_AST** re_ast)
 {
   *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
 
   if (*re_ast == NULL)
      return ERROR_INSUFFICIENT_MEMORY;
  
    (*re_ast)->flags = 0;
   (*re_ast)->levels = 0;
    (*re_ast)->root_node = NULL;
  
    return ERROR_SUCCESS;
 }",[10],libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule that is mishandled in the _yr_re_emit function.
208153," status_t OMXNodeInstance::configureVideoTunnelMode(
 
          OMX_U32 portIndex, OMX_BOOL tunneled, OMX_U32 audioHwSync,
          native_handle_t **sidebandHandle) {
      Mutex::Autolock autolock(mLock);
     if (mSailed) {
         android_errorWriteLog(0x534e4554, ""29422020"");
         return INVALID_OPERATION;
     }
      CLOG_CONFIG(configureVideoTunnelMode, ""%s:%u tun=%d sync=%u"",
              portString(portIndex), portIndex, tunneled, audioHwSync);
  
     OMX_INDEXTYPE index;
     OMX_STRING name = const_cast<OMX_STRING>(
  ""OMX.google.android.index.configureVideoTunnelMode"");
 
     OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);
  if (err != OMX_ErrorNone) {
         CLOG_ERROR_IF(tunneled, getExtensionIndex, err, ""%s"", name);
  return StatusFromOMXError(err);
  }
 
  ConfigureVideoTunnelModeParams tunnelParams;
  InitOMXParams(&tunnelParams);
     tunnelParams.nPortIndex = portIndex;
     tunnelParams.bTunneled = tunneled;
     tunnelParams.nAudioHwSync = audioHwSync;
     err = OMX_SetParameter(mHandle, index, &tunnelParams);
  if (err != OMX_ErrorNone) {
         CLOG_ERROR(setParameter, err, ""%s(%#x): %s:%u tun=%d sync=%u"", name, index,
                 portString(portIndex), portIndex, tunneled, audioHwSync);
  return StatusFromOMXError(err);
  }
 
     err = OMX_GetParameter(mHandle, index, &tunnelParams);
  if (err != OMX_ErrorNone) {
         CLOG_ERROR(getParameter, err, ""%s(%#x): %s:%u tun=%d sync=%u"", name, index,
                 portString(portIndex), portIndex, tunneled, audioHwSync);
  return StatusFromOMXError(err);
  }
  if (sidebandHandle) {
  *sidebandHandle = (native_handle_t*)tunnelParams.pSidebandWindow;
  }
 
  return OK;
 }","[6, 7, 8, 9]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
199915," static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)
 {
 	while (elements-- > 0) {
 		zval *key, *data, **old_data;
 
 		ALLOC_INIT_ZVAL(key);
 
 		if (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {
 			zval_dtor(key);
 			FREE_ZVAL(key);
 			return 0;
 		}
 
 		if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {
 			zval_dtor(key);
 			FREE_ZVAL(key);
 			return 0;
 		}
 
 		ALLOC_INIT_ZVAL(data);
 
 		if (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {
 			zval_dtor(key);
 			FREE_ZVAL(key);
 			zval_dtor(data);
 			FREE_ZVAL(data);
 			return 0;
 		}
 
 		if (!objprops) {
 			switch (Z_TYPE_P(key)) {
 			case IS_LONG:
 				if (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {
 					var_push_dtor(var_hash, old_data);
 				}
 				zend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);
 				break;
 			case IS_STRING:
 				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
 					var_push_dtor(var_hash, old_data);
 				}
 				zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);
 				break;
 			}
  		} else {
  			 
  			convert_to_string(key);
			if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
 			if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
  				var_push_dtor(var_hash, old_data);
  			}
  			zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,
 					sizeof data, NULL);
 		}
 		
 		zval_dtor(key);
 		FREE_ZVAL(key);
 
 		if (elements && *(*p-1) != ';' && *(*p-1) != '}') {
 			(*p)--;
 			return 0;
 		}
 	}","[49, 48]","Use-after-free vulnerability in the process_nested_data function in ext/standard/var_unserializer.re in PHP before 5.4.37, 5.5.x before 5.5.21, and 5.6.x before 5.6.5 allows remote attackers to execute arbitrary code via a crafted unserialize call that leverages improper handling of duplicate numerical keys within the serialized properties of an object.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-8142."
6321,"void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) {
mpz_t xdiff, ydiff, lambda;
mpz_inits(xdiff, ydiff, lambda, NULL);


mpz_sub(ydiff, op2->y, op1->y);
mpz_sub(xdiff, op2->x, op1->x);
mpz_invert(xdiff, xdiff, curve->p);
mpz_mul(lambda, ydiff, xdiff);
mpz_mod(lambda, lambda, curve->p);


mpz_mul(rop->x, lambda, lambda);
mpz_sub(rop->x, rop->x, op1->x);
mpz_sub(rop->x, rop->x, op2->x);
mpz_mod(rop->x, rop->x, curve->p);


mpz_sub(rop->y, op1->x, rop->x);
mpz_mul(rop->y, lambda, rop->y);
mpz_sub(rop->y, rop->y, op1->y);
mpz_mod(rop->y, rop->y, curve->p);

mpz_clears(xdiff, ydiff, lambda, NULL);
}",[24],"An issue was discovered in fastecdsa before 2.1.2. When using the NIST P-256 curve in the ECDSA implementation, the point at infinity is mishandled. This means that for an extreme value in k and s^-1, the signature verification fails even if the signature is correct. This behavior is not solely a usability problem. There are some threat models where an attacker can benefit by successfully guessing users for whom signature verification will fail."
207824," int Track::Info::Copy(Info& dst) const {
  if (&dst == this)
  return 0;
 
   dst.type = type;
   dst.number = number;
   dst.defaultDuration = defaultDuration;
   dst.codecDelay = codecDelay;
   dst.seekPreRoll = seekPreRoll;
   dst.uid = uid;
   dst.lacing = lacing;
   dst.settings = settings;
 
 
  if (int status = CopyStr(&Info::nameAsUTF8, dst))
  return status;
 
  if (int status = CopyStr(&Info::language, dst))
  return status;
 
  if (int status = CopyStr(&Info::codecId, dst))
  return status;
 
  if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
  return status;
 
  if (codecPrivateSize > 0) {
  if (codecPrivate == NULL)
  return -1;
 
  if (dst.codecPrivate)
  return -1;
 
 
      if (dst.codecPrivateSize != 0)
        return -1;
  
    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
     dst.codecPrivate = SafeArrayAlloc<unsigned char>(1, codecPrivateSize);
  
      if (dst.codecPrivate == NULL)
        return -1;
 
     memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
     dst.codecPrivateSize = codecPrivateSize;
  }
 
  return 0;
 }","[39, 38]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
206911," void RenderThreadImpl::Init(
     const scoped_refptr<base::SingleThreadTaskRunner>& resource_task_queue) {
   TRACE_EVENT0(""startup"", ""RenderThreadImpl::Init"");
 
   base::trace_event::TraceLog::GetInstance()->SetThreadSortIndex(
       base::PlatformThread::CurrentId(),
       kTraceEventRendererMainThreadSortIndex);
 
 #if BUILDFLAG(USE_EXTERNAL_POPUP_MENU)
   blink::WebView::SetUseExternalPopupMenus(true);
 #endif
 
   lazy_tls.Pointer()->Set(this);
 
   ChildProcess::current()->set_main_thread(this);
 
   metrics::InitializeSingleSampleMetricsFactory(
       base::BindRepeating(&CreateSingleSampleMetricsProvider,
                           message_loop()->task_runner(), GetConnector()));
 
   gpu_ = ui::Gpu::Create(
       GetConnector(),
       IsRunningInMash() ? ui::mojom::kServiceName : mojom::kBrowserServiceName,
       GetIOTaskRunner());
 
   viz::mojom::SharedBitmapAllocationNotifierPtr
       shared_bitmap_allocation_notifier_ptr;
   GetConnector()->BindInterface(
       mojom::kBrowserServiceName,
       mojo::MakeRequest(&shared_bitmap_allocation_notifier_ptr));
   shared_bitmap_manager_ = std::make_unique<viz::ClientSharedBitmapManager>(
       viz::mojom::ThreadSafeSharedBitmapAllocationNotifierPtr::Create(
           shared_bitmap_allocation_notifier_ptr.PassInterface(),
           GetChannel()->ipc_task_runner_refptr()));
 
   notification_dispatcher_ =
       new NotificationDispatcher(thread_safe_sender());
   AddFilter(notification_dispatcher_->GetFilter());
 
   resource_dispatcher_.reset(new ResourceDispatcher(
       this, message_loop()->task_runner()));
   resource_message_filter_ =
       new ChildResourceMessageFilter(resource_dispatcher_.get());
   AddFilter(resource_message_filter_.get());
   quota_message_filter_ =
       new QuotaMessageFilter(thread_safe_sender());
   quota_dispatcher_.reset(new QuotaDispatcher(thread_safe_sender(),
                                               quota_message_filter_.get()));
 
   AddFilter(quota_message_filter_->GetFilter());
 
   auto registry = std::make_unique<service_manager::BinderRegistry>();
   BlinkInterfaceRegistryImpl interface_registry(registry->GetWeakPtr());
 
   InitializeWebKit(resource_task_queue, &interface_registry);
   blink_initialized_time_ = base::TimeTicks::Now();
 
   webkit_shared_timer_suspended_ = false;
   widget_count_ = 0;
   hidden_widget_count_ = 0;
   idle_notification_delay_in_ms_ = kInitialIdleHandlerDelayMs;
   idle_notifications_to_skip_ = 0;
 
   appcache_dispatcher_.reset(
       new AppCacheDispatcher(Get(), new AppCacheFrontendImpl()));
   dom_storage_dispatcher_.reset(new DomStorageDispatcher());
   main_thread_indexed_db_dispatcher_.reset(new IndexedDBDispatcher());
   main_thread_cache_storage_dispatcher_.reset(
       new CacheStorageDispatcher(thread_safe_sender()));
   file_system_dispatcher_.reset(new FileSystemDispatcher());
 
   resource_dispatch_throttler_.reset(new ResourceDispatchThrottler(
       static_cast<RenderThread*>(this), renderer_scheduler_.get(),
       base::TimeDelta::FromSecondsD(kThrottledResourceRequestFlushPeriodS),
       kMaxResourceRequestsPerFlushWhenThrottled));
   resource_dispatcher_->set_message_sender(resource_dispatch_throttler_.get());
 
   blob_message_filter_ = new BlobMessageFilter(GetFileThreadTaskRunner());
   AddFilter(blob_message_filter_.get());
   vc_manager_.reset(new VideoCaptureImplManager());
 
   browser_plugin_manager_.reset(new BrowserPluginManager());
   AddObserver(browser_plugin_manager_.get());
 
 #if BUILDFLAG(ENABLE_WEBRTC)
   peer_connection_tracker_.reset(new PeerConnectionTracker());
   AddObserver(peer_connection_tracker_.get());
 
   p2p_socket_dispatcher_ = new P2PSocketDispatcher(GetIOTaskRunner().get());
   AddFilter(p2p_socket_dispatcher_.get());
 
   peer_connection_factory_.reset(
       new PeerConnectionDependencyFactory(p2p_socket_dispatcher_.get()));
 
   aec_dump_message_filter_ = new AecDumpMessageFilter(
       GetIOTaskRunner(), message_loop()->task_runner());
 
   AddFilter(aec_dump_message_filter_.get());
 
 #endif   
 
   audio_input_message_filter_ = new AudioInputMessageFilter(GetIOTaskRunner());
   AddFilter(audio_input_message_filter_.get());
 
   scoped_refptr<AudioMessageFilter> audio_message_filter;
   if (!base::FeatureList::IsEnabled(
           features::kUseMojoAudioOutputStreamFactory)) {
     audio_message_filter =
         base::MakeRefCounted<AudioMessageFilter>(GetIOTaskRunner());
     AddFilter(audio_message_filter.get());
   }
 
   audio_ipc_factory_.emplace(std::move(audio_message_filter),
                              GetIOTaskRunner());
 
   midi_message_filter_ = new MidiMessageFilter(GetIOTaskRunner());
   AddFilter(midi_message_filter_.get());
 
   AddFilter((new CacheStorageMessageFilter(thread_safe_sender()))->GetFilter());
 
   AddFilter((new ServiceWorkerContextMessageFilter())->GetFilter());
 
 
 #if defined(USE_AURA)
   if (IsRunningInMash()) {
     CreateRenderWidgetWindowTreeClientFactory(GetServiceManagerConnection());
   }
 #endif
 
   registry->AddInterface(base::Bind(&SharedWorkerFactoryImpl::Create),
                          base::ThreadTaskRunnerHandle::Get());
   GetServiceManagerConnection()->AddConnectionFilter(
       std::make_unique<SimpleConnectionFilter>(std::move(registry)));
 
   {
     auto registry_with_source_info =
         std::make_unique<service_manager::BinderRegistryWithArgs<
             const service_manager::BindSourceInfo&>>();
     registry_with_source_info->AddInterface(
         base::Bind(&CreateFrameFactory), base::ThreadTaskRunnerHandle::Get());
     GetServiceManagerConnection()->AddConnectionFilter(
         std::make_unique<SimpleConnectionFilterWithSourceInfo>(
             std::move(registry_with_source_info)));
   }
 
   GetContentClient()->renderer()->RenderThreadStarted();
 
   StartServiceManagerConnection();
 
   GetAssociatedInterfaceRegistry()->AddInterface(
       base::Bind(&RenderThreadImpl::OnRendererInterfaceRequest,
                  base::Unretained(this)));
 
   InitSkiaEventTracer();
   base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(
       skia::SkiaMemoryDumpProvider::GetInstance(), ""Skia"", nullptr);
 
   const base::CommandLine& command_line =
       *base::CommandLine::ForCurrentProcess();
 
 #if defined(ENABLE_IPC_FUZZER)
   if (command_line.HasSwitch(switches::kIpcDumpDirectory)) {
     base::FilePath dump_directory =
         command_line.GetSwitchValuePath(switches::kIpcDumpDirectory);
     IPC::ChannelProxy::OutgoingMessageFilter* filter =
         LoadExternalIPCDumper(dump_directory);
     GetChannel()->set_outgoing_message_filter(filter);
   }
 #endif
 
   cc::SetClientNameForMetrics(""Renderer"");
 
   is_threaded_animation_enabled_ =
       !command_line.HasSwitch(cc::switches::kDisableThreadedAnimation);
 
   is_zero_copy_enabled_ = command_line.HasSwitch(switches::kEnableZeroCopy);
   is_partial_raster_enabled_ =
       !command_line.HasSwitch(switches::kDisablePartialRaster);
   is_gpu_memory_buffer_compositor_resources_enabled_ = command_line.HasSwitch(
       switches::kEnableGpuMemoryBufferCompositorResources);
 
 #if defined(OS_MACOSX)
   is_elastic_overscroll_enabled_ = true;
 #else
   is_elastic_overscroll_enabled_ = false;
 #endif
 
   std::string image_texture_target_string =
       command_line.GetSwitchValueASCII(switches::kContentImageTextureTarget);
   buffer_to_texture_target_map_ =
       viz::StringToBufferToTextureTargetMap(image_texture_target_string);
 
   if (command_line.HasSwitch(switches::kDisableLCDText)) {
     is_lcd_text_enabled_ = false;
   } else if (command_line.HasSwitch(switches::kEnableLCDText)) {
     is_lcd_text_enabled_ = true;
   } else {
 #if defined(OS_ANDROID)
     is_lcd_text_enabled_ = false;
 #else
     is_lcd_text_enabled_ = true;
 #endif
   }
 
   if (command_line.HasSwitch(switches::kDisableGpuCompositing))
     is_gpu_compositing_disabled_ = true;
 
   is_gpu_rasterization_forced_ =
       command_line.HasSwitch(switches::kForceGpuRasterization);
   is_async_worker_context_enabled_ =
       command_line.HasSwitch(switches::kEnableGpuAsyncWorkerContext);
 
   if (command_line.HasSwitch(switches::kGpuRasterizationMSAASampleCount)) {
     std::string string_value = command_line.GetSwitchValueASCII(
         switches::kGpuRasterizationMSAASampleCount);
     bool parsed_msaa_sample_count =
         base::StringToInt(string_value, &gpu_rasterization_msaa_sample_count_);
     DCHECK(parsed_msaa_sample_count) << string_value;
     DCHECK_GE(gpu_rasterization_msaa_sample_count_, 0);
   } else {
     gpu_rasterization_msaa_sample_count_ = -1;
   }
 
   if (command_line.HasSwitch(switches::kDisableDistanceFieldText)) {
     is_distance_field_text_enabled_ = false;
   } else if (command_line.HasSwitch(switches::kEnableDistanceFieldText)) {
     is_distance_field_text_enabled_ = true;
   } else {
     is_distance_field_text_enabled_ = false;
   }
 
   WebRuntimeFeatures::EnableCompositorImageAnimations(
       command_line.HasSwitch(switches::kEnableCompositorImageAnimations));
 
   media::InitializeMediaLibrary();
 
 #if defined(OS_ANDROID)
   if (!command_line.HasSwitch(switches::kDisableAcceleratedVideoDecode) &&
       media::MediaCodecUtil::IsMediaCodecAvailable()) {
     media::EnablePlatformDecoderSupport();
   }
 #endif
 
   memory_pressure_listener_.reset(new base::MemoryPressureListener(
       base::Bind(&RenderThreadImpl::OnMemoryPressure, base::Unretained(this)),
       base::Bind(&RenderThreadImpl::OnSyncMemoryPressure,
                  base::Unretained(this))));
 
   if (base::FeatureList::IsEnabled(features::kMemoryCoordinator)) {
     base::MemoryPressureListener::SetNotificationsSuppressed(true);
 
     mojom::MemoryCoordinatorHandlePtr parent_coordinator;
     GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                   mojo::MakeRequest(&parent_coordinator));
     memory_coordinator_ = CreateChildMemoryCoordinator(
         std::move(parent_coordinator), this);
   }
 
   int num_raster_threads = 0;
   std::string string_value =
       command_line.GetSwitchValueASCII(switches::kNumRasterThreads);
   bool parsed_num_raster_threads =
       base::StringToInt(string_value, &num_raster_threads);
   DCHECK(parsed_num_raster_threads) << string_value;
   DCHECK_GT(num_raster_threads, 0);
 
   categorized_worker_pool_->Start(num_raster_threads);
 
   discardable_memory::mojom::DiscardableSharedMemoryManagerPtr manager_ptr;
   if (IsRunningInMash()) {
 #if defined(USE_AURA)
     GetServiceManagerConnection()->GetConnector()->BindInterface(
         ui::mojom::kServiceName, &manager_ptr);
 #else
     NOTREACHED();
 #endif
   } else {
     ChildThread::Get()->GetConnector()->BindInterface(
         mojom::kBrowserServiceName, mojo::MakeRequest(&manager_ptr));
   }
 
   discardable_shared_memory_manager_ = std::make_unique<
       discardable_memory::ClientDiscardableSharedMemoryManager>(
       std::move(manager_ptr), GetIOTaskRunner());
 
   base::DiscardableMemoryAllocator::SetInstance(
       discardable_shared_memory_manager_.get());
 
   GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                 mojo::MakeRequest(&storage_partition_service_));
 
 #if defined(OS_LINUX)
   ChildProcess::current()->SetIOThreadPriority(base::ThreadPriority::DISPLAY);
   ChildThreadImpl::current()->SetThreadPriority(
       categorized_worker_pool_->background_worker_thread_id(),
       base::ThreadPriority::BACKGROUND);
 #endif
 
   process_foregrounded_count_ = 0;
   needs_to_record_first_active_paint_ = false;
   was_backgrounded_time_ = base::TimeTicks::Min();
 
   base::MemoryCoordinatorClientRegistry::GetInstance()->Register(this);
 
    if (!command_line.HasSwitch(switches::kSingleProcess))
      base::SequencedWorkerPool::EnableForProcess();
  
  EVP_set_buggy_rsa_parser(
      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
    GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                  mojo::MakeRequest(&frame_sink_provider_));
  
   if (!is_gpu_compositing_disabled_) {
     GetConnector()->BindInterface(
         mojom::kBrowserServiceName,
         mojo::MakeRequest(&compositing_mode_reporter_));
 
     viz::mojom::CompositingModeWatcherPtr watcher_ptr;
     compositing_mode_watcher_binding_.Bind(mojo::MakeRequest(&watcher_ptr));
     compositing_mode_reporter_->AddCompositingModeWatcher(
         std::move(watcher_ptr));
   }
 }","[308, 309]",Inappropriate implementation in BoringSSL SPAKE2 in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to leak the low-order bits of SHA512(password) by inspecting protocol traffic.
198887," static void encode_share_access(struct xdr_stream *xdr, int open_flags)
 static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode)
  {
  	__be32 *p;
  
  	RESERVE_SPACE(8);
	switch (open_flags & (FMODE_READ|FMODE_WRITE)) {
 	switch (fmode & (FMODE_READ|FMODE_WRITE)) {
  		case FMODE_READ:
  			WRITE32(NFS4_SHARE_ACCESS_READ);
  			break;
 		case FMODE_WRITE:
 			WRITE32(NFS4_SHARE_ACCESS_WRITE);
 			break;
 		case FMODE_READ|FMODE_WRITE:
  			WRITE32(NFS4_SHARE_ACCESS_BOTH);
  			break;
  		default:
			BUG();
 			WRITE32(0);
  	}
  	WRITE32(0);		 
  }","[2, 8, 20, 7, 19]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
205063," void RenderProcessHostImpl::OnCompositorSurfaceBuffersSwappedNoHost(
       int32 surface_id,
       uint64 surface_handle,
       int32 route_id,
       const gfx::Size& size,
       int32 gpu_process_host_id) {
   TRACE_EVENT0(""renderer_host"",
                 ""RenderWidgetHostImpl::OnCompositorSurfaceBuffersSwappedNoHost"");
    RenderWidgetHostImpl::AcknowledgeBufferPresent(route_id,
                                                   gpu_process_host_id,
                                                 false,
                                                  surface_handle,
                                                   0);
  }","[12, 11]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
200025," xfs_attr_shortform_list(xfs_attr_list_context_t *context)
 {
 	attrlist_cursor_kern_t *cursor;
 	xfs_attr_sf_sort_t *sbuf, *sbp;
 	xfs_attr_shortform_t *sf;
 	xfs_attr_sf_entry_t *sfe;
 	xfs_inode_t *dp;
 	int sbsize, nsbuf, count, i;
 	int error;
 
 	ASSERT(context != NULL);
 	dp = context->dp;
 	ASSERT(dp != NULL);
 	ASSERT(dp->i_afp != NULL);
 	sf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;
 	ASSERT(sf != NULL);
 	if (!sf->hdr.count)
 		return 0;
 	cursor = context->cursor;
 	ASSERT(cursor != NULL);
 
 	trace_xfs_attr_list_sf(context);
 
 	 
 	if (context->bufsize == 0 ||
 	    (XFS_ISRESET_CURSOR(cursor) &&
              (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {
 		for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
 			error = context->put_listent(context,
 					   sfe->flags,
 					   sfe->nameval,
 					   (int)sfe->namelen,
 					   (int)sfe->valuelen,
 					   &sfe->nameval[sfe->namelen]);
 
 			 
 			if (context->seen_enough)
 				break;
 
 			if (error)
 				return error;
 			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
 		}
 		trace_xfs_attr_list_sf_all(context);
 		return 0;
 	}
 
 	 
 	if (context->bufsize == 0)
 		return 0;
 
 	 
 	sbsize = sf->hdr.count * sizeof(*sbuf);
 	sbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);
 
 	 
 	nsbuf = 0;
 	for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
 		if (unlikely(
 		    ((char *)sfe < (char *)sf) ||
 		    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {
 			XFS_CORRUPTION_ERROR(""xfs_attr_shortform_list"",
 					     XFS_ERRLEVEL_LOW,
 					     context->dp->i_mount, sfe);
 			kmem_free(sbuf);
 			return -EFSCORRUPTED;
 		}
 
 		sbp->entno = i;
 		sbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);
 		sbp->name = sfe->nameval;
 		sbp->namelen = sfe->namelen;
 		 
 		sbp->valuelen = sfe->valuelen;
 		sbp->flags = sfe->flags;
 		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
 		sbp++;
 		nsbuf++;
 	}
 
 	 
 	xfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);
 
 	 
 	count = 0;
 	cursor->initted = 1;
 	cursor->blkno = 0;
 	for (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {
 		if (sbp->hash == cursor->hashval) {
 			if (cursor->offset == count) {
 				break;
 			}
 			count++;
 		} else if (sbp->hash > cursor->hashval) {
 			break;
 		}
 	}
 	if (i == nsbuf) {
 		kmem_free(sbuf);
 		return 0;
 	}
 
 	 
 	for ( ; i < nsbuf; i++, sbp++) {
 		if (cursor->hashval != sbp->hash) {
 			cursor->hashval = sbp->hash;
 			cursor->offset = 0;
 		}
 		error = context->put_listent(context,
 					sbp->flags,
 					sbp->name,
  					sbp->namelen,
  					sbp->valuelen,
  					&sbp->name[sbp->namelen]);
		if (error)
 		if (error) {
 			kmem_free(sbuf);
  			return error;
 		}
  		if (context->seen_enough)
  			break;
  		cursor->offset++;
 	}
 
 	kmem_free(sbuf);
 	return 0;
 }","[116, 117, 119, 115]",Multiple memory leaks in error paths in fs/xfs/xfs_attr_list.c in the Linux kernel before 4.5.1 allow local users to cause a denial of service (memory consumption) via crafted XFS filesystem operations.
7824,"static void launch(OpKernelContext* context, bool cudnn_use_autotune,
const Tensor& input, const Tensor& filter,
const std::array<int64, 3>& dilations,
const std::array<int64, 3>& strides, const Padding padding,
TensorFormat data_format, Tensor* output) {
OP_REQUIRES(context, data_format == FORMAT_NHWC,
errors::InvalidArgument(""CPU implementation of Conv3D ""
""currently only supports the NHWC ""
""tensor format.""));
OP_REQUIRES(context,
dilations[0] == 1 && dilations[1] == 1 && dilations[2] == 1,
errors::InvalidArgument(""CPU implementation of Conv3D ""
""currently only supports dilated rates ""
""of 1.""));
functor::CuboidConvolution<CPUDevice, T>()(
context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),
input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],
strides[0], BrainPadding2EigenPadding(padding));
}",[15],"TensorFlow is an end-to-end open source platform for machine learning. A malicious user could trigger a division by 0 in `Conv3D` implementation. The implementation(https://github.com/tensorflow/tensorflow/blob/42033603003965bffac51ae171b51801565e002d/tensorflow/core/kernels/conv_ops_3d.cc#L143-L145) does a modulo operation based on user controlled input. Thus, when `filter` has a 0 as the fifth element, this results in a division by 0. Additionally, if the shape of the two tensors is not valid, an Eigen assertion can be triggered, resulting in a program crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
199080," SYSCALL_DEFINE1(inotify_init1, int, flags)
 {
 	struct fsnotify_group *group;
 	struct user_struct *user;
 	int ret;
 
 	 
 	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
 	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);
 
 	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
 		return -EINVAL;
 
 	user = get_current_user();
 	if (unlikely(atomic_read(&user->inotify_devs) >=
 			inotify_max_user_instances)) {
 		ret = -EMFILE;
 		goto out_free_uid;
 	}
 
 	 
 	group = inotify_new_group(user, inotify_max_queued_events);
 	if (IS_ERR(group)) {
 		ret = PTR_ERR(group);
 		goto out_free_uid;
 	}
 
 	atomic_inc(&user->inotify_devs);
 
 	ret = anon_inode_getfd(""inotify"", &inotify_fops, group,
 				  O_RDONLY | flags);
  	if (ret >= 0)
  		return ret;
  
 	fsnotify_put_group(group);
  	atomic_dec(&user->inotify_devs);
  out_free_uid:
  	free_uid(user);
 	return ret;
 }",[35],Memory leak in the inotify_init1 function in fs/notify/inotify/inotify_user.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service (memory consumption) via vectors involving failed attempts to create files.
9603,"void jsvAddName(JsVar *parent, JsVar *namedChild) {
namedChild = jsvRef(namedChild);
assert(jsvIsName(namedChild));


if (jsvIsArray(parent) && jsvIsInt(namedChild)) {
JsVarInt index = namedChild->varData.integer;
if (index >= jsvGetArrayLength(parent)) {
jsvSetArrayLength(parent, index + 1, false);
}
}

if (jsvGetLastChild(parent)) {
JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));
if (jsvIsArray(parent)) {

while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {
JsVarRef prev = jsvGetPrevSibling(insertAfter);
jsvUnLock(insertAfter);
insertAfter = jsvLockSafe(prev);
}
}

if (insertAfter) {
if (jsvGetNextSibling(insertAfter)) {

JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));
jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));
jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));
jsvUnLock(insertBefore);
} else {

jsvSetLastChild(parent, jsvGetRef(namedChild));
}
jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));
jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));
jsvUnLock(insertAfter);
} else {

JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));
jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));
jsvUnLock(firstChild);

jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));

jsvSetFirstChild(parent, jsvGetRef(namedChild));
}
} else {
JsVarRef r = jsvGetRef(namedChild);
jsvSetFirstChild(parent, r);
jsvSetLastChild(parent, r);
}
}",[25],Espruino 2v11.251 was discovered to contain a stack buffer overflow via src/jsvar.c in jsvNewFromString.
204898," void GestureProviderAura::OnTouchEventAck(bool event_consumed) {
   DCHECK(pending_gestures_.empty());
    DCHECK(!handling_event_);
    base::AutoReset<bool> handling_event(&handling_event_, true);
    filtered_gesture_provider_.OnTouchEventAck(event_consumed);
   last_touch_event_latency_info_.Clear();
  }",[6],Multiple unspecified vulnerabilities in Google Chrome before 29.0.1547.57 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
8003,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;

ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);

i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);

while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}

ISOM_DECREASE_SIZE(ptr, 1)
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}

ISOM_DECREASE_SIZE(ptr, 1)
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}

if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}

i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}

i=0;
tmp_strsize=(u32)ptr->size;
while (tmp_strsize) {
ISOM_DECREASE_SIZE(ptr, 1)
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}

ISOM_DECREASE_SIZE(ptr, 1)
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}

ISOM_DECREASE_SIZE(ptr, 1)
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}

gf_free(tmp_str);

return GF_OK;
}","[7, 30, 32, 34, 42, 47, 49, 51, 60, 65, 67, 70, 77, 81, 83, 85, 91, 95, 97, 99]",Buffer overflow in the abst_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.
200959," AcpiPsCompleteFinalOp (
     ACPI_WALK_STATE         *WalkState,
      ACPI_PARSE_OBJECT       *Op,
      ACPI_STATUS             Status)
  {
    ACPI_STATUS             Status2;
     ACPI_STATUS             ReturnStatus = AE_OK;
     BOOLEAN                 Ascending = TRUE;
  
  
      ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);
 
 
      
     ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, ""AML package complete at Op %p\n"", Op));
     do
      {
          if (Op)
          {
            if (WalkState->AscendingCallback != NULL)
             if (Ascending && WalkState->AscendingCallback != NULL)
              {
                  WalkState->Op = Op;
                  WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
                 WalkState->Opcode = Op->Common.AmlOpcode;
 
                 Status = WalkState->AscendingCallback (WalkState);
                 Status = AcpiPsNextParseState (WalkState, Op, Status);
                 if (Status == AE_CTRL_PENDING)
                 {
                     Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
                     if (ACPI_FAILURE (Status))
                     {
                         return_ACPI_STATUS (Status);
                     }
                 }
  
                  if (Status == AE_CTRL_TERMINATE)
                  {
                    Status = AE_OK;
                     
                    do
                    {
                        if (Op)
                        {
                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
                            if (ACPI_FAILURE (Status2))
                            {
                                return_ACPI_STATUS (Status2);
                            }
                        }
                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
                            &WalkState->ArgTypes, &WalkState->ArgCount);
                    } while (Op);
                    return_ACPI_STATUS (Status);
                     Ascending = FALSE;
                     ReturnStatus = AE_CTRL_TERMINATE;
                  }
  
                  else if (ACPI_FAILURE (Status))
                  {
                       
  
                    (void) AcpiPsCompleteThisOp (WalkState, Op);
                    return_ACPI_STATUS (Status);
                     Ascending = FALSE;
                     ReturnStatus = Status;
                  }
              }
  
            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status2))
             Status = AcpiPsCompleteThisOp (WalkState, Op);
             if (ACPI_FAILURE (Status))
              {
                return_ACPI_STATUS (Status2);
                 Ascending = FALSE;
                 if (ACPI_SUCCESS (ReturnStatus) ||
                     ReturnStatus == AE_CTRL_TERMINATE)
                 {
                     ReturnStatus = Status;
                 }
              }
          }
  
         AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
             &WalkState->ArgCount);
  
      } while (Op);
  
    return_ACPI_STATUS (Status);
     return_ACPI_STATUS (ReturnStatus);
  }","[7, 8, 21, 56, 57, 66, 67, 73, 74, 77, 78, 79, 80, 81, 82, 92, 6, 20, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 71, 72, 76, 91]","The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."
201505," static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 	int vA, vB, vC, payload = 0, i = (int) buf[0];
 	int size = dalvik_opcodes[i].len;
 	char str[1024], *strasm;
 	ut64 offset;
 	const char *flag_str; 
 
 	op->buf_asm[0] = 0;
 	if (buf[0] == 0x00) {  
 		switch (buf[1]) {
 		case 0x01:  
  			{
  				unsigned short array_size = buf[2] | (buf[3] << 8);
  				int first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);
				sprintf (op->buf_asm, ""packed-switch-payload %d, %d"", array_size, first_key);
 				snprintf (op->buf_asm, sizeof(op->buf_asm), ""packed-switch-payload %d, %d"", array_size, first_key);
  				size = 8;
  				payload = 2 * (array_size * 2);
  				len = 0;
 			}
 			break;
 		case 0x02:  
  			{
  				unsigned short array_size = buf[2] | (buf[3] << 8);
				sprintf (op->buf_asm, ""sparse-switch-payload %d"", array_size);
 				snprintf (op->buf_asm, sizeof (op->buf_asm), ""sparse-switch-payload %d"", array_size);
  				size = 4;
  				payload = 2 * (array_size*4);
  				len = 0;
 			}
 			break;
 		case 0x03:  
 			if (len > 7) {
 				unsigned short elem_width = buf[2] | (buf[3] << 8);
 				unsigned int array_size = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);
 				snprintf (op->buf_asm, sizeof (op->buf_asm),
 					""fill-array-data-payload %d, %d"",
 					elem_width, array_size);
 				payload = 2 * ((array_size * elem_width+1)/2);
 			}
 			size = 8;
 			len = 0;
 			break;
 		default:
 			 
 			break;
 		}
 	}
 	strasm = NULL;
 	if (size <= len) {
 		strncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);
 		strasm = strdup (op->buf_asm);
 		size = dalvik_opcodes[i].len;
 		switch (dalvik_opcodes[i].fmt) {
 		case fmtop: break;
  		case fmtopvAvB:
  			vA = buf[1] & 0x0f;
  			vB = (buf[1] & 0xf0) >> 4;
			sprintf (str, "" v%i, v%i"", vA, vB);
 			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAAvBBBB:
  			vA = (int) buf[1];
  			vB = (buf[3] << 8) | buf[2];
			sprintf (str, "" v%i, v%i"", vA, vB);
 			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAAAAvBBBB:  
  			vA = (buf[3] << 8) | buf[2];
  			vB = (buf[5] << 8) | buf[4];
			sprintf (str, "" v%i, v%i"", vA, vB);
 			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAA:
  			vA = (int) buf[1];
			sprintf (str, "" v%i"", vA);
 			snprintf (str, sizeof (str), "" v%i"", vA);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAcB:
  			vA = buf[1] & 0x0f;
  			vB = (buf[1] & 0xf0) >> 4;
			sprintf (str, "" v%i, %#x"", vA, vB);
 			snprintf (str, sizeof (str), "" v%i, %#x"", vA, vB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAAcBBBB:
  			vA = (int) buf[1];
  			{
  				short sB = (buf[3] << 8) | buf[2];
				sprintf (str, "" v%i, %#04hx"", vA, sB);
 				snprintf (str, sizeof (str), "" v%i, %#04hx"", vA, sB);
  				strasm = r_str_concat (strasm, str);
  			}
  			break;
 		case fmtopvAAcBBBBBBBB:
 			vA = (int) buf[1];
 			vB = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);
 			if (buf[0] == 0x17) {  
 				snprintf (str, sizeof (str), "" v%i:v%i, 0x%08x"", vA, vA + 1, vB);
 			} else {  
 				snprintf (str, sizeof (str), "" v%i, 0x%08x"", vA, vB);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAcBBBB0000:
 			vA = (int) buf[1];
 			vB = 0 | (buf[2] << 16) | (buf[3] << 24);
 			if (buf[0] == 0x19) {  
 				snprintf (str, sizeof (str), "" v%i:v%i, 0x%08x"", vA, vA + 1, vB);
 			} else {
 				snprintf (str, sizeof (str), "" v%i, 0x%08x"", vA, vB);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAcBBBBBBBBBBBBBBBB:
 			vA = (int) buf[1];
 			#define llint long long int
 			llint lB = (llint)buf[2] | ((llint)buf[3] << 8)|
 				((llint)buf[4] << 16) | ((llint)buf[5] << 24)|
  				((llint)buf[6] << 32) | ((llint)buf[7] << 40)|
  				((llint)buf[8] << 48) | ((llint)buf[9] << 56);
  			#undef llint
			sprintf (str, "" v%i:v%i, 0x%""PFMT64x, vA, vA + 1, lB);
 			snprintf (str, sizeof (str), "" v%i:v%i, 0x%""PFMT64x, vA, vA + 1, lB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAAvBBvCC:
  			vA = (int) buf[1];
  			vB = (int) buf[2];
  			vC = (int) buf[3];
			sprintf (str, "" v%i, v%i, v%i"", vA, vB, vC);
 			snprintf (str, sizeof (str), "" v%i, v%i, v%i"", vA, vB, vC);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAAvBBcCC:
  			vA = (int) buf[1];
  			vB = (int) buf[2];
  			vC = (int) buf[3];
			sprintf (str, "" v%i, v%i, %#x"", vA, vB, vC);
 			snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAvBcCCCC:
  			vA = buf[1] & 0x0f;
  			vB = (buf[1] & 0xf0) >> 4;
  			vC = (buf[3] << 8) | buf[2];
			sprintf (str, "" v%i, v%i, %#x"", vA, vB, vC);
 			snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtoppAA:
  			vA = (char) buf[1];
 			 
  			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA * 2));  
  			strasm = r_str_concat (strasm, str);
  			break;
 		case fmtoppAAAA:
 			vA = (short) (buf[3] << 8 | buf[2]);
 			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA * 2));  
 			strasm = r_str_concat (strasm, str);
 			break;
  		case fmtopvAApBBBB:  
  			vA = (int) buf[1];
  			vB = (int) (buf[3] << 8 | buf[2]);
 			 
  			snprintf (str, sizeof (str), "" v%i, 0x%08""PFMT64x, vA, a->pc + (vB * 2));
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtoppAAAAAAAA:
  			vA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));
 			 
  			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA*2));  
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAvBpCCCC:  
  			vA = buf[1] & 0x0f;
  			vB = (buf[1] & 0xf0) >> 4;
  			vC = (int) (buf[3] << 8 | buf[2]);
 			 
  			snprintf (str, sizeof (str),"" v%i, v%i, 0x%08""PFMT64x, vA, vB, a->pc + (vC * 2));
  			strasm = r_str_concat (strasm, str);
  			break;
 		case fmtopvAApBBBBBBBB:
 			vA = (int) buf[1];
 			vB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));
 			snprintf (str, sizeof (str), "" v%i, 0x%08""PFMT64x, vA, a->pc + vB);  
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoptinlineI:
 			vA = (int) (buf[1] & 0x0f);
 			vB = (buf[3] << 8) | buf[2];
  			*str = 0;
  			switch (vA) {
  			case 1:
				sprintf (str, "" {v%i}"", buf[4] & 0x0f);
 				snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
  				break;
  			case 2:
				sprintf (str, "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 				snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
  				break;
  			case 3:
				sprintf (str, "" {v%i, v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
 				snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
  				break;
  			case 4:
				sprintf (str, "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 				snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
  						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
  				break;
  			default:
				sprintf (str, "" {}"");
 				snprintf (str, sizeof (str), "" {}"");
  			}
  			strasm = r_str_concat (strasm, str);
			sprintf (str, "", [%04x]"", vB);
 			snprintf (str, sizeof (str), "", [%04x]"", vB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtoptinlineIR:
  		case fmtoptinvokeVSR:
  			vA = (int) buf[1];
  			vB = (buf[3] << 8) | buf[2];
  			vC = (buf[5] << 8) | buf[4];
			sprintf (str, "" {v%i..v%i}, [%04x]"", vC, vC + vA - 1, vB);
 			snprintf (str, sizeof (str), "" {v%i..v%i}, [%04x]"", vC, vC + vA - 1, vB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtoptinvokeVS:
  			vA = (int) (buf[1] & 0xf0) >> 4;
  			vB = (buf[3] << 8) | buf[2];
  			switch (vA) {
  			case 1:
				sprintf (str, "" {v%i}"", buf[4] & 0x0f);
 				snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
  				break;
  			case 2:
				sprintf (str, "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 				snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
  				break;
  			case 3:
				sprintf (str, "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
 				snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
  						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
  				break;
  			case 4:
				sprintf (str, "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 				snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
  						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
  				break;
  			default:
				sprintf (str, "" {}"");
 				snprintf (str, sizeof (str), "" {}"");
  				break;
  			}
  			strasm = r_str_concat (strasm, str);
			sprintf (str, "", [%04x]"", vB);
 			snprintf (str, sizeof (str), "", [%04x]"", vB);
  			strasm = r_str_concat (strasm, str);
  			break;
  		case fmtopvAAtBBBB:  
 			vA = (int) buf[1];
 			vB = (buf[3] << 8) | buf[2];
  			if (buf[0] == 0x1a) {
  				offset = R_ASM_GET_OFFSET (a, 's', vB);
  				if (offset == -1) {
					sprintf (str, "" v%i, string+%i"", vA, vB);
 					snprintf (str, sizeof (str), "" v%i, string+%i"", vA, vB);
  				} else {
					sprintf (str, "" v%i, 0x%""PFMT64x, vA, offset);
 					snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
  				}
  			} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {
  				flag_str = R_ASM_GET_NAME (a, 'c', vB);
  				if (!flag_str) {
					sprintf (str, "" v%i, class+%i"", vA, vB);
 					snprintf (str, sizeof (str), "" v%i, class+%i"", vA, vB);
  				} else {
					sprintf (str, "" v%i, %s"", vA, flag_str);
 					snprintf (str, sizeof (str), "" v%i, %s"", vA, flag_str);
  				}
  			} else {
  				flag_str = R_ASM_GET_NAME (a, 'f', vB);
  				if (!flag_str) {
					sprintf (str, "" v%i, field+%i"", vA, vB);
 					snprintf (str, sizeof (str), "" v%i, field+%i"", vA, vB);
  				} else {
					sprintf (str, "" v%i, %s"", vA, flag_str);
 					snprintf (str, sizeof (str), "" v%i, %s"", vA, flag_str);
  				}
  			}
  			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoptopvAvBoCCCC:
 			vA = (buf[1] & 0x0f);
 			vB = (buf[1] & 0xf0) >> 4;
  			vC = (buf[3]<<8) | buf[2];
  			offset = R_ASM_GET_OFFSET (a, 'o', vC);
  			if (offset == -1) {
				sprintf (str, "" v%i, v%i, [obj+%04x]"", vA, vB, vC);
 				snprintf (str, sizeof (str), "" v%i, v%i, [obj+%04x]"", vA, vB, vC);
  			} else {
				sprintf (str, "" v%i, v%i, [0x%""PFMT64x""]"", vA, vB, offset);
 				snprintf (str, sizeof (str), "" v%i, v%i, [0x%""PFMT64x""]"", vA, vB, offset);
  			}
  			strasm = r_str_concat (strasm, str);
  			break;
 		case fmtopAAtBBBB:
 			vA = (int) buf[1];
  			vB = (buf[3] << 8) | buf[2];
  			offset = R_ASM_GET_OFFSET (a, 't', vB);
  			if (offset == -1) {
				sprintf (str, "" v%i, thing+%i"", vA, vB);
 				snprintf (str, sizeof (str), "" v%i, thing+%i"", vA, vB);
  			} else {
				sprintf (str, "" v%i, 0x%""PFMT64x, vA, offset);
 				snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
  			}
  			strasm = r_str_concat (strasm, str);
  			break;
 		case fmtopvAvBtCCCC:
 			vA = (buf[1] & 0x0f);
 			vB = (buf[1] & 0xf0) >> 4;
 			vC = (buf[3] << 8) | buf[2];
  			if (buf[0] == 0x20 || buf[0] == 0x23) {  
  				flag_str = R_ASM_GET_NAME (a, 'c', vC);
  				if (flag_str) {
					sprintf (str, "" v%i, v%i, %s"", vA, vB, flag_str);
 					snprintf (str, sizeof (str), "" v%i, v%i, %s"", vA, vB, flag_str);
  				}
  				else {
					sprintf (str, "" v%i, v%i, class+%i"", vA, vB, vC);
 					snprintf (str, sizeof (str), "" v%i, v%i, class+%i"", vA, vB, vC);
  				}
  			} else {
  				flag_str = R_ASM_GET_NAME (a, 'f', vC);
  				if (flag_str) {
					sprintf (str, "" v%i, v%i, %s"", vA, vB, flag_str);
 					snprintf (str, sizeof (str), "" v%i, v%i, %s"", vA, vB, flag_str);
  				}
  				else {
					sprintf (str, "" v%i, v%i, field+%i"", vA, vB, vC);
 					snprintf (str, sizeof (str), "" v%i, v%i, field+%i"", vA, vB, vC);
  				}
  			}
  			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAtBBBBBBBB:
 			vA = (int) buf[1];
  			vB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));
  			offset = R_ASM_GET_OFFSET (a, 's', vB);
  			if (offset == -1) {
				sprintf (str, "" v%i, string+%i"", vA, vB);
 				snprintf (str, sizeof (str), "" v%i, string+%i"", vA, vB);
  			}
  			else {
				sprintf (str, "" v%i, 0x%""PFMT64x, vA, offset);
 				snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
  			}
  			strasm = r_str_concat (strasm, str);
  			break;
 		case fmtopvCCCCmBBBB:
 			vA = (int) buf[1];
 			vB = (buf[3] << 8) | buf[2];
 			vC = (buf[5] << 8) | buf[4];
  			if (buf[0] == 0x25) {  
  				flag_str = R_ASM_GET_NAME (a, 'c', vB);
  				if (flag_str) {
					sprintf (str, "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
 					snprintf (str, sizeof (str), "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
  				}
  				else {
					sprintf (str, "" {v%i..v%i}, class+%i"", vC, vC + vA - 1, vB);
 					snprintf (str, sizeof (str), "" {v%i..v%i}, class+%i"", vC, vC + vA - 1, vB);
  				}
  			} else {
  				flag_str = R_ASM_GET_NAME (a, 'm', vB);
  				if (flag_str) {
					sprintf (str, "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
 					snprintf (str, sizeof (str), "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
  				}
  				else {
					sprintf (str, "" {v%i..v%i}, method+%i"", vC, vC + vA - 1, vB);
 					snprintf (str, sizeof (str), "" {v%i..v%i}, method+%i"", vC, vC + vA - 1, vB);
  				}
  			}
  			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvXtBBBB:
 			vA = (int) (buf[1] & 0xf0) >> 4;
  			vB = (buf[3] << 8) | buf[2];
  			switch (vA) {
  				case 1:
					sprintf (str, "" {v%i}"", buf[4] & 0x0f);
 					snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
  					break;
  				case 2:
					sprintf (str, "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 					snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
  					break;
  				case 3:
					sprintf (str, "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
 					snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
  							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
  					break;
  				case 4:
					sprintf (str, "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 					snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
  							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
  					break;
  				case 5:
					sprintf (str, "" {v%i, v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 					snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
  							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f);  
  					break;
  				default:
					sprintf (str, "" {}"");
 					snprintf (str, sizeof (str), "" {}"");
  			}
  			strasm = r_str_concat (strasm, str);
  			if (buf[0] == 0x24) {  
  				flag_str = R_ASM_GET_NAME (a, 'c', vB);
  				if (flag_str) {
					sprintf (str, "", %s ; 0x%x"", flag_str, vB);
 					snprintf (str, sizeof (str), "", %s ; 0x%x"", flag_str, vB);
  				} else {
					sprintf (str, "", class+%i"", vB);
 					snprintf (str, sizeof (str), "", class+%i"", vB);
  				}
  			} else {
  				flag_str = R_ASM_GET_NAME (a, 'm', vB);
  				if (flag_str) {
					sprintf (str, "", %s ; 0x%x"", flag_str, vB);
 					snprintf (str, sizeof (str), "", %s ; 0x%x"", flag_str, vB);
  				} else {
					sprintf (str, "", method+%i"", vB);
 					snprintf (str, sizeof (str), "", method+%i"", vB);
  				}
  
  			}
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoptinvokeI:  
 		case fmtoptinvokeIR:
 		case fmt00:
 		default:
 			strcpy (op->buf_asm, ""invalid "");
 			free (strasm);
 			strasm = NULL;
 			size = 2;
 		}
 		if (strasm) {
 			strncpy (op->buf_asm, strasm, sizeof (op->buf_asm) - 1);
 			op->buf_asm[sizeof (op->buf_asm) - 1] = 0;
 		} else {
 			strcpy (op->buf_asm , ""invalid"");
 		}
 	} else if (len > 0) {
 		strcpy (op->buf_asm, ""invalid "");
 		op->size = len;
 		size = len;
 	}
 	op->payload = payload;
 	size += payload;  
 	op->size = size;
 	free (strasm);
 	return size;
 }","[16, 26, 60, 67, 74, 80, 87, 95, 128, 136, 144, 152, 157, 169, 175, 183, 200, 204, 208, 212, 217, 221, 230, 239, 243, 247, 252, 257, 262, 272, 275, 281, 284, 290, 293, 305, 308, 318, 321, 333, 337, 343, 347, 358, 362, 374, 378, 384, 388, 399, 403, 407, 412, 417, 422, 429, 432, 438, 441, 15, 25, 59, 66, 73, 79, 86, 94, 127, 135, 143, 151, 199, 203, 207, 211, 216, 220, 229, 238, 242, 246, 251, 256, 261, 271, 274, 280, 283, 289, 292, 304, 307, 317, 320, 332, 336, 342, 346, 357, 361, 373, 377, 383, 387, 398, 402, 406, 411, 416, 421, 428, 431, 437, 440]",The dalvik_disassemble function in libr/asm/p/asm_dalvik.c in radare2 1.2.1 allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted DEX file.
201737," static Image *ReadFITSImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   typedef struct _FITSInfo
   {
     MagickBooleanType
       extend,
       simple;
 
     int
       bits_per_pixel,
       columns,
       rows,
       number_axes,
       number_planes;
 
     double
       min_data,
       max_data,
       zero,
       scale;
 
     EndianType
       endian;
   } FITSInfo;
 
   char
     *comment,
     keyword[9],
     property[MaxTextExtent],
     value[73];
 
   double
     pixel,
     scale;
 
   FITSInfo
     fits_info;
 
   Image
     *image;
 
   int
     c;
 
   MagickBooleanType
     status;
 
   MagickSizeType
     number_pixels;
 
   register ssize_t
     i,
     x;
 
   register PixelPacket
     *q;
 
   ssize_t
     count,
     scene,
     y;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   (void) ResetMagickMemory(&fits_info,0,sizeof(fits_info));
   fits_info.extend=MagickFalse;
   fits_info.simple=MagickFalse;
   fits_info.bits_per_pixel=8;
   fits_info.columns=1;
   fits_info.rows=1;
   fits_info.rows=1;
   fits_info.number_planes=1;
   fits_info.min_data=0.0;
   fits_info.max_data=0.0;
   fits_info.zero=0.0;
   fits_info.scale=1.0;
   fits_info.endian=MSBEndian;
    
   for (comment=(char *) NULL; EOFBlob(image) == MagickFalse; )
   {
     for ( ; EOFBlob(image) == MagickFalse; )
     {
       register char
         *p;
 
       count=ReadBlob(image,8,(unsigned char *) keyword);
       if (count != 8)
         break;
       for (i=0; i < 8; i++)
       {
         if (isspace((int) ((unsigned char) keyword[i])) != 0)
           break;
         keyword[i]=tolower((int) ((unsigned char) keyword[i]));
       }
       keyword[i]='\0';
       count=ReadBlob(image,72,(unsigned char *) value);
       value[72]='\0';
       if (count != 72)
         break;
       p=value;
       if (*p == '=')
         {
           p+=2;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
         }
       if (LocaleCompare(keyword,""end"") == 0)
         break;
       if (LocaleCompare(keyword,""extend"") == 0)
         fits_info.extend=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;
       if (LocaleCompare(keyword,""simple"") == 0)
         fits_info.simple=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;
       if (LocaleCompare(keyword,""bitpix"") == 0)
         fits_info.bits_per_pixel=StringToLong(p);
       if (LocaleCompare(keyword,""naxis"") == 0)
         fits_info.number_axes=StringToLong(p);
       if (LocaleCompare(keyword,""naxis1"") == 0)
         fits_info.columns=StringToLong(p);
       if (LocaleCompare(keyword,""naxis2"") == 0)
         fits_info.rows=StringToLong(p);
       if (LocaleCompare(keyword,""naxis3"") == 0)
         fits_info.number_planes=StringToLong(p);
       if (LocaleCompare(keyword,""datamax"") == 0)
         fits_info.max_data=StringToDouble(p,(char **) NULL);
       if (LocaleCompare(keyword,""datamin"") == 0)
         fits_info.min_data=StringToDouble(p,(char **) NULL);
       if (LocaleCompare(keyword,""bzero"") == 0)
         fits_info.zero=StringToDouble(p,(char **) NULL);
       if (LocaleCompare(keyword,""bscale"") == 0)
         fits_info.scale=StringToDouble(p,(char **) NULL);
       if (LocaleCompare(keyword,""comment"") == 0)
         {
           if (comment == (char *) NULL)
             comment=ConstantString(p);
           else
             (void) ConcatenateString(&comment,p);
         }
       if (LocaleCompare(keyword,""xendian"") == 0)
         {
           if (LocaleNCompare(p,""big"",3) == 0)
             fits_info.endian=MSBEndian;
           else
             fits_info.endian=LSBEndian;
         }
       (void) FormatLocaleString(property,MaxTextExtent,""fits:%s"",keyword);
       (void) SetImageProperty(image,property,p);
     }
     c=0;
     while (((TellBlob(image) % FITSBlocksize) != 0) && (c != EOF))
       c=ReadBlobByte(image);
     if (fits_info.extend == MagickFalse)
       break;
     number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;
     if ((fits_info.simple != MagickFalse) && (fits_info.number_axes >= 1) &&
         (fits_info.number_axes <= 4) && (number_pixels != 0))
       break;
   }
    
   if (comment != (char *) NULL)
     {
       (void) SetImageProperty(image,""comment"",comment);
       comment=DestroyString(comment);
     }
   if (EOFBlob(image) != MagickFalse)
     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
       image->filename);
   number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;
   if ((fits_info.simple == MagickFalse) || (fits_info.number_axes < 1) ||
       (fits_info.number_axes > 4) || (number_pixels == 0))
     ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
   for (scene=0; scene < (ssize_t) fits_info.number_planes; scene++)
   {
     image->columns=(size_t) fits_info.columns;
     image->rows=(size_t) fits_info.rows;
     image->depth=(size_t) (fits_info.bits_per_pixel < 0 ? -1 : 1)*
       fits_info.bits_per_pixel;
     image->endian=fits_info.endian;
     image->scene=(size_t) scene;
      if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
        if (image->scene >= (image_info->scene+image_info->number_scenes-1))
          break;
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }
       
     (void) SetImageColorspace(image,GRAYColorspace);
     if ((fits_info.min_data == 0.0) && (fits_info.max_data == 0.0))
       {
         if (fits_info.zero == 0.0)
           (void) GetFITSPixelExtrema(image,fits_info.bits_per_pixel,
             &fits_info.min_data,&fits_info.max_data);
         else
           fits_info.max_data=GetFITSPixelRange((size_t)
             fits_info.bits_per_pixel);
       }
     else
       fits_info.max_data=GetFITSPixelRange((size_t) fits_info.bits_per_pixel);
      
     scale=QuantumRange/(fits_info.max_data-fits_info.min_data);
     for (y=(ssize_t) image->rows-1; y >= 0; y--)
     {
       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
       if (q == (PixelPacket *) NULL)
         break;
       for (x=0; x < (ssize_t) image->columns; x++)
       {
         pixel=GetFITSPixel(image,fits_info.bits_per_pixel);
         if ((image->depth == 16) || (image->depth == 32) ||
             (image->depth == 64))
           SetFITSUnsignedPixels(1,image->depth,image->endian,(unsigned char *)
             &pixel);
         SetPixelRed(q,ClampToQuantum(scale*(fits_info.scale*(pixel-
           fits_info.min_data)+fits_info.zero)));
         SetPixelGreen(q,GetPixelRed(q));
         SetPixelBlue(q,GetPixelRed(q));
         q++;
       }
       if (SyncAuthenticPixels(image,exception) == MagickFalse)
         break;
       if (image->previous == (Image *) NULL)
         {
           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
           if (status == MagickFalse)
             break;
         }
     }
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     if (scene < (ssize_t) (fits_info.number_planes-1))
       {
          
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   }
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[197, 198, 199, 200, 201, 202]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
199922," int ssl3_get_cert_verify(SSL *s)
 	{
 	EVP_PKEY *pkey=NULL;
 	unsigned char *p;
 	int al,ok,ret=0;
 	long n;
 	int type=0,i,j;
 	X509 *peer;
 	const EVP_MD *md = NULL;
 	EVP_MD_CTX mctx;
 	EVP_MD_CTX_init(&mctx);
 
 	n=s->method->ssl_get_message(s,
 		SSL3_ST_SR_CERT_VRFY_A,
 		SSL3_ST_SR_CERT_VRFY_B,
 		-1,
 		SSL3_RT_MAX_PLAIN_LENGTH,
 		&ok);
 
 	if (!ok) return((int)n);
 
 	if (s->session->peer != NULL)
 		{
 		peer=s->session->peer;
 		pkey=X509_get_pubkey(peer);
 		type=X509_certificate_type(peer,pkey);
 		}
 	else
 		{
 		peer=NULL;
 		pkey=NULL;
 		}
 
  	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
  		{
  		s->s3->tmp.reuse_message=1;
		if ((peer != NULL) && (type & EVP_PKT_SIGN))
 		if (peer != NULL)
  			{
  			al=SSL_AD_UNEXPECTED_MESSAGE;
  			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);
 			goto f_err;
 			}
 		ret=1;
 		goto end;
 		}
 
 	if (peer == NULL)
 		{
 		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);
 		al=SSL_AD_UNEXPECTED_MESSAGE;
 		goto f_err;
 		}
 
 	if (!(type & EVP_PKT_SIGN))
 		{
 		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		goto f_err;
 		}
 
 	if (s->s3->change_cipher_spec)
 		{
 		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
 		al=SSL_AD_UNEXPECTED_MESSAGE;
 		goto f_err;
 		}
 
 	 
 	p=(unsigned char *)s->init_msg;
 	 
 	 
 	if (n==64 && (pkey->type==NID_id_GostR3410_94 ||
 		pkey->type == NID_id_GostR3410_2001) )
 		{
 		i=64;
 		} 
 	else 
 		{	
 		if (SSL_USE_SIGALGS(s))
 			{
 			int rv = tls12_check_peer_sigalg(&md, s, p, pkey);
 			if (rv == -1)
 				{
 				al = SSL_AD_INTERNAL_ERROR;
 				goto f_err;
 				}
 			else if (rv == 0)
 				{
 				al = SSL_AD_DECODE_ERROR;
 				goto f_err;
 				}
 #ifdef SSL_DEBUG
 fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
 #endif
 			p += 2;
 			n -= 2;
 			}
 		n2s(p,i);
 		n-=2;
 		if (i > n)
 			{
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
 			al=SSL_AD_DECODE_ERROR;
 			goto f_err;
 			}
     	}
 	j=EVP_PKEY_size(pkey);
 	if ((i > j) || (n > j) || (n <= 0))
 		{
 		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);
 		al=SSL_AD_DECODE_ERROR;
 		goto f_err;
 		}
 
 	if (SSL_USE_SIGALGS(s))
 		{
 		long hdatalen = 0;
 		void *hdata;
 		hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
 		if (hdatalen <= 0)
 			{
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
 			al=SSL_AD_INTERNAL_ERROR;
 			goto f_err;
 			}
 #ifdef SSL_DEBUG
 		fprintf(stderr, ""Using TLS 1.2 with client verify alg %s\n"",
 							EVP_MD_name(md));
 #endif
 		if (!EVP_VerifyInit_ex(&mctx, md, NULL)
 			|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))
 			{
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
 			al=SSL_AD_INTERNAL_ERROR;
 			goto f_err;
 			}
 
 		if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)
 			{
 			al=SSL_AD_DECRYPT_ERROR;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);
 			goto f_err;
 			}
 		}
 	else
 #ifndef OPENSSL_NO_RSA 
 	if (pkey->type == EVP_PKEY_RSA)
 		{
 		i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
 			MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, 
 							pkey->pkey.rsa);
 		if (i < 0)
 			{
 			al=SSL_AD_DECRYPT_ERROR;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);
 			goto f_err;
 			}
 		if (i == 0)
 			{
 			al=SSL_AD_DECRYPT_ERROR;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);
 			goto f_err;
 			}
 		}
 	else
 #endif
 #ifndef OPENSSL_NO_DSA
 		if (pkey->type == EVP_PKEY_DSA)
 		{
 		j=DSA_verify(pkey->save_type,
 			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
 			SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);
 		if (j <= 0)
 			{
 			 
 			al=SSL_AD_DECRYPT_ERROR;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);
 			goto f_err;
 			}
 		}
 	else
 #endif
 #ifndef OPENSSL_NO_ECDSA
 		if (pkey->type == EVP_PKEY_EC)
 		{
 		j=ECDSA_verify(pkey->save_type,
 			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
 			SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
 		if (j <= 0)
 			{
 			 
 			al=SSL_AD_DECRYPT_ERROR;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
 			    SSL_R_BAD_ECDSA_SIGNATURE);
 			goto f_err;
 			}
 		}
 	else
 #endif
 	if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)
 		{   unsigned char signature[64];
 			int idx;
 			EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);
 			EVP_PKEY_verify_init(pctx);
 			if (i!=64) {
 				fprintf(stderr,""GOST signature length is %d"",i);
 			}	
 			for (idx=0;idx<64;idx++) {
 				signature[63-idx]=p[idx];
 			}	
 			j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);
 			EVP_PKEY_CTX_free(pctx);
 			if (j<=0) 
 				{
 				al=SSL_AD_DECRYPT_ERROR;
 				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
 					SSL_R_BAD_ECDSA_SIGNATURE);
 				goto f_err;
 				}	
 		}
 	else	
 		{
 		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
 		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
 		goto f_err;
 		}
 
 
 	ret=1;
 	if (0)
 		{
 f_err:
 		ssl3_send_alert(s,SSL3_AL_FATAL,al);
 		}
 end:
 	if (s->s3->handshake_buffer)
 		{
 		BIO_free(s->s3->handshake_buffer);
 		s->s3->handshake_buffer = NULL;
 		s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;
 		}
 	EVP_MD_CTX_cleanup(&mctx);
 	EVP_PKEY_free(pkey);
 	return(ret);
 	}","[38, 37]","The ssl3_get_cert_verify function in s3_srvr.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k accepts client authentication with a Diffie-Hellman (DH) certificate without requiring a CertificateVerify message, which allows remote attackers to obtain access without knowledge of a private key via crafted TLS Handshake Protocol traffic to a server that recognizes a Certification Authority with DH support."
203233,"  header_read (SF_PRIVATE *psf, void *ptr, int bytes)
  {	int count = 0 ;
  
	if (psf->headindex >= SIGNED_SIZEOF (psf->header))
		return psf_fread (ptr, 1, bytes, psf) ;
	if (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))
	{	int most ;
 	if (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))
 		return count ;
  
		most = SIGNED_SIZEOF (psf->header) - psf->headend ;
		psf_fread (psf->header + psf->headend, 1, most, psf) ;
		memcpy (ptr, psf->header + psf->headend, most) ;
		psf->headend = psf->headindex += most ;
		psf_fread ((char *) ptr + most, bytes - most, 1, psf) ;
		return bytes ;
		} ;
	if (psf->headindex + bytes > psf->headend)
	{	count = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;
		if (count != bytes - (int) (psf->headend - psf->headindex))
 	if (psf->header.indx + bytes > psf->header.end)
 	{	count = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;
 		if (count != bytes - (int) (psf->header.end - psf->header.indx))
  		{	psf_log_printf (psf, ""Error : psf_fread returned short count.\n"") ;
  			return count ;
  			} ;
		psf->headend += count ;
 		psf->header.end += count ;
  		} ;
  
	memcpy (ptr, psf->header + psf->headindex, bytes) ;
	psf->headindex += bytes ;
 	memcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;
 	psf->header.indx += bytes ;
  
  	return bytes ;
  }  ","[8, 9, 21, 22, 23, 28, 33, 34, 4, 5, 6, 7, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 27, 31, 32]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file."
206990," bool DoCanonicalizePathURL(const URLComponentSource<CHAR>& source,
                            const Parsed& parsed,
                            CanonOutput* output,
                            Parsed* new_parsed) {
   bool success = CanonicalizeScheme(source.scheme, parsed.scheme,
                                     output, &new_parsed->scheme);
 
   new_parsed->username.reset();
   new_parsed->password.reset();
   new_parsed->host.reset();
    new_parsed->port.reset();
  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(
      source.path, parsed.path, '\0', output, &new_parsed->path);
  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(
      source.query, parsed.query, '?', output, &new_parsed->query);
  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(
      source.ref, parsed.ref, '#', output, &new_parsed->ref);
    
    
    
   DoCanonicalizePathComponent<CHAR, UCHAR>(source.path, parsed.path, '\0',
                                            output, &new_parsed->path);
   DoCanonicalizePathComponent<CHAR, UCHAR>(source.query, parsed.query, '?',
                                            output, &new_parsed->query);
   DoCanonicalizePathComponent<CHAR, UCHAR>(source.ref, parsed.ref, '#', output,
                                            &new_parsed->ref);
  
    return success;
  }","[18, 19, 20, 21, 22, 23, 24, 25, 26, 12, 13, 14, 15, 16, 17]",Excessive data validation in URL parser in Google Chrome prior to 75.0.3770.80 allowed a remote attacker who convinced a user to input a URL to bypass website URL validation via a crafted URL.
208109," VOID ixheaacd_esbr_postradixcompute2(WORD32 *ptr_y, WORD32 *ptr_x,
  const WORD32 *pdig_rev_tbl,
                                      WORD32 npoints) {
   WORD32 i, k;
   WORD32 h2;
 
    WORD32 x_0, x_1, x_2, x_3;
    WORD32 x_4, x_5, x_6, x_7;
    WORD32 x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
  WORD32 n00, n10, n20, n30, n01, n11, n21, n31;
  WORD32 n02, n12, n22, n32, n03, n13, n23, n33;
    WORD32 n0, j0;
    WORD32 *x2, *x0;
    WORD32 *y0, *y1, *y2, *y3;
 
   y0 = ptr_y;
   y2 = ptr_y + (WORD32)npoints;
   x0 = ptr_x;
   x2 = ptr_x + (WORD32)(npoints >> 1);
 
   y1 = y0 + (WORD32)(npoints >> 2);
   y3 = y2 + (WORD32)(npoints >> 2);
   j0 = 8;
   n0 = npoints >> 1;
 
  for (k = 0; k < 2; k++) {
  for (i = 0; i<npoints>> 1; i += 8) {
       h2 = *pdig_rev_tbl++ >> 2;
 
       x_0 = *x0++;
       x_1 = *x0++;
       x_2 = *x0++;
       x_3 = *x0++;
       x_4 = *x0++;
       x_5 = *x0++;
 
        x_6 = *x0++;
        x_7 = *x0++;
  
      n00 = x_0 + x_2;
      n01 = x_1 + x_3;
      n20 = x_0 - x_2;
      n21 = x_1 - x_3;
      n10 = x_4 + x_6;
      n11 = x_5 + x_7;
      n30 = x_4 - x_6;
      n31 = x_5 - x_7;
      y0[h2] = n00;
      y0[h2 + 1] = n01;
      y1[h2] = n10;
      y1[h2 + 1] = n11;
      y2[h2] = n20;
      y2[h2 + 1] = n21;
      y3[h2] = n30;
      y3[h2 + 1] = n31;
       y0[h2] = ixheaacd_add32_sat(x_0, x_2);
       y0[h2 + 1] = ixheaacd_add32_sat(x_1, x_3);
       y1[h2] = ixheaacd_add32_sat(x_4, x_6);
       y1[h2 + 1] = ixheaacd_add32_sat(x_5, x_7);
       y2[h2] = ixheaacd_sub32_sat(x_0, x_2);
       y2[h2 + 1] = ixheaacd_sub32_sat(x_1, x_3);
       y3[h2] = ixheaacd_sub32_sat(x_4, x_6);
       y3[h2 + 1] = ixheaacd_sub32_sat(x_5, x_7);
  
        x_8 = *x2++;
        x_9 = *x2++;
       x_a = *x2++;
       x_b = *x2++;
       x_c = *x2++;
       x_d = *x2++;
 
        x_e = *x2++;
        x_f = *x2++;
  
      n02 = x_8 + x_a;
      n03 = x_9 + x_b;
      n22 = x_8 - x_a;
      n23 = x_9 - x_b;
      n12 = x_c + x_e;
      n13 = x_d + x_f;
      n32 = x_c - x_e;
      n33 = x_d - x_f;
      y0[h2 + 2] = n02;
      y0[h2 + 3] = n03;
      y1[h2 + 2] = n12;
      y1[h2 + 3] = n13;
      y2[h2 + 2] = n22;
      y2[h2 + 3] = n23;
      y3[h2 + 2] = n32;
      y3[h2 + 3] = n33;
       y0[h2 + 2] = ixheaacd_add32_sat(x_8, x_a);
       y0[h2 + 3] = ixheaacd_add32_sat(x_9, x_b);
       y1[h2 + 2] = ixheaacd_add32_sat(x_c, x_e);
       y1[h2 + 3] = ixheaacd_add32_sat(x_d, x_f);
       y2[h2 + 2] = ixheaacd_sub32_sat(x_8, x_a);
       y2[h2 + 3] = ixheaacd_sub32_sat(x_9, x_b);
       y3[h2 + 2] = ixheaacd_sub32_sat(x_c, x_e);
       y3[h2 + 3] = ixheaacd_sub32_sat(x_d, x_f);
      }
      x0 += (WORD32)npoints >> 1;
      x2 += (WORD32)npoints >> 1;
  }
 }","[56, 57, 58, 59, 60, 61, 62, 63, 91, 92, 93, 94, 95, 96, 97, 98, 10, 11, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]",In ixheaacd_real_synth_fft_p3 of ixheaacd_esbr_fft.c there is a possible out of bounds write due to a missing bounds check. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-9.0 Android ID: A-110769924
206541," void DiceResponseHandler::OnTokenExchangeSuccess(
     DiceTokenFetcher* token_fetcher,
     const std::string& refresh_token,
     bool is_under_advanced_protection) {
   const std::string& email = token_fetcher->email();
   const std::string& gaia_id = token_fetcher->gaia_id();
   if (!CanGetTokenForAccount(gaia_id, email))
     return;
   VLOG(1) << ""[Dice] OAuth success for email "" << email;
   bool should_enable_sync = token_fetcher->should_enable_sync();
   std::string account_id =
        account_tracker_service_->SeedAccountInfo(gaia_id, email);
    account_tracker_service_->SetIsAdvancedProtectionAccount(
        account_id, is_under_advanced_protection);
  token_service_->UpdateCredentials(account_id, refresh_token);
   token_service_->UpdateCredentials(
       account_id, refresh_token,
       signin_metrics::SourceForRefreshTokenOperation::
           kDiceResponseHandler_Signin);
    about_signin_internals_->OnRefreshTokenReceived(
        base::StringPrintf(""Successful (%s)"", account_id.c_str()));
    if (should_enable_sync)
     token_fetcher->delegate()->EnableSync(account_id);
 
   DeleteTokenFetcher(token_fetcher);
 }","[16, 17, 18, 19, 15]","The JSGenericLowering class in compiler/js-generic-lowering.cc in Google V8, as used in Google Chrome before 50.0.2661.94, mishandles comparison operators, which allows remote attackers to obtain sensitive information via crafted JavaScript code."
203933,"   virtual void AddObserver(Observer* observer) {
   virtual void AddObserver(InputMethodLibrary::Observer* observer) {
      if (!observers_.size()) {
        observer->FirstObserverIsAdded(this);
      }
      observers_.AddObserver(observer);
    }",[2],"Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
202225," construct_mac_tlv(struct sc_card *card, unsigned char *apdu_buf, size_t data_tlv_len, size_t le_tlv_len,
 		unsigned char *mac_tlv, size_t * mac_tlv_len, const unsigned char key_type)
 {
 	size_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);
 	unsigned char mac[4096] = { 0 };
 	size_t mac_len;
 	unsigned char icv[16] = { 0 };
 	int i = (KEY_TYPE_AES == key_type ? 15 : 7);
 	epass2003_exdata *exdata = NULL;
 
 	if (!card->drv_data) 
 		return SC_ERROR_INVALID_ARGUMENTS;
 
 	exdata = (epass2003_exdata *)card->drv_data;
 
 	if (0 == data_tlv_len && 0 == le_tlv_len) {
 		mac_len = block_size;
 	}
 	else {
 		 
 		*(apdu_buf + block_size + data_tlv_len + le_tlv_len) = 0x80;
 		if ((data_tlv_len + le_tlv_len + 1) % block_size)
 			mac_len = (((data_tlv_len + le_tlv_len + 1) / block_size) +
 					1) * block_size + block_size;
 
 		else
 			mac_len = data_tlv_len + le_tlv_len + 1 + block_size;
 
 		memset((apdu_buf + block_size + data_tlv_len + le_tlv_len + 1),
 		       0, (mac_len - (data_tlv_len + le_tlv_len + 1)));
 	}
 
 	 
 	for (; i >= 0; i--) {
 		if (exdata->icv_mac[i] == 0xff) {
 			exdata->icv_mac[i] = 0;
 		}
 		else {
 			exdata->icv_mac[i]++;
 			break;
 		}
 	}
 
 	 
 	memset(icv, 0, sizeof(icv));
 	memcpy(icv, exdata->icv_mac, 16);
 	if (KEY_TYPE_AES == key_type) {
 		aes128_encrypt_cbc(exdata->sk_mac, 16, icv, apdu_buf, mac_len, mac);
  		memcpy(mac_tlv + 2, &mac[mac_len - 16], 8);
  	}
  	else {
		unsigned char iv[8] = { 0 };
 		unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
  		unsigned char tmp[8] = { 0 };
  		des_encrypt_cbc(exdata->sk_mac, 8, icv, apdu_buf, mac_len, mac);
  		des_decrypt_cbc(&exdata->sk_mac[8], 8, iv, &mac[mac_len - 8], 8, tmp);
		memset(iv, 0x00, 8);
 		memset(iv, 0x00, sizeof iv);
  		des_encrypt_cbc(exdata->sk_mac, 8, iv, tmp, 8, mac_tlv + 2);
  	}
  
 	*mac_tlv_len = 2 + 8;
 	return 0;
 }","[53, 58, 52, 57]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.
5515,"GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)
{
int r;

static const char resp[] =
""<u:%sResponse ""
""xmlns:u=\""%s\"">""
""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>""
""</u:%sResponse>"";

char body[512];
int bodylen;
struct NameValueParserData data;
char * int_ip, * int_port, * rem_host, * rem_port, * protocol;
int opt=0;

unsigned short iport, rport;

if (GETFLAG(IPV6FCFWDISABLEDMASK))
{
SoapError(h, 702, ""FirewallDisabled"");
return;
}

ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);
int_ip = GetValueFromNameValueList(&data, ""InternalClient"");
int_port = GetValueFromNameValueList(&data, ""InternalPort"");
rem_host = GetValueFromNameValueList(&data, ""RemoteHost"");
rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
protocol = GetValueFromNameValueList(&data, ""Protocol"");

if (!int_port || !ext_port || !protocol)
{
ClearNameValueList(&data);
SoapError(h, 402, ""Invalid Args"");
return;
}

rport = (unsigned short)atoi(rem_port);
iport = (unsigned short)atoi(int_port);


syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol);


r = -1;

switch(r)
{
case 1:
bodylen = snprintf(body, sizeof(body), resp,
action, ns                                                           ,
opt, action);
BuildSendAndCloseSoapResp(h, body, bodylen);
break;
case -5:
SoapError(h, 705, ""ProtocolNotSupported"");
break;
default:
SoapError(h, 501, ""ActionFailed"");
}
ClearNameValueList(&data);
}",[32],A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for int_port.
207463," void btif_hl_select_monitor_callback(fd_set *p_cur_set ,fd_set *p_org_set) {
     UNUSED(p_org_set);
 
     BTIF_TRACE_DEBUG(""entering %s"",__FUNCTION__);
 
  for (const list_node_t *node = list_begin(soc_queue);
             node != list_end(soc_queue); node = list_next(node)) {
  btif_hl_soc_cb_t *p_scb = list_node(node);
  if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_W4_READ) {
  if (FD_ISSET(p_scb->socket_id[1], p_cur_set)) {
                 BTIF_TRACE_DEBUG(""read data state= BTIF_HL_SOC_STATE_W4_READ"");
  btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(p_scb->app_idx,
                         p_scb->mcl_idx, p_scb->mdl_idx);
                 assert(p_dcb != NULL);
  if (p_dcb->p_tx_pkt) {
                     BTIF_TRACE_ERROR(""Rcv new pkt but the last pkt is still not been""
  ""  sent tx_size=%d"", p_dcb->tx_size);
                     btif_hl_free_buf((void **) &p_dcb->p_tx_pkt);
 
                  }
                  p_dcb->p_tx_pkt = btif_hl_get_buf (p_dcb->mtu);
                  if (p_dcb) {
                    int r = (int)recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,
                            p_dcb->mtu, MSG_DONTWAIT);
                     int r = (int)TEMP_FAILURE_RETRY(recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,
                             p_dcb->mtu, MSG_DONTWAIT));
                      if (r > 0) {
                          BTIF_TRACE_DEBUG(""btif_hl_select_monitor_callback send data r =%d"", r);
                          p_dcb->tx_size = r;
                         BTIF_TRACE_DEBUG(""btif_hl_select_monitor_callback send data tx_size=%d"", p_dcb->tx_size );
                         BTA_HlSendData(p_dcb->mdl_handle, p_dcb->tx_size);
  } else {
                         BTIF_TRACE_DEBUG(""btif_hl_select_monitor_callback receive failed r=%d"",r);
                         BTA_HlDchClose(p_dcb->mdl_handle);
  }
  }
  }
  }
  }
 
  if (list_is_empty(soc_queue))
         BTIF_TRACE_DEBUG(""btif_hl_select_monitor_queue is empty"");
 
     BTIF_TRACE_DEBUG(""leaving %s"",__FUNCTION__);
 }","[25, 26, 23, 24]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
7526,"static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
int bits, int row, int row_stride)
{
x3f_directory_entry_header_t *DEH = &DE->header;
x3f_image_data_t *ID = &DEH->data_subsection.image_data;
x3f_huffman_t *HUF = ID->huffman;

uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);

uint16_t c[3] = {0, 0, 0};
int col;

uint32_t mask = 0;

switch (bits)
{
case 8:
mask = 0x0ff;
break;
case 9:
mask = 0x1ff;
break;
case 10:
mask = 0x3ff;
break;
case 11:
mask = 0x7ff;
break;
case 12:
mask = 0xfff;
break;
default:
mask = 0;

throw LIBRAW_EXCEPTION_IO_CORRUPT;
break;
}

for (col = 0; col < ID->columns; col++)
{
int color;
uint32_t val = data[col];

for (color = 0; color < 3; color++)
{
uint16_t c_fix;
c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);

switch (ID->type_format)
{
case X3F_IMAGE_RAW_HUFFMAN_X530:
case X3F_IMAGE_RAW_HUFFMAN_10BIT:
c_fix = (int16_t)c[color] > 0 ? c[color] : 0;

HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;
break;
case X3F_IMAGE_THUMB_HUFFMAN:
c_fix = (int8_t)c[color] > 0 ? c[color] : 0;

HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;
break;
default:

throw LIBRAW_EXCEPTION_IO_CORRUPT;
}
}
}
}",[8],"In LibRaw, an out-of-bounds read vulnerability exists within the ""simple_decode_row()"" function (libraw\src\x3f\x3f_utils_patched.cpp) which can be triggered via an image with a large row_stride field."
199499," donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,
     int clazz, int swap, size_t align, int *flags)
 {
 	Elf32_Nhdr nh32;
 	Elf64_Nhdr nh64;
 	size_t noff, doff;
 #ifdef ELFCORE
 	int os_style = -1;
 #endif
  	uint32_t namesz, descsz;
  	unsigned char *nbuf = CAST(unsigned char *, vbuf);
  
 	if (xnh_sizeof + offset > size) {
 		 
 		return xnh_sizeof + offset;
 	}
 
  	(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);
  	offset += xnh_sizeof;
  
 	namesz = xnh_namesz;
 	descsz = xnh_descsz;
 	if ((namesz == 0) && (descsz == 0)) {
 		 
 		return (offset >= size) ? offset : size;
 	}
 
 	if (namesz & 0x80000000) {
 	    (void)file_printf(ms, "", bad note name size 0x%lx"",
 		(unsigned long)namesz);
 	    return offset;
 	}
 
 	if (descsz & 0x80000000) {
 	    (void)file_printf(ms, "", bad note description size 0x%lx"",
 		(unsigned long)descsz);
 	    return offset;
 	}
 
 
 	noff = offset;
 	doff = ELF_ALIGN(offset + namesz);
 
 	if (offset + namesz > size) {
 		 
 		return doff;
 	}
 
 	offset = ELF_ALIGN(doff + descsz);
 	if (doff + descsz > size) {
 		 
 		return (offset >= size) ? offset : size;
 	}
 
 	if ((*flags & (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID)) ==
 	    (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID))
 		goto core;
 
 	if (namesz == 5 && strcmp((char *)&nbuf[noff], ""SuSE"") == 0 &&
 	    xnh_type == NT_GNU_VERSION && descsz == 2) {
 	    file_printf(ms, "", for SuSE %d.%d"", nbuf[doff], nbuf[doff + 1]);
 	}
 	if (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&
 	    xnh_type == NT_GNU_VERSION && descsz == 16) {
 		uint32_t desc[4];
 		(void)memcpy(desc, &nbuf[doff], sizeof(desc));
 
 		if (file_printf(ms, "", for GNU/"") == -1)
 			return size;
 		switch (elf_getu32(swap, desc[0])) {
 		case GNU_OS_LINUX:
 			if (file_printf(ms, ""Linux"") == -1)
 				return size;
 			break;
 		case GNU_OS_HURD:
 			if (file_printf(ms, ""Hurd"") == -1)
 				return size;
 			break;
 		case GNU_OS_SOLARIS:
 			if (file_printf(ms, ""Solaris"") == -1)
 				return size;
 			break;
 		case GNU_OS_KFREEBSD:
 			if (file_printf(ms, ""kFreeBSD"") == -1)
 				return size;
 			break;
 		case GNU_OS_KNETBSD:
 			if (file_printf(ms, ""kNetBSD"") == -1)
 				return size;
 			break;
 		default:
 			if (file_printf(ms, ""<unknown>"") == -1)
 				return size; 
 		}
 		if (file_printf(ms, "" %d.%d.%d"", elf_getu32(swap, desc[1]),
 		    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)
 			return size;
 		*flags |= FLAGS_DID_NOTE;
 		return size;
 	}
 
 	if (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&
 	    xnh_type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {
 	    uint8_t desc[20];
 	    uint32_t i;
 	    if (file_printf(ms, "", BuildID[%s]="", descsz == 16 ? ""md5/uuid"" :
 		""sha1"") == -1)
 		    return size;
 	    (void)memcpy(desc, &nbuf[doff], descsz);
 	    for (i = 0; i < descsz; i++)
 		if (file_printf(ms, ""%02x"", desc[i]) == -1)
 		    return size;
 	    *flags |= FLAGS_DID_BUILD_ID;
 	}
 
 	if (namesz == 4 && strcmp((char *)&nbuf[noff], ""PaX"") == 0 &&
 	    xnh_type == NT_NETBSD_PAX && descsz == 4) {
 		static const char *pax[] = {
 		    ""+mprotect"",
 		    ""-mprotect"",
 		    ""+segvguard"",
 		    ""-segvguard"",
 		    ""+ASLR"",
 		    ""-ASLR"",
 		};
 		uint32_t desc;
 		size_t i;
 		int did = 0;
 
 		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
 		desc = elf_getu32(swap, desc);
 
 		if (desc && file_printf(ms, "", PaX: "") == -1)
 			return size;
 
 		for (i = 0; i < __arraycount(pax); i++) {
 			if (((1 << i) & desc) == 0)
 				continue;
 			if (file_printf(ms, ""%s%s"", did++ ? "","" : """",
 			    pax[i]) == -1)
 				return size;
 		}
 	}
 
 	if (namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0) {
 		switch (xnh_type) {
 		case NT_NETBSD_VERSION:
 			if (descsz == 4) {
 				do_note_netbsd_version(ms, swap, &nbuf[doff]);
 				*flags |= FLAGS_DID_NOTE;
 				return size;
 			}
 			break;
 		case NT_NETBSD_MARCH:
 			if (file_printf(ms, "", compiled for: %.*s"", (int)descsz,
 			    (const char *)&nbuf[doff]) == -1)
 				return size;
 			break;
 		case NT_NETBSD_CMODEL:
 			if (file_printf(ms, "", compiler model: %.*s"",
 			    (int)descsz, (const char *)&nbuf[doff]) == -1)
 				return size;
 			break;
 		default:
 			if (file_printf(ms, "", note=%u"", xnh_type) == -1)
 				return size;
 			break;
 		}
 		return size;
 	}
 
 	if (namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0) {
 	    	if (xnh_type == NT_FREEBSD_VERSION && descsz == 4) {
 			do_note_freebsd_version(ms, swap, &nbuf[doff]);
 			*flags |= FLAGS_DID_NOTE;
 			return size;
 		}
 	}
 
 	if (namesz == 8 && strcmp((char *)&nbuf[noff], ""OpenBSD"") == 0 &&
 	    xnh_type == NT_OPENBSD_VERSION && descsz == 4) {
 		if (file_printf(ms, "", for OpenBSD"") == -1)
 			return size;
 		 
 		*flags |= FLAGS_DID_NOTE;
 		return size;
 	}
 
 	if (namesz == 10 && strcmp((char *)&nbuf[noff], ""DragonFly"") == 0 &&
 	    xnh_type == NT_DRAGONFLY_VERSION && descsz == 4) {
 		uint32_t desc;
 		if (file_printf(ms, "", for DragonFly"") == -1)
 			return size;
 		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
 		desc = elf_getu32(swap, desc);
 		if (file_printf(ms, "" %d.%d.%d"", desc / 100000,
 		    desc / 10000 % 10, desc % 10000) == -1)
 			return size;
 		*flags |= FLAGS_DID_NOTE;
 		return size;
 	}
 
 core:
 	 
 	if ((namesz == 4 && strncmp((char *)&nbuf[noff], ""CORE"", 4) == 0) ||
 	    (namesz == 5 && strcmp((char *)&nbuf[noff], ""CORE"") == 0)) {
 		os_style = OS_STYLE_SVR4;
 	} 
 
 	if ((namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0)) {
 		os_style = OS_STYLE_FREEBSD;
 	}
 
 	if ((namesz >= 11 && strncmp((char *)&nbuf[noff], ""NetBSD-CORE"", 11)
 	    == 0)) {
 		os_style = OS_STYLE_NETBSD;
 	}
 
 #ifdef ELFCORE
 	if ((*flags & FLAGS_DID_CORE) != 0)
 		return size;
 
 	if (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {
 		if (file_printf(ms, "", %s-style"", os_style_names[os_style])
 		    == -1)
 			return size;
 		*flags |= FLAGS_DID_CORE_STYLE;
 	}
 
 	switch (os_style) {
 	case OS_STYLE_NETBSD:
 		if (xnh_type == NT_NETBSD_CORE_PROCINFO) {
 			uint32_t signo;
 			 
 			if (file_printf(ms, "", from '%.31s'"",
 			    &nbuf[doff + 0x7c]) == -1)
 				return size;
 			
 			 
 			(void)memcpy(&signo, &nbuf[doff + 0x08],
 			    sizeof(signo));
 			if (file_printf(ms, "" (signal %u)"",
 			    elf_getu32(swap, signo)) == -1)
 				return size;
 			*flags |= FLAGS_DID_CORE;
 			return size;
 		}
 		break;
 
 	default:
 		if (xnh_type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {
 			size_t i, j;
 			unsigned char c;
 			 
 			for (i = 0; i < NOFFSETS; i++) {
 				unsigned char *cname, *cp;
 				size_t reloffset = prpsoffsets(i);
 				size_t noffset = doff + reloffset;
 				size_t k;
 				for (j = 0; j < 16; j++, noffset++,
 				    reloffset++) {
 					 
 					if (noffset >= size)
 						goto tryanother;
 
 					 
 					if (reloffset >= descsz)
 						goto tryanother;
 
 					c = nbuf[noffset];
 					if (c == '\0') {
 						 
 						if (j == 0)
 							goto tryanother;
 						else
 							break;
 					} else {
 						 
 						if (!isprint(c) || isquote(c))
 							goto tryanother;
 					}
 				}
 				 
 
 				 
 				for (k = i + 1 ; k < NOFFSETS ; k++) {
 					size_t no;
 					int adjust = 1;
 					if (prpsoffsets(k) >= prpsoffsets(i))
 						continue;
 					for (no = doff + prpsoffsets(k);
 					     no < doff + prpsoffsets(i); no++)
 						adjust = adjust
 						         && isprint(nbuf[no]);
 					if (adjust)
 						i = k;
 				}
 
 				cname = (unsigned char *)
 				    &nbuf[doff + prpsoffsets(i)];
 				for (cp = cname; *cp && isprint(*cp); cp++)
 					continue;
 				 
 				while (cp > cname && isspace(cp[-1]))
 					cp--;
 				if (file_printf(ms, "", from '%.*s'"",
 				    (int)(cp - cname), cname) == -1)
 					return size;
 				*flags |= FLAGS_DID_CORE;
 				return size;
 
 			tryanother:
 				;
 			}
 		}
 		break;
 	}
 #endif
 	return offset;
 }","[13, 14, 15, 16, 17]","The donote function in readelf.c in file through 5.20, as used in the Fileinfo component in PHP 5.4.34, does not ensure that sufficient note headers are present, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted ELF file."
9686,"compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)
{
int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';
char_u *name_start = eap->arg;
char_u *name_end = to_name_end(eap->arg, TRUE);
int  off;
char_u *func_name;
char_u *lambda_name;
ufunc_T *ufunc;
int  r = FAIL;
compiletype_T   compile_type;
isn_T *funcref_isn = NULL;

if (eap->forceit)
{
emsg(_(e_cannot_use_bang_with_nested_def));
return NULL;
}

if (*name_start == '/')
{
name_end = skip_regexp(name_start + 1, '/', TRUE);
if (*name_end == '/')
++name_end;
set_nextcmd(eap, name_end);
}
if (name_end == name_start || *skipwhite(name_end) != '(')
{
if (!ends_excmd2(name_start, name_end))
{
if (*skipwhite(name_end) == '.')
semsg(_(e_cannot_define_dict_func_in_vim9_script_str),
eap->cmd);
else
semsg(_(e_invalid_command_str), eap->cmd);
return NULL;
}


if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)
return NULL;
return eap->nextcmd == NULL ? (char_u *)"""" : eap->nextcmd;
}


if (name_start[1] == ':' && !is_global)
{
semsg(_(e_namespace_not_supported_str), name_start);
return NULL;
}
if (cctx->ctx_skip != SKIP_YES
&& check_defined(name_start, name_end - name_start, cctx,
NULL, FALSE) == FAIL)
return NULL;
if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))
{
semsg(_(e_function_name_must_start_with_capital_str), name_start);
return NULL;
}

eap->arg = name_end;
fill_exarg_from_cctx(eap, cctx);

eap->forceit = FALSE;

lambda_name = vim_strsave(get_lambda_name());
if (lambda_name == NULL)
return NULL;


off = is_global ? 2 : 0;
func_name = vim_strnsave(name_start + off, name_end - name_start - off);
if (func_name == NULL)
{
r = FAIL;
goto theend;
}

ufunc = define_function(eap, lambda_name, lines_to_free);
if (ufunc == NULL)
{
r = eap->skip ? OK : FAIL;
goto theend;
}
if (eap->nextcmd != NULL)
{
semsg(_(e_text_found_after_str_str),
eap->cmdidx == CMD_def ? ""enddef"" : ""endfunction"", eap->nextcmd);
r = FAIL;
func_ptr_unref(ufunc);
goto theend;
}


if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)
{
int block_depth = cctx->ctx_ufunc->uf_block_depth;

ufunc->uf_block_ids = ALLOC_MULT(int, block_depth);
if (ufunc->uf_block_ids != NULL)
{
mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,
sizeof(int) * block_depth);
ufunc->uf_block_depth = block_depth;
}
}



if (is_global)
{
r = generate_NEWFUNC(cctx, lambda_name, func_name);
func_name = NULL;
lambda_name = NULL;
}
else
{

lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,
TRUE, ufunc->uf_func_type);

if (lvar == NULL)
goto theend;
if (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)
goto theend;
r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);
}

compile_type = get_compile_type(ufunc);
#ifdef FEAT_PROFILE


if (cctx->ctx_compile_type == CT_PROFILE)
compile_type = CT_PROFILE;
#endif
if (func_needs_compiling(ufunc, compile_type)
&& compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)
{
func_ptr_unref(ufunc);
goto theend;
}

#ifdef FEAT_PROFILE


if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))
compile_def_function(ufunc, FALSE, CT_NONE, cctx);
#endif


if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)
funcref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;

theend:
vim_free(lambda_name);
vim_free(func_name);
return r == FAIL ? NULL : (char_u *)"""";
}","[14, 119, 140]",Use After Free in GitHub repository vim/vim prior to 9.0.0221.
7394,"v8::Local<v8::Object> CreateNativeEvent(
v8::Isolate* isolate,
v8::Local<v8::Object> sender,
content::RenderFrameHost* frame,
electron::mojom::ElectronBrowser::MessageSyncCallback callback) {
v8::Local<v8::Object> event;
if (frame && callback) {
gin::Handle<Event> native_event = Event::Create(isolate);
native_event->SetCallback(std::move(callback));
event = v8::Local<v8::Object>::Cast(native_event.ToV8());
} else {

event = CreateEvent(isolate);
}

Dictionary dict(isolate, event);
dict.Set(""sender"", sender);

if (frame)
dict.Set(""frameId"", frame->GetRoutingID());
return event;
}","[19, 21]","The Electron framework lets you write cross-platform desktop applications using JavaScript, HTML and CSS. In affected versions of Electron IPC messages sent from the main process to a subframe in the renderer process, through webContents.sendToFrame, event.reply or when using the remote module, can in some cases be delivered to the wrong frame. If your app uses remote, calls webContents.sendToFrame, or calls event.reply in an IPC message handler then it is impacted by this issue. This has been fixed in versions 9.4.0, 10.2.0, 11.1.0, and 12.0.0-beta.9. There are no workarounds for this issue."
206930," DOMWindow* CreateWindow(const String& url_string,
                         const AtomicString& frame_name,
                         const String& window_features_string,
                         LocalDOMWindow& calling_window,
                         LocalFrame& first_frame,
                         LocalFrame& opener_frame,
                         ExceptionState& exception_state) {
   LocalFrame* active_frame = calling_window.GetFrame();
   DCHECK(active_frame);
 
   KURL completed_url = url_string.IsEmpty()
                            ? KURL(kParsedURLString, g_empty_string)
                            : first_frame.GetDocument()->CompleteURL(url_string);
   if (!completed_url.IsEmpty() && !completed_url.IsValid()) {
     UseCounter::Count(active_frame, WebFeature::kWindowOpenWithInvalidURL);
     exception_state.ThrowDOMException(
         kSyntaxError, ""Unable to open a window with invalid URL '"" +
                           completed_url.GetString() + ""'.\n"");
      return nullptr;
    }
  
   if (completed_url.ProtocolIsJavaScript() &&
       opener_frame.GetDocument()->GetContentSecurityPolicy() &&
       !ContentSecurityPolicy::ShouldBypassMainWorld(
           opener_frame.GetDocument())) {
     const int kJavascriptSchemeLength = sizeof(""javascript:"") - 1;
     String script_source = DecodeURLEscapeSequences(completed_url.GetString())
                                .Substring(kJavascriptSchemeLength);
 
     if (!opener_frame.GetDocument()
              ->GetContentSecurityPolicy()
              ->AllowJavaScriptURLs(nullptr, script_source,
                                    opener_frame.GetDocument()->Url(),
                                    OrdinalNumber())) {
       return nullptr;
     }
   }
 
    WebWindowFeatures window_features =
        GetWindowFeaturesFromString(window_features_string);
  
   FrameLoadRequest frame_request(calling_window.document(),
                                  ResourceRequest(completed_url), frame_name);
   frame_request.SetShouldSetOpener(window_features.noopener ? kNeverSetOpener
                                                             : kMaybeSetOpener);
   frame_request.GetResourceRequest().SetFrameType(
       WebURLRequest::kFrameTypeAuxiliary);
   frame_request.GetResourceRequest().SetRequestorOrigin(
       SecurityOrigin::Create(active_frame->GetDocument()->Url()));
 
   frame_request.GetResourceRequest().SetHTTPReferrer(
       SecurityPolicy::GenerateReferrer(
           active_frame->GetDocument()->GetReferrerPolicy(), completed_url,
           active_frame->GetDocument()->OutgoingReferrer()));
 
   bool has_user_gesture = UserGestureIndicator::ProcessingUserGesture();
 
   bool created;
   Frame* new_frame = CreateWindowHelper(
       opener_frame, *active_frame, opener_frame, frame_request, window_features,
       kNavigationPolicyIgnore, created);
   if (!new_frame)
     return nullptr;
   if (new_frame->DomWindow()->IsInsecureScriptAccess(calling_window,
                                                      completed_url))
     return window_features.noopener ? nullptr : new_frame->DomWindow();
 
   if (created) {
     FrameLoadRequest request(calling_window.document(),
                              ResourceRequest(completed_url));
     request.GetResourceRequest().SetHasUserGesture(has_user_gesture);
     new_frame->Navigate(request);
   } else if (!url_string.IsEmpty()) {
     new_frame->Navigate(*calling_window.document(), completed_url, false,
                         has_user_gesture ? UserGestureStatus::kActive
                                          : UserGestureStatus::kNone);
   }
   return window_features.noopener ? nullptr : new_frame->DomWindow();
 }","[22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38]",Insufficient enforcement of Content Security Policy in Blink in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to open javascript: URL windows when they should not be allowed to via a crafted HTML page.
206109,"   FileMetricsProviderTest()
       : create_large_files_(GetParam()),
         task_runner_(new base::TestSimpleTaskRunner()),
         thread_task_runner_handle_(task_runner_),
         statistics_recorder_(
             base::StatisticsRecorder::CreateTemporaryForTesting()),
         prefs_(new TestingPrefServiceSimple) {
      EXPECT_TRUE(temp_dir_.CreateUniqueTempDir());
      FileMetricsProvider::RegisterPrefs(prefs_->registry(), kMetricsName);
      FileMetricsProvider::SetTaskRunnerForTesting(task_runner_);
    base::GlobalHistogramAllocator::GetCreateHistogramResultHistogram();
    }",[11],"The Extensions subsystem in Google Chrome before 49.0.2623.75 does not properly maintain own properties, which allows remote attackers to bypass intended access restrictions via crafted JavaScript code that triggers an incorrect cast, related to extensions/renderer/v8_helpers.h and gin/converter.h."
9258,"int nfc_dep_link_down(struct nfc_dev *dev)
{
int rc = 0;

pr_debug(""dev_name=%s\n"", dev_name(&dev->dev));

if (!dev->ops->dep_link_down)
return -EOPNOTSUPP;

device_lock(&dev->dev);

if (!device_is_registered(&dev->dev)) {
rc = -ENODEV;
goto error;
}

if (dev->dep_link_up == false) {
rc = -EALREADY;
goto error;
}

rc = dev->ops->dep_link_down(dev);
if (!rc) {
dev->dep_link_up = false;
dev->active_target = NULL;
dev->rf_mode = NFC_RF_NONE;
nfc_llcp_mac_is_down(dev);
nfc_genl_dep_link_down_event(dev);
}

error:
device_unlock(&dev->dev);

return rc;
}",[12],A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.
200372,"  static void array_cleanup( char* arr[] , int arr_size)
  {
  	int i=0;
	for( i=0; i< arr_size; i++ ){ 
 	for( i=0; i< arr_size; i++ ){
  		if( arr[i*2] ){
  			efree( arr[i*2]);
  		}
 	}
 	efree(arr);
 }","[5, 4]","The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call."
199878," static int cg_open(const char *path, struct fuse_file_info *fi)
 {
 	const char *cgroup;
 	char *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;
 	struct cgfs_files *k = NULL;
 	struct file_info *file_info;
 	struct fuse_context *fc = fuse_get_context();
 	int ret;
 
 	if (!fc)
 		return -EIO;
 
 	controller = pick_controller_from_path(fc, path);
 	if (!controller)
 		return -EIO;
 	cgroup = find_cgroup_in_path(path);
 	if (!cgroup)
 		return -EINVAL;
 
 	get_cgdir_and_path(cgroup, &cgdir, &fpath);
 	if (!fpath) {
 		path1 = ""/"";
 		path2 = cgdir;
 	} else {
 		path1 = cgdir;
 		path2 = fpath;
 	}
 
 	k = cgfs_get_key(controller, path1, path2);
 	if (!k) {
 		ret = -EINVAL;
 		goto out;
  	}
  	free_key(k);
  
 	if (!caller_may_see_dir(fc->pid, controller, path1)) {
 		ret = -ENOENT;
 		goto out;
 	}
  	if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {
  		ret = -EACCES;
 		goto out;
 	}
 
 	 
 	file_info = malloc(sizeof(*file_info));
 	if (!file_info) {
 		ret = -ENOMEM;
 		goto out;
 	}
 	file_info->controller = must_copy_string(controller);
 	file_info->cgroup = must_copy_string(path1);
 	file_info->file = must_copy_string(path2);
 	file_info->type = LXC_TYPE_CGFILE;
 	file_info->buf = NULL;
 	file_info->buflen = 0;
 
 	fi->fh = (unsigned long)file_info;
 	ret = 0;
 
 out:
 	free(cgdir);
 	return ret;
 }","[36, 37, 38, 39]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup."
734,"static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)

{
unsigned int len;
unsigned long start=0, off;
struct au1200fb_device *fbdev = info->par;

if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
return -EINVAL;
}

start = fbdev->fb_phys & PAGE_MASK;
len = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);

off = vma->vm_pgoff << PAGE_SHIFT;

if ((vma->vm_end - vma->vm_start + off) > len) {
return -EINVAL;
}

off += start;
vma->vm_pgoff = off >> PAGE_SHIFT;

vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
pgprot_val(vma->vm_page_prot) |= _CACHE_MASK;

return io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
vma->vm_end - vma->vm_start,
vma->vm_page_prot);
}","[4, 5, 8, 9, 12, 13, 15, 17, 18, 21, 22, 27, 28, 29]","Multiple integer overflows in Alchemy LCD frame-buffer drivers in the Linux kernel before 3.12 allow local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted mmap operations, related to the (1) au1100fb_fb_mmap function in drivers/video/au1100fb.c and the (2) au1200fb_fb_mmap function in drivers/video/au1200fb.c."
202153,"  init_global_keywords(bool global_active)
  {
 	 
 	install_keyword_root(""linkbeat_use_polling"", use_polling_handler, global_active);
 #if HAVE_DECL_CLONE_NEWNET
 	install_keyword_root(""net_namespace"", &net_namespace_handler, global_active);
 	install_keyword_root(""namespace_with_ipsets"", &namespace_ipsets_handler, global_active);
 #endif
 	install_keyword_root(""use_pid_dir"", &use_pid_dir_handler, global_active);
 	install_keyword_root(""instance"", &instance_handler, global_active);
 	install_keyword_root(""child_wait_time"", &child_wait_handler, global_active);
 	install_keyword_root(""global_defs"", NULL, global_active);
 	install_keyword(""router_id"", &routerid_handler);
 	install_keyword(""notification_email_from"", &emailfrom_handler);
 	install_keyword(""smtp_server"", &smtpserver_handler);
 	install_keyword(""smtp_helo_name"", &smtphelo_handler);
 	install_keyword(""smtp_connect_timeout"", &smtpto_handler);
 	install_keyword(""notification_email"", &email_handler);
 	install_keyword(""smtp_alert"", &smtp_alert_handler);
 #ifdef _WITH_VRRP_
 	install_keyword(""smtp_alert_vrrp"", &smtp_alert_vrrp_handler);
 #endif
 #ifdef _WITH_LVS_
 	install_keyword(""smtp_alert_checker"", &smtp_alert_checker_handler);
 #endif
 #ifdef _WITH_VRRP_
 	install_keyword(""dynamic_interfaces"", &dynamic_interfaces_handler);
 	install_keyword(""no_email_faults"", &no_email_faults_handler);
 	install_keyword(""default_interface"", &default_interface_handler);
 #endif
 #ifdef _WITH_LVS_
 	install_keyword(""lvs_timeouts"", &lvs_timeouts);
 	install_keyword(""lvs_flush"", &lvs_flush_handler);
 #ifdef _WITH_VRRP_
 	install_keyword(""lvs_sync_daemon"", &lvs_syncd_handler);
 #endif
 #endif
 #ifdef _WITH_VRRP_
 	install_keyword(""vrrp_mcast_group4"", &vrrp_mcast_group4_handler);
 	install_keyword(""vrrp_mcast_group6"", &vrrp_mcast_group6_handler);
 	install_keyword(""vrrp_garp_master_delay"", &vrrp_garp_delay_handler);
 	install_keyword(""vrrp_garp_master_repeat"", &vrrp_garp_rep_handler);
 	install_keyword(""vrrp_garp_master_refresh"", &vrrp_garp_refresh_handler);
 	install_keyword(""vrrp_garp_master_refresh_repeat"", &vrrp_garp_refresh_rep_handler);
 	install_keyword(""vrrp_garp_lower_prio_delay"", &vrrp_garp_lower_prio_delay_handler);
 	install_keyword(""vrrp_garp_lower_prio_repeat"", &vrrp_garp_lower_prio_rep_handler);
 	install_keyword(""vrrp_garp_interval"", &vrrp_garp_interval_handler);
 	install_keyword(""vrrp_gna_interval"", &vrrp_gna_interval_handler);
 	install_keyword(""vrrp_lower_prio_no_advert"", &vrrp_lower_prio_no_advert_handler);
 	install_keyword(""vrrp_higher_prio_send_advert"", &vrrp_higher_prio_send_advert_handler);
 	install_keyword(""vrrp_version"", &vrrp_version_handler);
 	install_keyword(""vrrp_iptables"", &vrrp_iptables_handler);
 #ifdef _HAVE_LIBIPSET_
 	install_keyword(""vrrp_ipsets"", &vrrp_ipsets_handler);
 #endif
 	install_keyword(""vrrp_check_unicast_src"", &vrrp_check_unicast_src_handler);
 	install_keyword(""vrrp_skip_check_adv_addr"", &vrrp_check_adv_addr_handler);
 	install_keyword(""vrrp_strict"", &vrrp_strict_handler);
 	install_keyword(""vrrp_priority"", &vrrp_prio_handler);
 	install_keyword(""vrrp_no_swap"", &vrrp_no_swap_handler);
 #ifdef _HAVE_SCHED_RT_
 	install_keyword(""vrrp_rt_priority"", &vrrp_rt_priority_handler);
 #if HAVE_DECL_RLIMIT_RTTIME == 1
 	install_keyword(""vrrp_rlimit_rtime"", &vrrp_rt_rlimit_handler);
 #endif
 #endif
 #endif
 	install_keyword(""notify_fifo"", &global_notify_fifo);
 	install_keyword(""notify_fifo_script"", &global_notify_fifo_script);
 #ifdef _WITH_VRRP_
 	install_keyword(""vrrp_notify_fifo"", &vrrp_notify_fifo);
 	install_keyword(""vrrp_notify_fifo_script"", &vrrp_notify_fifo_script);
 #endif
 #ifdef _WITH_LVS_
 	install_keyword(""lvs_notify_fifo"", &lvs_notify_fifo);
 	install_keyword(""lvs_notify_fifo_script"", &lvs_notify_fifo_script);
 	install_keyword(""checker_priority"", &checker_prio_handler);
 	install_keyword(""checker_no_swap"", &checker_no_swap_handler);
 #ifdef _HAVE_SCHED_RT_
 	install_keyword(""checker_rt_priority"", &checker_rt_priority_handler);
 #if HAVE_DECL_RLIMIT_RTTIME == 1
 	install_keyword(""checker_rlimit_rtime"", &checker_rt_rlimit_handler);
 #endif
 #endif
 #endif
 #ifdef _WITH_BFD_
 	install_keyword(""bfd_priority"", &bfd_prio_handler);
 	install_keyword(""bfd_no_swap"", &bfd_no_swap_handler);
 #ifdef _HAVE_SCHED_RT_
 	install_keyword(""bfd_rt_priority"", &bfd_rt_priority_handler);
 #if HAVE_DECL_RLIMIT_RTTIME == 1
 	install_keyword(""bfd_rlimit_rtime"", &bfd_rt_rlimit_handler);
 #endif
 #endif
 #endif
 #ifdef _WITH_SNMP_
 	install_keyword(""snmp_socket"", &snmp_socket_handler);
 	install_keyword(""enable_traps"", &trap_handler);
 #ifdef _WITH_SNMP_VRRP_
 	install_keyword(""enable_snmp_vrrp"", &snmp_vrrp_handler);
 	install_keyword(""enable_snmp_keepalived"", &snmp_vrrp_handler);	 
 #endif
 #ifdef _WITH_SNMP_RFC_
 	install_keyword(""enable_snmp_rfc"", &snmp_rfc_handler);
 #endif
 #ifdef _WITH_SNMP_RFCV2_
 	install_keyword(""enable_snmp_rfcv2"", &snmp_rfcv2_handler);
 #endif
 #ifdef _WITH_SNMP_RFCV3_
 	install_keyword(""enable_snmp_rfcv3"", &snmp_rfcv3_handler);
 #endif
 #ifdef _WITH_SNMP_CHECKER_
 	install_keyword(""enable_snmp_checker"", &snmp_checker_handler);
 #endif
 #endif
 #ifdef _WITH_DBUS_
 	install_keyword(""enable_dbus"", &enable_dbus_handler);
 	install_keyword(""dbus_service_name"", &dbus_service_name_handler);
 #endif
 	install_keyword(""script_user"", &script_user_handler);
 	install_keyword(""enable_script_security"", &script_security_handler);
 #ifdef _WITH_VRRP_
 	install_keyword(""vrrp_netlink_cmd_rcv_bufs"", &vrrp_netlink_cmd_rcv_bufs_handler);
 	install_keyword(""vrrp_netlink_cmd_rcv_bufs_force"", &vrrp_netlink_cmd_rcv_bufs_force_handler);
 	install_keyword(""vrrp_netlink_monitor_rcv_bufs"", &vrrp_netlink_monitor_rcv_bufs_handler);
 	install_keyword(""vrrp_netlink_monitor_rcv_bufs_force"", &vrrp_netlink_monitor_rcv_bufs_force_handler);
 #endif
 #ifdef _WITH_LVS_
 	install_keyword(""lvs_netlink_cmd_rcv_bufs"", &lvs_netlink_cmd_rcv_bufs_handler);
 	install_keyword(""lvs_netlink_cmd_rcv_bufs_force"", &lvs_netlink_cmd_rcv_bufs_force_handler);
 	install_keyword(""lvs_netlink_monitor_rcv_bufs"", &lvs_netlink_monitor_rcv_bufs_handler);
 	install_keyword(""lvs_netlink_monitor_rcv_bufs_force"", &lvs_netlink_monitor_rcv_bufs_force_handler);
 #endif
 #ifdef _WITH_LVS_
 	install_keyword(""rs_init_notifies"", &rs_init_notifies_handler);
 	install_keyword(""no_checker_emails"", &no_checker_emails_handler);
 #endif
 #ifdef _WITH_VRRP_
  	install_keyword(""vrrp_rx_bufs_policy"", &vrrp_rx_bufs_policy_handler);
  	install_keyword(""vrrp_rx_bufs_multiplier"", &vrrp_rx_bufs_multiplier_handler);
  #endif
 	install_keyword(""umask"", &umask_handler);
  }",[142],"keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information."
199826," spnego_gss_delete_sec_context(
 			    OM_uint32 *minor_status,
 			    gss_ctx_id_t *context_handle,
 			    gss_buffer_t output_token)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
 	spnego_gss_ctx_id_t *ctx =
 		    (spnego_gss_ctx_id_t *)context_handle;
 
 	*minor_status = 0;
 
 	if (context_handle == NULL)
 		return (GSS_S_FAILURE);
 
  	if (*ctx == NULL)
  		return (GSS_S_COMPLETE);
  
	 
	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
		(void) gss_delete_sec_context(minor_status,
				    &(*ctx)->ctx_handle,
				    output_token);
		(void) release_spnego_ctx(ctx);
	} else {
		ret = gss_delete_sec_context(minor_status,
				    context_handle,
				    output_token);
	}
 	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
 				      output_token);
 	(void) release_spnego_ctx(ctx);
  
  	return (ret);
  }","[29, 30, 31, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
199787," vhost_scsi_make_tpg(struct se_wwn *wwn,
 		   struct config_group *group,
 		   const char *name)
 {
 	struct vhost_scsi_tport *tport = container_of(wwn,
  			struct vhost_scsi_tport, tport_wwn);
  
  	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	u16 tpgt;
  	int ret;
  
  	if (strstr(name, ""tpgt_"") != name)
  		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 	if (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)
  		return ERR_PTR(-EINVAL);
  
  	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
 	if (!tpg) {
 		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
 		return ERR_PTR(-ENOMEM);
 	}
 	mutex_init(&tpg->tv_tpg_mutex);
 	INIT_LIST_HEAD(&tpg->tv_tpg_list);
 	tpg->tport = tport;
 	tpg->tport_tpgt = tpgt;
 
 	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
 				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
 	if (ret < 0) {
 		kfree(tpg);
 		return NULL;
 	}
 	mutex_lock(&vhost_scsi_mutex);
 	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
 	mutex_unlock(&vhost_scsi_mutex);
 
 	return &tpg->se_tpg;
 }","[10, 16, 9, 15]",Array index error in the tcm_vhost_make_tpg function in drivers/vhost/scsi.c in the Linux kernel before 4.0 might allow guest OS users to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted VHOST_SCSI_SET_ENDPOINT ioctl call.  NOTE: the affected function was renamed to vhost_scsi_make_tpg before the vulnerability was announced.
201238," SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)
 {
 	int ufd;
 	struct timerfd_ctx *ctx;
 
 	 
 	BUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);
 	BUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);
 
 	if ((flags & ~TFD_CREATE_FLAGS) ||
 	    (clockid != CLOCK_MONOTONIC &&
 	     clockid != CLOCK_REALTIME &&
 	     clockid != CLOCK_REALTIME_ALARM &&
 	     clockid != CLOCK_BOOTTIME &&
 	     clockid != CLOCK_BOOTTIME_ALARM))
 		return -EINVAL;
 
 	if (!capable(CAP_WAKE_ALARM) &&
 	    (clockid == CLOCK_REALTIME_ALARM ||
 	     clockid == CLOCK_BOOTTIME_ALARM))
 		return -EPERM;
 
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
  		return -ENOMEM;
  
  	init_waitqueue_head(&ctx->wqh);
 	spin_lock_init(&ctx->cancel_lock);
  	ctx->clockid = clockid;
  
  	if (isalarm(ctx))
 		alarm_init(&ctx->t.alarm,
 			   ctx->clockid == CLOCK_REALTIME_ALARM ?
 			   ALARM_REALTIME : ALARM_BOOTTIME,
 			   timerfd_alarmproc);
 	else
 		hrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);
 
 	ctx->moffs = ktime_mono_to_real(0);
 
 	ufd = anon_inode_getfd(""[timerfd]"", &timerfd_fops, ctx,
 			       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));
 	if (ufd < 0)
 		kfree(ctx);
 
 	return ufd;
 }",[28],Race condition in fs/timerfd.c in the Linux kernel before 4.10.15 allows local users to gain privileges or cause a denial of service (list corruption or use-after-free) via simultaneous file-descriptor operations that leverage improper might_cancel queueing.
207253,"   ExtensionScriptAndCaptureVisibleTest()
       : http_url(""http:www.google.com""),
         http_url_with_path(""http:www.google.com/index.html""),
         https_url(""https:www.google.com""),
         example_com(""https:example.com""),
         test_example_com(""https:test.example.com""),
         sample_example_com(""https:sample.example.com""),
         file_url(""file:/foo/bar""),
         favicon_url(""chrome:favicon/http:www.google.com""),
         extension_url(""chrome-extension:"" +
                        crx_file::id_util::GenerateIdForPath(
                            base::FilePath(FILE_PATH_LITERAL(""foo"")))),
          settings_url(""chrome:settings""),
        about_url(""about:flags"") {
         about_flags_url(""about:flags"") {
      urls_.insert(http_url);
      urls_.insert(http_url_with_path);
      urls_.insert(https_url);
     urls_.insert(example_com);
     urls_.insert(test_example_com);
     urls_.insert(sample_example_com);
     urls_.insert(file_url);
      urls_.insert(favicon_url);
      urls_.insert(extension_url);
      urls_.insert(settings_url);
    urls_.insert(about_url);
     urls_.insert(about_flags_url);
      PermissionsData::SetPolicyDelegate(NULL);
    }","[15, 27, 14, 26]",Insufficient policy enforcement in Extensions API in Google Chrome prior to 67.0.3396.62 allowed an attacker who convinced a user to install a malicious extension to bypass navigation restrictions via a crafted Chrome Extension.
204587," bool GraphicsContext3D::getImageData(Image* image,
                                      GC3Denum format,
                                      GC3Denum type,
                                      bool premultiplyAlpha,
                                      bool ignoreGammaAndColorProfile,
                                      Vector<uint8_t>& outputVector)
 {
     if (!image)
          return false;
      CGImageRef cgImage;
      RetainPtr<CGImageRef> decodedImage;
    bool hasAlpha = image->isBitmapImage() ? static_cast<BitmapImage*>(image)->frameHasAlphaAtIndex(0) : true;
     bool hasAlpha = image->isBitmapImage() ? image->currentFrameHasAlpha() : true;
      if ((ignoreGammaAndColorProfile || (hasAlpha && !premultiplyAlpha)) && image->data()) {
          ImageSource decoder(ImageSource::AlphaNotPremultiplied,
                              ignoreGammaAndColorProfile ? ImageSource::GammaAndColorProfileIgnored : ImageSource::GammaAndColorProfileApplied);
         decoder.setData(image->data(), true);
         if (!decoder.frameCount())
             return false;
         decodedImage.adoptCF(decoder.createFrameAtIndex(0));
         cgImage = decodedImage.get();
     } else
         cgImage = image->nativeImageForCurrentFrame();
     if (!cgImage)
         return false;
 
     size_t width = CGImageGetWidth(cgImage);
     size_t height = CGImageGetHeight(cgImage);
     if (!width || !height)
         return false;
 
     CGColorSpaceRef colorSpace = CGImageGetColorSpace(cgImage);
     CGColorSpaceModel model = CGColorSpaceGetModel(colorSpace);
     if (model == kCGColorSpaceModelIndexed) {
         RetainPtr<CGContextRef> bitmapContext;
         bitmapContext.adoptCF(CGBitmapContextCreate(0, width, height, 8, width * 4,
                                                     deviceRGBColorSpaceRef(),
                                                     kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host));
         if (!bitmapContext)
             return false;
 
         CGContextSetBlendMode(bitmapContext.get(), kCGBlendModeCopy);
         CGContextSetInterpolationQuality(bitmapContext.get(), kCGInterpolationNone);
         CGContextDrawImage(bitmapContext.get(), CGRectMake(0, 0, width, height), cgImage);
 
         decodedImage.adoptCF(CGBitmapContextCreateImage(bitmapContext.get()));
         cgImage = decodedImage.get();
     }
 
     size_t bitsPerComponent = CGImageGetBitsPerComponent(cgImage);
     size_t bitsPerPixel = CGImageGetBitsPerPixel(cgImage);
     if (bitsPerComponent != 8 && bitsPerComponent != 16)
         return false;
     if (bitsPerPixel % bitsPerComponent)
         return false;
     size_t componentsPerPixel = bitsPerPixel / bitsPerComponent;
 
     CGBitmapInfo bitInfo = CGImageGetBitmapInfo(cgImage);
     bool bigEndianSource = false;
     if (bitsPerComponent == 16) {
         switch (bitInfo & kCGBitmapByteOrderMask) {
         case kCGBitmapByteOrder16Big:
             bigEndianSource = true;
             break;
         case kCGBitmapByteOrder16Little:
             bigEndianSource = false;
             break;
         case kCGBitmapByteOrderDefault:
             bigEndianSource = true;
             break;
         default:
             return false;
         }
     } else {
         switch (bitInfo & kCGBitmapByteOrderMask) {
         case kCGBitmapByteOrder32Big:
             bigEndianSource = true;
             break;
         case kCGBitmapByteOrder32Little:
             bigEndianSource = false;
             break;
         case kCGBitmapByteOrderDefault:
             bigEndianSource = true;
             break;
         default:
             return false;
         }
     }
 
     AlphaOp neededAlphaOp = AlphaDoNothing;
     AlphaFormat alphaFormat = AlphaFormatNone;
     switch (CGImageGetAlphaInfo(cgImage)) {
     case kCGImageAlphaPremultipliedFirst:
         if (!premultiplyAlpha)
             neededAlphaOp = AlphaDoUnmultiply;
         alphaFormat = AlphaFormatFirst;
         break;
     case kCGImageAlphaFirst:
         if (premultiplyAlpha)
             neededAlphaOp = AlphaDoPremultiply;
         alphaFormat = AlphaFormatFirst;
         break;
     case kCGImageAlphaNoneSkipFirst:
         alphaFormat = AlphaFormatFirst;
         break;
     case kCGImageAlphaPremultipliedLast:
         if (!premultiplyAlpha)
             neededAlphaOp = AlphaDoUnmultiply;
         alphaFormat = AlphaFormatLast;
         break;
     case kCGImageAlphaLast:
         if (premultiplyAlpha)
             neededAlphaOp = AlphaDoPremultiply;
         alphaFormat = AlphaFormatLast;
         break;
     case kCGImageAlphaNoneSkipLast:
         alphaFormat = AlphaFormatLast;
         break;
     case kCGImageAlphaNone:
         alphaFormat = AlphaFormatNone;
         break;
     default:
         return false;
     }
     SourceDataFormat srcDataFormat = getSourceDataFormat(componentsPerPixel, alphaFormat, bitsPerComponent == 16, bigEndianSource);
     if (srcDataFormat == SourceFormatNumFormats)
         return false;
 
     RetainPtr<CFDataRef> pixelData;
     pixelData.adoptCF(CGDataProviderCopyData(CGImageGetDataProvider(cgImage)));
     if (!pixelData)
         return false;
     const UInt8* rgba = CFDataGetBytePtr(pixelData.get());
 
     unsigned int packedSize;
     if (computeImageSizeInBytes(format, type, width, height, 1, &packedSize, 0) != GraphicsContext3D::NO_ERROR)
         return false;
     outputVector.resize(packedSize);
 
     unsigned int srcUnpackAlignment = 0;
     size_t bytesPerRow = CGImageGetBytesPerRow(cgImage);
     unsigned int padding = bytesPerRow - bitsPerPixel / 8 * width;
     if (padding) {
         srcUnpackAlignment = padding + 1;
         while (bytesPerRow % srcUnpackAlignment)
             ++srcUnpackAlignment;
     }
     bool rt = packPixels(rgba, srcDataFormat, width, height, srcUnpackAlignment,
                          format, type, neededAlphaOp, outputVector.data());
     return rt;
 }","[13, 12]",Use-after-free vulnerability in Google Chrome before 20.0.1132.43 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to SVG painting.
202054," static int read_uids_guids(long long *table_start)
 static int read_id_table(long long *table_start)
  {
 	 
  	int res, i;
  	int bytes = SQUASHFS_ID_BYTES(sBlk.s.no_ids);
  	int indexes = SQUASHFS_ID_BLOCKS(sBlk.s.no_ids);
	long long id_index_table[indexes];
 	int length = SQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids);
 	long long *id_index_table;
 
 	 
 	if(length != (*table_start - sBlk.s.id_table_start)) {
 		ERROR(""read_id_table: Bad id count in super block\n"");
 		return FALSE;
 	}
  
	TRACE(""read_uids_guids: no_ids %d\n"", sBlk.s.no_ids);
 	TRACE(""read_id_table: no_ids %d\n"", sBlk.s.no_ids);
  
 	id_index_table = alloc_index_table(indexes);
  	id_table = malloc(bytes);
  	if(id_table == NULL) {
		ERROR(""read_uids_guids: failed to allocate id table\n"");
 		ERROR(""read_id_table: failed to allocate id table\n"");
  		return FALSE;
  	}
  
	res = read_fs_bytes(fd, sBlk.s.id_table_start,
		SQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), id_index_table);
 	res = read_fs_bytes(fd, sBlk.s.id_table_start, length, id_index_table);
  	if(res == FALSE) {
		ERROR(""read_uids_guids: failed to read id index table\n"");
 		ERROR(""read_id_table: failed to read id index table\n"");
  		return FALSE;
  	}
  	SQUASHFS_INSWAP_ID_BLOCKS(id_index_table, indexes);
 
 	 
 	*table_start = id_index_table[0];
 
 	for(i = 0; i < indexes; i++) {
 		int expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :
 					bytes & (SQUASHFS_METADATA_SIZE - 1);
  		res = read_block(fd, id_index_table[i], NULL, expected,
  			((char *) id_table) + i * SQUASHFS_METADATA_SIZE);
  		if(res == FALSE) {
			ERROR(""read_uids_guids: failed to read id table block""
 			ERROR(""read_id_table: failed to read id table block""
  				""\n"");
  			return FALSE;
  		}
 	}
 
 	SQUASHFS_INSWAP_INTS(id_table, sBlk.s.no_ids);
 
 	return TRUE;
 }","[2, 4, 9, 10, 11, 12, 13, 14, 15, 16, 19, 21, 25, 31, 34, 49, 8, 18, 24, 29, 30, 33, 48]","Integer overflow in the read_fragment_table_4 function in unsquash-4.c in Squashfs and sasquatch allows remote attackers to cause a denial of service (application crash) via a crafted input, which triggers a stack-based buffer overflow."
9804,"void svhandler_flash_pgm_blk(void) {
uint32_t beginAddr = _param_1;
uint32_t data = _param_2;
uint32_t length = _param_3;


if (beginAddr + length < beginAddr) return;


if (((beginAddr >= BSTRP_FLASH_SECT_START) &&
(beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||
(((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&
((beginAddr + length) <=
(BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {
return;
}

if (((beginAddr >= BLDR_FLASH_SECT_START) &&
(beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||
(((beginAddr + length) >= BLDR_FLASH_SECT_START) &&
((beginAddr + length) <=
(BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {
return;
}


flash_clear_status_flags();
flash_unlock();


flash_program(beginAddr, (uint8_t *)data, length);


_param_1 = !!flash_chk_status();
_param_2 = 0;
_param_3 = 0;


flash_wait_for_last_operation();


FLASH_CR &= ~FLASH_CR_PG;


FLASH_CR |= FLASH_CR_LOCK;
}","[7, 10, 11, 12, 13, 14, 15, 18, 19, 20, 21, 22, 23]","In the KeepKey firmware before 7.3.2,Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations. Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes."
207576," bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,
                                            LINK_KEY link_key,
  uint8_t key_type,
  uint8_t pin_length)
 {
  bdstr_t bdstr;
     bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
 
      int ret = btif_config_set_int(bdstr, ""LinkKeyType"", (int)key_type);
      ret &= btif_config_set_int(bdstr, ""PinLength"", (int)pin_length);
      ret &= btif_config_set_bin(bdstr, ""LinkKey"", link_key, sizeof(LINK_KEY));
 
     if (is_restricted_mode()) {
         BTIF_TRACE_WARNING(""%s: '%s' pairing will be removed if unrestricted"",
                          __func__, bdstr);
         btif_config_set_int(bdstr, ""Restricted"", 1);
     }
 
       
      btif_config_flush();
      return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
 }","[12, 13, 14, 15, 16, 17, 18]","Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683."
208099," void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  uint8_t* p = (uint8_t*)p_data;
 
    uint8_t reason = SMP_INVALID_PARAMETERS;
  
    SMP_TRACE_DEBUG(""%s"", __func__);
  p_cb->status = *(uint8_t*)p_data;
  
    if (smp_command_has_invalid_parameters(p_cb)) {
     if (p_cb->rcvd_cmd_len < 2) {   
       android_errorWriteLog(0x534e4554, ""111936834"");
     }
      smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);
      return;
    }
  
   p_cb->status = *(uint8_t*)p_data;
 
    if (p != NULL) {
      STREAM_TO_UINT8(p_cb->peer_keypress_notification, p);
    } else {
     p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;
  }
   p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;
 }","[10, 11, 12, 17, 18, 7]","In smp_process_keypress_notification of smp_act.cc, there is a possible out of bounds read due to an incorrect bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-111936834"
203291," static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   Image
     *image;
 
   MagickBooleanType
     status;
 
   MagickSizeType
     number_pixels;
 
   MemoryInfo
     *pixel_info;
 
   register Quantum
     *q;
 
   register ssize_t
     i,
     x;
 
   register unsigned char
     *p;
 
   SGIInfo
     iris_info;
 
   size_t
     bytes_per_pixel,
     quantum;
 
   ssize_t
     count,
     y,
     z;
 
   unsigned char
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   iris_info.magic=ReadBlobMSBShort(image);
   do
   {
      
     if (iris_info.magic != 0x01DA)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     iris_info.storage=(unsigned char) ReadBlobByte(image);
     switch (iris_info.storage)
     {
       case 0x00: image->compression=NoCompression; break;
       case 0x01: image->compression=RLECompression; break;
       default:
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
     iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);
     if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     iris_info.dimension=ReadBlobMSBShort(image);
     iris_info.columns=ReadBlobMSBShort(image);
     iris_info.rows=ReadBlobMSBShort(image);
     iris_info.depth=ReadBlobMSBShort(image);
     if ((iris_info.depth == 0) || (iris_info.depth > 4))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      iris_info.minimum_value=ReadBlobMSBLong(image);
      iris_info.maximum_value=ReadBlobMSBLong(image);
      iris_info.sans=ReadBlobMSBLong(image);
    (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *)
     count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)
        iris_info.name);
     if (count != sizeof(iris_info.name))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      iris_info.name[sizeof(iris_info.name)-1]='\0';
      if (*iris_info.name != '\0')
        (void) SetImageProperty(image,""label"",iris_info.name,exception);
      iris_info.pixel_format=ReadBlobMSBLong(image);
      if (iris_info.pixel_format != 0)
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);
    (void) count;
     if (count != sizeof(iris_info.filler))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      image->columns=iris_info.columns;
      image->rows=iris_info.rows;
      image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);
     if (iris_info.pixel_format == 0)
       image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,
         MAGICKCORE_QUANTUM_DEPTH);
     if (iris_info.depth < 3)
       {
          image->storage_class=PseudoClass;
          image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;
        }
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))
     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
        if (image->scene >= (image_info->scene+image_info->number_scenes-1))
          break;
      status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
      
     bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;
     number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;
     if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)
         (4*bytes_per_pixel*number_pixels)))
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*
       bytes_per_pixel*sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     if ((int) iris_info.storage != 0x01)
       {
         unsigned char
           *scanline;
 
          
         scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,
           bytes_per_pixel*sizeof(*scanline));
         if (scanline == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         for (z=0; z < (ssize_t) iris_info.depth; z++)
         {
           p=pixels+bytes_per_pixel*z;
           for (y=0; y < (ssize_t) iris_info.rows; y++)
           {
             count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);
             if (EOFBlob(image) != MagickFalse)
               break;
             if (bytes_per_pixel == 2)
               for (x=0; x < (ssize_t) iris_info.columns; x++)
               {
                 *p=scanline[2*x];
                 *(p+1)=scanline[2*x+1];
                 p+=8;
               }
             else
               for (x=0; x < (ssize_t) iris_info.columns; x++)
               {
                 *p=scanline[x];
                 p+=4;
               }
           }
         }
         scanline=(unsigned char *) RelinquishMagickMemory(scanline);
       }
     else
       {
         MemoryInfo
           *packet_info;
 
         size_t
           *runlength;
 
         ssize_t
           offset,
           *offsets;
 
         unsigned char
           *packets;
 
         unsigned int
           data_order;
 
          
         offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,
           iris_info.depth*sizeof(*offsets));
         runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,
           iris_info.depth*sizeof(*runlength));
         packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*
           sizeof(*packets));
         if ((offsets == (ssize_t *) NULL) ||
             (runlength == (size_t *) NULL) ||
             (packet_info == (MemoryInfo *) NULL))
           {
             if (offsets == (ssize_t *) NULL)
               offsets=(ssize_t *) RelinquishMagickMemory(offsets);
             if (runlength == (size_t *) NULL)
               runlength=(size_t *) RelinquishMagickMemory(runlength);
             if (packet_info == (MemoryInfo *) NULL)
               packet_info=RelinquishVirtualMemory(packet_info);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);
         for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
           offsets[i]=ReadBlobMSBSignedLong(image);
         for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
         {
           runlength[i]=ReadBlobMSBLong(image);
           if (runlength[i] > (4*(size_t) iris_info.columns+10))
             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         }
          
         offset=0;
         data_order=0;
         for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)
           for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)
           {
             if (offsets[y+z*iris_info.rows] < offset)
               data_order=1;
             offset=offsets[y+z*iris_info.rows];
           }
         offset=(ssize_t) TellBlob(image);
         if (data_order == 1)
           {
             for (z=0; z < (ssize_t) iris_info.depth; z++)
             {
               p=pixels;
               for (y=0; y < (ssize_t) iris_info.rows; y++)
               {
                 if (offset != offsets[y+z*iris_info.rows])
                   {
                     offset=offsets[y+z*iris_info.rows];
                     offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);
                   }
                 count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],
                   packets);
                 if (EOFBlob(image) != MagickFalse)
                   break;
                 offset+=(ssize_t) runlength[y+z*iris_info.rows];
                 status=SGIDecode(bytes_per_pixel,(ssize_t)
                   (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,
                   1L*iris_info.columns,p+bytes_per_pixel*z);
                 if (status == MagickFalse)
                   ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
                 p+=(iris_info.columns*4*bytes_per_pixel);
               }
             }
           }
         else
           {
             MagickOffsetType
               position;
            
             position=TellBlob(image);
             p=pixels;
             for (y=0; y < (ssize_t) iris_info.rows; y++)
             {
               for (z=0; z < (ssize_t) iris_info.depth; z++)
               {
                 if (offset != offsets[y+z*iris_info.rows])
                   {
                     offset=offsets[y+z*iris_info.rows];
                     offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);
                   }
                 count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],
                   packets);
                 if (EOFBlob(image) != MagickFalse)
                   break;
                 offset+=(ssize_t) runlength[y+z*iris_info.rows];
                 status=SGIDecode(bytes_per_pixel,(ssize_t)
                   (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,
                   1L*iris_info.columns,p+bytes_per_pixel*z);
                 if (status == MagickFalse)
                   ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
               }
               p+=(iris_info.columns*4*bytes_per_pixel);
             }
             offset=(ssize_t) SeekBlob(image,position,SEEK_SET);
           }
         packet_info=RelinquishVirtualMemory(packet_info);
         runlength=(size_t *) RelinquishMagickMemory(runlength);
         offsets=(ssize_t *) RelinquishMagickMemory(offsets);
       }
      
     image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait : 
       UndefinedPixelTrait;
     image->columns=iris_info.columns;
     image->rows=iris_info.rows;
      
     if (image->storage_class == DirectClass)
       {
          
         if (bytes_per_pixel == 2)
           {
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               p=pixels+(image->rows-y-1)*8*image->columns;
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelRed(image,ScaleShortToQuantum((unsigned short)
                   ((*(p+0) << 8) | (*(p+1)))),q);
                 SetPixelGreen(image,ScaleShortToQuantum((unsigned short)
                   ((*(p+2) << 8) | (*(p+3)))),q);
                 SetPixelBlue(image,ScaleShortToQuantum((unsigned short)
                   ((*(p+4) << 8) | (*(p+5)))),q);
                 SetPixelAlpha(image,OpaqueAlpha,q);
                 if (image->alpha_trait != UndefinedPixelTrait)
                   SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)
                     ((*(p+6) << 8) | (*(p+7)))),q);
                 p+=8;
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
           }
         else
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             p=pixels+(image->rows-y-1)*4*image->columns;
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               SetPixelRed(image,ScaleCharToQuantum(*p),q);
               SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
               SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
               SetPixelAlpha(image,OpaqueAlpha,q);
               if (image->alpha_trait != UndefinedPixelTrait)
                 SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
               p+=4;
               q+=GetPixelChannels(image);
             }
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                   image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
       }
     else
       {
          
         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          
         if (bytes_per_pixel == 2)
           {
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               p=pixels+(image->rows-y-1)*8*image->columns;
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 quantum=(*p << 8);
                 quantum|=(*(p+1));
                 SetPixelIndex(image,(Quantum) quantum,q);
                 p+=8;
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
           }
         else
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             p=pixels+(image->rows-y-1)*4*image->columns;
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               SetPixelIndex(image,*p,q);
               p+=4;
               q+=GetPixelChannels(image);
             }
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
         (void) SyncImage(image,exception);
       }
     pixel_info=RelinquishVirtualMemory(pixel_info);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     iris_info.magic=ReadBlobMSBShort(image);
     if (iris_info.magic == 0x01DA)
       {
          
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while (iris_info.magic == 0x01DA);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[83, 85, 86, 95, 96, 111, 82, 94, 108, 109, 110]",The SGI coder in ImageMagick before 7.0.2-10 allows remote attackers to cause a denial of service (out-of-bounds read) via a large row value in an sgi file.
9043,"static RList *symbols(RBinFile *bf) {
RList *res = r_list_newf ((RListFree)r_bin_symbol_free);
r_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);
RCoreSymCacheElement *element = bf->o->bin_obj;
size_t i;
HtUU *hash = ht_uu_new0 ();
if (!hash) {
return res;
}
bool found = false;
for (i = 0; i < element->hdr->n_lined_symbols; i++) {
RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
ht_uu_find (hash, sym->paddr, &found);
if (found) {
continue;
}
RBinSymbol *s = bin_symbol_from_symbol (element, sym);
if (s) {
r_list_append (res, s);
ht_uu_insert (hash, sym->paddr, 1);
}
}
if (element->symbols) {
for (i = 0; i < element->hdr->n_symbols; i++) {
RCoreSymCacheElementSymbol *sym = &element->symbols[i];
ht_uu_find (hash, sym->paddr, &found);
if (found) {
continue;
}
RBinSymbol *s = bin_symbol_from_symbol (element, sym);
if (s) {
r_list_append (res, s);
}
}
}
ht_uu_free (hash);
return res;
}",[13],NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.4.
200505," static struct dst_entry *inet6_csk_route_socket(struct sock *sk,
 						struct flowi6 *fl6)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct in6_addr *final_p, final;
 	struct dst_entry *dst;
 
 	memset(fl6, 0, sizeof(*fl6));
 	fl6->flowi6_proto = sk->sk_protocol;
 	fl6->daddr = sk->sk_v6_daddr;
 	fl6->saddr = np->saddr;
 	fl6->flowlabel = np->flow_label;
 	IP6_ECN_flow_xmit(sk, fl6->flowlabel);
 	fl6->flowi6_oif = sk->sk_bound_dev_if;
 	fl6->flowi6_mark = sk->sk_mark;
 	fl6->fl6_sport = inet->inet_sport;
  	fl6->fl6_dport = inet->inet_dport;
  	security_sk_classify_flow(sk, flowi6_to_flowi(fl6));
  
	final_p = fl6_update_dst(fl6, np->opt, &final);
 	rcu_read_lock();
 	final_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);
 	rcu_read_unlock();
  
  	dst = __inet6_csk_dst_check(sk, np->dst_cookie);
  	if (!dst) {
 		dst = ip6_dst_lookup_flow(sk, fl6, final_p);
 
 		if (!IS_ERR(dst))
 			__inet6_csk_dst_store(sk, dst, NULL, NULL);
 	}
 	return dst;
 }","[22, 23, 24, 21]","The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call."
7547,"filter_session_io(struct io *io, int evt, void *arg)
{
struct filter_session *fs = arg;
char *line = NULL;
ssize_t len;

log_trace(TRACE_IO, ""filter session: %p: %s %s"", fs, io_strevent(evt),
io_strio(io));

switch (evt) {
case IO_DATAIN:
nextline:
line = io_getline(fs->io, &len);

if (line == NULL)
return;

filter_data(fs->id, line);

goto nextline;

case IO_DISCONNECTED:
io_free(fs->io);
fs->io = NULL;
break;
}
}","[22, 23, 24, 25]","smtpd/lka_filter.c in OpenSMTPD before 6.8.0p1, in certain configurations, allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted pattern of client activity, because the filter state machine does not properly maintain the I/O channel between the SMTP engine and the filters layer."
201817," static struct dentry *aio_mount(struct file_system_type *fs_type,
 				int flags, const char *dev_name, void *data)
 {
  	static const struct dentry_operations ops = {
  		.d_dname	= simple_dname,
  	};
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
 	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
 					   AIO_RING_MAGIC);
 
 	if (!IS_ERR(root))
 		root->d_sb->s_iflags |= SB_I_NOEXEC;
 	return root;
  }","[8, 9, 10, 11, 12, 13, 7]","The aio_mount function in fs/aio.c in the Linux kernel before 4.7.7 does not properly restrict execute access, which makes it easier for local users to bypass intended SELinux W^X policy restrictions, and consequently gain privileges, via an io_setup system call."
198041," int SSL_library_init(void)
 	{
 
 #ifndef OPENSSL_NO_DES
 	EVP_add_cipher(EVP_des_cbc());
 	EVP_add_cipher(EVP_des_ede3_cbc());
 #endif
 #ifndef OPENSSL_NO_IDEA
 	EVP_add_cipher(EVP_idea_cbc());
 #endif
 #ifndef OPENSSL_NO_RC4
 	EVP_add_cipher(EVP_rc4());
 #if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))
 	EVP_add_cipher(EVP_rc4_hmac_md5());
 #endif
 #endif  
 #ifndef OPENSSL_NO_RC2
 	EVP_add_cipher(EVP_rc2_cbc());
 	 
 	EVP_add_cipher(EVP_rc2_40_cbc());
 #endif
 #ifndef OPENSSL_NO_AES
 	EVP_add_cipher(EVP_aes_128_cbc());
 	EVP_add_cipher(EVP_aes_192_cbc());
         EVP_add_cipher(EVP_aes_256_cbc());
         EVP_add_cipher(EVP_aes_128_gcm());
         EVP_add_cipher(EVP_aes_256_gcm());
#if 0  
  #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
         EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
         EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
  #endif
#endif
  
  #endif
  #ifndef OPENSSL_NO_CAMELLIA
 #endif
 #ifndef OPENSSL_NO_CAMELLIA
 	EVP_add_cipher(EVP_camellia_128_cbc());
 	EVP_add_cipher(EVP_camellia_256_cbc());
 #endif
 
 #ifndef OPENSSL_NO_SEED
 	EVP_add_cipher(EVP_seed_cbc());
 #endif
   
 #ifndef OPENSSL_NO_MD5
 	EVP_add_digest(EVP_md5());
 	EVP_add_digest_alias(SN_md5,""ssl2-md5"");
 	EVP_add_digest_alias(SN_md5,""ssl3-md5"");
 #endif
 #ifndef OPENSSL_NO_SHA
 	EVP_add_digest(EVP_sha1());  
 	EVP_add_digest_alias(SN_sha1,""ssl3-sha1"");
 	EVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);
 #endif
 #ifndef OPENSSL_NO_SHA256
 	EVP_add_digest(EVP_sha224());
 	EVP_add_digest(EVP_sha256());
 #endif
 #ifndef OPENSSL_NO_SHA512
 	EVP_add_digest(EVP_sha384());
 	EVP_add_digest(EVP_sha512());
 #endif
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)
 	EVP_add_digest(EVP_dss1());  
 	EVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);
 	EVP_add_digest_alias(SN_dsaWithSHA1,""DSS1"");
 	EVP_add_digest_alias(SN_dsaWithSHA1,""dss1"");
 #endif
 #ifndef OPENSSL_NO_ECDSA
 	EVP_add_digest(EVP_ecdsa());
 #endif
 	 
 #if 0
 	EVP_add_digest(EVP_sha());
 	EVP_add_digest(EVP_dss());
 #endif
 #ifndef OPENSSL_NO_COMP
 	 
 	(void)SSL_COMP_get_compression_methods();
 #endif
 	 
 	ssl_load_ciphers();
 	return(1);
 	}","[28, 33]",crypto/evp/e_aes_cbc_hmac_sha1.c in the AES-NI functionality in the TLS 1.1 and 1.2 implementations in OpenSSL 1.0.1 before 1.0.1d allows remote attackers to cause a denial of service (application crash) via crafted CBC data.
198233," PHP_METHOD(Phar, unlinkArchive)
 {
 	char *fname, *error, *zname, *arch, *entry;
 	size_t fname_len;
         int zname_len, arch_len, entry_len;
         phar_archive_data *phar;
  
       if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"", &fname, &fname_len) == FAILURE) {
        if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p"", &fname, &fname_len) == FAILURE) {
                 RETURN_FALSE;
         }
  
 	if (!fname_len) {
 		zend_throw_exception_ex(phar_ce_PharException, 0, ""Unknown phar archive \""\"""");
 		return;
 	}
 
 	if (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error)) {
 		if (error) {
 			zend_throw_exception_ex(phar_ce_PharException, 0, ""Unknown phar archive \""%s\"": %s"", fname, error);
 			efree(error);
 		} else {
 			zend_throw_exception_ex(phar_ce_PharException, 0, ""Unknown phar archive \""%s\"""", fname);
 		}
 		return;
 	}
 
 	zname = (char*)zend_get_executed_filename();
 	zname_len = strlen(zname);
 
 	if (zname_len > 7 && !memcmp(zname, ""phar:"", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0)) {
 		if (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {
 			zend_throw_exception_ex(phar_ce_PharException, 0, ""phar archive \""%s\"" cannot be unlinked from within itself"", fname);
 			efree(arch);
 			efree(entry);
 			return;
 		}
 		efree(arch);
 		efree(entry);
 	}
 
 	if (phar->is_persistent) {
 		zend_throw_exception_ex(phar_ce_PharException, 0, ""phar archive \""%s\"" is in phar.cache_list, cannot unlinkArchive()"", fname);
 		return;
 	}
 
 	if (phar->refcount) {
 		zend_throw_exception_ex(phar_ce_PharException, 0, ""phar archive \""%s\"" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()"", fname);
 		return;
 	}
 
 	fname = estrndup(phar->fname, phar->fname_len);
 
 	 
 	PHAR_G(last_phar) = NULL;
 	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;
 
 	phar_archive_delref(phar);
 	unlink(fname);
 	efree(fname);
 	RETURN_TRUE;
 }","[9, 8]","The Phar extension in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allows remote attackers to execute arbitrary code via a crafted filename, as demonstrated by mishandling of \0 characters by the phar_analyze_path function in ext/phar/phar.c."
203357," static char *__filterShell(const char *arg) {
 	r_return_val_if_fail (arg, NULL);
 	char *a = malloc (strlen (arg) + 1);
 	if (!a) {
 		return NULL;
  	}
  	char *b = a;
  	while (*arg) {
		switch (*arg) {
 		char ch = *arg;
 		switch (ch) {
  		case '@':
  		case '`':
  		case '|':
  		case ';':
 		case '=':
  		case '\n':
  			break;
  		default:
			*b++ = *arg;
 			*b++ = ch;
  			break;
  		}
  		arg++;
 	}
 	*b = 0;
 	return a;
 }","[10, 11, 16, 21, 9, 20]","In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables."
198341," int main(int argc, char ** argv)
 {
 	int c;
 	unsigned long flags = MS_MANDLOCK;
 	char * orgoptions = NULL;
 	char * share_name = NULL;
 	const char * ipaddr = NULL;
 	char * uuid = NULL;
 	char * mountpoint = NULL;
 	char * options = NULL;
 	char * optionstail;
 	char * resolved_path = NULL;
 	char * temp;
 	char * dev_name;
 	int rc = 0;
 	int rsize = 0;
 	int wsize = 0;
 	int nomtab = 0;
 	int uid = 0;
 	int gid = 0;
 	int optlen = 0;
 	int orgoptlen = 0;
 	size_t options_size = 0;
 	size_t current_len;
 	int retry = 0;  
 	struct addrinfo *addrhead = NULL, *addr;
 	struct utsname sysinfo;
 	struct mntent mountent;
 	struct sockaddr_in *addr4;
 	struct sockaddr_in6 *addr6;
 	FILE * pmntfile;
 
 	 
 
 	if(argc && argv)
 		thisprogram = argv[0];
 	else
 		mount_cifs_usage(stderr);
 
 	if(thisprogram == NULL)
 		thisprogram = ""mount.cifs"";
 
 	uname(&sysinfo);
 	 
 
  
 	if(argc > 2) {
 		dev_name = argv[1];
 		share_name = strndup(argv[1], MAX_UNC_LEN);
 		if (share_name == NULL) {
 			fprintf(stderr, ""%s: %s"", argv[0], strerror(ENOMEM));
 			exit(EX_SYSERR);
 		}
 		mountpoint = argv[2];
 	} else if (argc == 2) {
 		if ((strcmp(argv[1], ""-V"") == 0) ||
 		    (strcmp(argv[1], ""--version"") == 0))
 		{
 			print_cifs_mount_version();
 			exit(0);
 		}
 
 		if ((strcmp(argv[1], ""-h"") == 0) ||
 		    (strcmp(argv[1], ""-?"") == 0) ||
 		    (strcmp(argv[1], ""--help"") == 0))
 			mount_cifs_usage(stdout);
 
 		mount_cifs_usage(stderr);
 	} else {
 		mount_cifs_usage(stderr);
 	}
 
 
 	 
 	while ((c = getopt_long (argc, argv, ""afFhilL:no:O:rsSU:vVwt:"",
 			 longopts, NULL)) != -1) {
 		switch (c) {
  
  
  
 
 		case '?':
 		case 'h':	  
 			mount_cifs_usage(stdout);
 		case 'n':
 			++nomtab;
 			break;
 		case 'b':
 #ifdef MS_BIND
 			flags |= MS_BIND;
 #else
 			fprintf(stderr,
 				""option 'b' (MS_BIND) not supported\n"");
 #endif
 			break;
 		case 'm':
 #ifdef MS_MOVE		      
 			flags |= MS_MOVE;
 #else
 			fprintf(stderr,
 				""option 'm' (MS_MOVE) not supported\n"");
 #endif
 			break;
 		case 'o':
 			orgoptions = strdup(optarg);
 		    break;
 		case 'r':   
 			flags |= MS_RDONLY;
 			break;
 		case 'U':
 			uuid = optarg;
 			break;
 		case 'v':
 			++verboseflag;
 			break;
 		case 'V':
 			print_cifs_mount_version();
 			exit (0);
 		case 'w':
 			flags &= ~MS_RDONLY;
 			break;
 		case 'R':
 			rsize = atoi(optarg) ;
 			break;
 		case 'W':
 			wsize = atoi(optarg);
 			break;
 		case '1':
 			if (isdigit(*optarg)) {
 				char *ep;
 
 				uid = strtoul(optarg, &ep, 10);
 				if (*ep) {
 					fprintf(stderr, ""bad uid value \""%s\""\n"", optarg);
 					exit(EX_USAGE);
 				}
 			} else {
 				struct passwd *pw;
 
 				if (!(pw = getpwnam(optarg))) {
 					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
 					exit(EX_USAGE);
 				}
 				uid = pw->pw_uid;
 				endpwent();
 			}
 			break;
 		case '2':
 			if (isdigit(*optarg)) {
 				char *ep;
 
 				gid = strtoul(optarg, &ep, 10);
 				if (*ep) {
 					fprintf(stderr, ""bad gid value \""%s\""\n"", optarg);
 					exit(EX_USAGE);
 				}
 			} else {
 				struct group *gr;
 
 				if (!(gr = getgrnam(optarg))) {
 					fprintf(stderr, ""bad user name \""%s\""\n"", optarg);
 					exit(EX_USAGE);
 				}
 				gid = gr->gr_gid;
 				endpwent();
 			}
 			break;
 		case 'u':
 			got_user = 1;
 			user_name = optarg;
 			break;
 		case 'd':
 			domain_name = optarg;  
 			got_domain = 1;
 			break;
 		case 'p':
 			if(mountpassword == NULL)
 				mountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);
 			if(mountpassword) {
 				got_password = 1;
 				strlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);
 			}
 			break;
 		case 'S':
 			get_password_from_file(0  ,NULL);
 			break;
 		case 't':
 			break;
 		case 'f':
 			++fakemnt;
 			break;
 		default:
 			fprintf(stderr, ""unknown mount option %c\n"",c);
 			mount_cifs_usage(stderr);
 		}
 	}
 
 	if((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {
 		mount_cifs_usage(stderr);
         }
  
          
        rc = chdir(mountpoint);
        if (rc) {
                fprintf(stderr, ""Couldn't chdir to %s: %s\n"", mountpoint,
                                strerror(errno));
                rc = EX_USAGE;
                goto mount_exit;
        }
 
         rc = check_mountpoint(thisprogram, mountpoint);
         if (rc)
                 goto mount_exit;
 		 
 		flags |= CIFS_SETUID_FLAGS;
 	}","[203, 204, 205, 206, 207, 208, 209, 210]","client/mount.cifs.c in mount.cifs in smbfs in Samba 3.0.22, 3.0.28a, 3.2.3, 3.3.2, 3.4.0, and 3.4.5 allows local users to mount a CIFS share on an arbitrary mountpoint, and gain privileges, via a symlink attack on the mountpoint directory file."
199164," static int persistent_prepare_exception(struct dm_exception_store *store,
  					struct dm_exception *e)
  {
  	struct pstore *ps = get_info(store);
	uint32_t stride;
	chunk_t next_free;
  	sector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);
  
  	 
 	if (size < ((ps->next_free + 1) * store->chunk_size))
 		return -ENOSPC;
 
 	e->new_chunk = ps->next_free;
 
 	 
	stride = (ps->exceptions_per_area + 1);
	next_free = ++ps->next_free;
	if (sector_div(next_free, stride) == 1)
		ps->next_free++;
 	ps->next_free++;
 	skip_metadata(ps);
  
  	atomic_inc(&ps->pending_count);
  	return 0;
 }","[20, 21, 5, 6, 16, 17, 18, 19]",Interpretation conflict in drivers/md/dm-snap-persistent.c in the Linux kernel through 3.11.6 allows remote authenticated users to obtain sensitive information or modify data via a crafted mapping to a snapshot block device.
202118," u_char *_our_safe_pcap_next(pcap_t *pcap,  struct pcap_pkthdr *pkthdr,
         const char *funcname, const int line, const char *file)
 {
     u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);
 
     if (pktdata) {
         if (pkthdr->len > MAXPACKET) {
             fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
                     file, funcname, line, pkthdr->len, MAXPACKET);
              exit(-1);
          }
  
        if (pkthdr->len < pkthdr->caplen) {
            fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
         if (!pkthdr->len || pkthdr->len < pkthdr->caplen) {
             fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length=%u capture length=%u\n"",
                      file, funcname, line, pkthdr->len, pkthdr->caplen);
              exit(-1);
          }
     }
 
     return pktdata;
 }","[15, 16, 13, 14]",Tcpreplay before 4.3.1 has a heap-based buffer over-read in get_l2len in common/get.c.
204259," void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)
 void BlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)
  {
      if (origin && BlobURL::getOrigin(url) == ""null"")
          originMap()->add(url.string(), origin);
  
    if (isMainThread())
        blobRegistry().registerBlobURL(url, srcURL);
    else {
     if (isMainThread()) {
         if (WebBlobRegistry* registry = blobRegistry())
             registry->registerBlobURL(url, srcURL);
     } else {
          OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));
          callOnMainThread(&registerBlobURLFromTask, context.leakPtr());
      }
 }","[2, 10, 11, 12, 13, 7, 8, 9]","Google Chrome before 23.0.1271.91 on Mac OS X does not properly mitigate improper rendering behavior in the Intel GPU driver, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
8378,"enum sctp_disposition sctp_sf_shutdown_pending_abort(
struct net *net,
const struct sctp_endpoint *ep,
const struct sctp_association *asoc,
const union sctp_subtype type,
void *arg,
struct sctp_cmd_seq *commands)
{
struct sctp_chunk *chunk = arg;

if (!sctp_vtag_verify_either(chunk, asoc))
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);











if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);






if (SCTP_ADDR_DEL ==
sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))
return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);

if (!sctp_err_chunk_valid(chunk))
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);

return __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);
}",[34],A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses.
201691," static int kvm_ioctl_create_device(struct kvm *kvm,
 				   struct kvm_create_device *cd)
 {
 	struct kvm_device_ops *ops = NULL;
 	struct kvm_device *dev;
 	bool test = cd->flags & KVM_CREATE_DEVICE_TEST;
 	int ret;
 
 	if (cd->type >= ARRAY_SIZE(kvm_device_ops_table))
 		return -ENODEV;
 
 	ops = kvm_device_ops_table[cd->type];
 	if (ops == NULL)
 		return -ENODEV;
 
 	if (test)
 		return 0;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
 		return -ENOMEM;
 
 	dev->ops = ops;
 	dev->kvm = kvm;
 
 	mutex_lock(&kvm->lock);
 	ret = ops->create(dev, cd->type);
 	if (ret < 0) {
 		mutex_unlock(&kvm->lock);
 		kfree(dev);
 		return ret;
 	}
 	list_add(&dev->vm_node, &kvm->devices);
 	mutex_unlock(&kvm->lock);
 
 	if (ops->init)
 		ops->init(dev);
  
  	ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);
  	if (ret < 0) {
		ops->destroy(dev);
  		mutex_lock(&kvm->lock);
  		list_del(&dev->vm_node);
  		mutex_unlock(&kvm->lock);
 		ops->destroy(dev);
  		return ret;
  	}
  
 	kvm_get_kvm(kvm);
 	cd->fd = ret;
 	return 0;
 }","[45, 41]",Use-after-free vulnerability in the kvm_ioctl_create_device function in virt/kvm/kvm_main.c in the Linux kernel before 4.8.13 allows host OS users to cause a denial of service (host OS crash) or possibly gain privileges via crafted ioctl calls on the /dev/kvm device.
205730,"  void FrameSelection::DocumentAttached(Document* document) {
    DCHECK(document);
  use_secure_keyboard_entry_when_active_ = false;
    selection_editor_->DocumentAttached(document);
    SetContext(document);
  }",[3],Multiple unspecified vulnerabilities in Google Chrome before 46.0.2490.71 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
204886," bool FileBrowserPrivateGetShareUrlFunction::RunAsync() {
   using extensions::api::file_browser_private::GetShareUrl::Params;
   const scoped_ptr<Params> params(Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params);
 
   const base::FilePath path = file_manager::util::GetLocalPathFromURL(
       render_view_host(), GetProfile(), GURL(params->url));
   DCHECK(drive::util::IsUnderDriveMountPoint(path));
 
   const base::FilePath drive_path = drive::util::ExtractDrivePath(path);
 
   drive::FileSystemInterface* const file_system =
       drive::util::GetFileSystemByProfile(GetProfile());
   if (!file_system) {
     return false;
   }
  
    file_system->GetShareUrl(
        drive_path,
      file_manager::util::GetFileManagerBaseUrl(),   
       GURL(""chrome-extension:"" + extension_id()),   
        base::Bind(&FileBrowserPrivateGetShareUrlFunction::OnGetShareUrl, this));
    return true;
  }","[21, 20]","Use-after-free vulnerability in core/html/HTMLTemplateElement.cpp in Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that operates on a TEMPLATE element."
207946," status_t MPEG4Source::read(
  MediaBuffer **out, const ReadOptions *options) {
  Mutex::Autolock autoLock(mLock);
 
     CHECK(mStarted);
 
  if (mFirstMoofOffset > 0) {
  return fragmentedRead(out, options);
  }
 
  *out = NULL;
 
  int64_t targetSampleTimeUs = -1;
 
  int64_t seekTimeUs;
  ReadOptions::SeekMode mode;
  if (options && options->getSeekTo(&seekTimeUs, &mode)) {
  uint32_t findFlags = 0;
  switch (mode) {
  case ReadOptions::SEEK_PREVIOUS_SYNC:
                 findFlags = SampleTable::kFlagBefore;
  break;
  case ReadOptions::SEEK_NEXT_SYNC:
                 findFlags = SampleTable::kFlagAfter;
  break;
  case ReadOptions::SEEK_CLOSEST_SYNC:
  case ReadOptions::SEEK_CLOSEST:
                 findFlags = SampleTable::kFlagClosest;
  break;
  default:
                 CHECK(!""Should not be here."");
  break;
  }
 
  uint32_t sampleIndex;
  status_t err = mSampleTable->findSampleAtTime(
                 seekTimeUs, 1000000, mTimescale,
  &sampleIndex, findFlags);
 
  if (mode == ReadOptions::SEEK_CLOSEST) {
             findFlags = SampleTable::kFlagBefore;
  }
 
  uint32_t syncSampleIndex;
  if (err == OK) {
             err = mSampleTable->findSyncSampleNear(
                     sampleIndex, &syncSampleIndex, findFlags);
  }
 
  uint32_t sampleTime;
  if (err == OK) {
             err = mSampleTable->getMetaDataForSample(
                     sampleIndex, NULL, NULL, &sampleTime);
  }
 
  if (err != OK) {
  if (err == ERROR_OUT_OF_RANGE) {
                 err = ERROR_END_OF_STREAM;
  }
             ALOGV(""end of stream"");
  return err;
  }
 
  if (mode == ReadOptions::SEEK_CLOSEST) {
             targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;
  }
 
 #if 0
  uint32_t syncSampleTime;
         CHECK_EQ(OK, mSampleTable->getMetaDataForSample(
                     syncSampleIndex, NULL, NULL, &syncSampleTime));
 
         ALOGI(""seek to time %lld us => sample at time %lld us, ""
  ""sync sample at time %lld us"",
              seekTimeUs,
              sampleTime * 1000000ll / mTimescale,
              syncSampleTime * 1000000ll / mTimescale);
 #endif
 
         mCurrentSampleIndex = syncSampleIndex;
  if (mBuffer != NULL) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  }
 
  off64_t offset;
  size_t size;
  uint32_t cts, stts;
  bool isSyncSample;
  bool newBuffer = false;
  if (mBuffer == NULL) {
         newBuffer = true;
 
  status_t err =
             mSampleTable->getMetaDataForSample(
                     mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);
 
  if (err != OK) {
  return err;
  }
 
         err = mGroup->acquire_buffer(&mBuffer);
 
  if (err != OK) {
             CHECK(mBuffer == NULL);
  return err;
  }
  if (size > mBuffer->size()) {
             ALOGE(""buffer too small: %zu > %zu"", size, mBuffer->size());
  return ERROR_BUFFER_TOO_SMALL;
  }
  }
 
  if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {
  if (newBuffer) {
  ssize_t num_bytes_read =
                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);
 
  if (num_bytes_read < (ssize_t)size) {
                 mBuffer->release();
                 mBuffer = NULL;
 
  return ERROR_IO;
  }
 
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
             mBuffer->meta_data()->clear();
             mBuffer->meta_data()->setInt64(
                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
             mBuffer->meta_data()->setInt64(
                     kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
                 mBuffer->meta_data()->setInt64(
                         kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
  }
 
  if (!mIsAVC && !mIsHEVC) {
  *out = mBuffer;
             mBuffer = NULL;
 
  return OK;
  }
 
 
         CHECK(mBuffer->range_length() >= mNALLengthSize);
 
  const uint8_t *src =
  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
 
  size_t nal_size = parseNALSize(src);
  if (mNALLengthSize > SIZE_MAX - nal_size) {
             ALOGE(""b/24441553, b/24445122"");
  }
  if (mBuffer->range_length() - mNALLengthSize < nal_size) {
             ALOGE(""incomplete NAL unit."");
 
             mBuffer->release();
             mBuffer = NULL;
 
  return ERROR_MALFORMED;
  }
 
  MediaBuffer *clone = mBuffer->clone();
         CHECK(clone != NULL);
         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);
 
         CHECK(mBuffer != NULL);
         mBuffer->set_range(
                 mBuffer->range_offset() + mNALLengthSize + nal_size,
                 mBuffer->range_length() - mNALLengthSize - nal_size);
 
  if (mBuffer->range_length() == 0) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  *out = clone;
 
  return OK;
  } else {
  ssize_t num_bytes_read = 0;
  int32_t drm = 0;
  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
  if (usesDRM) {
             num_bytes_read =
                 mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);
  } else {
             num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);
  }
 
  if (num_bytes_read < (ssize_t)size) {
             mBuffer->release();
             mBuffer = NULL;
 
  return ERROR_IO;
  }
 
  if (usesDRM) {
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
 
  } else {
  uint8_t *dstData = (uint8_t *)mBuffer->data();
  size_t srcOffset = 0;
  size_t dstOffset = 0;
 
  while (srcOffset < size) {
  bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);
  size_t nalLength = 0;
  if (!isMalFormed) {
                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                     srcOffset += mNALLengthSize;
                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);
  }
 
  if (isMalFormed) {
                     ALOGE(""Video is malformed"");
                     mBuffer->release();
                     mBuffer = NULL;
  return ERROR_MALFORMED;
  }
 
  if (nalLength == 0) {
 
                      continue;
                  }
  
                CHECK(dstOffset + 4 <= mBuffer->size());
                 if (dstOffset > SIZE_MAX - 4 ||
                         dstOffset + 4 > SIZE_MAX - nalLength ||
                         dstOffset + 4 + nalLength > mBuffer->size()) {
                     ALOGE(""b/27208621 : %zu %zu"", dstOffset, mBuffer->size());
                     android_errorWriteLog(0x534e4554, ""27208621"");
                     mBuffer->release();
                     mBuffer = NULL;
                     return ERROR_MALFORMED;
                 }
  
                  dstData[dstOffset++] = 0;
                  dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 1;
                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);
                 srcOffset += nalLength;
                 dstOffset += nalLength;
  }
             CHECK_EQ(srcOffset, size);
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, dstOffset);
  }
 
         mBuffer->meta_data()->clear();
         mBuffer->meta_data()->setInt64(
                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
         mBuffer->meta_data()->setInt64(
                 kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
             mBuffer->meta_data()->setInt64(
                     kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
 
  *out = mBuffer;
         mBuffer = NULL;
 
  return OK;
  }
 }","[240, 241, 242, 243, 244, 245, 246, 247, 248, 239]","MPEG4Extractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (out-of-bounds read and memory corruption) via a crafted media file, aka internal bug 27208621."
206591," void RemoteFrame::ScheduleNavigation(Document& origin_document,
                                       const KURL& url,
                                       WebFrameLoadType frame_load_type,
                                       UserGestureStatus user_gesture_status) {
   if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) {
     origin_document.AddConsoleMessage(ConsoleMessage::Create(
         kSecurityMessageSource, kErrorMessageLevel,
         ""Not allowed to load local resource: "" + url.ElidedString()));
     return;
   }
 
    FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));
    frame_request.GetResourceRequest().SetHasUserGesture(
        user_gesture_status == UserGestureStatus::kActive);
   frame_request.GetResourceRequest().SetFrameType(
       IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel
                     : network::mojom::RequestContextFrameType::kNested);
   Navigate(frame_request, frame_load_type);
 }","[5, 6, 7, 8, 9, 10, 11]",Remote frame navigations was incorrectly permitted to local resources in Blink in Google Chrome prior to 71.0.3578.80 allowed an attacker who convinced a user to install a malicious extension to access files on the local file system via a crafted Chrome Extension.
200334," static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,
 				    struct nlattr **attrs)
 {
 	struct nlattr *link[TIPC_NLA_LINK_MAX + 1];
 	struct tipc_link_info link_info;
 	int err;
 
 	if (!attrs[TIPC_NLA_LINK])
 		return -EINVAL;
 
 	err = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],
 			       NULL);
 	if (err)
 		return err;
  
  	link_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);
  	link_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));
	strcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));
 	nla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),
 		    TIPC_MAX_LINK_NAME);
  
  	return tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,
  			    &link_info, sizeof(link_info));
 }","[19, 20, 18]","The tipc_nl_compat_link_dump function in net/tipc/netlink_compat.c in the Linux kernel through 4.6.3 does not properly copy a certain string, which allows local users to obtain sensitive information from kernel stack memory by reading a Netlink message."
201404,"  ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {
  	int i;
  
	if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)
 	if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {
  		return 0;
	for (i = 0; i < bin->nsegs; ++i)
		if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)
 	}
 	for (i = 0; i < bin->nsegs; ++i) {
 		if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {
  			return bin->segs[i].vmaddr;
 		}
 	}
  	return 0;
  }","[5, 9, 10, 11, 13, 14, 4, 7, 8]",The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.
198712," int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
 	const struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
 	struct inet_sock *inet = inet_sk(sk);
 	struct dccp_sock *dp = dccp_sk(sk);
 	__be16 orig_sport, orig_dport;
 	__be32 daddr, nexthop;
  	struct flowi4 fl4;
  	struct rtable *rt;
  	int err;
 	struct ip_options_rcu *inet_opt;
  
  	dp->dccps_role = DCCP_ROLE_CLIENT;
  
 	if (addr_len < sizeof(struct sockaddr_in))
 		return -EINVAL;
 
 	if (usin->sin_family != AF_INET)
  		return -EAFNOSUPPORT;
  
  	nexthop = daddr = usin->sin_addr.s_addr;
	if (inet->opt != NULL && inet->opt->srr) {
 
 	inet_opt = rcu_dereference_protected(inet->inet_opt,
 					     sock_owned_by_user(sk));
 	if (inet_opt != NULL && inet_opt->opt.srr) {
  		if (daddr == 0)
  			return -EINVAL;
		nexthop = inet->opt->faddr;
 		nexthop = inet_opt->opt.faddr;
  	}
  
  	orig_sport = inet->inet_sport;
 	orig_dport = usin->sin_port;
 	rt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,
 			      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,
 			      IPPROTO_DCCP,
 			      orig_sport, orig_dport, sk, true);
 	if (IS_ERR(rt))
 		return PTR_ERR(rt);
 
 	if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {
 		ip_rt_put(rt);
  		return -ENETUNREACH;
  	}
  
	if (inet->opt == NULL || !inet->opt->srr)
 	if (inet_opt == NULL || !inet_opt->opt.srr)
  		daddr = rt->rt_dst;
  
  	if (inet->inet_saddr == 0)
 		inet->inet_saddr = rt->rt_src;
 	inet->inet_rcv_saddr = inet->inet_saddr;
 
 	inet->inet_dport = usin->sin_port;
  	inet->inet_daddr = daddr;
  
  	inet_csk(sk)->icsk_ext_hdr_len = 0;
	if (inet->opt != NULL)
		inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;
 	if (inet_opt)
 		inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;
  	 
 	dccp_set_state(sk, DCCP_REQUESTING);
 	err = inet_hash_connect(&dccp_death_row, sk);
 	if (err != 0)
 		goto failure;
 
 	rt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,
 			       inet->inet_sport, inet->inet_dport, sk);
 	if (IS_ERR(rt)) {
 		rt = NULL;
 		goto failure;
 	}
 	 
 	sk_setup_caps(sk, &rt->dst);
 
 	dp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,
 						    inet->inet_daddr,
 						    inet->inet_sport,
 						    inet->inet_dport);
 	inet->inet_id = dp->dccps_iss ^ jiffies;
 
 	err = dccp_connect(sk);
 	rt = NULL;
 	if (err != 0)
 		goto failure;
 out:
 	return err;
 failure:
 	 
 	dccp_set_state(sk, DCCP_CLOSED);
 	ip_rt_put(rt);
 	sk->sk_route_caps = 0;
 	inet->inet_dport = 0;
 	goto out;
 }","[11, 23, 24, 25, 26, 30, 48, 61, 62, 22, 29, 47, 59, 60]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
1355,"rrd_info_t *rrd_graph_v(
int argc,
char **argv)
{
image_desc_t im;
rrd_info_t *grinfo;
char *old_locale;
rrd_graph_init(&im);

old_locale = setlocale(LC_NUMERIC, ""C"");
rrd_graph_options(argc, argv, &im);
if (rrd_test_error()) {
rrd_info_free(im.grinfo);
im_free(&im);
return NULL;
}

if (optind >= argc) {
rrd_info_free(im.grinfo);
im_free(&im);
rrd_set_error(""missing filename"");
return NULL;
}

if (strlen(argv[optind]) >= MAXPATH) {
rrd_set_error(""filename (including path) too long"");
rrd_info_free(im.grinfo);
im_free(&im);
return NULL;
}

strncpy(im.graphfile, argv[optind], MAXPATH - 1);
im.graphfile[MAXPATH - 1] = '\0';

if (strcmp(im.graphfile, ""-"") == 0) {
im.graphfile[0] = '\0';
}

rrd_graph_script(argc, argv, &im, 1);
setlocale(LC_NUMERIC, old_locale);

if (rrd_test_error()) {
rrd_info_free(im.grinfo);
im_free(&im);
return NULL;
}



if (graph_paint(&im) == -1) {
rrd_info_free(im.grinfo);
im_free(&im);
return NULL;
}






if (im.imginfo) {
rrd_infoval_t info;
char     *path;
char     *filename;

if (bad_format_imginfo(im.imginfo)) {
rrd_info_free(im.grinfo);
im_free(&im);
rrd_set_error(""bad format for imginfo"");
return NULL;
}
path = strdup(im.graphfile);
filename = basename(path);
info.u_str =
sprintf_alloc(im.imginfo,
filename,
(long) (im.zoom *
im.ximg), (long) (im.zoom * im.yimg));
grinfo_push(&im, sprintf_alloc(""image_info""), RD_I_STR, info);
free(info.u_str);
free(path);
}
if (im.rendered_image) {
rrd_infoval_t img;

img.u_blo.size = im.rendered_image_size;
img.u_blo.ptr = im.rendered_image;
grinfo_push(&im, sprintf_alloc(""image""), RD_I_BLO, img);
}
grinfo = im.grinfo;
im_free(&im);
return grinfo;
}",[69],"Multiple format string vulnerabilities in the python module in RRDtool, as used in Zenoss Core before 4.2.5 and other products, allow remote attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted third argument to the rrdtool.graph function, aka ZEN-15415, a related issue to CVE-2013-2131."
203788," error::Error GLES2DecoderImpl::HandleDrawElements(
     uint32 immediate_data_size, const gles2::DrawElements& c) {
   if (!bound_element_array_buffer_ ||
       bound_element_array_buffer_->IsDeleted()) {
     SetGLError(GL_INVALID_OPERATION,
                ""glDrawElements: No element array buffer bound"");
     return error::kNoError;
   }
 
   GLenum mode = c.mode;
   GLsizei count = c.count;
   GLenum type = c.type;
   int32 offset = c.index_offset;
   if (count < 0) {
     SetGLError(GL_INVALID_VALUE, ""glDrawElements: count < 0"");
     return error::kNoError;
   }
   if (offset < 0) {
     SetGLError(GL_INVALID_VALUE, ""glDrawElements: offset < 0"");
     return error::kNoError;
   }
   if (!validators_->draw_mode.IsValid(mode)) {
     SetGLError(GL_INVALID_ENUM, ""glDrawElements: mode GL_INVALID_ENUM"");
     return error::kNoError;
   }
   if (!validators_->index_type.IsValid(type)) {
     SetGLError(GL_INVALID_ENUM, ""glDrawElements: type GL_INVALID_ENUM"");
     return error::kNoError;
   }
 
   if (!CheckFramebufferComplete(""glDrawElements"")) {
     return error::kNoError;
   }
 
   if (count == 0) {
     return error::kNoError;
   }
 
   GLuint max_vertex_accessed;
   if (!bound_element_array_buffer_->GetMaxValueForRange(
       offset, count, type, &max_vertex_accessed)) {
     SetGLError(GL_INVALID_OPERATION,
                ""glDrawElements: range out of bounds for buffer"");
     return error::kNoError;
    }
  
    if (IsDrawValid(max_vertex_accessed)) {
    bool simulated_attrib_0 = SimulateAttrib0(max_vertex_accessed);
     bool simulated_attrib_0 = false;
     if (!SimulateAttrib0(max_vertex_accessed, &simulated_attrib_0)) {
       return error::kNoError;
     }
      bool simulated_fixed_attribs = false;
      if (SimulateFixedAttribs(max_vertex_accessed, &simulated_fixed_attribs)) {
        bool textures_set = SetBlackTextureForNonRenderableTextures();
       ApplyDirtyState();
       const GLvoid* indices = reinterpret_cast<const GLvoid*>(offset);
       glDrawElements(mode, count, type, indices);
       if (textures_set) {
         RestoreStateForNonRenderableTextures();
       }
       if (simulated_fixed_attribs) {
         RestoreStateForSimulatedFixedAttribs();
       }
     }
     if (simulated_attrib_0) {
       RestoreStateForSimulatedAttrib0();
     }
     if (WasContextLost()) {
       LOG(ERROR) << ""  GLES2DecoderImpl: Context lost during DrawElements."";
       return error::kLostContext;
     }
   }
   return error::kNoError;
 }","[49, 50, 51, 52, 48]","Google Chrome before 14.0.835.163 does not properly handle triangle arrays, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
198078," static void coroutine_fn v9fs_write(void *opaque)
 {
     ssize_t err;
     int32_t fid;
     uint64_t off;
     uint32_t count;
     int32_t len = 0;
     int32_t total = 0;
     size_t offset = 7;
     V9fsFidState *fidp;
     V9fsPDU *pdu = opaque;
     V9fsState *s = pdu->s;
     QEMUIOVector qiov_full;
     QEMUIOVector qiov;
 
     err = pdu_unmarshal(pdu, offset, ""dqd"", &fid, &off, &count);
     if (err < 0) {
         pdu_complete(pdu, err);
         return;
     }
     offset += err;
     v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);
     trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);
 
     fidp = get_fid(pdu, fid);
     if (fidp == NULL) {
         err = -EINVAL;
         goto out_nofid;
     }
     if (fidp->fid_type == P9_FID_FILE) {
         if (fidp->fs.fd == -1) {
             err = -EINVAL;
             goto out;
         }
     } else if (fidp->fid_type == P9_FID_XATTR) {
          
         err = v9fs_xattr_write(s, pdu, fidp, off, count,
                                qiov_full.iov, qiov_full.niov);
         goto out;
     } else {
         err = -EINVAL;
         goto out;
     }
     qemu_iovec_init(&qiov, qiov_full.niov);
     do {
         qemu_iovec_reset(&qiov);
         qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);
         if (0) {
             print_sg(qiov.iov, qiov.niov);
         }
          
         do {
             len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);
             if (len >= 0) {
                 off   += len;
                 total += len;
             }
         } while (len == -EINTR && !pdu->cancelled);
         if (len < 0) {
              
             err = len;
             goto out_qiov;
         }
     } while (total < count && len > 0);
 
      offset = 7;
      err = pdu_marshal(pdu, offset, ""d"", total);
      if (err < 0) {
        goto out;
         goto out_qiov;
      }
      err += offset;
      trace_v9fs_write_return(pdu->tag, pdu->id, total, err);
 out_qiov:
     qemu_iovec_destroy(&qiov);
 out:
     put_fid(pdu, fidp);
 out_nofid:
     qemu_iovec_destroy(&qiov_full);
     pdu_complete(pdu, err);
 }","[70, 69]",Memory leak in the v9fs_write function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) by leveraging failure to free an IO vector.
7862,"auto decode = [&](const int64 begin, const int64 end) {
for (int b = begin; b < end; ++b) {
sequences[b].resize(1);
auto &sequence = sequences[b][0];
int prev_indices = -1;
for (int t = 0; t < seq_len_t(b); ++t) {
int max_class_indices;
log_prob_t(b, 0) +=
-RowMax<T>(input_list_t[t], b, &max_class_indices);
if (max_class_indices != blank_index &&
!(merge_repeated_ && max_class_indices == prev_indices)) {
sequence.push_back(max_class_indices);
}
prev_indices = max_class_indices;
}
}
};",[8],"TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.CTCGreedyDecoder`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1615440b17b364b875eb06f43d087381f1460a65/tensorflow/core/kernels/ctc_decoder_ops.cc#L37-L50) has a `CHECK_LT` inserted to validate some invariants. When this condition is false, the program aborts, instead of returning a valid error to the user. This abnormal termination can be weaponized in denial of service attacks. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
199920," dtls1_process_record(SSL *s)
 {
 	int i,al;
 	int enc_err;
 	SSL_SESSION *sess;
 	SSL3_RECORD *rr;
 	unsigned int mac_size;
 	unsigned char md[EVP_MAX_MD_SIZE];
 
 	rr= &(s->s3->rrec);
 	sess = s->session;
 
 	 
 	rr->input= &(s->packet[DTLS1_RT_HEADER_LENGTH]);
 
 	  
 
 	 
 
 	 
 	if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)
 		{
 		al=SSL_AD_RECORD_OVERFLOW;
 		SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
 		goto f_err;
 		}
 
 	 
 	rr->data=rr->input;
 	rr->orig_len=rr->length;
 
 	enc_err = s->method->ssl3_enc->enc(s,0);
 	 
 	if (enc_err == 0)
 		{
 		 
 		rr->length = 0;
 		s->packet_length = 0;
 		goto err;
 		}
 
 #ifdef TLS_DEBUG
 printf(""dec %d\n"",rr->length);
 { unsigned int z; for (z=0; z<rr->length; z++) printf(""%02X%c"",rr->data[z],((z+1)%16)?' ':'\n'); }
 printf(""\n"");
 #endif
 
 	 
 	if ((sess != NULL) &&
 	    (s->enc_read_ctx != NULL) &&
 	    (EVP_MD_CTX_md(s->read_hash) != NULL))
 		{
 		 
 		unsigned char *mac = NULL;
 		unsigned char mac_tmp[EVP_MAX_MD_SIZE];
 		mac_size=EVP_MD_CTX_size(s->read_hash);
 		OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
 
 		 
 		if (rr->orig_len < mac_size ||
 		     
 		    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
 		     rr->orig_len < mac_size+1))
 			{
 			al=SSL_AD_DECODE_ERROR;
 			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);
 			goto f_err;
 			}
 
 		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)
 			{
 			 
 			mac = mac_tmp;
 			ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
 			rr->length -= mac_size;
 			}
 		else
 			{
 			 
 			rr->length -= mac_size;
 			mac = &rr->data[rr->length];
 			}
 
 		i=s->method->ssl3_enc->mac(s,md,0  );
 		if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
 			enc_err = -1;
 		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)
 			enc_err = -1;
 		}
 
 	if (enc_err < 0)
 		{
 		 
 		rr->length = 0;
 		s->packet_length = 0;
 		goto err;
 		}
 
 	 
 	if (s->expand != NULL)
 		{
 		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH)
 			{
 			al=SSL_AD_RECORD_OVERFLOW;
 			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);
 			goto f_err;
 			}
 		if (!ssl3_do_uncompress(s))
 			{
 			al=SSL_AD_DECOMPRESSION_FAILURE;
 			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_BAD_DECOMPRESSION);
 			goto f_err;
 			}
 		}
 
 	if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH)
 		{
 		al=SSL_AD_RECORD_OVERFLOW;
 		SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);
 		goto f_err;
 		}
 
 	rr->off=0;
 	 
  
  	 
  	s->packet_length=0;
	dtls1_record_bitmap_update(s, &(s->d1->bitmap)); 
  	return(1);
  
  f_err:
 	ssl3_send_alert(s,SSL3_AL_FATAL,al);
 err:
 	return(0);
 }",[128],"Memory leak in the dtls1_buffer_record function in d1_pkt.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k allows remote attackers to cause a denial of service (memory consumption) by sending many duplicate records for the next epoch, leading to failure of replay detection."
206422,"  void DevToolsUIBindings::RecordEnumeratedHistogram(const std::string& name,
                                                     int sample,
                                                     int boundary_value) {
   if (!frontend_host_)
     return;
    if (!(boundary_value >= 0 && boundary_value <= 100 && sample >= 0 &&
          sample < boundary_value)) {
     frontend_host_->BadMessageRecieved();
     return;
   }
   if (name == kDevToolsActionTakenHistogram)
     UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);
   else if (name == kDevToolsPanelShownHistogram)
     UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);
   else
     frontend_host_->BadMessageRecieved();
 }","[4, 5]","Google Chrome prior to 56.0.2924.76 for Windows insufficiently sanitized DevTools URLs, which allowed a remote attacker who convinced a user to install a malicious extension to read filesystem contents via a crafted HTML page."
198603,"  stub_charset ()
  {
   locale = get_locale_var (""LC_CTYPE"");
  
    locale = get_locale_var (""LC_CTYPE"");
    if (locale == 0 || *locale == 0)
    return ""ASCII"";
     {
       strcpy (charsetbuf, ""ASCII"");
       return charsetbuf;
     }
    s = strrchr (locale, '.');
    if (s)
      {
      t = strchr (s, '@');
       strcpy (charsetbuf, s+1);
       t = strchr (charsetbuf, '@');
        if (t)
  	*t = 0;
      return ++s;
       return charsetbuf;
      }
  else if (STREQ (locale, ""UTF-8""))
    return ""UTF-8"";
  else
    return ""ASCII"";
   strcpy (charsetbuf, locale);
   return charsetbuf;
  }","[8, 9, 10, 11, 16, 17, 21, 27, 28, 7, 15, 20, 23, 24, 25, 26]","A heap-based buffer overflow exists in GNU Bash before 4.3 when wide characters, not supported by the current locale set in the LC_CTYPE environment variable, are printed through the echo built-in function. A local attacker, who can provide data to print through the ""echo -e"" built-in function, may use this flaw to crash a script or execute code with the privileges of the bash process. This occurs because ansicstr() in lib/sh/strtrans.c mishandles u32cconv()."
8804,"hb_set_subtract (hb_set_t       *set,
const hb_set_t *other)
{
if (unlikely (hb_object_is_immutable (set)))
return;

set->subtract (*other);
}","[4, 5]",HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).
204344," void TouchEventHandler::handleTouchPoint(Platform::TouchPoint& point, unsigned modifiers)
 void TouchEventHandler::handleTouchPoint(const Platform::TouchPoint& point, unsigned modifiers)
  {
      m_webPage->m_inputHandler->setInputModeEnabled();
 
     bool shiftActive = modifiers & KEYMOD_SHIFT;
      bool altActive = modifiers & KEYMOD_ALT;
      bool ctrlActive = modifiers & KEYMOD_CTRL;
  
    switch (point.m_state) {
     switch (point.state()) {
      case Platform::TouchPoint::TouchPressed:
          {
             m_webPage->m_inputHandler->clearDidSpellCheckState();
 
             if (!m_lastFatFingersResult.isValid())
                 doFatFingers(point);
 
             Element* elementUnderFatFinger = m_lastFatFingersResult.nodeAsElementIfApplicable();
 
              if (m_lastFatFingersResult.isTextInput()) {
                  elementUnderFatFinger = m_lastFatFingersResult.nodeAsElementIfApplicable(FatFingersResult::ShadowContentNotAllowed, true  );
                m_shouldRequestSpellCheckOptions = m_webPage->m_inputHandler->shouldRequestSpellCheckingOptionsForPoint(point.m_pos, elementUnderFatFinger, m_spellCheckOptionRequest);
                 m_shouldRequestSpellCheckOptions = m_webPage->m_inputHandler->shouldRequestSpellCheckingOptionsForPoint(point.documentContentPosition(), elementUnderFatFinger, m_spellCheckOptionRequest);
              }
  
              handleFatFingerPressed(shiftActive, altActive, ctrlActive);
             break;
         }
     case Platform::TouchPoint::TouchReleased:
         {
 
             if (!m_shouldRequestSpellCheckOptions)
                 m_webPage->m_inputHandler->processPendingKeyboardVisibilityChange();
 
             if (m_webPage->m_inputHandler->isInputMode())
                 m_webPage->m_inputHandler->notifyClientOfKeyboardVisibilityChange(true);
 
             m_webPage->m_tapHighlight->hide();
 
             IntPoint adjustedPoint = m_webPage->mapFromContentsToViewport(m_lastFatFingersResult.adjustedPosition());
             PlatformMouseEvent mouseEvent(adjustedPoint, m_lastScreenPoint, PlatformEvent::MouseReleased, 1, LeftButton, shiftActive, ctrlActive, altActive, TouchScreen);
 
             m_webPage->handleMouseEvent(mouseEvent);
 
             if (m_shouldRequestSpellCheckOptions) {
                 IntPoint pixelPositionRelativeToViewport = m_webPage->mapToTransformed(adjustedPoint);
                 IntSize screenOffset(m_lastScreenPoint - pixelPositionRelativeToViewport);
                 m_webPage->m_inputHandler->requestSpellingCheckingOptions(m_spellCheckOptionRequest, screenOffset);
                 m_shouldRequestSpellCheckOptions = false;
             }
 
             m_lastFatFingersResult.reset();  
             break;
         }
     case Platform::TouchPoint::TouchMoved:
         {
              m_webPage->m_inputHandler->clearDidSpellCheckState();
  
            PlatformMouseEvent mouseEvent(point.m_pos, m_lastScreenPoint, PlatformEvent::MouseMoved, 1, LeftButton, shiftActive, ctrlActive, altActive, TouchScreen);
            m_lastScreenPoint = point.m_screenPos;
             PlatformMouseEvent mouseEvent(point.documentViewportPosition(), m_lastScreenPoint, PlatformEvent::MouseMoved, 1, LeftButton, shiftActive, ctrlActive, altActive, TouchScreen);
             m_lastScreenPoint = point.screenPosition();
              m_webPage->handleMouseEvent(mouseEvent);
              break;
          }
     default:
         break;
     }
 }","[2, 11, 24, 62, 63, 10, 23, 60, 61]",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
204455,"   void RenameFile(const DownloadId& id,
                   const FilePath& new_path,
                   const FilePath& unique_path,
                   net::Error rename_error,
                   RenameFileState state,
                   RenameFileOverwrite should_overwrite) {
     MockDownloadFile* file = download_file_factory_->GetExistingFile(id);
     ASSERT_TRUE(file != NULL);
 
     EXPECT_CALL(*file, Rename(unique_path))
         .Times(1)
         .WillOnce(Return(rename_error));
 
     if (rename_error != net::OK) {
       EXPECT_CALL(*file, BytesSoFar())
           .Times(AtLeast(1))
           .WillRepeatedly(Return(byte_count_[id]));
       EXPECT_CALL(*file, GetHashState())
            .Times(AtLeast(1));
        EXPECT_CALL(*file, GetDownloadManager())
            .Times(AtLeast(1));
    } else if (state == COMPLETE) {
#if defined(OS_MACOSX)
      EXPECT_CALL(*file, AnnotateWithSourceInformation());
#endif
      }
  
    if (state == IN_PROGRESS) {
      download_file_manager_->RenameInProgressDownloadFile(
          id, new_path, (should_overwrite == OVERWRITE),
          base::Bind(&TestDownloadManager::OnDownloadRenamed,
                     download_manager_, id.local()));
    } else {   
      download_file_manager_->RenameCompletingDownloadFile(
          id, new_path, (should_overwrite == OVERWRITE),
          base::Bind(&TestDownloadManager::OnDownloadRenamed,
                     download_manager_, id.local()));
    }
     download_file_manager_->RenameDownloadFile(
         id, new_path, (should_overwrite == OVERWRITE),
         base::Bind(&TestDownloadManager::OnDownloadRenamed,
                    download_manager_, id.local()));
  
      if (rename_error != net::OK) {
        EXPECT_CALL(*download_manager_,
                   OnDownloadInterrupted(
                       id.local(),
                       byte_count_[id],
                       """",
                       content::ConvertNetErrorToInterruptReason(
                           rename_error,
                           content::DOWNLOAD_INTERRUPT_FROM_DISK)));
       EXPECT_CALL(*download_manager_,
                   OnDownloadRenamed(id.local(), FilePath()));
       ProcessAllPendingMessages();
       ++error_count_[id];
     } else {
       EXPECT_CALL(*download_manager_,
                   OnDownloadRenamed(id.local(), unique_path));
       ProcessAllPendingMessages();
      }
    }","[39, 40, 41, 42, 22, 23, 24, 25, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38]",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
204284,"  views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
      views::Widget* widget) {
  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
   ShellWindowFrameView* frame_view =
       new ShellWindowFrameView(use_custom_frame_);
    frame_view->Init(window_);
    return frame_view;
  }","[4, 5, 3]","Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*"
202679," int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
                 const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
 {
     ECDSA_VALIDATE_RET( grp   != NULL );
     ECDSA_VALIDATE_RET( r     != NULL );
     ECDSA_VALIDATE_RET( s     != NULL );
     ECDSA_VALIDATE_RET( d     != NULL );
      ECDSA_VALIDATE_RET( f_rng != NULL );
      ECDSA_VALIDATE_RET( buf   != NULL || blen == 0 );
  
      
      return( ecdsa_sign_restartable( grp, r, s, d, buf, blen,
                                    f_rng, p_rng, NULL ) );
                                     f_rng, p_rng, f_rng, p_rng, NULL ) );
  }","[12, 15, 14]","Arm Mbed TLS before 2.19.0 and Arm Mbed Crypto before 2.0.0, when deterministic ECDSA is enabled, use an RNG with insufficient entropy for blinding, which might allow an attacker to recover a private key via side-channel attacks if a victim signs the same message many times. (For Mbed TLS, the fix is also available in versions 2.7.12 and 2.16.3.)"
199988," krb5_gss_inquire_context(minor_status, context_handle, initiator_name,
                          acceptor_name, lifetime_rec, mech_type, ret_flags,
                          locally_initiated, opened)
     OM_uint32 *minor_status;
     gss_ctx_id_t context_handle;
     gss_name_t *initiator_name;
     gss_name_t *acceptor_name;
     OM_uint32 *lifetime_rec;
     gss_OID *mech_type;
     OM_uint32 *ret_flags;
     int *locally_initiated;
     int *opened;
 {
     krb5_context context;
     krb5_error_code code;
     krb5_gss_ctx_id_rec *ctx;
     krb5_gss_name_t initiator, acceptor;
     krb5_timestamp now;
     krb5_deltat lifetime;
 
     if (initiator_name)
         *initiator_name = (gss_name_t) NULL;
     if (acceptor_name)
         *acceptor_name = (gss_name_t) NULL;
  
      ctx = (krb5_gss_ctx_id_rec *) context_handle;
  
    if (! ctx->established) {
     if (ctx->terminated || !ctx->established) {
          *minor_status = KG_CTX_INCOMPLETE;
          return(GSS_S_NO_CONTEXT);
      }
 
     initiator = NULL;
     acceptor = NULL;
     context = ctx->k5_context;
 
     if ((code = krb5_timeofday(context, &now))) {
         *minor_status = code;
         save_error_info(*minor_status, context);
         return(GSS_S_FAILURE);
     }
 
     if ((lifetime = ctx->krb_times.endtime - now) < 0)
         lifetime = 0;
 
     if (initiator_name) {
         if ((code = kg_duplicate_name(context,
                                       ctx->initiate ? ctx->here : ctx->there,
                                       &initiator))) {
             *minor_status = code;
             save_error_info(*minor_status, context);
             return(GSS_S_FAILURE);
         }
     }
 
     if (acceptor_name) {
         if ((code = kg_duplicate_name(context,
                                       ctx->initiate ? ctx->there : ctx->here,
                                       &acceptor))) {
             if (initiator)
                 kg_release_name(context, &initiator);
             *minor_status = code;
             save_error_info(*minor_status, context);
             return(GSS_S_FAILURE);
         }
     }
 
     if (initiator_name)
         *initiator_name = (gss_name_t) initiator;
 
     if (acceptor_name)
         *acceptor_name = (gss_name_t) acceptor;
 
     if (lifetime_rec)
         *lifetime_rec = lifetime;
 
     if (mech_type)
         *mech_type = (gss_OID) ctx->mech_used;
 
     if (ret_flags)
         *ret_flags = ctx->gss_flags;
 
     if (locally_initiated)
         *locally_initiated = ctx->initiate;
 
     if (opened)
         *opened = ctx->established;
 
     *minor_status = 0;
     return((lifetime == 0)?GSS_S_CONTEXT_EXPIRED:GSS_S_COMPLETE);
 }","[29, 28]","The krb5_gss_process_context_token function in lib/gssapi/krb5/process_context_token.c in the libgssapi_krb5 library in MIT Kerberos 5 (aka krb5) through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 does not properly maintain security-context handles, which allows remote authenticated users to cause a denial of service (use-after-free and double free, and daemon crash) or possibly execute arbitrary code via crafted GSSAPI traffic, as demonstrated by traffic to kadmind."
8480,"u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)
{
u32 val=0, code;
s32 nb_lead = -1;
u32 bits = 0;
for (code=0; !code; nb_lead++) {
if (nb_lead>=32) {


if (!gf_bs_available(bs)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n""));
} else {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead));
}
return 0;
}

code = gf_bs_read_int(bs, 1);
bits++;
}

if (nb_lead) {
val = gf_bs_read_int(bs, nb_lead);
val += (1 << nb_lead) - 1;
bits += nb_lead;
}

if (fname) {
gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);
}
return val;
}","[23, 24]","A Segmentation fault caused by null pointer dereference vulnerability eists in Gpac through 1.0.2 via the avc_parse_slice function in av_parsers.c when using mp4box, which causes a denial of service."
207694,"  next_format(png_bytep colour_type, png_bytep bit_depth,
   unsigned int* palette_number, int no_low_depth_gray)
    unsigned int* palette_number, int low_depth_gray, int tRNS)
  {
     if (*bit_depth == 0)
     {
        *colour_type = 0;
      if (no_low_depth_gray)
         *bit_depth = 8;
      else
       if (low_depth_gray)
           *bit_depth = 1;
       else
          *bit_depth = 8;
        *palette_number = 0;
        return 1;
     }
  
   if (*colour_type == 3)
    if  (*colour_type < 4 )
     {
        
      if (++*palette_number < PALETTE_COUNT(*bit_depth))
       unsigned int pn = ++*palette_number;
       png_byte ct = *colour_type;
 
       if (((ct == 0  || ct  == 2) && tRNS && pn < 2) ||
           (ct == 3  && pn < PALETTE_COUNT(*bit_depth)))
           return 1;
  
        
        *palette_number = 0;
     }
  
  *bit_depth = (png_byte)(*bit_depth << 1);
 
  
      
     if (*bit_depth <= 8
#     ifdef DO_16BIT
 #ifdef DO_16BIT
           || (*colour_type != 3 && *bit_depth <= 16)
#     endif
 #endif
        )
        return 1;
  
   
  switch (*colour_type)
  {
  case 0:
  *colour_type = 2;
  *bit_depth = 8;
  return 1;
 
  case 2:
  *colour_type = 3;
  *bit_depth = 1;
  return 1;
 
  case 3:
  *colour_type = 4;
  *bit_depth = 8;
  return 1;
 
  case 4:
  *colour_type = 6;
  *bit_depth = 8;
  return 1;
 
  default:
  return 0;
  }
 }","[3, 11, 13, 14, 20, 24, 25, 26, 27, 28, 31, 41, 44, 2, 8, 9, 10, 19, 23, 40, 43]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
206240," ResourceHostMsg_Request CreateXHRRequestWithOrigin(const char* origin) {
 ResourceHostMsg_Request CreateXHRRequest(const char* url) {
    ResourceHostMsg_Request request;
    request.method = ""GET"";
  request.url = GURL(""http:bar.com/simple_page.html"");
  request.first_party_for_cookies = GURL(origin);
   request.url = GURL(url);
    request.referrer_policy = blink::WebReferrerPolicyDefault;
  request.headers = base::StringPrintf(""Origin: %s\r\n"", origin);
    request.load_flags = 0;
    request.origin_pid = 0;
    request.resource_type = RESOURCE_TYPE_XHR;
   request.request_context = 0;
   request.appcache_host_id = kAppCacheNoHostId;
   request.download_to_file = false;
   request.should_reset_appcache = false;
   request.is_main_frame = true;
   request.parent_is_main_frame = false;
   request.parent_render_frame_id = -1;
   request.transition_type = ui::PAGE_TRANSITION_LINK;
   request.allow_download = true;
    return request;
  }","[2, 7, 5, 6, 9]",Race condition in the ResourceDispatcherHostImpl::BeginRequest function in content/browser/loader/resource_dispatcher_host_impl.cc in Google Chrome before 50.0.2661.102 allows remote attackers to make arbitrary HTTP requests by leveraging access to a renderer process and reusing a request ID.
201000," esis_print(netdissect_options *ndo,
            const uint8_t *pptr, u_int length)
 {
 	const uint8_t *optr;
 	u_int li,esis_pdu_type,source_address_length, source_address_number;
 	const struct esis_header_t *esis_header;
 
 	if (!ndo->ndo_eflag)
 		ND_PRINT((ndo, ""ES-IS""));
 
 	if (length <= 2) {
 		ND_PRINT((ndo, ndo->ndo_qflag ? ""bad pkt!"" : ""no header at all!""));
 		return;
 	}
 
 	esis_header = (const struct esis_header_t *) pptr;
         ND_TCHECK(*esis_header);
         li = esis_header->length_indicator;
         optr = pptr;
 
          
 
         if (esis_header->nlpid != NLPID_ESIS) {
             ND_PRINT((ndo, "" nlpid 0x%02x packet not supported"", esis_header->nlpid));
             return;
         }
 
         if (esis_header->version != ESIS_VERSION) {
             ND_PRINT((ndo, "" version %d packet not supported"", esis_header->version));
             return;
         }
 
 	if (li > length) {
             ND_PRINT((ndo, "" length indicator(%u) > PDU size (%u)!"", li, length));
             return;
 	}
 
 	if (li < sizeof(struct esis_header_t) + 2) {
             ND_PRINT((ndo, "" length indicator %u < min PDU size:"", li));
             while (pptr < ndo->ndo_snapend)
                 ND_PRINT((ndo, ""%02X"", *pptr++));
             return;
 	}
 
         esis_pdu_type = esis_header->type & ESIS_PDU_TYPE_MASK;
 
         if (ndo->ndo_vflag < 1) {
             ND_PRINT((ndo, ""%s%s, length %u"",
                    ndo->ndo_eflag ? """" : "", "",
                    tok2str(esis_pdu_values,""unknown type (%u)"",esis_pdu_type),
                    length));
             return;
         } else
             ND_PRINT((ndo, ""%slength %u\n\t%s (%u)"",
                    ndo->ndo_eflag ? """" : "", "",
                    length,
                    tok2str(esis_pdu_values,""unknown type: %u"", esis_pdu_type),
                    esis_pdu_type));
 
         ND_PRINT((ndo, "", v: %u%s"", esis_header->version, esis_header->version == ESIS_VERSION ? """" : ""unsupported"" ));
         ND_PRINT((ndo, "", checksum: 0x%04x"", EXTRACT_16BITS(esis_header->cksum)));
 
         osi_print_cksum(ndo, pptr, EXTRACT_16BITS(esis_header->cksum), 7, li);
 
         ND_PRINT((ndo, "", holding time: %us, length indicator: %u"",
                   EXTRACT_16BITS(esis_header->holdtime), li));
 
         if (ndo->ndo_vflag > 1)
             print_unknown_data(ndo, optr, ""\n\t"", sizeof(struct esis_header_t));
 
 	pptr += sizeof(struct esis_header_t);
 	li -= sizeof(struct esis_header_t);
 
 	switch (esis_pdu_type) {
 	case ESIS_PDU_REDIRECT: {
 		const uint8_t *dst, *snpa, *neta;
 		u_int dstl, snpal, netal;
 
 		ND_TCHECK(*pptr);
 		if (li < 1) {
 			ND_PRINT((ndo, "", bad redirect/li""));
 			return;
 		}
 		dstl = *pptr;
 		pptr++;
 		li--;
 		ND_TCHECK2(*pptr, dstl);
 		if (li < dstl) {
 			ND_PRINT((ndo, "", bad redirect/li""));
 			return;
 		}
 		dst = pptr;
 		pptr += dstl;
                 li -= dstl;
 		ND_PRINT((ndo, ""\n\t  %s"", isonsap_string(ndo, dst, dstl)));
 
 		ND_TCHECK(*pptr);
 		if (li < 1) {
 			ND_PRINT((ndo, "", bad redirect/li""));
 			return;
 		}
 		snpal = *pptr;
 		pptr++;
 		li--;
 		ND_TCHECK2(*pptr, snpal);
 		if (li < snpal) {
 			ND_PRINT((ndo, "", bad redirect/li""));
 			return;
 		}
 		snpa = pptr;
 		pptr += snpal;
                 li -= snpal;
 		ND_TCHECK(*pptr);
 		if (li < 1) {
 			ND_PRINT((ndo, "", bad redirect/li""));
 			return;
 		}
 		netal = *pptr;
 		pptr++;
 		ND_TCHECK2(*pptr, netal);
 		if (li < netal) {
 			ND_PRINT((ndo, "", bad redirect/li""));
 			return;
 		}
 		neta = pptr;
 		pptr += netal;
                 li -= netal;
 
 		if (snpal == 6)
 			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
 			       snpal,
 			       etheraddr_string(ndo, snpa)));
 		else
 			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
 			       snpal,
 			       linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal)));
 		if (netal != 0)
 			ND_PRINT((ndo, ""\n\t  NET (length: %u) %s"",
 			       netal,
 			       isonsap_string(ndo, neta, netal)));
 		break;
 	}
 
 	case ESIS_PDU_ESH:
             ND_TCHECK(*pptr);
             if (li < 1) {
                 ND_PRINT((ndo, "", bad esh/li""));
                 return;
             }
             source_address_number = *pptr;
             pptr++;
             li--;
 
             ND_PRINT((ndo, ""\n\t  Number of Source Addresses: %u"", source_address_number));
 
             while (source_address_number > 0) {
                 ND_TCHECK(*pptr);
             	if (li < 1) {
                     ND_PRINT((ndo, "", bad esh/li""));
             	    return;
             	}
                 source_address_length = *pptr;
                 pptr++;
             	li--;
 
                 ND_TCHECK2(*pptr, source_address_length);
             	if (li < source_address_length) {
                     ND_PRINT((ndo, "", bad esh/li""));
             	    return;
             	}
                 ND_PRINT((ndo, ""\n\t  NET (length: %u): %s"",
                        source_address_length,
                        isonsap_string(ndo, pptr, source_address_length)));
                 pptr += source_address_length;
                 li -= source_address_length;
                 source_address_number--;
             }
 
             break;
 
 	case ESIS_PDU_ISH: {
             ND_TCHECK(*pptr);
             if (li < 1) {
                 ND_PRINT((ndo, "", bad ish/li""));
                 return;
             }
             source_address_length = *pptr;
             pptr++;
             li--;
             ND_TCHECK2(*pptr, source_address_length);
             if (li < source_address_length) {
                 ND_PRINT((ndo, "", bad ish/li""));
                 return;
             }
             ND_PRINT((ndo, ""\n\t  NET (length: %u): %s"", source_address_length, isonsap_string(ndo, pptr, source_address_length)));
             pptr += source_address_length;
             li -= source_address_length;
             break;
 	}
 
 	default:
 		if (ndo->ndo_vflag <= 1) {
 			if (pptr < ndo->ndo_snapend)
 				print_unknown_data(ndo, pptr, ""\n\t  "", ndo->ndo_snapend - pptr);
 		}
 		return;
 	}
 
          
         while (li != 0) {
             u_int op, opli;
             const uint8_t *tptr;
 
             if (li < 2) {
                 ND_PRINT((ndo, "", bad opts/li""));
                 return;
             }
             ND_TCHECK2(*pptr, 2);
             op = *pptr++;
             opli = *pptr++;
             li -= 2;
             if (opli > li) {
                 ND_PRINT((ndo, "", opt (%d) too long"", op));
                 return;
             }
             li -= opli;
             tptr = pptr;
 
             ND_PRINT((ndo, ""\n\t  %s Option #%u, length %u, value: "",
                    tok2str(esis_option_values,""Unknown"",op),
                    op,
                    opli));
 
             switch (op) {
 
             case ESIS_OPTION_ES_CONF_TIME:
                 if (opli == 2) {
                     ND_TCHECK2(*pptr, 2);
                     ND_PRINT((ndo, ""%us"", EXTRACT_16BITS(tptr)));
                 } else
                     ND_PRINT((ndo, ""(bad length)""));
                 break;
  
              case ESIS_OPTION_PROTOCOLS:
                  while (opli>0) {
                    ND_TCHECK(*pptr);
                     ND_TCHECK(*tptr);
                      ND_PRINT((ndo, ""%s (0x%02x)"",
                             tok2str(nlpid_values,
                                     ""unknown"",
                                    *tptr),
                            *tptr));
                     if (opli>1)  
                         ND_PRINT((ndo, "", ""));
                     tptr++;
                     opli--;
                 }
                 break;
 
                  
 
             case ESIS_OPTION_QOS_MAINTENANCE:
             case ESIS_OPTION_SECURITY:
             case ESIS_OPTION_PRIORITY:
             case ESIS_OPTION_ADDRESS_MASK:
             case ESIS_OPTION_SNPA_MASK:
 
             default:
                 print_unknown_data(ndo, tptr, ""\n\t  "", opli);
                 break;
             }
             if (ndo->ndo_vflag > 1)
                 print_unknown_data(ndo, pptr, ""\n\t  "", opli);
              pptr += opli;
          }
  trunc:
	return;
         ND_PRINT((ndo, ""[|esis]""));
  }","[247, 278, 246, 277]",The ISO ES-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:esis_print().
207147," void HTMLMediaElement::NoneSupported(const String& message) {
  BLINK_MEDIA_LOG << ""NoneSupported("" << (void*)this << "", message='"" << message
                  << ""')"";
 void HTMLMediaElement::NoneSupported(const String& input_message) {
   BLINK_MEDIA_LOG << ""NoneSupported("" << (void*)this << "", message='""
                   << input_message << ""')"";
  
    StopPeriodicTimers();
    load_state_ = kWaitingForSource;
    current_source_node_ = nullptr;
  
   String empty_string;
   const String& message = MediaShouldBeOpaque() ? empty_string : input_message;
 
  
   error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);
 
   ForgetResourceSpecificTracks();
 
   SetNetworkState(kNetworkNoSource);
 
   UpdateDisplayState();
 
   ScheduleEvent(EventTypeNames::error);
 
   ScheduleRejectPlayPromises(kNotSupportedError);
 
   CloseMediaSource();
 
   SetShouldDelayLoadEvent(false);
 
   if (GetLayoutObject())
     GetLayoutObject()->UpdateFromElement();
 }","[4, 5, 6, 12, 13, 14, 2, 3]",Information leak in media engine in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
203988," bool ConvertProperty(IBusProperty* ibus_prop,
                      int selection_item_id,
                      ImePropertyList* out_prop_list) {
   DCHECK(ibus_prop);
   DCHECK(ibus_prop->key);
   DCHECK(out_prop_list);
 
   const bool has_sub_props = PropertyHasChildren(ibus_prop);
   if (has_sub_props && (ibus_prop->type != PROP_TYPE_MENU)) {
     LOG(ERROR) << ""The property has sub properties, ""
                << ""but the type of the property is not PROP_TYPE_MENU"";
     return false;
    }
    if ((!has_sub_props) && (ibus_prop->type == PROP_TYPE_MENU)) {
    DLOG(INFO) << ""Property list is empty"";
     VLOG(1) << ""Property list is empty"";
      return false;
    }
    if (ibus_prop->type == PROP_TYPE_SEPARATOR ||
       ibus_prop->type == PROP_TYPE_MENU) {
     return true;
   }
 
   const bool is_selection_item = (ibus_prop->type == PROP_TYPE_RADIO);
   selection_item_id = is_selection_item ?
       selection_item_id : ImeProperty::kInvalidSelectionItemId;
 
   bool is_selection_item_checked = false;
   if (ibus_prop->state == PROP_STATE_INCONSISTENT) {
     LOG(WARNING) << ""The property is in PROP_STATE_INCONSISTENT, ""
                  << ""which is not supported."";
   } else if ((!is_selection_item) && (ibus_prop->state == PROP_STATE_CHECKED)) {
     LOG(WARNING) << ""PROP_STATE_CHECKED is meaningful only if the type is ""
                  << ""PROP_TYPE_RADIO."";
   } else {
     is_selection_item_checked = (ibus_prop->state == PROP_STATE_CHECKED);
   }
 
   if (!ibus_prop->key) {
     LOG(ERROR) << ""key is NULL"";
   }
   if (ibus_prop->tooltip && (!ibus_prop->tooltip->text)) {
     LOG(ERROR) << ""tooltip is NOT NULL, but tooltip->text IS NULL: key=""
                << Or(ibus_prop->key, """");
   }
   if (ibus_prop->label && (!ibus_prop->label->text)) {
     LOG(ERROR) << ""label is NOT NULL, but label->text IS NULL: key=""
                << Or(ibus_prop->key, """");
   }
 
   std::string label =
       ((ibus_prop->tooltip &&
         ibus_prop->tooltip->text) ? ibus_prop->tooltip->text : """");
   if (label.empty()) {
     label = (ibus_prop->label && ibus_prop->label->text)
         ? ibus_prop->label->text : """";
   }
   if (label.empty()) {
     label = Or(ibus_prop->key, """");
   }
 
   out_prop_list->push_back(ImeProperty(ibus_prop->key,
                                        label,
                                        is_selection_item,
                                        is_selection_item_checked,
                                        selection_item_id));
   return true;
 }","[16, 15]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
202265," ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
 {
     unsigned nSyms = darray_size(expr->keysym_list.syms);
     unsigned numEntries = darray_size(append->keysym_list.syms);
 
     darray_append(expr->keysym_list.symsMapIndex, nSyms);
      darray_append(expr->keysym_list.symsNumEntries, numEntries);
      darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
  
    FreeStmt((ParseCommon *) &append);
     FreeStmt((ParseCommon *) append);
  
      return expr;
  }","[11, 10]",An invalid free in ExprAppendMultiKeysymList in xkbcomp/ast-build.c in xkbcommon before 0.8.1 could be used by local attackers to crash xkbcommon keymap parsers or possibly have unspecified other impact by supplying a crafted keymap file.
206359," base::string16 IDNToUnicodeWithAdjustments(
     base::StringPiece host, base::OffsetAdjuster::Adjustments* adjustments) {
   if (adjustments)
     adjustments->clear();
   base::string16 input16;
    input16.reserve(host.length());
    input16.insert(input16.end(), host.begin(), host.end());
  
   bool is_tld_ascii = true;
   size_t last_dot = host.rfind('.');
   if (last_dot != base::StringPiece::npos &&
       host.substr(last_dot).starts_with("".xn--"")) {
     is_tld_ascii = false;
   }
 
    base::string16 out16;
   for (size_t component_start = 0, component_end;
        component_start < input16.length();
        component_start = component_end + 1) {
     component_end = input16.find('.', component_start);
     if (component_end == base::string16::npos)
       component_end = input16.length();   
     size_t component_length = component_end - component_start;
     size_t new_component_start = out16.length();
     bool converted_idn = false;
     if (component_end > component_start) {
        converted_idn =
            IDNToUnicodeOneComponent(input16.data() + component_start,
                                   component_length, &out16);
                                    component_length, is_tld_ascii, &out16);
      }
      size_t new_component_length = out16.length() - new_component_start;
  
     if (converted_idn && adjustments) {
       adjustments->push_back(base::OffsetAdjuster::Adjustment(
           component_start, component_length, new_component_length));
     }
 
     if (component_end < input16.length())
       out16.push_back('.');
   }
   return out16;
 }","[9, 10, 11, 12, 13, 14, 15, 30, 29]","Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 58.0.3029.81 for Mac, Windows, and Linux, and 58.0.3029.83 for Android, allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
200114,"  choose_filters(struct archive_read *a)
  {
	int number_bidders, i, bid, best_bid;
 	int number_bidders, i, bid, best_bid, n;
  	struct archive_read_filter_bidder *bidder, *best_bidder;
  	struct archive_read_filter *filter;
  	ssize_t avail;
  	int r;
  
	for (;;) {
 	for (n = 0; n < 25; ++n) {
  		number_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);
  
  		best_bid = 0;
 		best_bidder = NULL;
 
 		bidder = a->bidders;
 		for (i = 0; i < number_bidders; i++, bidder++) {
 			if (bidder->bid != NULL) {
 				bid = (bidder->bid)(bidder, a->filter);
 				if (bid > best_bid) {
 					best_bid = bid;
 					best_bidder = bidder;
 				}
 			}
 		}
 
 		 
 		if (best_bidder == NULL) {
 			 
 			__archive_read_filter_ahead(a->filter, 1, &avail);
 			if (avail < 0) {
 				__archive_read_close_filters(a);
 				__archive_read_free_filters(a);
 				return (ARCHIVE_FATAL);
 			}
 			a->archive.compression_name = a->filter->name;
 			a->archive.compression_code = a->filter->code;
 			return (ARCHIVE_OK);
 		}
 
 		filter
 		    = (struct archive_read_filter *)calloc(1, sizeof(*filter));
 		if (filter == NULL)
 			return (ARCHIVE_FATAL);
 		filter->bidder = best_bidder;
 		filter->archive = a;
 		filter->upstream = a->filter;
 		a->filter = filter;
 		r = (best_bidder->init)(a->filter);
 		if (r != ARCHIVE_OK) {
 			__archive_read_close_filters(a);
 			__archive_read_free_filters(a);
  			return (ARCHIVE_FATAL);
  		}
  	}
 	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 	    ""Input requires too many filters for decoding"");
 	return (ARCHIVE_FATAL);
  }","[4, 11, 57, 58, 59, 3, 10]","libarchive before 3.2.0 does not limit the number of recursive decompressions, which allows remote attackers to cause a denial of service (memory consumption and application crash) via a crafted gzip file."
202965," GF_Err gf_sm_load_init(GF_SceneLoader *load)
 {
 	GF_Err e = GF_NOT_SUPPORTED;
 	char *ext, szExt[50];
 	 
 	if (!load || (!load->ctx && !load->scene_graph)
 #ifndef GPAC_DISABLE_ISOM
 	        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )
 #endif
 	   ) return GF_BAD_PARAM;
 
 	if (!load->type) {
 #ifndef GPAC_DISABLE_ISOM
 		if (load->isom) {
 			load->type = GF_SM_LOAD_MP4;
 		} else
 #endif
 		{
 			ext = (char *)strrchr(load->fileName, '.');
 			if (!ext) return GF_NOT_SUPPORTED;
 			if (!stricmp(ext, "".gz"")) {
 				char *anext;
 				ext[0] = 0;
 				anext = (char *)strrchr(load->fileName, '.');
  				ext[0] = '.';
  				ext = anext;
  			}
 			if (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (""[Scene Manager] invalid extension in file name %s\n"", load->fileName));
 				return GF_NOT_SUPPORTED;
 			}
  			strcpy(szExt, &ext[1]);
  			strlwr(szExt);
  			if (strstr(szExt, ""bt"")) load->type = GF_SM_LOAD_BT;
 			else if (strstr(szExt, ""wrl"")) load->type = GF_SM_LOAD_VRML;
 			else if (strstr(szExt, ""x3dv"")) load->type = GF_SM_LOAD_X3DV;
 #ifndef GPAC_DISABLE_LOADER_XMT
 			else if (strstr(szExt, ""xmt"") || strstr(szExt, ""xmta"")) load->type = GF_SM_LOAD_XMTA;
 			else if (strstr(szExt, ""x3d"")) load->type = GF_SM_LOAD_X3D;
 #endif
 			else if (strstr(szExt, ""swf"")) load->type = GF_SM_LOAD_SWF;
 			else if (strstr(szExt, ""mov"")) load->type = GF_SM_LOAD_QT;
 			else if (strstr(szExt, ""svg"")) load->type = GF_SM_LOAD_SVG;
 			else if (strstr(szExt, ""xsr"")) load->type = GF_SM_LOAD_XSR;
 			else if (strstr(szExt, ""xbl"")) load->type = GF_SM_LOAD_XBL;
 			else if (strstr(szExt, ""xml"")) {
 				char *rtype = gf_xml_get_root_type(load->fileName, &e);
 				if (rtype) {
 					if (!strcmp(rtype, ""SAFSession"")) load->type = GF_SM_LOAD_XSR;
 					else if (!strcmp(rtype, ""XMT-A"")) load->type = GF_SM_LOAD_XMTA;
 					else if (!strcmp(rtype, ""X3D"")) load->type = GF_SM_LOAD_X3D;
 					else if (!strcmp(rtype, ""bindings"")) load->type = GF_SM_LOAD_XBL;
 
 					gf_free(rtype);
 				}
 			}
 		}
 	}
 	if (!load->type) return e;
 
 	if (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;
 
 	switch (load->type) {
 #ifndef GPAC_DISABLE_LOADER_BT
 	case GF_SM_LOAD_BT:
 	case GF_SM_LOAD_VRML:
 	case GF_SM_LOAD_X3DV:
 		return gf_sm_load_init_bt(load);
 #endif
 
 #ifndef GPAC_DISABLE_LOADER_XMT
 	case GF_SM_LOAD_XMTA:
 	case GF_SM_LOAD_X3D:
 		return gf_sm_load_init_xmt(load);
 #endif
 
 #ifndef GPAC_DISABLE_SVG
 	case GF_SM_LOAD_SVG:
 	case GF_SM_LOAD_XSR:
 	case GF_SM_LOAD_DIMS:
 		return gf_sm_load_init_svg(load);
 
 	case GF_SM_LOAD_XBL:
 		e = gf_sm_load_init_xbl(load);
 
 		load->process = gf_sm_load_run_xbl;
 		load->done = gf_sm_load_done_xbl;
 		return e;
 #endif
 
 #ifndef GPAC_DISABLE_SWF_IMPORT
 	case GF_SM_LOAD_SWF:
 		return gf_sm_load_init_swf(load);
 #endif
 
 #ifndef GPAC_DISABLE_LOADER_ISOM
 	case GF_SM_LOAD_MP4:
 		return gf_sm_load_init_isom(load);
 #endif
 
 #ifndef GPAC_DISABLE_QTVR
 	case GF_SM_LOAD_QT:
 		return gf_sm_load_init_qt(load);
 #endif
 	default:
 		return GF_NOT_SUPPORTED;
 	}
 	return GF_NOT_SUPPORTED;
 }","[28, 29, 30, 31]",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.
203146," static void ext2_put_super (struct super_block * sb)
 {
 	int db_count;
 	int i;
 	struct ext2_sb_info *sbi = EXT2_SB(sb);
  
  	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
  
	ext2_xattr_put_super(sb);
 	if (sbi->s_mb_cache) {
 		ext2_xattr_destroy_cache(sbi->s_mb_cache);
 		sbi->s_mb_cache = NULL;
 	}
  	if (!(sb->s_flags & MS_RDONLY)) {
  		struct ext2_super_block *es = sbi->s_es;
  
 		spin_lock(&sbi->s_lock);
 		es->s_state = cpu_to_le16(sbi->s_mount_state);
 		spin_unlock(&sbi->s_lock);
 		ext2_sync_super(sb, es, 1);
 	}
 	db_count = sbi->s_gdb_count;
 	for (i = 0; i < db_count; i++)
 		if (sbi->s_group_desc[i])
 			brelse (sbi->s_group_desc[i]);
 	kfree(sbi->s_group_desc);
 	kfree(sbi->s_debts);
 	percpu_counter_destroy(&sbi->s_freeblocks_counter);
 	percpu_counter_destroy(&sbi->s_freeinodes_counter);
 	percpu_counter_destroy(&sbi->s_dirs_counter);
 	brelse (sbi->s_sbh);
 	sb->s_fs_info = NULL;
 	kfree(sbi->s_blockgroup_lock);
 	kfree(sbi);
 }","[10, 11, 12, 13, 9]","The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba."
7565,"pixFewColorsOctcubeQuantMixed(PIX       *pixs,
l_int32    level,
l_int32    darkthresh,
l_int32    lightthresh,
l_int32    diffthresh,
l_float32  minfract,
l_int32    maxspan)
{
l_int32    i, j, w, h, wplc, wplm, wpld, ncolors, index;
l_int32    rval, gval, bval, val, minval, maxval;
l_int32   *lut;
l_uint32  *datac, *datam, *datad, *linec, *linem, *lined;
PIX       *pixc, *pixm, *pixg, *pixd;
PIXCMAP   *cmap, *cmapd;

PROCNAME(""pixFewColorsOctcubeQuantMixed"");

if (!pixs || pixGetDepth(pixs) != 32)
return (PIX *)ERROR_PTR(""pixs undefined or not 32 bpp"", procName, NULL);
if (level <= 0) level = 3;
if (level > 6)
return (PIX *)ERROR_PTR(""invalid level"", procName, NULL);
if (darkthresh <= 0) darkthresh = 20;
if (lightthresh <= 0) lightthresh = 244;
if (diffthresh <= 0) diffthresh = 20;
if (minfract <= 0.0) minfract = 0.05;
if (maxspan <= 2) maxspan = 15;


if ((pixc = pixFewColorsOctcubeQuant1(pixs, level)) == NULL)
return (PIX *)ERROR_PTR(""too many colors"", procName, NULL);



cmap = pixGetColormap(pixc);
ncolors = pixcmapGetCount(cmap);
cmapd = pixcmapCreate(8);
lut = (l_int32 *)LEPT_CALLOC(256, sizeof(l_int32));
for (i = 0; i < 256; i++)
lut[i] = -1;
for (i = 0, index = 0; i < ncolors; i++) {
pixcmapGetColor(cmap, i, &rval, &gval, &bval);
minval = L_MIN(rval, gval);
minval = L_MIN(minval, bval);
if (minval > lightthresh)
continue;
maxval = L_MAX(rval, gval);
maxval = L_MAX(maxval, bval);
if (maxval < darkthresh)
continue;


if (maxval - minval >= diffthresh) {
pixcmapAddColor(cmapd, rval, gval, bval);
lut[i] = index;
index++;
}
}




pixGetDimensions(pixs, &w, &h, NULL);
pixd = pixCreate(w, h, 8);
pixSetColormap(pixd, cmapd);
pixm = pixCreate(w, h, 1);
datac = pixGetData(pixc);
datam = pixGetData(pixm);
datad = pixGetData(pixd);
wplc = pixGetWpl(pixc);
wplm = pixGetWpl(pixm);
wpld = pixGetWpl(pixd);
for (i = 0; i < h; i++) {
linec = datac + i * wplc;
linem = datam + i * wplm;
lined = datad + i * wpld;
for (j = 0; j < w; j++) {
val = GET_DATA_BYTE(linec, j);
if (lut[val] == -1)
SET_DATA_BIT(linem, j);
else
SET_DATA_BYTE(lined, j, lut[val]);
}
}



pixg = pixConvertTo8(pixs, 0);
pixGrayQuantFromHisto(pixd, pixg, pixm, minfract, maxspan);

LEPT_FREE(lut);
pixDestroy(&pixc);
pixDestroy(&pixm);
pixDestroy(&pixg);
return pixd;
}","[13, 30, 35]",Leptonica before 1.80.0 allows a heap-based buffer over-read in pixFewColorsOctcubeQuantMixed in colorquant1.c.
200872," long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)
 {
 	struct key_user *newowner, *zapowner = NULL;
 	struct key *key;
 	key_ref_t key_ref;
 	long ret;
 	kuid_t uid;
 	kgid_t gid;
 
 	uid = make_kuid(current_user_ns(), user);
 	gid = make_kgid(current_user_ns(), group);
 	ret = -EINVAL;
 	if ((user != (uid_t) -1) && !uid_valid(uid))
 		goto error;
 	if ((group != (gid_t) -1) && !gid_valid(gid))
 		goto error;
 
 	ret = 0;
 	if (user == (uid_t) -1 && group == (gid_t) -1)
 		goto error;
 
 	key_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,
 				  KEY_NEED_SETATTR);
 	if (IS_ERR(key_ref)) {
 		ret = PTR_ERR(key_ref);
 		goto error;
 	}
 
 	key = key_ref_to_ptr(key_ref);
 
 	 
 	ret = -EACCES;
 	down_write(&key->sem);
 
 	if (!capable(CAP_SYS_ADMIN)) {
 		 
 		if (user != (uid_t) -1 && !uid_eq(key->uid, uid))
 			goto error_put;
 
 		 
 		if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))
 			goto error_put;
 	}
 
 	 
 	if (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {
 		ret = -ENOMEM;
 		newowner = key_user_lookup(uid);
 		if (!newowner)
 			goto error_put;
 
 		 
 		if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {
 			unsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?
 				key_quota_root_maxkeys : key_quota_maxkeys;
 			unsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?
 				key_quota_root_maxbytes : key_quota_maxbytes;
 
 			spin_lock(&newowner->lock);
 			if (newowner->qnkeys + 1 >= maxkeys ||
 			    newowner->qnbytes + key->quotalen >= maxbytes ||
 			    newowner->qnbytes + key->quotalen <
 			    newowner->qnbytes)
 				goto quota_overrun;
 
 			newowner->qnkeys++;
 			newowner->qnbytes += key->quotalen;
 			spin_unlock(&newowner->lock);
 
 			spin_lock(&key->user->lock);
 			key->user->qnkeys--;
 			key->user->qnbytes -= key->quotalen;
 			spin_unlock(&key->user->lock);
 		}
 
  		atomic_dec(&key->user->nkeys);
  		atomic_inc(&newowner->nkeys);
  
		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
 		if (key->state != KEY_IS_UNINSTANTIATED) {
  			atomic_dec(&key->user->nikeys);
  			atomic_inc(&newowner->nikeys);
  		}
 
 		zapowner = key->user;
 		key->user = newowner;
 		key->uid = uid;
 	}
 
 	 
 	if (group != (gid_t) -1)
 		key->gid = gid;
 
 	ret = 0;
 
 error_put:
 	up_write(&key->sem);
 	key_put(key);
 	if (zapowner)
 		key_user_put(zapowner);
 error:
 	return ret;
 
 quota_overrun:
 	spin_unlock(&newowner->lock);
 	zapowner = newowner;
 	ret = -EDQUOT;
 	goto error_put;
 }","[80, 79]","The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the *negative* state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."
1813,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)
{
VirtQueueElement elem;
VirtQueue *vq;

vq = vser->c_ivq;
if (!virtio_queue_ready(vq)) {
return 0;
}
if (!virtqueue_pop(vq, &elem)) {
return 0;
}

memcpy(elem.in_sg[0].iov_base, buf, len);

virtqueue_push(vq, &elem, len);
virtio_notify(VIRTIO_DEVICE(vser), vq);
return len;
}",[14],Buffer overflow in the send_control_msg function in hw/char/virtio-serial-bus.c in QEMU before 2.4.0 allows guest users to cause a denial of service (QEMU process crash) via a crafted virtio control message.
205691,"  bool PaintArtifactCompositor::MightOverlap(const PendingLayer& layer_a,
                                             const PendingLayer& layer_b) {
  PropertyTreeState root_property_tree_state(TransformPaintPropertyNode::Root(),
                                             ClipPaintPropertyNode::Root(),
                                             EffectPaintPropertyNode::Root());
    FloatClipRect bounds_a(layer_a.bounds);
  GeometryMapper::LocalToAncestorVisualRect(layer_a.property_tree_state,
                                            root_property_tree_state, bounds_a);
   GeometryMapper::LocalToAncestorVisualRect(
       layer_a.property_tree_state, PropertyTreeState::Root(), bounds_a);
    FloatClipRect bounds_b(layer_b.bounds);
  GeometryMapper::LocalToAncestorVisualRect(layer_b.property_tree_state,
                                            root_property_tree_state, bounds_b);
   GeometryMapper::LocalToAncestorVisualRect(
       layer_b.property_tree_state, PropertyTreeState::Root(), bounds_b);
  
    return bounds_a.Rect().Intersects(bounds_b.Rect());
  }","[9, 10, 14, 15, 3, 4, 5, 7, 8, 12, 13]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
202837,"  static void copyIPv6IfDifferent(void * dest, const void * src)
  {
	if(dest != src) {
 	if(dest != src && src != NULL) {
  		memcpy(dest, src, sizeof(struct in6_addr));
  	}
  }","[4, 3]",A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in copyIPv6IfDifferent in pcpserver.c.
200059,"  horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)
  {
  	TIFFPredictorState* sp = PredictorState(tif);
  	tmsize_t stride = sp->stride;
  	unsigned char* cp = (unsigned char*) cp0;
  
	assert((cc%stride)==0);
     if((cc%stride)!=0)
     {
         TIFFErrorExt(tif->tif_clientdata, ""horDiff8"",
                      ""%s"", ""(cc%stride)!=0"");
         return 0;
     }
  
  	if (cc > stride) {
  		cc -= stride;
 		 
 		if (stride == 3) {
 			unsigned int r1, g1, b1;
 			unsigned int r2 = cp[0];
 			unsigned int g2 = cp[1];
 			unsigned  int b2 = cp[2];
 			do {
 				r1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1;
 				g1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1;
 				b1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1;
 				cp += 3;
 			} while ((cc -= 3) > 0);
 		} else if (stride == 4) {
 			unsigned int r1, g1, b1, a1;
 			unsigned int r2 = cp[0];
 			unsigned int g2 = cp[1];
 			unsigned int b2 = cp[2];
 			unsigned int a2 = cp[3];
 			do {
 				r1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1;
 				g1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1;
 				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;
 				a1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1;
 				cp += 4;
 			} while ((cc -= 4) > 0);
 		} else {
 			cp += cc - 1;
 			do {
 				REPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)
  			} while ((cc -= stride) > 0);
  		}
  	}
 	return 1;
  }","[8, 9, 10, 11, 12, 13, 49, 7]","tif_predict.h and tif_predict.c in libtiff 4.0.6 have assertions that can lead to assertion failures in debug mode, or buffer overflows in release mode, when dealing with unusual tile size like YCbCr with subsampling. Reported as MSVR 35105, aka *Predictor heap-buffer-overflow.*"
204860," void XMLHttpRequest::genericError()
 void XMLHttpRequest::handleDidFailGeneric()
  {
      clearResponse();
      clearRequest();
    m_error = true;
  
    changeState(DONE);
     m_error = true;
  }","[2, 9, 6, 8]","Use-after-free vulnerability in core/xml/XMLHttpRequest.cpp in Blink, as used in Google Chrome before 30.0.1599.101, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger multiple conflicting uses of the same XMLHttpRequest object."
201480," IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
 {
     int i;
     int ret = 0;
 
     DefragInit();
 
      
 
     int id = 1;
     Packet *packets[17];
     memset(packets, 0x00, sizeof(packets));
 
      
  
       
    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
     packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
  
       
    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
     packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
  
       
    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
     packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
  
       
    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
     packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
  
       
    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
     packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
  
       
    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
     packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
  
       
    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
     packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
  
       
    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
     packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
  
       
    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
     packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
  
       
  
       
    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
     packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
  
       
    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
     packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
  
       
    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
     packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
  
       
    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
     packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
  
       
    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
     packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
  
       
    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
     packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
  
       
    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
     packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
  
       
    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
     packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
  
      default_policy = policy;
  
      
     for (i = 0; i < 9; i++) {
         Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
         if (tp != NULL) {
             SCFree(tp);
             goto end;
         }
         if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
             goto end;
         }
     }
     int overlap = 0;
     for (; i < 16; i++) {
         Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
         if (tp != NULL) {
             SCFree(tp);
             goto end;
         }
         if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
             overlap++;
         }
     }
     if (!overlap)
         goto end;
 
      
     Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);
     if (reassembled == NULL)
         goto end;
     if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)
         goto end;
 
     if (IPV6_GET_PLEN(reassembled) != 192)
         goto end;
 
     SCFree(reassembled);
 
      
     if (defrag_context->frag_pool->outstanding != 0) {
         printf(""defrag_context->frag_pool->outstanding %u: "", defrag_context->frag_pool->outstanding);
         goto end;
     }
 
     ret = 1;
 
 end:
     for (i = 0; i < 17; i++) {
         SCFree(packets[i]);
     }
     DefragDestroy();
     return ret;
 }","[18, 22, 26, 30, 34, 38, 42, 46, 50, 56, 60, 64, 68, 72, 76, 80, 84, 17, 21, 25, 29, 33, 37, 41, 45, 49, 55, 59, 63, 67, 71, 75, 79, 83]",Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.
199916," static int lua_websocket_read(lua_State *L) 
  {
      apr_socket_t *sock;
      apr_status_t rv;
     int do_read = 1;
      int n = 0;
      apr_size_t len = 1;
      apr_size_t plen = 0;
     unsigned short payload_short = 0;
     apr_uint64_t payload_long = 0;
     unsigned char *mask_bytes;
     char byte;
     int plaintext;
     
     
     request_rec *r = ap_lua_check_request_rec(L, 1);
     plaintext = ap_lua_ssl_is_https(r->connection) ? 0 : 1;
 
     
      mask_bytes = apr_pcalloc(r->pool, 4);
      sock = ap_get_conn_socket(r->connection);
  
     while (do_read) { 
     do_read = 0;
       
      if (plaintext) {
          rv = apr_socket_recv(sock, &byte, &len);
     }
     else {
         rv = lua_websocket_readbytes(r->connection, &byte, 1);
     }
     if (rv == APR_SUCCESS) {
         unsigned char ubyte, fin, opcode, mask, payload;
         ubyte = (unsigned char)byte;
          
         fin = ubyte >> (CHAR_BIT - 1);
          
         opcode = ubyte & 0xf;
         
          
         if (plaintext) {
             rv = apr_socket_recv(sock, &byte, &len);
         }
         else {
             rv = lua_websocket_readbytes(r->connection, &byte, 1);
         }
         if (rv == APR_SUCCESS) {
             ubyte = (unsigned char)byte;
              
             mask = ubyte >> (CHAR_BIT - 1);
              
             payload = ubyte & 0x7f;
             plen = payload;
             
              
             if (payload == 126) {
                 len = 2;
                 if (plaintext) {
                      
                     rv = apr_socket_recv(sock, (char*) &payload_short, &len);
                 }
                 else {
                     rv = lua_websocket_readbytes(r->connection, 
                         (char*) &payload_short, 2);
                 }
                 payload_short = ntohs(payload_short);
                 
                 if (rv == APR_SUCCESS) {
                     plen = payload_short;
                 }
                 else {
                     return 0;
                 }
             }
              
             if (payload == 127) {
                 len = 8;
                 if (plaintext) {
                     rv = apr_socket_recv(sock, (char*) &payload_long, &len);
                 }
                 else {
                     rv = lua_websocket_readbytes(r->connection, 
                             (char*) &payload_long, 8);
                 }
                 if (rv == APR_SUCCESS) {
                     plen = ap_ntoh64(&payload_long);
                 }
                 else {
                     return 0;
                 }
             }
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
                     ""Websocket: Reading %"" APR_SIZE_T_FMT "" (%s) bytes, masking is %s. %s"", 
                     plen,
                     (payload >= 126) ? ""extra payload"" : ""no extra payload"", 
                     mask ? ""on"" : ""off"", 
                     fin ? ""This is a final frame"" : ""more to follow"");
             if (mask) {
                 len = 4;
                 if (plaintext) {
                     rv = apr_socket_recv(sock, (char*) mask_bytes, &len);
                 }
                 else {
                     rv = lua_websocket_readbytes(r->connection, 
                             (char*) mask_bytes, 4);
                 }
                 if (rv != APR_SUCCESS) {
                     return 0;
                 }
             }
             if (plen < (HUGE_STRING_LEN*1024) && plen > 0) {
                 apr_size_t remaining = plen;
                 apr_size_t received;
                 apr_off_t at = 0;
                 char *buffer = apr_palloc(r->pool, plen+1);
                 buffer[plen] = 0;
                 
                 if (plaintext) {
                     while (remaining > 0) {
                         received = remaining;
                         rv = apr_socket_recv(sock, buffer+at, &received);
                         if (received > 0 ) {
                             remaining -= received;
                             at += received;
                         }
                     }
                     ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, 
                     ""Websocket: Frame contained %"" APR_OFF_T_FMT "" bytes, pushed to Lua stack"", 
                         at);
                 }
                 else {
                     rv = lua_websocket_readbytes(r->connection, buffer, 
                             remaining);
                     ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, 
                     ""Websocket: SSL Frame contained %"" APR_SIZE_T_FMT "" bytes, ""\
                             ""pushed to Lua stack"", 
                         remaining);
                 }
                 if (mask) {
                     for (n = 0; n < plen; n++) {
                         buffer[n] ^= mask_bytes[n%4];
                     }
                 }
                 
                 lua_pushlstring(L, buffer, (size_t) plen);  
                 lua_pushboolean(L, fin);  
                 return 2;
             }
             
             
              
             if (opcode == 0x09) {  
                 char frame[2];
                 plen = 2;
                  frame[0] = 0x8A;
                  frame[1] = 0;
                  apr_socket_send(sock, frame, &plen);  
                lua_websocket_read(L);  
                 do_read = 1;
              }
          }
      }
     }
      return 0;
  }","[5, 23, 24, 159, 163, 158]",The lua_websocket_read function in lua_request.c in the mod_lua module in the Apache HTTP Server through 2.4.12 allows remote attackers to cause a denial of service (child-process crash) by sending a crafted WebSocket Ping frame after a Lua script has called the wsupgrade function.
199452," static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 					int flag)
 {
 	struct super_block *sb = old->mnt.mnt_sb;
 	struct mount *mnt;
 	int err;
 
 	mnt = alloc_vfsmnt(old->mnt_devname);
 	if (!mnt)
 		return ERR_PTR(-ENOMEM);
 
 	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
 		mnt->mnt_group_id = 0;  
 	else
 		mnt->mnt_group_id = old->mnt_group_id;
 
 	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
 		err = mnt_alloc_group_id(mnt);
 		if (err)
 			goto out_free;
 	}
  
  	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);
  	 
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
 	if (flag & CL_UNPRIVILEGED) {
 		mnt->mnt.mnt_flags |= MNT_LOCK_ATIME;
 
 		if (mnt->mnt.mnt_flags & MNT_READONLY)
 			mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
 
 		if (mnt->mnt.mnt_flags & MNT_NODEV)
 			mnt->mnt.mnt_flags |= MNT_LOCK_NODEV;
 
 		if (mnt->mnt.mnt_flags & MNT_NOSUID)
 			mnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;
 
 		if (mnt->mnt.mnt_flags & MNT_NOEXEC)
 			mnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;
 	}
  
  	 
  	if ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))
 		mnt->mnt.mnt_flags |= MNT_LOCKED;
 
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
 	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
 	mnt->mnt_parent = mnt;
 	lock_mount_hash();
 	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
 	unlock_mount_hash();
 
 	if ((flag & CL_SLAVE) ||
 	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
 		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
 		mnt->mnt_master = old;
 		CLEAR_MNT_SHARED(mnt);
 	} else if (!(flag & CL_PRIVATE)) {
 		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
 			list_add(&mnt->mnt_share, &old->mnt_share);
 		if (IS_MNT_SLAVE(old))
 			list_add(&mnt->mnt_slave, &old->mnt_slave);
 		mnt->mnt_master = old->mnt_master;
 	}
 	if (flag & CL_MAKE_SHARED)
 		set_mnt_shared(mnt);
 
 	 
 	if (flag & CL_EXPIRE) {
 		if (!list_empty(&old->mnt_expire))
 			list_add(&mnt->mnt_expire, &old->mnt_expire);
 	}
 
 	return mnt;
 
  out_free:
 	mnt_free_id(mnt);
 	free_vfsmnt(mnt);
 	return ERR_PTR(err);
 }","[27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 25, 26]","fs/namespace.c in the Linux kernel through 3.16.1 does not properly restrict clearing MNT_NODEV, MNT_NOSUID, and MNT_NOEXEC and changing MNT_ATIME_MASK during a remount of a bind mount, which allows local users to gain privileges, interfere with backups and auditing on systems that had atime enabled, or cause a denial of service (excessive filesystem updating) on systems that had atime disabled via a *mount -o remount* command within a user namespace."
206473," static sk_sp<SkImage> premulSkImageToUnPremul(SkImage* input) {
   SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),
                                        kN32_SkColorType, kUnpremul_SkAlphaType);
   RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);
   if (!dstPixels)
      return nullptr;
    return newSkImageFromRaster(
        info, std::move(dstPixels),
      static_cast<size_t>(input->width()) * info.bytesPerPixel());
       static_cast<unsigned>(input->width()) * info.bytesPerPixel());
  }","[10, 9]","Bad casting in bitmap manipulation in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
202865," static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define CheckOverflowException(length,width,height) \
   (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))
 
   char
     *comment;
 
   Image
     *image;
 
   IndexPacket
     index;
 
   int
     x_status;
 
   MagickBooleanType
     authentic_colormap;
 
   MagickStatusType
     status;
 
   register IndexPacket
     *indexes;
 
   register ssize_t
     x;
 
   register PixelPacket
     *q;
 
   register ssize_t
     i;
 
   register size_t
     pixel;
 
   size_t
     length;
 
   ssize_t
     count,
     y;
 
   unsigned long
     lsb_first;
 
   XColor
     *colors;
 
   XImage
     *ximage;
 
   XWDFileHeader
     header;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);
   if (count != sz_XWDheader)
     ThrowReaderException(CorruptImageError,""UnableToReadImageHeader"");
    
   lsb_first=1;
   if ((int) (*(char *) &lsb_first) != 0)
     MSBOrderLong((unsigned char *) &header,sz_XWDheader);
    
   if (header.file_version != XWD_FILE_VERSION)
     ThrowReaderException(CorruptImageError,""FileFormatVersionMismatch"");
   if (header.header_size < sz_XWDheader)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((header.bits_per_pixel == 0) || (header.bits_per_pixel > 32))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if ((header.bitmap_bit_order != MSBFirst) &&
       (header.bitmap_bit_order != LSBFirst))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (header.bitmap_unit > 32)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if (header.ncolors > 256)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   switch (header.visual_class)
   {
     case StaticGray:
     case GrayScale:
     case StaticColor:
     case PseudoColor:
     case TrueColor:
     case DirectColor:
       break;
     default:
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   }
   switch (header.pixmap_format)
   {
     case XYBitmap:
     case XYPixmap:
     case ZPixmap:
       break;
     default:
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   }
   length=(size_t) (header.header_size-sz_XWDheader);
   if ((length+1) != ((size_t) ((CARD32) (length+1))))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));
   if (comment == (char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   count=ReadBlob(image,length,(unsigned char *) comment);
   comment[length]='\0';
   (void) SetImageProperty(image,""comment"",comment);
   comment=DestroyString(comment);
   if (count != (ssize_t) length)
     ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    
   ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));
   if (ximage == (XImage *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   ximage->depth=(int) header.pixmap_depth;
   ximage->format=(int) header.pixmap_format;
   ximage->xoffset=(int) header.xoffset;
   ximage->data=(char *) NULL;
   ximage->width=(int) header.pixmap_width;
   ximage->height=(int) header.pixmap_height;
   ximage->bitmap_pad=(int) header.bitmap_pad;
   ximage->bytes_per_line=(int) header.bytes_per_line;
   ximage->byte_order=(int) header.byte_order;
   ximage->bitmap_unit=(int) header.bitmap_unit;
   ximage->bitmap_bit_order=(int) header.bitmap_bit_order;
   ximage->bits_per_pixel=(int) header.bits_per_pixel;
   ximage->red_mask=header.red_mask;
   ximage->green_mask=header.green_mask;
   ximage->blue_mask=header.blue_mask;
   if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || 
       (ximage->format < 0) || (ximage->byte_order < 0) ||
       (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||
       (ximage->bytes_per_line < 0))
     {
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
   if ((ximage->width > 65535) || (ximage->height > 65535))
     {
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
   if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))
     {
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
   x_status=XInitImage(ximage);
   if (x_status == 0)
     {
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
     }
    
   authentic_colormap=MagickFalse;
   colors=(XColor *) NULL;
   if (header.ncolors != 0)
     {
       XWDColor
         color;
 
       length=(size_t) header.ncolors;
       if (length > ((~0UL)/sizeof(*colors)))
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));
       if (colors == (XColor *) NULL)
         {
           ximage=(XImage *) RelinquishMagickMemory(ximage);
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         }
       for (i=0; i < (ssize_t) header.ncolors; i++)
       {
         count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);
         if (count != sz_XWDColor)
           {
             colors=(XColor *) RelinquishMagickMemory(colors);
             ximage=(XImage *) RelinquishMagickMemory(ximage);
             ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
           }
         colors[i].pixel=color.pixel;
         colors[i].red=color.red;
         colors[i].green=color.green;
         colors[i].blue=color.blue;
         colors[i].flags=(char) color.flags;
         if (color.flags != 0)
           authentic_colormap=MagickTrue;
       }
        
       lsb_first=1;
       if ((int) (*(char *) &lsb_first) != 0)
         for (i=0; i < (ssize_t) header.ncolors; i++)
         {
           MSBOrderLong((unsigned char *) &colors[i].pixel,
             sizeof(colors[i].pixel));
           MSBOrderShort((unsigned char *) &colors[i].red,3*
             sizeof(colors[i].red));
         }
     }
    
   length=(size_t) ximage->bytes_per_line*ximage->height;
   if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))
     {
       if (header.ncolors != 0)
         colors=(XColor *) RelinquishMagickMemory(colors);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
   if (ximage->format != ZPixmap)
     {
       size_t
         extent;
 
       extent=length;
       length*=ximage->depth;
       if (CheckOverflowException(length,extent,ximage->depth))
         {
           if (header.ncolors != 0)
             colors=(XColor *) RelinquishMagickMemory(colors);
           ximage=(XImage *) RelinquishMagickMemory(ximage);
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         }
     }
   ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));
   if (ximage->data == (char *) NULL)
     {
       if (header.ncolors != 0)
         colors=(XColor *) RelinquishMagickMemory(colors);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
   count=ReadBlob(image,length,(unsigned char *) ximage->data);
   if (count != (ssize_t) length)
     {
       if (header.ncolors != 0)
         colors=(XColor *) RelinquishMagickMemory(colors);
       ximage->data=DestroyString(ximage->data);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
     }
    
   image->columns=(size_t) ximage->width;
   image->rows=(size_t) ximage->height;
   image->depth=8;
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       if (header.ncolors != 0)
         colors=(XColor *) RelinquishMagickMemory(colors);
       ximage->data=DestroyString(ximage->data);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
   if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||
       (ximage->green_mask != 0) || (ximage->blue_mask != 0))
     image->storage_class=DirectClass;
   else
     image->storage_class=PseudoClass;
   image->colors=header.ncolors;
   if (image_info->ping == MagickFalse)
     switch (image->storage_class)
     {
       case DirectClass:
       default:
       {
         register size_t
           color;
 
         size_t
           blue_mask,
           blue_shift,
           green_mask,
           green_shift,
           red_mask,
           red_shift;
 
          
         red_mask=ximage->red_mask;
         red_shift=0;
         while ((red_mask != 0) && ((red_mask & 0x01) == 0))
         {
           red_mask>>=1;
           red_shift++;
         }
         green_mask=ximage->green_mask;
         green_shift=0;
         while ((green_mask != 0) && ((green_mask & 0x01) == 0))
         {
           green_mask>>=1;
           green_shift++;
         }
         blue_mask=ximage->blue_mask;
         blue_shift=0;
         while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))
         {
           blue_mask>>=1;
           blue_shift++;
         }
          
         if ((image->colors != 0) && (authentic_colormap != MagickFalse))
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (PixelPacket *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               pixel=XGetPixel(ximage,(int) x,(int) y);
               index=ConstrainColormapIndex(image,(ssize_t) (pixel >>
                 red_shift) & red_mask);
               SetPixelRed(q,ScaleShortToQuantum(colors[(ssize_t) index].red));
               index=ConstrainColormapIndex(image,(ssize_t) (pixel >>
                 green_shift) & green_mask);
               SetPixelGreen(q,ScaleShortToQuantum(colors[(ssize_t)
                 index].green));
               index=ConstrainColormapIndex(image,(ssize_t) (pixel >>
                 blue_shift) & blue_mask);
               SetPixelBlue(q,ScaleShortToQuantum(colors[(ssize_t) index].blue));
               q++;
             }
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
               image->rows);
             if (status == MagickFalse)
               break;
           }
         else
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (PixelPacket *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               pixel=XGetPixel(ximage,(int) x,(int) y);
               color=(pixel >> red_shift) & red_mask;
               if (red_mask != 0)
                 color=(color*65535UL)/red_mask;
               SetPixelRed(q,ScaleShortToQuantum((unsigned short) color));
               color=(pixel >> green_shift) & green_mask;
               if (green_mask != 0)
                 color=(color*65535UL)/green_mask;
               SetPixelGreen(q,ScaleShortToQuantum((unsigned short) color));
               color=(pixel >> blue_shift) & blue_mask;
               if (blue_mask != 0)
                 color=(color*65535UL)/blue_mask;
               SetPixelBlue(q,ScaleShortToQuantum((unsigned short) color));
               q++;
             }
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
               image->rows);
             if (status == MagickFalse)
               break;
           }
         break;
       }
       case PseudoClass:
       {
          
         if (AcquireImageColormap(image,image->colors) == MagickFalse)
           {
             if (header.ncolors != 0)
               colors=(XColor *) RelinquishMagickMemory(colors);
             ximage->data=DestroyString(ximage->data);
             ximage=(XImage *) RelinquishMagickMemory(ximage);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         for (i=0; i < (ssize_t) image->colors; i++)
         {
           image->colormap[i].red=ScaleShortToQuantum(colors[i].red);
           image->colormap[i].green=ScaleShortToQuantum(colors[i].green);
           image->colormap[i].blue=ScaleShortToQuantum(colors[i].blue);
         }
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           indexes=GetAuthenticIndexQueue(image);
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             index=ConstrainColormapIndex(image,(ssize_t) XGetPixel(ximage,(int)
               x,(int) y));
             SetPixelIndex(indexes+x,index);
             SetPixelRGBO(q,image->colormap+(ssize_t) index);
             q++;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
             image->rows);
           if (status == MagickFalse)
             break;
         }
         break;
       }
     }
    
   if (header.ncolors != 0)
     colors=(XColor *) RelinquishMagickMemory(colors);
   ximage->data=DestroyString(ximage->data);
   ximage=(XImage *) RelinquishMagickMemory(ximage);
   if (EOFBlob(image) != MagickFalse)
     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
       image->filename);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[88, 89, 90]",ReadXWDImage in coders/xwd.c in the XWD image parsing component of ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (divide-by-zero error) by crafting an XWD image file in which the header indicates neither LSB first nor MSB first.
197771,"  int dns_read_name(unsigned char *buffer, unsigned char *bufend,
                   unsigned char *name, char *destination, int dest_len,
                 int *offset)
                  int *offset, unsigned int depth)
  {
         int nb_bytes = 0, n = 0;
         int label_len;
 	unsigned char *reader = name;
 	char *dest = destination;
 
 	while (1) {
 		 
 		if ((*reader & 0xc0) == 0xc0) {
 			 
                         if ((buffer + reader[1]) > reader)
                                 goto err;
  
                        if (depth++ > 100)
                                goto err;
 
                         n = dns_read_name(buffer, bufend, buffer + reader[1],
                                         dest, dest_len - nb_bytes, offset);
                                          dest, dest_len - nb_bytes, offset, depth);
                         if (n == 0)
                                 goto err;
  
 		}
 
 		label_len = *reader;
 		if (label_len == 0)
 			goto out;
 
 		 
 		if ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))
 			goto err;
 
 		 
 		label_len++;
 
 		memcpy(dest, reader, label_len);
 
 		dest     += label_len;
 		nb_bytes += label_len;
 		reader   += label_len;
 	}
 
   out:
 	 
 	reader  = name;
 	*offset = 0;
 	while (reader < bufend) {
 		if ((reader[0] & 0xc0) == 0xc0) {
 			*offset += 2;
 			break;
 		}
 		else if (*reader == 0) {
 			*offset += 1;
 			break;
 		}
 		*offset += 1;
 		++reader;
 	}
 	return nb_bytes;
 
   err:
 	return 0;
 }","[4, 18, 19, 20, 23, 3, 22]","An issue was discovered in dns.c in HAProxy through 1.8.14. In the case of a compressed pointer, a crafted packet can trigger infinite recursion by making the pointer point to itself, or create a long chain of valid pointers resulting in stack exhaustion."
205615,"  bool AppCacheBackendImpl::SelectCacheForWorker(
      int host_id, int parent_process_id, int parent_host_id) {
    AppCacheHost* host = GetHost(host_id);
  if (!host || host->was_select_cache_called())
   if (!host)
      return false;
  
  host->SelectCacheForWorker(parent_process_id, parent_host_id);
  return true;
   return host->SelectCacheForWorker(parent_process_id, parent_host_id);
  }","[5, 10, 4, 8, 9]",Use-after-free vulnerability in the AppCache implementation in Google Chrome before 47.0.2526.73 allows remote attackers with renderer access to cause a denial of service or possibly have unspecified other impact by leveraging incorrect AppCacheUpdateJob behavior associated with duplicate cache selection.
202213," static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   char
     filename[MagickPathExtent];
 
   FILE
     *file;
 
   Image
     *image,
     *next_image,
     *pwp_image;
 
   ImageInfo
     *read_info;
 
   int
     c,
     unique_file;
 
   MagickBooleanType
     status;
 
   register Image
     *p;
 
   register ssize_t
     i;
 
   size_t
     filesize,
     length;
 
   ssize_t
     count;
 
   unsigned char
     magick[MagickPathExtent];
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImage(image);
       return((Image *) NULL);
     }
   pwp_image=image;
   memset(magick,0,sizeof(magick));
   count=ReadBlob(pwp_image,5,magick);
   if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   read_info=CloneImageInfo(image_info);
   (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
     (void *) NULL);
   SetImageInfoBlob(read_info,(void *) NULL,0);
   unique_file=AcquireUniqueFileResource(filename);
   (void) FormatLocaleString(read_info->filename,MagickPathExtent,""sfw:%s"",
     filename);
   for ( ; ; )
   {
     (void) memset(magick,0,sizeof(magick));
     for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
     {
       for (i=0; i < 17; i++)
         magick[i]=magick[i+1];
       magick[17]=(unsigned char) c;
       if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
         break;
     }
     if (c == EOF)
       {
         (void) RelinquishUniqueFileResource(filename);
         read_info=DestroyImageInfo(read_info);
         ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
       }
     if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
       {
         (void) RelinquishUniqueFileResource(filename);
         read_info=DestroyImageInfo(read_info);
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       }
      
     file=(FILE *) NULL;
     if (unique_file != -1)
       file=fdopen(unique_file,""wb"");
     if ((unique_file == -1) || (file == (FILE *) NULL))
       {
         (void) RelinquishUniqueFileResource(filename);
         read_info=DestroyImageInfo(read_info);
         ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
           image->filename);
         image=DestroyImageList(image);
         return((Image *) NULL);
       }
     length=fwrite(""SFW94A"",1,6,file);
     (void) length;
     filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
     for (i=0; i < (ssize_t) filesize; i++)
     {
        c=ReadBlobByte(pwp_image);
        if (c == EOF)
          break;
      (void) fputc(c,file);
       if (fputc(c,file) != c)
         break;
      }
      (void) fclose(file);
      if (c == EOF)
       {
         (void) RelinquishUniqueFileResource(filename);
         read_info=DestroyImageInfo(read_info);
         ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
       }
     next_image=ReadImage(read_info,exception);
     if (next_image == (Image *) NULL)
       break;
     (void) FormatLocaleString(next_image->filename,MagickPathExtent,
       ""slide_%02ld.sfw"",(long) next_image->scene);
     if (image == (Image *) NULL)
       image=next_image;
     else
       {
          
         for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
         next_image->previous=p;
         next_image->scene=p->scene+1;
         p->next=next_image;
       }
     if (image_info->number_scenes != 0)
       if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
       GetBlobSize(pwp_image));
     if (status == MagickFalse)
       break;
   }
   if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(filename);
   read_info=DestroyImageInfo(read_info);
   if (image != (Image *) NULL)
     {
       if (EOFBlob(image) != MagickFalse)
         {
           char
             *message;
 
           message=GetExceptionMessage(errno);
           (void) ThrowMagickException(exception,GetMagickModule(),
             CorruptImageError,""UnexpectedEndOfFile"",""`%s': %s"",image->filename,
             message);
           message=DestroyString(message);
         }
       (void) CloseBlob(image);
     }
   return(GetFirstImageInList(image));
 }","[112, 113, 111]","The functions ReadDCMImage in coders/dcm.c, ReadPWPImage in coders/pwp.c, ReadCALSImage in coders/cals.c, and ReadPICTImage in coders/pict.c in ImageMagick 7.0.8-4 do not check the return value of the fputc function, which allows remote attackers to cause a denial of service via a crafted image file."
199753," int ext4_orphan_add(handle_t *handle, struct inode *inode)
 {
 	struct super_block *sb = inode->i_sb;
  	struct ext4_iloc iloc;
  	int err = 0, rc;
  
	if (!ext4_handle_valid(handle))
 	if (!EXT4_SB(sb)->s_journal)
  		return 0;
  
  	mutex_lock(&EXT4_SB(sb)->s_orphan_lock);
 	if (!list_empty(&EXT4_I(inode)->i_orphan))
 		goto out_unlock;
 
 	 
 	J_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 		  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);
 
 	BUFFER_TRACE(EXT4_SB(sb)->s_sbh, ""get_write_access"");
 	err = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);
 	if (err)
 		goto out_unlock;
 
 	err = ext4_reserve_inode_write(handle, inode, &iloc);
 	if (err)
 		goto out_unlock;
 	 
 	if (NEXT_ORPHAN(inode) && NEXT_ORPHAN(inode) <=
 		(le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count)))
 			goto mem_insert;
 
 	 
 	NEXT_ORPHAN(inode) = le32_to_cpu(EXT4_SB(sb)->s_es->s_last_orphan);
 	EXT4_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);
 	err = ext4_handle_dirty_super(handle, sb);
 	rc = ext4_mark_iloc_dirty(handle, inode, &iloc);
 	if (!err)
 		err = rc;
 
 	 
 mem_insert:
 	if (!err)
 		list_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);
 
 	jbd_debug(4, ""superblock will point to %lu\n"", inode->i_ino);
 	jbd_debug(4, ""orphan inode %lu will point to %d\n"",
 			inode->i_ino, NEXT_ORPHAN(inode));
 out_unlock:
 	mutex_unlock(&EXT4_SB(sb)->s_orphan_lock);
 	ext4_std_error(inode->i_sb, err);
 	return err;
 }","[8, 7]","fs/ext4/namei.c in the Linux kernel before 3.7 allows physically proximate attackers to cause a denial of service (system crash) via a crafted no-journal filesystem, a related issue to CVE-2013-2015."
199272," int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,
 			int len)
 {
 	int r;
 	unsigned long addr;
 
  	addr = gfn_to_hva(kvm, gfn);
  	if (kvm_is_error_hva(addr))
  		return -EFAULT;
	r = copy_from_user(data, (void __user *)addr + offset, len);
 	r = __copy_from_user(data, (void __user *)addr + offset, len);
  	if (r)
  		return -EFAULT;
  	return 0;
 }","[11, 10]","The KVM subsystem in the Linux kernel before 3.0 does not check whether kernel addresses are specified during allocation of memory slots for use in a guest's physical address space, which allows local users to gain privileges or obtain sensitive information from kernel memory via a crafted application, related to arch/x86/kvm/paging_tmpl.h and virt/kvm/kvm_main.c."
208160," status_t OMXNodeInstance::setConfig(
         OMX_INDEXTYPE index, const void *params, size_t size) {
  Mutex::Autolock autoLock(mLock);
 
      OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
      CLOG_CONFIG(setConfig, ""%s(%#x), %zu@%p)"", asString(extIndex), index, size, params);
  
     if (isProhibitedIndex_l(index)) {
         android_errorWriteLog(0x534e4554, ""29422020"");
         return BAD_INDEX;
     }
 
      OMX_ERRORTYPE err = OMX_SetConfig(
              mHandle, index, const_cast<void *>(params));
      CLOG_IF_ERROR(setConfig, err, ""%s(%#x)"", asString(extIndex), index);
  return StatusFromOMXError(err);
 }","[8, 9, 10, 11, 12]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
199717," int _mkp_stage_30(struct plugin *p,
         struct client_session *cs,
         struct session_request *sr)
 {
     mk_ptr_t referer;
     (void) p;
      (void) cs;
  
      PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
 
     if (mk_security_check_url(sr->uri_processed) < 0) {
          PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
          mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
          return MK_PLUGIN_RET_CLOSE_CONX;
     }
 
     PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
     referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
     if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
     }
 
     return MK_PLUGIN_RET_NOT_ME;
 }","[11, 12, 10]","The Mandril security plugin in Monkey HTTP Daemon (monkeyd) before 1.5.0 allows remote attackers to bypass access restrictions via a crafted URI, as demonstrated by an encoded forward slash."
207189," void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(
     const String& source,
     Document* owner_document) {
   Document* document = frame_->GetDocument();
   if (!document_loader_ ||
       document->PageDismissalEventBeingDispatched() != Document::kNoDismissal)
     return;
 
   UseCounter::Count(*document, WebFeature::kReplaceDocumentViaJavaScriptURL);
 
   const KURL& url = document->Url();
  
    
    
    
    
    WebGlobalObjectReusePolicy global_object_reuse_policy =
      frame_->ShouldReuseDefaultView(url)
       frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())
            ? WebGlobalObjectReusePolicy::kUseExisting
            : WebGlobalObjectReusePolicy::kCreateNew;
  
   StopAllLoaders();
   SubframeLoadingDisabler disabler(document);
   frame_->DetachChildren();
 
   if (!frame_->IsAttached() || document != frame_->GetDocument())
     return;
 
   frame_->GetDocument()->Shutdown();
   Client()->TransitionToCommittedForNewPage();
   document_loader_->ReplaceDocumentWhileExecutingJavaScriptURL(
       url, owner_document, global_object_reuse_policy, source);
 }","[13, 14, 15, 16, 19, 18]",Object lifecycle issue in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass content security policy via a crafted HTML page.
206350," bool ResourcePrefetchPredictor::PredictPreconnectOrigins(
     const GURL& url,
     PreconnectPrediction* prediction) const {
   DCHECK(!prediction || prediction->requests.empty());
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   if (initialization_state_ != INITIALIZED)
     return false;
 
   url::Origin url_origin = url::Origin::Create(url);
   url::Origin redirect_origin;
   bool has_any_prediction = GetRedirectEndpointsForPreconnect(
       url_origin, *host_redirect_data_, prediction);
   if (!GetRedirectOrigin(url_origin, *host_redirect_data_, &redirect_origin)) {
     return has_any_prediction;
   }
 
   OriginData data;
   if (!origin_data_->TryGetData(redirect_origin.host(), &data)) {
     return has_any_prediction;
   }
 
   if (prediction) {
     prediction->host = redirect_origin.host();
     prediction->is_redirected = (redirect_origin != url_origin);
   }
 
   net::NetworkIsolationKey network_isolation_key(redirect_origin,
                                                  redirect_origin);
 
   for (const OriginStat& origin : data.origins()) {
     float confidence = static_cast<float>(origin.number_of_hits()) /
                        (origin.number_of_hits() + origin.number_of_misses());
     if (confidence < kMinOriginConfidenceToTriggerPreresolve)
       continue;
 
      has_any_prediction = true;
      if (prediction) {
        if (confidence > kMinOriginConfidenceToTriggerPreconnect) {
        prediction->requests.emplace_back(GURL(origin.origin()), 1,
                                          network_isolation_key);
         prediction->requests.emplace_back(
             url::Origin::Create(GURL(origin.origin())), 1,
             network_isolation_key);
        } else {
        prediction->requests.emplace_back(GURL(origin.origin()), 0,
                                          network_isolation_key);
         prediction->requests.emplace_back(
             url::Origin::Create(GURL(origin.origin())), 0,
             network_isolation_key);
        }
      }
    }
 
   return has_any_prediction;
 }","[41, 42, 43, 47, 48, 49, 39, 40, 45, 46]","Insufficient validation of untrusted input in Skia in Google Chrome prior to 59.0.3071.86 for Linux, Windows, and Mac, and 59.0.3071.92 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
200408," static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 				      unsigned long resolution,
 				      unsigned long ticks)
 {
 	struct snd_timer_user *tu = timeri->callback_data;
 	struct snd_timer_tread *r, r1;
 	struct timespec tstamp;
 	int prev, append = 0;
 
 	memset(&tstamp, 0, sizeof(tstamp));
 	spin_lock(&tu->qlock);
 	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |
 			   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {
 		spin_unlock(&tu->qlock);
 		return;
 	}
 	if (tu->last_resolution != resolution || ticks > 0) {
 		if (timer_tstamp_monotonic)
 			ktime_get_ts(&tstamp);
 		else
 			getnstimeofday(&tstamp);
  	}
  	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
  	    tu->last_resolution != resolution) {
 		memset(&r1, 0, sizeof(r1));
  		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
  		r1.tstamp = tstamp;
  		r1.val = resolution;
 		snd_timer_user_append_to_tqueue(tu, &r1);
 		tu->last_resolution = resolution;
 		append++;
 	}
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)
 		goto __wake;
 	if (ticks == 0)
 		goto __wake;
 	if (tu->qused > 0) {
 		prev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;
 		r = &tu->tqueue[prev];
 		if (r->event == SNDRV_TIMER_EVENT_TICK) {
 			r->tstamp = tstamp;
 			r->val += ticks;
 			append++;
 			goto __wake;
 		}
 	}
 	r1.event = SNDRV_TIMER_EVENT_TICK;
 	r1.tstamp = tstamp;
 	r1.val = ticks;
 	snd_timer_user_append_to_tqueue(tu, &r1);
 	append++;
       __wake:
 	spin_unlock(&tu->qlock);
 	if (append == 0)
 		return;
 	kill_fasync(&tu->fasync, SIGIO, POLL_IN);
 	wake_up(&tu->qchange_sleep);
 }",[25],"sound/core/timer.c in the Linux kernel through 4.6 does not initialize certain r1 data structures, which allows local users to obtain sensitive information from kernel stack memory via crafted use of the ALSA timer interface, related to the (1) snd_timer_user_ccallback and (2) snd_timer_user_tinterrupt functions."
206326," void CheckClientDownloadRequest::UploadBinary(
     DownloadCheckResult result,
     DownloadCheckResultReason reason) {
   saved_result_ = result;
   saved_reason_ = reason;
 
   bool upload_for_dlp = ShouldUploadForDlpScan();
   bool upload_for_malware = ShouldUploadForMalwareScan(reason);
   auto request = std::make_unique<DownloadItemRequest>(
       item_,  true,
       base::BindOnce(&CheckClientDownloadRequest::OnDeepScanningComplete,
                      weakptr_factory_.GetWeakPtr()));
 
   Profile* profile = Profile::FromBrowserContext(GetBrowserContext());
 
   if (upload_for_dlp) {
     DlpDeepScanningClientRequest dlp_request;
     dlp_request.set_content_source(DlpDeepScanningClientRequest::FILE_DOWNLOAD);
     request->set_request_dlp_scan(std::move(dlp_request));
   }
 
   if (upload_for_malware) {
     MalwareDeepScanningClientRequest malware_request;
     malware_request.set_population(
         MalwareDeepScanningClientRequest::POPULATION_ENTERPRISE);
     malware_request.set_download_token(
         DownloadProtectionService::GetDownloadPingToken(item_));
      request->set_request_malware_scan(std::move(malware_request));
    }
  
  request->set_dm_token(
      policy::BrowserDMTokenStorage::Get()->RetrieveDMToken());
   auto dm_token = BrowserDMTokenStorage::Get()->RetrieveBrowserDMToken();
   DCHECK(dm_token.is_valid());
   request->set_dm_token(dm_token.value());
  
    service()->UploadForDeepScanning(profile, std::move(request));
  }","[33, 34, 35, 31, 32]",Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 59.0.3071.104 for Mac allowed a remote attacker to perform domain spoofing via a crafted domain name.
203342," static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )
 {
     int ret;
     const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
         ssl->transform_negotiate->ciphersuite_info;
     unsigned char *p = NULL, *end = NULL;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( ""=> parse server key exchange"" ) );
 
 #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )
     {
         MBEDTLS_SSL_DEBUG_MSG( 2, ( ""<= skip parse server key exchange"" ) );
         ssl->state++;
         return( 0 );
     }
     ((void) p);
     ((void) end);
 #endif
 
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
     defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
     {
         if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_RET( 1, ""ssl_get_ecdh_params_from_cert"", ret );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
             return( ret );
         }
 
         MBEDTLS_SSL_DEBUG_MSG( 2, ( ""<= skip parse server key exchange"" ) );
         ssl->state++;
         return( 0 );
     }
     ((void) p);
     ((void) end);
 #endif  
 
     if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
     {
         MBEDTLS_SSL_DEBUG_RET( 1, ""mbedtls_ssl_read_record"", ret );
         return( ret );
     }
 
     if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                         MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
      
     if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )
     {
         if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
             ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
         {
              
             ssl->keep_current_message = 1;
             goto exit;
         }
 
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""server key exchange message must ""
                                     ""not be skipped"" ) );
         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                         MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
 
         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
     p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
     end = ssl->in_msg + ssl->in_hslen;
     MBEDTLS_SSL_DEBUG_BUF( 3,   ""server key exchange"", p, end - p );
 
 #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
     {
         if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
         }
     }  
 #endif  
 
 #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \
     defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
         ;  
     else
 #endif  
 #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
     defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
     {
         if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
         }
     }
     else
 #endif  
 #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \
     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )
     {
         if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
         }
     }
     else
 #endif  
 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
     {
         ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,
                                               p, end - p );
         if( ret != 0 )
         {
             MBEDTLS_SSL_DEBUG_RET( 1, ""mbedtls_ecjpake_read_round_two"", ret );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
         }
     }
     else
 #endif  
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""should never happen"" ) );
         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
     }
 
 #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
     if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )
     {
         size_t sig_len, hashlen;
         unsigned char hash[64];
         mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
         mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
         unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
         size_t params_len = p - params;
 
          
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
         {
             if( ssl_parse_signature_algorithm( ssl, &p, end,
                                                &md_alg, &pk_alg ) != 0 )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
                 mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
                 return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
             }
 
             if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
                 mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
                 return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
             }
         }
         else
 #endif  
 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
     defined(MBEDTLS_SSL_PROTO_TLS1_1)
         if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )
         {
             pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
 
              
             if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )
                 md_alg = MBEDTLS_MD_SHA1;
         }
         else
 #endif
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""should never happen"" ) );
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
         }
 
          
 
         if( p > end - 2 )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
         }
          sig_len = ( p[0] << 8 ) | p[1];
          p += 2;
  
        if( end != p + sig_len )
         if( p != end - sig_len )
          {
              MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
              mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
         }
 
         MBEDTLS_SSL_DEBUG_BUF( 3, ""signature"", p, sig_len );
 
          
 #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
     defined(MBEDTLS_SSL_PROTO_TLS1_1)
         if( md_alg == MBEDTLS_MD_NONE )
         {
             hashlen = 36;
             ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,
                                                            params_len );
             if( ret != 0 )
                 return( ret );
         }
         else
 #endif  
 #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
     defined(MBEDTLS_SSL_PROTO_TLS1_2)
         if( md_alg != MBEDTLS_MD_NONE )
         {
              
             hashlen = 0;
             ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,
                                                           params_len, md_alg );
             if( ret != 0 )
                 return( ret );
         }
         else
 #endif  
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""should never happen"" ) );
             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
         }
 
         MBEDTLS_SSL_DEBUG_BUF( 3, ""parameters hash"", hash, hashlen != 0 ? hashlen :
             (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );
 
         if( ssl->session_negotiate->peer_cert == NULL )
         {
             MBEDTLS_SSL_DEBUG_MSG( 2, ( ""certificate required"" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
             return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
         }
 
          
         if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
             return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );
         }
 
         if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,
                                md_alg, hash, hashlen, p, sig_len ) ) != 0 )
         {
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                             MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );
             MBEDTLS_SSL_DEBUG_RET( 1, ""mbedtls_pk_verify"", ret );
             return( ret );
         }
     }
 #endif  
 
 exit:
     ssl->state++;
 
     MBEDTLS_SSL_DEBUG_MSG( 2, ( ""<= parse server key exchange"" ) );
 
     return( 0 );
 }","[217, 216]","ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input."
200931," static int read_tfra(MOVContext *mov, AVIOContext *f)
 {
     MOVFragmentIndex* index = NULL;
     int version, fieldlength, i, j;
     int64_t pos = avio_tell(f);
     uint32_t size = avio_rb32(f);
     void *tmp;
 
     if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {
         return 1;
     }
     av_log(mov->fc, AV_LOG_VERBOSE, ""found tfra\n"");
     index = av_mallocz(sizeof(MOVFragmentIndex));
     if (!index) {
         return AVERROR(ENOMEM);
     }
 
     tmp = av_realloc_array(mov->fragment_index_data,
                            mov->fragment_index_count + 1,
                            sizeof(MOVFragmentIndex*));
     if (!tmp) {
         av_freep(&index);
         return AVERROR(ENOMEM);
     }
     mov->fragment_index_data = tmp;
     mov->fragment_index_data[mov->fragment_index_count++] = index;
 
     version = avio_r8(f);
     avio_rb24(f);
     index->track_id = avio_rb32(f);
     fieldlength = avio_rb32(f);
     index->item_count = avio_rb32(f);
     index->items = av_mallocz_array(
             index->item_count, sizeof(MOVFragmentIndexItem));
     if (!index->items) {
         index->item_count = 0;
         return AVERROR(ENOMEM);
      }
      for (i = 0; i < index->item_count; i++) {
          int64_t time, offset;
 
         if (avio_feof(f)) {
             index->item_count = 0;
             av_freep(&index->items);
             return AVERROR_INVALIDDATA;
         }
 
          if (version == 1) {
              time   = avio_rb64(f);
              offset = avio_rb64(f);
         } else {
             time   = avio_rb32(f);
             offset = avio_rb32(f);
         }
         index->items[i].time = time;
         index->items[i].moof_offset = offset;
         for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)
             avio_r8(f);
         for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)
             avio_r8(f);
         for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)
             avio_r8(f);
     }
 
     avio_seek(f, pos + size, SEEK_SET);
     return 0;
 }","[41, 42, 43, 44, 45, 46, 47]","In libavformat/mov.c in FFmpeg 3.3.3, a DoS in read_tfra() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MOV file, which claims a large *item_count* field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU and memory resources, since there is no EOF check inside the loop."
7730,"file_rlookup(const char *filename)
{
int  i;
cache_t *wc;


for (i = web_files, wc = web_cache; i > 0; i --, wc ++)
if (!strcmp(wc->name, filename))
return (wc->url);

return (filename);
}","[8, 9]","A flaw was found in htmldoc in v1.9.12. Double-free in function pspdf_export(),in ps-pdf.cxx may result in a write-what-where condition, allowing an attacker to execute arbitrary code and denial of service."
207605,"  load_fake(png_charp param, png_bytepp profile)
  {
     char *endptr = NULL;
   unsigned long long int size = strtoull(param, &endptr, 0 );
    uint64_t size = strtoull(param, &endptr, 0 );
  
      
     if (endptr != NULL && *endptr == '*')
  {
  size_t len = strlen(++endptr);
  size_t result = (size_t)size;
 
  if (len == 0) len = 1;  
 
   
  if (result == size && (*profile = malloc(result)) != NULL)
  {
          png_bytep out = *profile;
 
  if (len == 1)
             memset(out, *endptr, result);
 
  else
  {
  while (size >= len)
  {
                memcpy(out, endptr, len);
                out += len;
                size -= len;
  }
             memcpy(out, endptr, size);
  }
 
  return result;
  }
 
  else
  {
          fprintf(stderr, ""%s: size exceeds system limits\n"", param);
          exit(1);
  }
  }
 
  return 0;
 }","[5, 4]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
8046,"static char *parse_note(char *p,
int flags)
{
struct SYMBOL *s;
char *q;
int pit = 0, len, acc, nostem, chord, j, m, n;

if (flags & ABC_F_GRACE) {
s = abc_new(ABC_T_NOTE, NULL);
} else {
s = abc_new(ABC_T_NOTE, gchord);
if (gchord)
gchord = NULL;
}
s->flags |= flags;
s->u.note.notes[0].color = -1;

if (!lyric_started) {
lyric_started = 1;
s->flags |= ABC_F_LYRIC_START;
}
if (*p != 'X' && *p != 'Z'
&& !(flags & ABC_F_GRACE)) {
if (!deco_start)
deco_start = s;
}
chord = 0;


switch (*p) {
case 'X':
s->flags |= ABC_F_INVIS;
case 'Z':
s->abc_type = ABC_T_MREST;
p++;
len = 1;
if (isdigit((unsigned char) *p)) {
len = strtol(p, &q, 10);
if (len == 0 || len > 100) {
syntax(""Bad number of measures"", p);
len = 1;
}
p = q;
}
s->u.bar.type = 0;
s->u.bar.len = len;
goto add_deco;
case 'y':
s->abc_type = ABC_T_REST;
s->flags |= ABC_F_INVIS;
p++;
if (isdigit((unsigned char) *p)
|| *p == '-') {
s->u.note.notes[0].shhd = strtol(p, &q, 10);
p = q;
} else {
s->u.note.notes[0].shhd = 10;
}
goto add_deco;
case 'x':
s->flags |= ABC_F_INVIS;

case 'z':
s->abc_type = ABC_T_REST;
p = parse_len(p + 1, ulen, &len);
s->u.note.notes[0].len = len;
goto do_brhythm;
case '[':
chord = 1;
p++;
break;
}

q = p;


m = 0;
nostem = 0;
for (;;) {
if (chord) {
if (m >= MAXHD) {
syntax(""Too many notes in chord"", p);
m--;
}
n = 0;
if (*p == '.') {
n = SL_DOTTED;
p++;
}
if (*p == '(') {
p++;
switch (*p) {
case '\'':
n += SL_ABOVE;
p++;
break;
case ',':
n += SL_BELOW;
p++;
break;
default:
n += SL_AUTO;
break;
}
s->u.note.notes[m].sl1 = (s->u.note.notes[m].sl1 << 3)
+ n;
}
}
p = parse_deco(p, &dc, m);
p = parse_acc_pit(p, &pit, &acc);
if (*p == '0') {
nostem = 1;
p++;
}
p = parse_len(p, (flags & ABC_F_GRACE) ?
BASE_LEN / 8 :
ulen,
&len);
s->u.note.notes[m].pit = pit;
s->pits[m] = pit;
s->u.note.notes[m].len = len;
s->u.note.notes[m].acc = acc;
s->u.note.notes[m].color = -1;

if (chord) {
for (;;) {
if (*p == '.') {
if (p[1] != '-')
break;
p++;
}
if (*p == '-') {
switch (p[1]) {
case '\'':
s->u.note.notes[m].ti1 = SL_ABOVE;
p++;
break;
case ',':
s->u.note.notes[m].ti1 = SL_BELOW;
p++;
break;
default:
s->u.note.notes[m].ti1 = SL_AUTO;
break;
}
} else if (*p == ')') {
s->u.note.notes[m].sl2++;
} else {
break;
}
p++;
}
}
if (acc >= 0)
m++;

if (!chord)
break;
if (*p == ']') {
p++;
if (*p == '0') {
nostem = 1;
p++;
}
if (*p == '/' || isdigit((unsigned char) *p)) {
p = parse_len(p, ulen, &len);
for (j = 0; j < m; j++) {
s->u.note.notes[j].len =
len * s->u.note.notes[j].len / ulen;
}
}
break;
}
if (*p == '\0') {
syntax(""Chord not closed"", q);
break;
}
}
if (nostem)
s->flags |= ABC_F_STEMLESS;

if (m == 0)
goto err;

s->u.note.microscale = microscale;
s->nhd = m - 1;

do_brhythm:
if (curvoice->last_note
&& curvoice->last_note->u.note.brhythm != 0)
broken_rhythm(s, -curvoice->last_note->u.note.brhythm);
add_deco:
if (dc.n > 0) {
memcpy(s->abc_type != ABC_T_MREST ? &s->u.note.dc
: &s->u.bar.dc,
&dc, sizeof dc);
dc.n = 0;
}


if (s->abc_type != ABC_T_NOTE && (flags & ABC_F_GRACE)) {
syntax(""Not a note in grace note sequence"", p);
goto err;
}
return p;

err:
if ((parse.last_sym = s->abc_prev) == NULL) {
parse.first_sym = NULL;
} else {
s->abc_prev->abc_next = NULL;
s->abc_prev->flags |= (s->flags & ABC_F_ERROR);
}
return p;
}",[205],Stack-based buffer overflow in the function get_key in parse.c of abcm2ps v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified vectors.
203934,"    virtual void CancelHandwritingStrokes(int stroke_count) {
      if (!initialized_successfully_)
        return;
    chromeos::CancelHandwriting(input_method_status_connection_, stroke_count);
     ibus_controller_->CancelHandwriting(stroke_count);
    }","[5, 4]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
8080,"int ldbRepl(lua_State *lua) {
sds *argv;
int argc;



while(1) {
while((argv = ldbReplParseCommand(&argc)) == NULL) {
char buf[1024];
int nread = connRead(ldb.conn,buf,sizeof(buf));
if (nread <= 0) {


ldb.step = 0;
ldb.bpcount = 0;
return C_ERR;
}
ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
}


sdsfree(ldb.cbuf);
ldb.cbuf = sdsempty();


if (!strcasecmp(argv[0],""h"") || !strcasecmp(argv[0],""help"")) {
ldbLog(sdsnew(""Redis Lua debugger help:""));
ldbLog(sdsnew(""[h]elp               Show this help.""));
ldbLog(sdsnew(""[s]tep               Run current line and stop again.""));
ldbLog(sdsnew(""[n]ext               Alias for step.""));
ldbLog(sdsnew(""[c]continue          Run till next breakpoint.""));
ldbLog(sdsnew(""[l]list              List source code around current line.""));
ldbLog(sdsnew(""[l]list [line]       List source code around [line].""));
ldbLog(sdsnew(""                     line = 0 means: current position.""));
ldbLog(sdsnew(""[l]list [line] [ctx] In this form [ctx] specifies how many lines""));
ldbLog(sdsnew(""                     to show before/after [line].""));
ldbLog(sdsnew(""[w]hole              List all source code. Alias for 'list 1 1000000'.""));
ldbLog(sdsnew(""[p]rint              Show all the local variables.""));
ldbLog(sdsnew(""[p]rint <var>        Show the value of the specified variable.""));
ldbLog(sdsnew(""                     Can also show global vars KEYS and ARGV.""));
ldbLog(sdsnew(""[b]reak              Show all breakpoints.""));
ldbLog(sdsnew(""[b]reak <line>       Add a breakpoint to the specified line.""));
ldbLog(sdsnew(""[b]reak -<line>      Remove breakpoint from the specified line.""));
ldbLog(sdsnew(""[b]reak 0            Remove all breakpoints.""));
ldbLog(sdsnew(""[t]race              Show a backtrace.""));
ldbLog(sdsnew(""[e]eval <code>       Execute some Lua code (in a different callframe).""));
ldbLog(sdsnew(""[r]edis <cmd>        Execute a Redis command.""));
ldbLog(sdsnew(""[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.""));
ldbLog(sdsnew(""                     Specifying zero as <len> means unlimited.""));
ldbLog(sdsnew(""[a]bort              Stop the execution of the script. In sync""));
ldbLog(sdsnew(""                     mode dataset changes will be retained.""));
ldbLog(sdsnew(""""));
ldbLog(sdsnew(""Debugger functions you can call from Lua scripts:""));
ldbLog(sdsnew(""redis.debug()        Produce logs in the debugger console.""));
ldbLog(sdsnew(""redis.breakpoint()   Stop execution like if there was a breakpoint in the""));
ldbLog(sdsnew(""                     next line of code.""));
ldbSendLogs();
} else if (!strcasecmp(argv[0],""s"") || !strcasecmp(argv[0],""step"") ||
!strcasecmp(argv[0],""n"") || !strcasecmp(argv[0],""next"")) {
ldb.step = 1;
break;
} else if (!strcasecmp(argv[0],""c"") || !strcasecmp(argv[0],""continue"")){
break;
} else if (!strcasecmp(argv[0],""t"") || !strcasecmp(argv[0],""trace"")) {
ldbTrace(lua);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""m"") || !strcasecmp(argv[0],""maxlen"")) {
ldbMaxlen(argv,argc);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""b"") || !strcasecmp(argv[0],""break"")) {
ldbBreak(argv,argc);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""e"") || !strcasecmp(argv[0],""eval"")) {
ldbEval(lua,argv,argc);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""a"") || !strcasecmp(argv[0],""abort"")) {
lua_pushstring(lua, ""script aborted for user request"");
lua_error(lua);
} else if (argc > 1 &&
(!strcasecmp(argv[0],""r"") || !strcasecmp(argv[0],""redis""))) {
ldbRedis(lua,argv,argc);
ldbSendLogs();
} else if ((!strcasecmp(argv[0],""p"") || !strcasecmp(argv[0],""print""))) {
if (argc == 2)
ldbPrint(lua,argv[1]);
else
ldbPrintAll(lua);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""l"") || !strcasecmp(argv[0],""list"")){
int around = ldb.currentline, ctx = 5;
if (argc > 1) {
int num = atoi(argv[1]);
if (num > 0) around = num;
}
if (argc > 2) ctx = atoi(argv[2]);
ldbList(around,ctx);
ldbSendLogs();
} else if (!strcasecmp(argv[0],""w"") || !strcasecmp(argv[0],""whole"")){
ldbList(1,1000000);
ldbSendLogs();
} else {
ldbLog(sdsnew(""<error> Unknown Redis Lua debugger command or ""
""wrong number of arguments.""));
ldbSendLogs();
}


sdsfreesplitres(argv,argc);
}


sdsfreesplitres(argv,argc);
return C_OK;
}","[7, 8, 10, 22]","Redis is an open source, in-memory database that persists on disk. When using the Redis Lua Debugger, users can send malformed requests that cause the debugger&#8217;s protocol parser to read data beyond the actual buffer. This issue affects all versions of Redis with Lua debugging support (3.2 or newer). The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14."
207501," bool config_save(const config_t *config, const char *filename) {
   assert(config != NULL);
 
    assert(filename != NULL);
    assert(*filename != '\0');
  
  char *temp_filename = osi_calloc(strlen(filename) + 5);
  if (!temp_filename) {
    LOG_ERROR(""%s unable to allocate memory for filename."", __func__);
    return false;
    
    
    
    
    
    
    
    
   int dir_fd = -1;
   FILE *fp = NULL;
 
    
   static const char *temp_file_ext = "".new"";
   const int filename_len = strlen(filename);
   const int temp_filename_len = filename_len + strlen(temp_file_ext) + 1;
   char *temp_filename = osi_calloc(temp_filename_len);
   snprintf(temp_filename, temp_filename_len, ""%s%s"", filename, temp_file_ext);
 
    
   char *temp_dirname = osi_strdup(filename);
   const char *directoryname = dirname(temp_dirname);
   if (!directoryname) {
     LOG_ERROR(""%s error extracting directory from '%s': %s"", __func__, filename, strerror(errno));
     goto error;
    }
  
  strcpy(temp_filename, filename);
  strcat(temp_filename, "".new"");
   dir_fd = TEMP_FAILURE_RETRY(open(directoryname, O_RDONLY));
   if (dir_fd < 0) {
     LOG_ERROR(""%s unable to open dir '%s': %s"", __func__, directoryname, strerror(errno));
     goto error;
   }
  
  FILE *fp = fopen(temp_filename, ""wt"");
   fp = fopen(temp_filename, ""wt"");
    if (!fp) {
      LOG_ERROR(""%s unable to write file '%s': %s"", __func__, temp_filename, strerror(errno));
      goto error;
  }
 
  
    for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {
      const section_t *section = (const section_t *)list_node(node);
    fprintf(fp, ""[%s]\n"", section->name);
     if (fprintf(fp, ""[%s]\n"", section->name) < 0) {
       LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
       goto error;
     }
  
      for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {
        const entry_t *entry = (const entry_t *)list_node(enode);
      fprintf(fp, ""%s = %s\n"", entry->key, entry->value);
       if (fprintf(fp, ""%s = %s\n"", entry->key, entry->value) < 0) {
         LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
         goto error;
       }
      }
  
    if (list_next(node) != list_end(config->sections))
      fputc('\n', fp);
     if (list_next(node) != list_end(config->sections)) {
       if (fputc('\n', fp) == EOF) {
         LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
         goto error;
       }
     }
    }
  
  fflush(fp);
  fclose(fp);
    
   if (fsync(fileno(fp)) < 0) {
     LOG_WARN(""%s unable to fsync file '%s': %s"", __func__, temp_filename, strerror(errno));
   }
 
   if (fclose(fp) == EOF) {
     LOG_ERROR(""%s unable to close file '%s': %s"", __func__, temp_filename, strerror(errno));
     goto error;
   }
   fp = NULL;
  
    if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {
     LOG_ERROR(""%s unable to change file permissions '%s': %s"", __func__, filename, strerror(errno));
 
      goto error;
    }
  
    
    if (rename(temp_filename, filename) == -1) {
      LOG_ERROR(""%s unable to commit file '%s': %s"", __func__, filename, strerror(errno));
      goto error;
    }
  
    
   if (fsync(dir_fd) < 0) {
     LOG_WARN(""%s unable to fsync dir '%s': %s"", __func__, directoryname, strerror(errno));
   }
 
   if (close(dir_fd) < 0) {
     LOG_ERROR(""%s unable to close dir '%s': %s"", __func__, directoryname, strerror(errno));
     goto error;
   }
 
    osi_free(temp_filename);
   osi_free(temp_dirname);
    return true;
  
error:;
 error:
    
    unlink(temp_filename);
   if (fp)
     fclose(fp);
   if (dir_fd != -1)
     close(dir_fd);
    osi_free(temp_filename);
   osi_free(temp_dirname);
    return false;
  }","[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 39, 40, 41, 42, 43, 46, 56, 57, 58, 59, 64, 65, 66, 67, 72, 73, 74, 75, 76, 77, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 99, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 116, 120, 121, 123, 124, 125, 126, 128, 7, 8, 9, 10, 37, 38, 45, 55, 63, 70, 71, 80, 81, 119]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
201835," main(int ac, char **av)
 {
 	int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;
 	int sock, fd, ch, result, saved_errno;
 	u_int nalloc;
 	char *shell, *format, *pidstr, *agentsocket = NULL;
 	fd_set *readsetp = NULL, *writesetp = NULL;
 	struct rlimit rlim;
 	extern int optind;
 	extern char *optarg;
 	pid_t pid;
 	char pidstrbuf[1 + 3 * sizeof pid];
 	struct timeval *tvp = NULL;
 	size_t len;
 	mode_t prev_mask;
 
 	ssh_malloc_init();	 
 	 
 	sanitise_stdfd();
 
 	 
 	setegid(getgid());
 	setgid(getgid());
 
 #ifdef WITH_OPENSSL
  	OpenSSL_add_all_algorithms();
  #endif
  
	while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) {
 	while ((ch = getopt(ac, av, ""cDdksE:a:P:t:"")) != -1) {
  		switch (ch) {
  		case 'E':
  			fingerprint_hash = ssh_digest_alg_by_name(optarg);
 			if (fingerprint_hash == -1)
 				fatal(""Invalid hash algorithm \""%s\"""", optarg);
 			break;
 		case 'c':
 			if (s_flag)
 				usage();
 			c_flag++;
 			break;
  		case 'k':
  			k_flag++;
  			break;
 		case 'P':
 			if (pkcs11_whitelist != NULL)
 				fatal(""-P option already specified"");
 			pkcs11_whitelist = xstrdup(optarg);
 			break;
  		case 's':
  			if (c_flag)
  				usage();
 			s_flag++;
 			break;
 		case 'd':
 			if (d_flag || D_flag)
 				usage();
 			d_flag++;
 			break;
 		case 'D':
 			if (d_flag || D_flag)
 				usage();
 			D_flag++;
 			break;
 		case 'a':
 			agentsocket = optarg;
 			break;
 		case 't':
 			if ((lifetime = convtime(optarg)) == -1) {
 				fprintf(stderr, ""Invalid lifetime\n"");
 				usage();
 			}
 			break;
 		default:
 			usage();
 		}
 	}
 	ac -= optind;
 	av += optind;
 
  	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
  		usage();
  
 	if (pkcs11_whitelist == NULL)
 		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);
 
  	if (ac == 0 && !c_flag && !s_flag) {
  		shell = getenv(""SHELL"");
  		if (shell != NULL && (len = strlen(shell)) > 2 &&
 		    strncmp(shell + len - 3, ""csh"", 3) == 0)
 			c_flag = 1;
 	}
 	if (k_flag) {
 		const char *errstr = NULL;
 
 		pidstr = getenv(SSH_AGENTPID_ENV_NAME);
 		if (pidstr == NULL) {
 			fprintf(stderr, ""%s not set, cannot kill agent\n"",
 			    SSH_AGENTPID_ENV_NAME);
 			exit(1);
 		}
 		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
 		if (errstr) {
 			fprintf(stderr,
 			    ""%s=\""%s\"", which is not a good PID: %s\n"",
 			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
 			exit(1);
 		}
 		if (kill(pid, SIGTERM) == -1) {
 			perror(""kill"");
 			exit(1);
 		}
 		format = c_flag ? ""unsetenv %s;\n"" : ""unset %s;\n"";
 		printf(format, SSH_AUTHSOCKET_ENV_NAME);
 		printf(format, SSH_AGENTPID_ENV_NAME);
 		printf(""echo Agent pid %ld killed;\n"", (long)pid);
 		exit(0);
 	}
 	parent_pid = getpid();
 
 	if (agentsocket == NULL) {
 		 
 		mktemp_proto(socket_dir, sizeof(socket_dir));
 		if (mkdtemp(socket_dir) == NULL) {
 			perror(""mkdtemp: private socket dir"");
 			exit(1);
 		}
 		snprintf(socket_name, sizeof socket_name, ""%s/agent.%ld"", socket_dir,
 		    (long)parent_pid);
 	} else {
 		 
 		socket_dir[0] = '\0';
 		strlcpy(socket_name, agentsocket, sizeof socket_name);
 	}
 
 	 
 	prev_mask = umask(0177);
 	sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);
 	if (sock < 0) {
 		 
 		*socket_name = '\0';  
 		cleanup_exit(1);
 	}
 	umask(prev_mask);
 
 	 
 	if (D_flag || d_flag) {
 		log_init(__progname,
 		    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,
 		    SYSLOG_FACILITY_AUTH, 1);
 		format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
 		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
 		    SSH_AUTHSOCKET_ENV_NAME);
 		printf(""echo Agent pid %ld;\n"", (long)parent_pid);
 		fflush(stdout);
 		goto skip;
 	}
 	pid = fork();
 	if (pid == -1) {
 		perror(""fork"");
 		cleanup_exit(1);
 	}
 	if (pid != 0) {		 
 		close(sock);
 		snprintf(pidstrbuf, sizeof pidstrbuf, ""%ld"", (long)pid);
 		if (ac == 0) {
 			format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
 			printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
 			    SSH_AUTHSOCKET_ENV_NAME);
 			printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
 			    SSH_AGENTPID_ENV_NAME);
 			printf(""echo Agent pid %ld;\n"", (long)pid);
 			exit(0);
 		}
 		if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||
 		    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {
 			perror(""setenv"");
 			exit(1);
 		}
 		execvp(av[0], av);
 		perror(av[0]);
 		exit(1);
 	}
 	 
 	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);
 
 	if (setsid() == -1) {
 		error(""setsid: %s"", strerror(errno));
 		cleanup_exit(1);
 	}
 
 	(void)chdir(""/"");
 	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
 		 
 		(void)dup2(fd, STDIN_FILENO);
 		(void)dup2(fd, STDOUT_FILENO);
 		(void)dup2(fd, STDERR_FILENO);
 		if (fd > 2)
 			close(fd);
 	}
 
 	 
 	rlim.rlim_cur = rlim.rlim_max = 0;
 	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
 		error(""setrlimit RLIMIT_CORE: %s"", strerror(errno));
 		cleanup_exit(1);
 	}
 
 skip:
 
 	cleanup_pid = getpid();
 
 #ifdef ENABLE_PKCS11
 	pkcs11_init(0);
 #endif
 	new_socket(AUTH_SOCKET, sock);
 	if (ac > 0)
 		parent_alive_interval = 10;
 	idtab_init();
 	signal(SIGPIPE, SIG_IGN);
 	signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);
 	signal(SIGHUP, cleanup_handler);
  	signal(SIGTERM, cleanup_handler);
  	nalloc = 0;
  
	if (pledge(""stdio cpath unix id proc exec"", NULL) == -1)
 	if (pledge(""stdio rpath cpath unix id proc exec"", NULL) == -1)
  		fatal(""%s: pledge: %s"", __progname, strerror(errno));
  
  	while (1) {
 		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);
 		result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);
 		saved_errno = errno;
 		if (parent_alive_interval != 0)
 			check_parent_exists();
 		(void) reaper();	 
 		if (result < 0) {
 			if (saved_errno == EINTR)
 				continue;
 			fatal(""select: %s"", strerror(saved_errno));
 		} else if (result > 0)
 			after_select(readsetp, writesetp);
 	}
 	 
 }","[30, 45, 46, 47, 48, 49, 84, 85, 86, 227, 29, 226]",Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.
207334," xsltFreeTemplateHashes(xsltStylesheetPtr style) {
     if (style->templatesHash != NULL)
 	xmlHashFree((xmlHashTablePtr) style->templatesHash,
 		    (xmlHashDeallocator) xsltFreeCompMatchList);
     if (style->rootMatch != NULL)
         xsltFreeCompMatchList(style->rootMatch);
     if (style->keyMatch != NULL)
         xsltFreeCompMatchList(style->keyMatch);
     if (style->elemMatch != NULL)
         xsltFreeCompMatchList(style->elemMatch);
     if (style->attrMatch != NULL)
         xsltFreeCompMatchList(style->attrMatch);
     if (style->parentMatch != NULL)
         xsltFreeCompMatchList(style->parentMatch);
     if (style->textMatch != NULL)
         xsltFreeCompMatchList(style->textMatch);
     if (style->piMatch != NULL)
          xsltFreeCompMatchList(style->piMatch);
      if (style->commentMatch != NULL)
          xsltFreeCompMatchList(style->commentMatch);
     if (style->namedTemplates != NULL)
         xmlHashFree(style->namedTemplates, NULL);
  }","[21, 22]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
208250," status_t ACodec::setupAACCodec(
  bool encoder, int32_t numChannels, int32_t sampleRate,
  int32_t bitRate, int32_t aacProfile, bool isADTS, int32_t sbrMode,
  int32_t maxOutputChannelCount, const drcParams_t& drc,
  int32_t pcmLimiterEnable) {
  if (encoder && isADTS) {
  return -EINVAL;
  }
 
  status_t err = setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
             sampleRate,
             numChannels);
 
  if (err != OK) {
  return err;
  }
 
  if (encoder) {
         err = selectAudioPortFormat(kPortIndexOutput, OMX_AUDIO_CodingAAC);
 
  if (err != OK) {
  return err;
  }
 
         OMX_PARAM_PORTDEFINITIONTYPE def;
  InitOMXParams(&def);
         def.nPortIndex = kPortIndexOutput;
 
         err = mOMX->getParameter(
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
  if (err != OK) {
  return err;
  }
 
         def.format.audio.bFlagErrorConcealment = OMX_TRUE;
         def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;
 
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
  if (err != OK) {
  return err;
  }
 
         OMX_AUDIO_PARAM_AACPROFILETYPE profile;
  InitOMXParams(&profile);
         profile.nPortIndex = kPortIndexOutput;
 
         err = mOMX->getParameter(
                 mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));
 
  if (err != OK) {
  return err;
  }
 
         profile.nChannels = numChannels;
 
         profile.eChannelMode =
  (numChannels == 1)
  ? OMX_AUDIO_ChannelModeMono: OMX_AUDIO_ChannelModeStereo;
 
         profile.nSampleRate = sampleRate;
         profile.nBitRate = bitRate;
         profile.nAudioBandWidth = 0;
         profile.nFrameLength = 0;
         profile.nAACtools = OMX_AUDIO_AACToolAll;
         profile.nAACERtools = OMX_AUDIO_AACERNone;
         profile.eAACProfile = (OMX_AUDIO_AACPROFILETYPE) aacProfile;
         profile.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;
  switch (sbrMode) {
  case 0:
             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;
             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;
  break;
  case 1:
             profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;
             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;
  break;
  case 2:
             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;
             profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;
  break;
  case -1:
             profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;
             profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;
  break;
  default:
  return BAD_VALUE;
  }
 
 
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));
 
  if (err != OK) {
  return err;
  }
 
  return err;
  }
 
     OMX_AUDIO_PARAM_AACPROFILETYPE profile;
  InitOMXParams(&profile);
     profile.nPortIndex = kPortIndexInput;
 
     err = mOMX->getParameter(
             mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));
 
  if (err != OK) {
  return err;
  }
 
     profile.nChannels = numChannels;
     profile.nSampleRate = sampleRate;
 
     profile.eAACStreamFormat =
         isADTS
  ? OMX_AUDIO_AACStreamFormatMP4ADTS
 
              : OMX_AUDIO_AACStreamFormatMP4FF;
  
      OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE presentation;
     InitOMXParams(&presentation);
      presentation.nMaxOutputChannels = maxOutputChannelCount;
      presentation.nDrcCut = drc.drcCut;
      presentation.nDrcBoost = drc.drcBoost;
     presentation.nHeavyCompression = drc.heavyCompression;
     presentation.nTargetReferenceLevel = drc.targetRefLevel;
     presentation.nEncodedTargetLevel = drc.encodedTargetLevel;
     presentation.nPCMLimiterEnable = pcmLimiterEnable;
 
  status_t res = mOMX->setParameter(mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));
  if (res == OK) {
         mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAacPresentation,
  &presentation, sizeof(presentation));
  } else {
         ALOGW(""did not set AudioAndroidAacPresentation due to error %d when setting AudioAac"", res);
  }
  return res;
 }",[125],"mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
207644," image_transform_ini_end(PNG_CONST image_transform *this,
 image_transform_ini_end(const image_transform *this,
     transform_display *that)
  {
     UNUSED(this)
    UNUSED(that)
 
  }",[2],"Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
201082," lldp_private_8021_print(netdissect_options *ndo,
                         const u_char *tptr, u_int tlv_len)
 {
      int subtype, hexdump = FALSE;
      u_int sublen;
      u_int tval;
    uint8_t i;
     u_int i;
  
      if (tlv_len < 4) {
          return hexdump;
     }
     subtype = *(tptr+3);
 
     ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
            tok2str(lldp_8021_subtype_values, ""unknown"", subtype),
            subtype));
 
     switch (subtype) {
     case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:
         if (tlv_len < 6) {
             return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    port vlan id (PVID): %u"",
                EXTRACT_16BITS(tptr + 4)));
         break;
     case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:
         if (tlv_len < 7) {
             return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)"",
                EXTRACT_16BITS(tptr+5),
 	       bittok2str(lldp_8021_port_protocol_id_values, ""none"", *(tptr+4)),
 	       *(tptr + 4)));
         break;
     case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:
         if (tlv_len < 6) {
             return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    vlan id (VID): %u"", EXTRACT_16BITS(tptr + 4)));
         if (tlv_len < 7) {
             return hexdump;
         }
         sublen = *(tptr+6);
         if (tlv_len < 7+sublen) {
             return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    vlan name: ""));
         safeputs(ndo, tptr + 7, sublen);
         break;
     case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:
         if (tlv_len < 5) {
             return hexdump;
         }
         sublen = *(tptr+4);
         if (tlv_len < 5+sublen) {
             return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    protocol identity: ""));
         safeputs(ndo, tptr + 5, sublen);
         break;
     case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:
         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){
         	return hexdump;
         }
         tval=*(tptr+4);
         ND_PRINT((ndo, ""\n\t    Pre-Priority CNPV Indicator""));
         ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
         ND_PRINT((ndo, ""\n\t     Value    : ""));
         for(i=0;i<NO_OF_BITS;i++)
             ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
         tval=*(tptr+5);
         ND_PRINT((ndo, ""\n\t    Pre-Priority Ready Indicator""));
         ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
         ND_PRINT((ndo, ""\n\t     Value    : ""));
         for(i=0;i<NO_OF_BITS;i++)
             ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
         break;
 
     case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:
         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {
             return hexdump;
         }
         tval=*(tptr+4);
         ND_PRINT((ndo, ""\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d"",
         	tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));
 
          
         print_ets_priority_assignment_table(ndo, tptr + 5);
 
          
         print_tc_bandwidth_table(ndo, tptr + 9);
 
          
         print_tsa_assignment_table(ndo, tptr + 17);
 
         break;
 
     case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:
         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {
         	return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
          
         print_ets_priority_assignment_table(ndo, tptr + 5);
          
         print_tc_bandwidth_table(ndo, tptr + 9);
          
         print_tsa_assignment_table(ndo, tptr + 17);
         break;
 
     case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:
         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {
             return hexdump;
         }
         tval=*(tptr+4);
         ND_PRINT((ndo, ""\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d "",
         	tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));
         ND_PRINT((ndo, ""\n\t    PFC Enable""));
         tval=*(tptr+5);
         ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
         ND_PRINT((ndo, ""\n\t     Value    : ""));
         for(i=0;i<NO_OF_BITS;i++)
             ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
         break;
 
     case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:
         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {
             return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
         if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){
         	return hexdump;
         }
          
         sublen=tlv_len-5;
         if(sublen%3!=0){
         	return hexdump;
         }
         i=0;
          ND_PRINT((ndo, ""\n\t    Application Priority Table""));
          while(i<sublen) {
          	tval=*(tptr+i+5);
        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));
        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));
         	ND_PRINT((ndo, ""\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u"",
         		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),
         		 EXTRACT_16BITS(tptr + i + 5)));
          	i=i+3;
          }
          break;
     case LLDP_PRIVATE_8021_SUBTYPE_EVB:
         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){
         	return hexdump;
         }
         ND_PRINT((ndo, ""\n\t    EVB Bridge Status""));
         tval=*(tptr+4);
         ND_PRINT((ndo, ""\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d"",
         	tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));
         ND_PRINT((ndo, ""\n\t    EVB Station Status""));
         tval=*(tptr+5);
         ND_PRINT((ndo, ""\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d"",
         	tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));
         tval=*(tptr+6);
         ND_PRINT((ndo, ""\n\t    R: %d, RTE: %d, "",tval >> 5, tval & 0x1f));
         tval=*(tptr+7);
         ND_PRINT((ndo, ""EVB Mode: %s [%d]"",
         	tok2str(lldp_evb_mode_values, ""unknown"", tval >> 6), tval >> 6));
         ND_PRINT((ndo, ""\n\t    ROL: %d, RWD: %d, "", (tval >> 5) & 0x01, tval & 0x1f));
         tval=*(tptr+8);
         ND_PRINT((ndo, ""RES: %d, ROL: %d, RKA: %d"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));
         break;
 
     case LLDP_PRIVATE_8021_SUBTYPE_CDCP:
         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){
         	return hexdump;
         }
         tval=*(tptr+4);
         ND_PRINT((ndo, ""\n\t    Role: %d, RES: %d, Scomp: %d "",
         	tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));
         ND_PRINT((ndo, ""ChnCap: %d"", EXTRACT_16BITS(tptr + 6) & 0x0fff));
         sublen=tlv_len-8;
         if(sublen%3!=0) {
         	return hexdump;
         }
         i=0;
         while(i<sublen) {
         	tval=EXTRACT_24BITS(tptr+i+8);
         	ND_PRINT((ndo, ""\n\t    SCID: %d, SVID: %d"",
         		tval >> 12, tval & 0x000fff));
         	i=i+3;
         }
         break;
 
     default:
         hexdump = TRUE;
         break;
     }
 
     return hexdump;
 }","[8, 147, 148, 149, 7, 144, 145, 146]",The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().
207066," void PaymentRequest::Init(mojom::PaymentRequestClientPtr client,
                           std::vector<mojom::PaymentMethodDataPtr> method_data,
                            mojom::PaymentDetailsPtr details,
                            mojom::PaymentOptionsPtr options) {
    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (is_initialized_) {
     log_.Error(""Attempted initialization twice"");
     OnConnectionTerminated();
     return;
   }
 
   is_initialized_ = true;
    client_ = std::move(client);
  
    const GURL last_committed_url = delegate_->GetLastCommittedURL();
    if (!OriginSecurityChecker::IsOriginSecure(last_committed_url)) {
    LOG(ERROR) << ""Not in a secure origin"";
     log_.Error(""Not in a secure origin"");
      OnConnectionTerminated();
      return;
    }
 
   bool allowed_origin =
        OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) ||
        OriginSecurityChecker::IsOriginLocalhostOrFile(last_committed_url);
    if (!allowed_origin) {
    LOG(ERROR) << ""Only localhost, file:, and cryptographic scheme origins ""
                  ""allowed"";
     log_.Error(
         ""Only localhost, file:, and cryptographic scheme origins allowed"");
    }
  
    bool invalid_ssl =
        OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) &&
        !delegate_->IsSslCertificateValid();
  if (invalid_ssl)
    LOG(ERROR) << ""SSL certificate is not valid"";
   if (invalid_ssl) {
     log_.Error(""SSL certificate is not valid."");
   }
  
    if (!allowed_origin || invalid_ssl) {
      
     log_.Error(
         ""No UI will be shown. CanMakePayment will always return false. ""
         ""Show will be rejected with NotSupportedError."");
      return;
    }
  
    std::string error;
    if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {
    LOG(ERROR) << error;
     log_.Error(error);
      OnConnectionTerminated();
      return;
    }
  
    if (!details->total) {
    LOG(ERROR) << ""Missing total"";
     log_.Error(""Missing total"");
      OnConnectionTerminated();
      return;
    }
 
   spec_ = std::make_unique<PaymentRequestSpec>(
       std::move(options), std::move(details), std::move(method_data), this,
       delegate_->GetApplicationLocale());
   state_ = std::make_unique<PaymentRequestState>(
       web_contents_, top_level_origin_, frame_origin_, spec_.get(), this,
       delegate_->GetApplicationLocale(), delegate_->GetPersonalDataManager(),
       delegate_.get(), &journey_logger_);
 
   journey_logger_.SetRequestedInformation(
       spec_->request_shipping(), spec_->request_payer_email(),
       spec_->request_payer_phone(), spec_->request_payer_name());
 
   GURL google_pay_url(kGooglePayMethodName);
   GURL android_pay_url(kAndroidPayMethodName);
   auto non_google_it =
       std::find_if(spec_->url_payment_method_identifiers().begin(),
                    spec_->url_payment_method_identifiers().end(),
                    [google_pay_url, android_pay_url](const GURL& url) {
                      return url != google_pay_url && url != android_pay_url;
                    });
   journey_logger_.SetRequestedPaymentMethodTypes(
        !spec_->supported_card_networks().empty(),
        
       base::ContainsValue(spec_->url_payment_method_identifiers(),
                           google_pay_url) ||
           base::ContainsValue(spec_->url_payment_method_identifiers(),
                               android_pay_url),
        non_google_it !=
           spec_->url_payment_method_identifiers().end());
  }","[6, 7, 8, 9, 10, 11, 12, 13, 19, 30, 31, 39, 40, 41, 44, 45, 46, 47, 54, 61, 18, 28, 29, 37, 38, 53, 60]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
200907,"  static unsigned int seedsize(struct crypto_alg *alg)
  {
  	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
  
	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
 	return ralg->seedsize;
  }","[7, 5, 6]",The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).
200766," wiki_handle_http_request(HttpRequest *req)
 {
   HttpResponse *res      = http_response_new(req);
   char         *page     = http_request_get_path_info(req); 
   char         *command  = http_request_get_query_string(req); 
   char         *wikitext = """";
 
   util_dehttpize(page); 	 
 
   if (!strcmp(page, ""/""))
     {
       if (access(""WikiHome"", R_OK) != 0)
 	wiki_redirect(res, ""/WikiHome?create"");
       page = ""/WikiHome"";
     }
 
   if (!strcmp(page, ""/styles.css""))
     {
        
       http_response_set_content_type(res, ""text/css"");
       http_response_printf(res, ""%s"", CssData);
       http_response_send(res);
       exit(0);
     }
 
   if (!strcmp(page, ""/favicon.ico""))
     {
        
       http_response_set_content_type(res, ""image/ico"");
       http_response_set_data(res, FaviconData, FaviconDataLen);
       http_response_send(res);
       exit(0);
     }
 
 
   page = page + 1; 		 
 
   if (!strncmp(page, ""api/"", 4))
     {
       char *p;
 
       page += 4; 
       for (p=page; *p != '\0'; p++)
 	if (*p=='?') { *p ='\0'; break; }
       
       wiki_handle_rest_call(req, res, page); 
       exit(0);
     }
 
     
  if (strchr(page, '/'))
   if (!page_name_is_good(page))
      {
        http_response_set_status(res, 404, ""Not Found"");
        http_response_printf(res, ""<html><body>404 Not Found</body></html>\n"");
       http_response_send(res);
       exit(0);
     }
 
   if (!strcmp(page, ""Changes""))
     {
       wiki_show_changes_page(res);
     }
   else if (!strcmp(page, ""ChangesRss""))
     {
       wiki_show_changes_page_rss(res);
     }
   else if (!strcmp(page, ""Search""))
     {
       wiki_show_search_results_page(res, http_request_param_get(req, ""expr""));
     }
   else if (!strcmp(page, ""Create""))
     {
       if ( (wikitext = http_request_param_get(req, ""title"")) != NULL)
 	{
 	   
 	  wiki_redirect(res, http_request_param_get(req, ""title""));
 	}
       else
 	{
 	    
 	  wiki_show_create_page(res);
 	}
     }
   else
     {
        
       if ( (wikitext = http_request_param_get(req, ""wikitext"")) != NULL)
 	{
 	  file_write(page, wikitext);	      
 	}
 
       if (access(page, R_OK) == 0) 	 
 	{
 	  wikitext = file_read(page);
 	  
 	  if (!strcmp(command, ""edit""))
 	    {
 	       
 	      wiki_show_edit_page(res, wikitext, page);
 	    }
 	  else
 	    {
 	      wiki_show_page(res, wikitext, page);
 	    }
 	}
       else
 	{
 	  if (!strcmp(command, ""create""))
 	    {
 	      wiki_show_edit_page(res, NULL, page);
 	    }
 	  else
 	    {
 	      char buf[1024];
 	      snprintf(buf, 1024, ""%s?create"", page);
 	      wiki_redirect(res, buf);
 	    }
 	}
     }
 
 }","[52, 51]",Directory traversal vulnerability in wiki.c in didiwiki allows remote attackers to read arbitrary files via the page parameter to api/page/get.
203959,"   static void RegisterPropertiesHandler(
      void* object, const ImePropertyList& prop_list) {
    
   virtual void OnRegisterImeProperties(
       const input_method::ImePropertyList& prop_list) {
      if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
        LOG(ERROR) << ""Not on UI thread"";
        return;
      }
  
    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->RegisterProperties(prop_list);
     RegisterProperties(prop_list);
    }","[3, 4, 5, 14, 2, 11, 12, 13]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
208244," OMX_ERRORTYPE SimpleSoftOMXComponent::internalGetParameter(
         OMX_INDEXTYPE index, OMX_PTR params) {
  switch (index) {
  case OMX_IndexParamPortDefinition:
  {
 
              OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                  (OMX_PARAM_PORTDEFINITIONTYPE *)params;
  
             if (!isValidOMXParam(defParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (defParams->nPortIndex >= mPorts.size()
                      || defParams->nSize
                              != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
  return OMX_ErrorUndefined;
  }
 
  const PortInfo *port =
  &mPorts.itemAt(defParams->nPortIndex);
 
             memcpy(defParams, &port->mDef, sizeof(port->mDef));
 
  return OMX_ErrorNone;
  }
 
  default:
  return OMX_ErrorUnsupportedIndex;
  }
 }","[10, 11, 12, 13]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
5976,"struct resource_pool *dcn10_create_resource_pool(
const struct dc_init_data *init_data,
struct dc *dc)
{
struct dcn10_resource_pool *pool =
kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);

if (!pool)
return NULL;

if (construct(init_data->num_virtual_links, dc, pool))
return &pool->base;

BREAK_TO_DEBUGGER();
return NULL;
}",[14],"Memory leaks in *create_resource_pool() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption). This affects the dce120_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, the dce100_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, and the dce112_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, aka CID-104c307147ad."
198434," int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
                      int len, int peek)
 {
     int al, i, j, ret;
     unsigned int n;
     SSL3_RECORD *rr;
     void (*cb) (const SSL *ssl, int type2, int val) = NULL;
 
     if (!SSL3_BUFFER_is_initialised(&s->rlayer.rbuf)) {
          
         if (!ssl3_setup_buffers(s))
             return (-1);
     }
 
     if ((type && (type != SSL3_RT_APPLICATION_DATA) &&
          (type != SSL3_RT_HANDSHAKE)) ||
         (peek && (type != SSL3_RT_APPLICATION_DATA))) {
         SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
         return -1;
     }
 
      
     if ((ret = have_handshake_fragment(s, type, buf, len)))
         return ret;
 
      
 
 #ifndef OPENSSL_NO_SCTP
      
     if ((!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) ||
         (BIO_dgram_is_sctp(SSL_get_rbio(s))
          && ossl_statem_in_sctp_read_sock(s)
          && s->s3->in_read_app_data != 2))
 #else
     if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s))
 #endif
     {
          
         i = s->handshake_func(s);
         if (i < 0)
             return (i);
         if (i == 0) {
             SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
             return (-1);
         }
     }
 
  start:
     s->rwstate = SSL_NOTHING;
 
      
     rr = s->rlayer.rrec;
 
      
     if (SSL_is_init_finished(s) && SSL3_RECORD_get_length(rr) == 0) {
         pitem *item;
         item = pqueue_pop(s->rlayer.d->buffered_app_data.q);
         if (item) {
 #ifndef OPENSSL_NO_SCTP
              
             if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {
                 DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *)item->data;
                 BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO,
                          sizeof(rdata->recordinfo), &rdata->recordinfo);
             }
 #endif
 
             dtls1_copy_record(s, item);
 
             OPENSSL_free(item->data);
             pitem_free(item);
         }
     }
 
      
     if (dtls1_handle_timeout(s) > 0)
         goto start;
 
      
     if ((SSL3_RECORD_get_length(rr) == 0)
         || (s->rlayer.rstate == SSL_ST_READ_BODY)) {
         ret = dtls1_get_record(s);
         if (ret <= 0) {
             ret = dtls1_read_failed(s, ret);
              
             if (ret <= 0)
                 return (ret);
             else
                 goto start;
          }
      }
  
      
     if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT
             && SSL3_RECORD_get_length(rr) != 0)
         s->rlayer.alert_count = 0;
 
       
  
      if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
                                 SSL3_RECORD_get_seq_num(rr)) < 0) {
             SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
             return -1;
         }
         SSL3_RECORD_set_length(rr, 0);
         goto start;
     }","[93, 94, 95, 96, 97]","A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients."
202687," static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
 			     size_t outlen, int invert)
  {
  	const u8 *in = inbuf;
  	u8 *out = (u8 *) outbuf;
	int zero_bits = *in & 0x07;
	size_t octets_left = inlen - 1;
  	int i, count = 0;
 	int zero_bits;
 	size_t octets_left;
  
	memset(outbuf, 0, outlen);
	in++;
  	if (outlen < octets_left)
  		return SC_ERROR_BUFFER_TOO_SMALL;
  	if (inlen < 1)
  		return SC_ERROR_INVALID_ASN1_OBJECT;
 
 	zero_bits = *in & 0x07;
 	octets_left = inlen - 1;
 	in++;
 	memset(outbuf, 0, outlen);
 
  	while (octets_left) {
  		 
  		 
 		 
 		int bits_to_go;
 
 		*out = 0;
 		if (octets_left == 1)
 			bits_to_go = 8 - zero_bits;
 		else
 			bits_to_go = 8;
 		if (invert)
 			for (i = 0; i < bits_to_go; i++) {
 				*out |= ((*in >> (7 - i)) & 1) << i;
 			}
 		else {
 			*out = *in;
 		}
 		out++;
 		in++;
 		octets_left--;
 		count++;
 	}
 	return (count * 8) - zero_bits;
 }","[9, 10, 18, 19, 20, 21, 22, 23, 6, 7, 12, 13]",OpenSC before 0.20.0-rc1 has an out-of-bounds access of an ASN.1 Bitstring in decode_bit_string in libopensc/asn1.c.
9774,"static int install_relocation_handler(int num_cpus, size_t save_state_size)
{
struct smm_loader_params smm_params = {
.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,
.num_concurrent_stacks = num_cpus,
.per_cpu_save_state_size = save_state_size,
.num_concurrent_save_states = 1,
.handler = smm_do_relocation,
};


if (mp_state.ops.adjust_smm_params != NULL)
mp_state.ops.adjust_smm_params(&smm_params, 0);

if (smm_setup_relocation_handler(&smm_params))
return -1;

adjust_smm_apic_id_map(&smm_params);

return 0;
}","[3, 5, 15]","An issue was discovered in coreboot 4.13 through 4.16. On APs, arbitrary code execution in SMM may occur."
206907," void NavigationObserver::PromptToEnableExtensionIfNecessary(
     NavigationController* nav_controller) {
   if (!in_progress_prompt_extension_id_.empty())
     return;
 
   NavigationEntry* nav_entry = nav_controller->GetVisibleEntry();
    if (!nav_entry)
      return;
  
  const GURL& url = (nav_entry->GetPageType() == content::PAGE_TYPE_ERROR &&
                     nav_entry->GetURL() == url::kAboutBlankURL &&
                     nav_entry->GetVirtualURL().SchemeIs(kExtensionScheme))
                        ? nav_entry->GetVirtualURL()
                        : nav_entry->GetURL();
   const GURL& url = nav_entry->GetURL();
  
   if (!url.SchemeIs(kExtensionScheme))
     return;
 
   const Extension* extension = ExtensionRegistry::Get(profile_)
                                    ->disabled_extensions()
                                    .GetExtensionOrAppByURL(url);
   if (!extension)
     return;
 
   if (!prompted_extensions_.insert(extension->id()).second &&
       !g_repeat_prompting) {
     return;
   }
 
   ExtensionPrefs* extension_prefs = ExtensionPrefs::Get(profile_);
   if (extension_prefs->DidExtensionEscalatePermissions(extension->id())) {
     in_progress_prompt_extension_id_ = extension->id();
     in_progress_prompt_navigation_controller_ = nav_controller;
 
     extension_install_prompt_.reset(
         new ExtensionInstallPrompt(nav_controller->GetWebContents()));
     ExtensionInstallPrompt::PromptType type =
         ExtensionInstallPrompt::GetReEnablePromptTypeForExtension(profile_,
                                                                   extension);
     extension_install_prompt_->ShowDialog(
         base::Bind(&NavigationObserver::OnInstallPromptDone,
                    weak_factory_.GetWeakPtr()),
         extension, nullptr,
         base::MakeUnique<ExtensionInstallPrompt::Prompt>(type),
         ExtensionInstallPrompt::GetDefaultShowDialogCallback());
   }
 }","[15, 10, 11, 12, 13, 14]",Incorrect handling of back navigations in error pages in Navigation in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
204808," v8::Handle<v8::Value> V8DirectoryEntry::getDirectoryCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.DirectoryEntry.getDirectory"");
      DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());
  
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
  
      STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);
      if (args.Length() <= 1) {
         imp->getDirectory(path);
         return v8::Handle<v8::Value>();
     }
     RefPtr<WebKitFlags> flags;
     if (!isUndefinedOrNull(args[1]) && args[1]->IsObject()) {
         EXCEPTION_BLOCK(v8::Handle<v8::Object>, object, v8::Handle<v8::Object>::Cast(args[1]));
         flags = WebKitFlags::create();
         v8::Local<v8::Value> v8Create = object->Get(v8::String::New(""create""));
         if (!v8Create.IsEmpty() && !isUndefinedOrNull(v8Create)) {
             EXCEPTION_BLOCK(bool, isCreate, v8Create->BooleanValue());
             flags->setCreate(isCreate);
         }
         v8::Local<v8::Value> v8Exclusive = object->Get(v8::String::New(""exclusive""));
         if (!v8Exclusive.IsEmpty() && !isUndefinedOrNull(v8Exclusive)) {
             EXCEPTION_BLOCK(bool, isExclusive, v8Exclusive->BooleanValue());
             flags->setExclusive(isExclusive);
         }
     }
     RefPtr<EntryCallback> successCallback;
     if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {
         if (!args[2]->IsObject())
             return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
         successCallback = V8EntryCallback::create(args[2], getScriptExecutionContext());
     }
     RefPtr<ErrorCallback> errorCallback;
     if (args.Length() > 3 && !args[3]->IsNull() && !args[3]->IsUndefined()) {
         if (!args[3]->IsObject())
             return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
         errorCallback = V8ErrorCallback::create(args[3], getScriptExecutionContext());
     }
     imp->getDirectory(path, flags, successCallback, errorCallback);
     return v8::Handle<v8::Value>();
 }","[8, 7]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
8677,"static int insert_pin(
sc_pkcs15_card_t *p15card,
const char       *path,
unsigned char     id,
unsigned char     auth_id,
unsigned char     pin_reference,
int               min_length,
const char       *label,
int               pin_flags
){
sc_card_t *card=p15card->card;
sc_context_t *ctx=p15card->card->ctx;
sc_file_t *f = NULL;
struct sc_pkcs15_auth_info pin_info;
struct sc_pkcs15_object pin_obj;
int r;

memset(&pin_info, 0, sizeof(pin_info));
pin_info.auth_id.len      = 1;
pin_info.auth_id.value[0] = id;
pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
pin_info.attrs.pin.reference        = pin_reference;
pin_info.attrs.pin.flags            = pin_flags;
pin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
pin_info.attrs.pin.min_length       = min_length;
pin_info.attrs.pin.stored_length    = 16;
pin_info.attrs.pin.max_length       = 16;
pin_info.attrs.pin.pad_char         = '\0';
pin_info.logged_in = SC_PIN_STATE_UNKNOWN;
sc_format_path(path, &pin_info.path);

memset(&pin_obj, 0, sizeof(pin_obj));
strlcpy(pin_obj.label, label, sizeof(pin_obj.label));
pin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;
pin_obj.auth_id.len      = auth_id ? 0 : 1;
pin_obj.auth_id.value[0] = auth_id;

if(card->type == SC_CARD_TYPE_TCOS_V3) {
unsigned char buf[256];
int i, rec_no=0;
if (pin_info.path.len >= 2) {
pin_info.path.len -= 2;
}
sc_append_file_id(&pin_info.path, 0x5049);
if (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) {
sc_log(ctx,
""Select(%s) failed\n"",
sc_print_path(&pin_info.path));
return 1;
}
sc_log(ctx,
""Searching for PIN-Ref %02X\n"", pin_reference);
while ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {
int found = 0, fbz = -1;
if (buf[0] != 0xA0)
continue;
for (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {
if (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {
++found;
}
if (buf[i] == 0x90) {
fbz = buf[i + 1 + buf[i + 1]];
}
}
if (found) {
pin_info.tries_left = fbz;
break;
}
}
if (r <= 0) {
sc_log(ctx, ""No EF_PWDD-Record found\n"");
return 1;
}
} else {
if (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS
|| !f->prop_attr || f->prop_attr_len < 4){
sc_log(ctx, ""Select(%s) failed\n"", path);
sc_file_free(f);
return 1;
}
pin_info.tries_left = f->prop_attr[3];
sc_file_free(f);
}

r=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
if(r!=SC_SUCCESS){
sc_log(ctx,  ""sc_pkcs15emu_add_pin_obj(%s) failed\n"", path);
return 4;
}
sc_log(ctx,  ""%s: OK, FBZ=%d\n"", path, pin_info.tries_left);
return 0;
}","[55, 57, 61]",A use after return issue was found in Opensc before version 0.22.0 in insert_pin function that could potentially crash programs using the library.
199679," static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,
 			   struct msghdr *msg, size_t len,
 			   int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct scm_cookie scm;
 	struct sock *sk = sock->sk;
 	struct netlink_sock *nlk = nlk_sk(sk);
 	int noblock = flags&MSG_DONTWAIT;
 	size_t copied;
 	struct sk_buff *skb, *data_skb;
 	int err, ret;
 
 	if (flags&MSG_OOB)
 		return -EOPNOTSUPP;
 
 	copied = 0;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (skb == NULL)
 		goto out;
 
 	data_skb = skb;
 
 #ifdef CONFIG_COMPAT_NETLINK_MESSAGES
 	if (unlikely(skb_shinfo(skb)->frag_list)) {
 		 
 		if (flags & MSG_CMSG_COMPAT)
 			data_skb = skb_shinfo(skb)->frag_list;
  	}
  #endif
  
	msg->msg_namelen = 0;
  	copied = data_skb->len;
  	if (len < copied) {
  		msg->msg_flags |= MSG_TRUNC;
 		copied = len;
 	}
 
 	skb_reset_transport_header(data_skb);
 	err = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);
 
 	if (msg->msg_name) {
 		struct sockaddr_nl *addr = (struct sockaddr_nl *)msg->msg_name;
 		addr->nl_family = AF_NETLINK;
 		addr->nl_pad    = 0;
 		addr->nl_pid	= NETLINK_CB(skb).portid;
 		addr->nl_groups	= netlink_group_mask(NETLINK_CB(skb).dst_group);
 		msg->msg_namelen = sizeof(*addr);
 	}
 
 	if (nlk->flags & NETLINK_RECV_PKTINFO)
 		netlink_cmsg_recv_pktinfo(msg, skb);
 
 	if (NULL == siocb->scm) {
 		memset(&scm, 0, sizeof(scm));
 		siocb->scm = &scm;
 	}
 	siocb->scm->creds = *NETLINK_CREDS(skb);
 	if (flags & MSG_TRUNC)
 		copied = data_skb->len;
 
 	skb_free_datagram(sk, skb);
 
 	if (nlk->cb_running &&
 	    atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf / 2) {
 		ret = netlink_dump(sk);
 		if (ret) {
 			sk->sk_err = ret;
 			sk->sk_error_report(sk);
 		}
 	}
 
 	scm_recv(sock, msg, siocb->scm, flags);
 out:
 	netlink_rcv_wake(sk);
 	return err ? : copied;
 }",[33],"The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
202700," static int hci_uart_set_proto(struct hci_uart *hu, int id)
 {
 	const struct hci_uart_proto *p;
 	int err;
 
 	p = hci_uart_get_proto(id);
 	if (!p)
  		return -EPROTONOSUPPORT;
  
  	hu->proto = p;
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
  
  	err = hci_uart_register_dev(hu);
  	if (err) {
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
  		return err;
  	}
  
 	set_bit(HCI_UART_PROTO_READY, &hu->flags);
  	return 0;
  }","[19, 11, 15]",An issue was discovered in the Linux kernel before 5.0.5. There is a use-after-free issue when hci_uart_register_dev() fails in hci_uart_set_proto() in drivers/bluetooth/hci_ldisc.c.
202588," bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)
 static bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)
  {
  	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
  	struct extent_tree *et;
 	struct extent_node *en;
 	struct extent_info ei;
 
 	if (!f2fs_may_extent_tree(inode)) {
 		 
 		if (i_ext && i_ext->len) {
 			i_ext->len = 0;
 			return true;
 		}
 		return false;
 	}
 
 	et = __grab_extent_tree(inode);
 
 	if (!i_ext || !i_ext->len)
 		return false;
 
 	get_extent_info(&ei, i_ext);
 
 	write_lock(&et->lock);
 	if (atomic_read(&et->node_cnt))
 		goto out;
 
 	en = __init_extent_tree(sbi, et, &ei);
 	if (en) {
 		spin_lock(&sbi->extent_lock);
 		list_add_tail(&en->list, &sbi->extent_list);
 		spin_unlock(&sbi->extent_lock);
 	}
 out:
 	write_unlock(&et->lock);
  	return false;
  }",[2],"fs/f2fs/extent_cache.c in the Linux kernel before 4.13 mishandles extent trees, which allows local users to cause a denial of service (BUG) via an application with multiple threads."
208112," WORD32 ixheaacd_complex_anal_filt(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer) {
   WORD32 idx;
   WORD32 anal_size = 2 * ptr_hbe_txposer->synth_size;
   WORD32 N = (10 * anal_size);
 
  for (idx = 0; idx < (ptr_hbe_txposer->no_bins >> 1); idx++) {
     WORD32 i, j, k, l;
     FLOAT32 window_output[640];
     FLOAT32 u[128], u_in[256], u_out[256];
     FLOAT32 accu_r, accu_i;
  const FLOAT32 *inp_signal;
     FLOAT32 *anal_buf;
 
     FLOAT32 *analy_cos_sin_tab = ptr_hbe_txposer->analy_cos_sin_tab;
  const FLOAT32 *interp_window_coeff = ptr_hbe_txposer->analy_wind_coeff;
     FLOAT32 *x = ptr_hbe_txposer->analy_buf;
 
     memset(ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1], 0,
            TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof(FLOAT32));
 
     inp_signal = ptr_hbe_txposer->ptr_input_buf +
                  idx * 2 * ptr_hbe_txposer->synth_size + 1;
     anal_buf = &ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1]
  [4 * ptr_hbe_txposer->k_start];
 
  for (i = N - 1; i >= anal_size; i--) {
       x[i] = x[i - anal_size];
  }
 
  for (i = anal_size - 1; i >= 0; i--) {
       x[i] = inp_signal[anal_size - 1 - i];
  }
 
  for (i = 0; i < N; i++) {
       window_output[i] = x[i] * interp_window_coeff[i];
  }
 
  for (i = 0; i < 2 * anal_size; i++) {
       accu_r = 0.0;
  for (j = 0; j < 5; j++) {
         accu_r = accu_r + window_output[i + j * 2 * anal_size];
  }
       u[i] = accu_r;
  }
 
  if (anal_size == 40) {
  for (i = 1; i < anal_size; i++) {
         FLOAT32 temp1 = u[i] + u[2 * anal_size - i];
         FLOAT32 temp2 = u[i] - u[2 * anal_size - i];
         u[i] = temp1;
         u[2 * anal_size - i] = temp2;
  }
 
  for (k = 0; k < anal_size; k++) {
         accu_r = u[anal_size];
  if (k & 1)
           accu_i = u[0];
  else
           accu_i = -u[0];
  for (l = 1; l < anal_size; l++) {
           accu_r = accu_r + u[0 + l] * analy_cos_sin_tab[2 * l + 0];
           accu_i = accu_i + u[2 * anal_size - l] * analy_cos_sin_tab[2 * l + 1];
  }
         analy_cos_sin_tab += (2 * anal_size);
  *anal_buf++ = (FLOAT32)accu_r;
  *anal_buf++ = (FLOAT32)accu_i;
  }
  } else {
       FLOAT32 *ptr_u = u_in;
       FLOAT32 *ptr_v = u_out;
  for (k = 0; k < anal_size * 2; k++) {
 
          *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);
          *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);
        }
      if (ixheaacd_cmplx_anal_fft != NULL)
        (*ixheaacd_cmplx_anal_fft)(u_in, u_out, anal_size * 2);
       if (ptr_hbe_txposer->ixheaacd_cmplx_anal_fft != NULL)
         (*(ptr_hbe_txposer->ixheaacd_cmplx_anal_fft))(u_in, u_out,
                                                       anal_size * 2);
        else
          return -1;
  
  for (k = 0; k < anal_size / 2; k++) {
  *(anal_buf + 1) = -*ptr_v++;
  *anal_buf = *ptr_v++;
 
         anal_buf += 2;
 
  *(anal_buf + 1) = *ptr_v++;
  *anal_buf = -*ptr_v++;
 
         anal_buf += 2;
  }
  }
  }
  return 0;
 }","[78, 79, 80, 76, 77]",In ixheaacd_real_synth_fft_p3 of ixheaacd_esbr_fft.c there is a possible out of bounds write due to a missing bounds check. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-9.0 Android ID: A-110769924
197802,"  static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)
  {
 	 
 	if (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))
 		return;
 
  	ct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);
  	ct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);
  	ct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);
 	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
 		      sizeof(struct nfct_attr_grp_port));
 }","[3, 4, 5, 6]","conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet."
205483," ExtensionFunction::ResponseAction UsbFindDevicesFunction::Run() {
   scoped_ptr<extensions::core_api::usb::FindDevices::Params> parameters =
       FindDevices::Params::Create(*args_);
   EXTENSION_FUNCTION_VALIDATE(parameters.get());
  
    vendor_id_ = parameters->options.vendor_id;
    product_id_ = parameters->options.product_id;
  interface_id_ = parameters->options.interface_id.get()
                      ? *parameters->options.interface_id.get()
                      : UsbDevicePermissionData::ANY_INTERFACE;
  UsbDevicePermission::CheckParam param(vendor_id_, product_id_, interface_id_);
   int interface_id = parameters->options.interface_id.get()
                          ? *parameters->options.interface_id.get()
                          : UsbDevicePermissionData::ANY_INTERFACE;
   UsbDevicePermission::CheckParam param(vendor_id_, product_id_, interface_id);
    if (!extension()->permissions_data()->CheckAPIPermissionWithParam(
            APIPermission::kUsbDevice, &param)) {
      return RespondNow(Error(kErrorPermissionDenied));
   }
 
   UsbService* service = device::DeviceClient::Get()->GetUsbService();
   if (!service) {
     return RespondNow(Error(kErrorInitService));
   }
 
   service->GetDevices(
       base::Bind(&UsbFindDevicesFunction::OnGetDevicesComplete, this));
   return RespondLater();
 }","[12, 13, 14, 15, 8, 9, 10, 11]",Use-after-free vulnerability in the WebSocketDispatcherHost::SendOrDrop function in content/browser/renderer_host/websocket_dispatcher_host.cc in the Web Sockets implementation in Google Chrome before 33.0.1750.149 might allow remote attackers to bypass the sandbox protection mechanism by leveraging an incorrect deletion in a certain failure case.
198460," polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,
                                                           PolkitSubject                  *caller,
                                                           PolkitSubject                  *subject,
                                                           const gchar                    *action_id,
                                                           PolkitDetails                  *details,
                                                           PolkitCheckAuthorizationFlags   flags,
                                                           GCancellable                   *cancellable,
                                                           GAsyncReadyCallback             callback,
                                                           gpointer                        user_data)
 {
   PolkitBackendInteractiveAuthority *interactive_authority;
   PolkitBackendInteractiveAuthorityPrivate *priv;
   gchar *caller_str;
    gchar *subject_str;
    PolkitIdentity *user_of_caller;
    PolkitIdentity *user_of_subject;
   gboolean user_of_subject_matches;
    gchar *user_of_caller_str;
    gchar *user_of_subject_str;
    PolkitAuthorizationResult *result;
   GError *error;
   GSimpleAsyncResult *simple;
   gboolean has_details;
   gchar **detail_keys;
 
   interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);
   priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);
 
   error = NULL;
   caller_str = NULL;
   subject_str = NULL;
   user_of_caller = NULL;
   user_of_subject = NULL;
   user_of_caller_str = NULL;
   user_of_subject_str = NULL;
   result = NULL;
 
   simple = g_simple_async_result_new (G_OBJECT (authority),
                                       callback,
                                       user_data,
                                       polkit_backend_interactive_authority_check_authorization);
 
    
   if (caller == NULL)
     {
        
       GDBusConnection *system_bus;
       system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
       caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));
       g_object_unref (system_bus);
     }
 
   caller_str = polkit_subject_to_string (caller);
   subject_str = polkit_subject_to_string (subject);
 
   g_debug (""%s is inquiring whether %s is authorized for %s"",
            caller_str,
            subject_str,
            action_id);
             action_id);
  
    user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                        caller,
                                                                         caller, NULL,
                                                                          &error);
    if (error != NULL)
      {
       g_simple_async_result_complete (simple);
       g_object_unref (simple);
       g_error_free (error);
       goto out;
     }
 
   user_of_caller_str = polkit_identity_to_string (user_of_caller);
   g_debug ("" user of caller is %s"", user_of_caller_str);
    g_debug ("" user of caller is %s"", user_of_caller_str);
  
    user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                         subject,
                                                                          subject, &user_of_subject_matches,
                                                                           &error);
    if (error != NULL)
      {
       g_simple_async_result_complete (simple);
       g_object_unref (simple);
       g_error_free (error);
       goto out;
     }
 
   user_of_subject_str = polkit_identity_to_string (user_of_subject);
   g_debug ("" user of subject is %s"", user_of_subject_str);
 
   has_details = FALSE;
   if (details != NULL)
     {
       detail_keys = polkit_details_get_keys (details);
       if (detail_keys != NULL)
         {
           if (g_strv_length (detail_keys) > 0)
             has_details = TRUE;
           g_strfreev (detail_keys);
         }
     }
 
    
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
   if (!user_of_subject_matches
       || !polkit_identity_equal (user_of_caller, user_of_subject)
       || has_details)
      {
        if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))
          {
                                                ""pass details"");
             }
           else
             {
               g_simple_async_result_set_error (simple,
                                                POLKIT_ERROR,
                                                POLKIT_ERROR_NOT_AUTHORIZED,
                                                ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for ""
                                                ""subjects belonging to other identities"");
             }
           g_simple_async_result_complete (simple);
           g_object_unref (simple);
           goto out;
         }
     }","[17, 64, 80, 107, 108, 109, 63, 79, 106]",A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.
203006," ospf6_print_lshdr(netdissect_options *ndo,
                   register const struct lsa6_hdr *lshp, const u_char *dataend)
  {
  	if ((const u_char *)(lshp + 1) > dataend)
  		goto trunc;
	ND_TCHECK(lshp->ls_type);
	ND_TCHECK(lshp->ls_seq);
 	ND_TCHECK(lshp->ls_length);	 
  
  	ND_PRINT((ndo, ""\n\t  Advertising Router %s, seq 0x%08x, age %us, length %u"",
                 ipaddr_string(ndo, &lshp->ls_router),
                EXTRACT_32BITS(&lshp->ls_seq),
                EXTRACT_16BITS(&lshp->ls_age),
                EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));
 
 	ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);
 
 	return (0);
 trunc:
 	return (1);
 }","[8, 6, 7]",The OSPFv3 parser in tcpdump before 4.9.3 has a buffer over-read in print-ospf6.c:ospf6_print_lshdr().
203375," static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
   ExceptionInfo *exception)
 {
   char
     buffer[MagickPathExtent],
     format,
     magick[MagickPathExtent];
 
   const char
     *value;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     scene;
 
   Quantum
     index;
 
   QuantumAny
     pixel;
 
   QuantumInfo
     *quantum_info;
 
   QuantumType
     quantum_type;
 
   register unsigned char
     *q;
 
   size_t
     extent,
     imageListLength,
     packet_size;
 
   ssize_t
     count,
     y;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(status);
   scene=0;
   imageListLength=GetImageListLength(image);
   do
   {
     QuantumAny
       max_value;
 
      
     packet_size=3;
     quantum_type=RGBQuantum;
     (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);
     max_value=GetQuantumRange(image->depth);
     switch (magick[1])
     {
       case 'A':
       case 'a':
       {
         format='7';
         break;
       }
       case 'B':
       case 'b':
       {
         format='4';
         if (image_info->compression == NoCompression)
           format='1';
         break;
       }
       case 'F':
       case 'f':
       {
         format='F';
         if (SetImageGray(image,exception) != MagickFalse)
           format='f';
         break;
       }
       case 'G':
       case 'g':
       {
         format='5';
         if (image_info->compression == NoCompression)
           format='2';
         break;
       }
       case 'N':
       case 'n':
       {
         if ((image_info->type != TrueColorType) &&
             (SetImageGray(image,exception) != MagickFalse))
           {
             format='5';
             if (image_info->compression == NoCompression)
               format='2';
             if (SetImageMonochrome(image,exception) != MagickFalse)
               {
                 format='4';
                 if (image_info->compression == NoCompression)
                   format='1';
               }
             break;
           }
       }
       default:
       {
         format='6';
         if (image_info->compression == NoCompression)
           format='3';
         break;
       }
     }
     (void) FormatLocaleString(buffer,MagickPathExtent,""P%c\n"",format);
     (void) WriteBlobString(image,buffer);
     value=GetImageProperty(image,""comment"",exception);
     if (value != (const char *) NULL)
       {
         register const char
           *p;
 
          
         (void) WriteBlobByte(image,'#');
         for (p=value; *p != '\0'; p++)
         {
           (void) WriteBlobByte(image,(unsigned char) *p);
           if ((*p == '\n') || (*p == '\r'))
             (void) WriteBlobByte(image,'#');
         }
         (void) WriteBlobByte(image,'\n');
       }
     if (format != '7')
       {
         (void) FormatLocaleString(buffer,MagickPathExtent,""%.20g %.20g\n"",
           (double) image->columns,(double) image->rows);
         (void) WriteBlobString(image,buffer);
       }
     else
       {
         char
           type[MagickPathExtent];
 
          
         (void) FormatLocaleString(buffer,MagickPathExtent,
           ""WIDTH %.20g\nHEIGHT %.20g\n"",(double) image->columns,(double)
           image->rows);
         (void) WriteBlobString(image,buffer);
         quantum_type=GetQuantumType(image,exception);
         switch (quantum_type)
         {
           case CMYKQuantum:
           case CMYKAQuantum:
           {
             packet_size=4;
             (void) CopyMagickString(type,""CMYK"",MagickPathExtent);
             break;
           }
           case GrayQuantum:
           case GrayAlphaQuantum:
           {
             packet_size=1;
             (void) CopyMagickString(type,""GRAYSCALE"",MagickPathExtent);
             if (IdentifyImageMonochrome(image,exception) != MagickFalse)
               (void) CopyMagickString(type,""BLACKANDWHITE"",MagickPathExtent);
             break;
           }
           default:
           {
             quantum_type=RGBQuantum;
             if (image->alpha_trait != UndefinedPixelTrait)
               quantum_type=RGBAQuantum;
             packet_size=3;
             (void) CopyMagickString(type,""RGB"",MagickPathExtent);
             break;
           }
         }
         if (image->alpha_trait != UndefinedPixelTrait)
           {
             packet_size++;
             (void) ConcatenateMagickString(type,""_ALPHA"",MagickPathExtent);
           }
         if (image->depth > 32)
           image->depth=32;
         (void) FormatLocaleString(buffer,MagickPathExtent,
           ""DEPTH %.20g\nMAXVAL %.20g\n"",(double) packet_size,(double)
           ((MagickOffsetType) GetQuantumRange(image->depth)));
         (void) WriteBlobString(image,buffer);
         (void) FormatLocaleString(buffer,MagickPathExtent,
           ""TUPLTYPE %s\nENDHDR\n"",type);
         (void) WriteBlobString(image,buffer);
       }
      
     switch (format)
     {
       case '1':
       {
         unsigned char
           pixels[2048];
 
          
         (void) SetImageType(image,BilevelType,exception);
         q=pixels;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           register ssize_t
             x;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?
               '0' : '1');
             *q++=' ';
             if ((q-pixels+1) >= (ssize_t) sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
             p+=GetPixelChannels(image);
           }
           *q++='\n';
           (void) WriteBlob(image,q-pixels,pixels);
           q=pixels;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         if (q != pixels)
           {
             *q++='\n';
             (void) WriteBlob(image,q-pixels,pixels);
           }
         break;
       }
       case '2':
       {
         unsigned char
           pixels[2048];
 
          
         if (image->depth <= 8)
           (void) WriteBlobString(image,""255\n"");
         else
           if (image->depth <= 16)
             (void) WriteBlobString(image,""65535\n"");
           else
             (void) WriteBlobString(image,""4294967295\n"");
         q=pixels;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           register ssize_t
             x;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             index=ClampToQuantum(GetPixelLuma(image,p));
             if (image->depth <= 8)
               count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,""%u "",
                 ScaleQuantumToChar(index));
             else
               if (image->depth <= 16)
                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
                   ""%u "",ScaleQuantumToShort(index));
               else
                  count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
                    ""%u "",ScaleQuantumToLong(index));
              extent=(size_t) count;
            (void) strncpy((char *) q,buffer,extent);
            q+=extent;
            if ((q-pixels+extent+2) >= sizeof(pixels))
             if ((q-pixels+extent+1) >= sizeof(pixels))
                {
                  *q++='\n';
                  (void) WriteBlob(image,q-pixels,pixels);
                  q=pixels;
                }
             (void) strncpy((char *) q,buffer,extent);
             q+=extent;
              p+=GetPixelChannels(image);
            }
            *q++='\n';
           (void) WriteBlob(image,q-pixels,pixels);
           q=pixels;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         if (q != pixels)
           {
             *q++='\n';
             (void) WriteBlob(image,q-pixels,pixels);
           }
         break;
       }
       case '3':
       {
         unsigned char
           pixels[2048];
 
          
         (void) TransformImageColorspace(image,sRGBColorspace,exception);
         if (image->depth <= 8)
           (void) WriteBlobString(image,""255\n"");
         else
           if (image->depth <= 16)
             (void) WriteBlobString(image,""65535\n"");
           else
             (void) WriteBlobString(image,""4294967295\n"");
         q=pixels;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           register ssize_t
             x;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             if (image->depth <= 8)
               count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
                 ""%u %u %u "",ScaleQuantumToChar(GetPixelRed(image,p)),
                 ScaleQuantumToChar(GetPixelGreen(image,p)),
                 ScaleQuantumToChar(GetPixelBlue(image,p)));
             else
               if (image->depth <= 16)
                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
                   ""%u %u %u "",ScaleQuantumToShort(GetPixelRed(image,p)),
                   ScaleQuantumToShort(GetPixelGreen(image,p)),
                   ScaleQuantumToShort(GetPixelBlue(image,p)));
               else
                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
                   ""%u %u %u "",ScaleQuantumToLong(GetPixelRed(image,p)),
                    ScaleQuantumToLong(GetPixelGreen(image,p)),
                    ScaleQuantumToLong(GetPixelBlue(image,p)));
              extent=(size_t) count;
            (void) strncpy((char *) q,buffer,extent);
            q+=extent;
              if ((q-pixels+extent+2) >= sizeof(pixels))
                {
                  *q++='\n';
                  (void) WriteBlob(image,q-pixels,pixels);
                  q=pixels;
                }
             (void) strncpy((char *) q,buffer,extent);
             q+=extent;
              p+=GetPixelChannels(image);
            }
            *q++='\n';
           (void) WriteBlob(image,q-pixels,pixels);
           q=pixels;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         if (q != pixels)
           {
             *q++='\n';
             (void) WriteBlob(image,q-pixels,pixels);
           }
         break;
       }
       case '4':
       {
         register unsigned char
           *pixels;
 
          
         (void) SetImageType(image,BilevelType,exception);
         image->depth=1;
         quantum_info=AcquireQuantumInfo(image_info,image);
         if (quantum_info == (QuantumInfo *) NULL)
           ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
         quantum_info->min_is_white=MagickTrue;
         pixels=GetQuantumPixels(quantum_info);
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             GrayQuantum,pixels,exception);
           count=WriteBlob(image,extent,pixels);
           if (count != (ssize_t) extent)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         quantum_info=DestroyQuantumInfo(quantum_info);
         break;
       }
       case '5':
       {
         register unsigned char
           *pixels;
 
          
         if (image->depth > 32)
           image->depth=32;
         (void) FormatLocaleString(buffer,MagickPathExtent,""%.20g\n"",(double)
           ((MagickOffsetType) GetQuantumRange(image->depth)));
         (void) WriteBlobString(image,buffer);
         quantum_info=AcquireQuantumInfo(image_info,image);
         if (quantum_info == (QuantumInfo *) NULL)
           ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
         quantum_info->min_is_white=MagickTrue;
         pixels=GetQuantumPixels(quantum_info);
         extent=GetQuantumExtent(image,quantum_info,GrayQuantum);
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           register ssize_t
             x;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           q=pixels;
           switch (image->depth)
           {
             case 8:
             case 16:
             case 32:
             {
               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                 GrayQuantum,pixels,exception);
               break;
             }
             default:
             {
               if (image->depth <= 8)
                 {
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     if (IsPixelGray(image,p) == MagickFalse)
                       pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(
                         image,p)),max_value);
                     else
                       {
                         if (image->depth == 8)
                           pixel=ScaleQuantumToChar(GetPixelRed(image,p));
                         else
                           pixel=ScaleQuantumToAny(GetPixelRed(image,p),
                             max_value);
                       }
                     q=PopCharPixel((unsigned char) pixel,q);
                     p+=GetPixelChannels(image);
                   }
                   extent=(size_t) (q-pixels);
                   break;
                 }
               if (image->depth <= 16)
                 {
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     if (IsPixelGray(image,p) == MagickFalse)
                       pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,
                         p)),max_value);
                     else
                       {
                         if (image->depth == 16)
                           pixel=ScaleQuantumToShort(GetPixelRed(image,p));
                         else
                           pixel=ScaleQuantumToAny(GetPixelRed(image,p),
                             max_value);
                       }
                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                     p+=GetPixelChannels(image);
                   }
                   extent=(size_t) (q-pixels);
                   break;
                 }
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 if (IsPixelGray(image,p) == MagickFalse)
                   pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),
                     max_value);
                 else
                   {
                     if (image->depth == 16)
                       pixel=ScaleQuantumToLong(GetPixelRed(image,p));
                     else
                       pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                   }
                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                 p+=GetPixelChannels(image);
               }
               extent=(size_t) (q-pixels);
               break;
             }
           }
           count=WriteBlob(image,extent,pixels);
           if (count != (ssize_t) extent)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         quantum_info=DestroyQuantumInfo(quantum_info);
         break;
       }
       case '6':
       {
         register unsigned char
           *pixels;
 
          
         (void) TransformImageColorspace(image,sRGBColorspace,exception);
         if (image->depth > 32)
           image->depth=32;
         (void) FormatLocaleString(buffer,MagickPathExtent,""%.20g\n"",(double)
           ((MagickOffsetType) GetQuantumRange(image->depth)));
         (void) WriteBlobString(image,buffer);
         quantum_info=AcquireQuantumInfo(image_info,image);
         if (quantum_info == (QuantumInfo *) NULL)
           ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
         pixels=GetQuantumPixels(quantum_info);
         extent=GetQuantumExtent(image,quantum_info,quantum_type);
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           register ssize_t
             x;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           q=pixels;
           switch (image->depth)
           {
             case 8:
             case 16:
             case 32:
             {
               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                 quantum_type,pixels,exception);
               break;
             }
             default:
             {
               if (image->depth <= 8)
                 {
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                     q=PopCharPixel((unsigned char) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
                     q=PopCharPixel((unsigned char) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
                     q=PopCharPixel((unsigned char) pixel,q);
                     p+=GetPixelChannels(image);
                   }
                   extent=(size_t) (q-pixels);
                   break;
                 }
               if (image->depth <= 16)
                 {
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                     p+=GetPixelChannels(image);
                   }
                   extent=(size_t) (q-pixels);
                   break;
                 }
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                 pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                 pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                 p+=GetPixelChannels(image);
               }
               extent=(size_t) (q-pixels);
               break;
             }
           }
           count=WriteBlob(image,extent,pixels);
           if (count != (ssize_t) extent)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         quantum_info=DestroyQuantumInfo(quantum_info);
         break;
       }
       case '7':
       {
         register unsigned char
           *pixels;
 
          
         if (image->depth > 32)
           image->depth=32;
         quantum_info=AcquireQuantumInfo(image_info,image);
         if (quantum_info == (QuantumInfo *) NULL)
           ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
         (void) SetQuantumEndian(image,quantum_info,MSBEndian);
         pixels=GetQuantumPixels(quantum_info);
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           register ssize_t
             x;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           q=pixels;
           switch (image->depth)
           {
             case 8:
             case 16:
             case 32:
             {
               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
                 quantum_type,pixels,exception);
               break;
             }
             default:
             {
               switch (quantum_type)
               {
                 case GrayQuantum:
                 case GrayAlphaQuantum:
                 {
                   if (image->depth <= 8)
                     {
                       for (x=0; x < (ssize_t) image->columns; x++)
                       {
                         pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(
                           image,p)),max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         if (image->alpha_trait != UndefinedPixelTrait)
                           {
                             pixel=(unsigned char) ScaleQuantumToAny(
                               GetPixelAlpha(image,p),max_value);
                             q=PopCharPixel((unsigned char) pixel,q);
                           }
                         p+=GetPixelChannels(image);
                       }
                       break;
                     }
                   if (image->depth <= 16)
                     {
                       for (x=0; x < (ssize_t) image->columns; x++)
                       {
                         pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(
                           image,p)),max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         if (image->alpha_trait != UndefinedPixelTrait)
                           {
                             pixel=(unsigned char) ScaleQuantumToAny(
                               GetPixelAlpha(image,p),max_value);
                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                           }
                         p+=GetPixelChannels(image);
                       }
                       break;
                     }
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,
                       p)),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     if (image->alpha_trait != UndefinedPixelTrait)
                       {
                         pixel=(unsigned char) ScaleQuantumToAny(
                           GetPixelAlpha(image,p),max_value);
                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                       }
                     p+=GetPixelChannels(image);
                   }
                   break;
                 }
                 case CMYKQuantum:
                 case CMYKAQuantum:
                 {
                   if (image->depth <= 8)
                     {
                       for (x=0; x < (ssize_t) image->columns; x++)
                       {
                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
                           max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
                           max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelBlack(image,p),
                           max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         if (image->alpha_trait != UndefinedPixelTrait)
                           {
                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
                               max_value);
                             q=PopCharPixel((unsigned char) pixel,q);
                           }
                         p+=GetPixelChannels(image);
                       }
                       break;
                     }
                   if (image->depth <= 16)
                     {
                       for (x=0; x < (ssize_t) image->columns; x++)
                       {
                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
                           max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
                           max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelBlack(image,p),
                           max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         if (image->alpha_trait != UndefinedPixelTrait)
                           {
                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
                               max_value);
                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                           }
                         p+=GetPixelChannels(image);
                       }
                       break;
                     }
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     if (image->alpha_trait != UndefinedPixelTrait)
                       {
                         pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
                           max_value);
                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                       }
                     p+=GetPixelChannels(image);
                   }
                   break;
                 }
                 default:
                 {
                   if (image->depth <= 8)
                     {
                       for (x=0; x < (ssize_t) image->columns; x++)
                       {
                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
                           max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
                           max_value);
                         q=PopCharPixel((unsigned char) pixel,q);
                         if (image->alpha_trait != UndefinedPixelTrait)
                           {
                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
                               max_value);
                             q=PopCharPixel((unsigned char) pixel,q);
                           }
                         p+=GetPixelChannels(image);
                       }
                       break;
                     }
                   if (image->depth <= 16)
                     {
                       for (x=0; x < (ssize_t) image->columns; x++)
                       {
                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),
                           max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),
                           max_value);
                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                         if (image->alpha_trait != UndefinedPixelTrait)
                           {
                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
                               max_value);
                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);
                           }
                         p+=GetPixelChannels(image);
                       }
                       break;
                     }
                   for (x=0; x < (ssize_t) image->columns; x++)
                   {
                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);
                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                     if (image->alpha_trait != UndefinedPixelTrait)
                       {
                         pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),
                           max_value);
                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);
                       }
                     p+=GetPixelChannels(image);
                   }
                   break;
                 }
               }
               extent=(size_t) (q-pixels);
               break;
             }
           }
           count=WriteBlob(image,extent,pixels);
           if (count != (ssize_t) extent)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         quantum_info=DestroyQuantumInfo(quantum_info);
         break;
       }
       case 'F':
       case 'f':
       {
         register unsigned char
           *pixels;
 
         (void) WriteBlobString(image,image->endian == LSBEndian ? ""-1.0\n"" :
           ""1.0\n"");
         image->depth=32;
         quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;
         quantum_info=AcquireQuantumInfo(image_info,image);
         if (quantum_info == (QuantumInfo *) NULL)
           ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
         status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
         if (status == MagickFalse)
           ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
         pixels=GetQuantumPixels(quantum_info);
         for (y=(ssize_t) image->rows-1; y >= 0; y--)
         {
           register const Quantum
             *magick_restrict p;
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
           if (p == (const Quantum *) NULL)
             break;
           extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           (void) WriteBlob(image,extent,pixels);
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         quantum_info=DestroyQuantumInfo(quantum_info);
         break;
       }
     }
     if (GetNextImageInList(image) == (Image *) NULL)
       break;
     image=SyncNextImageInList(image);
     status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);
     if (status == MagickFalse)
       break;
   } while (image_info->adjoin != MagickFalse);
   (void) CloseBlob(image);
   return(MagickTrue);
 }","[297, 303, 304, 378, 379, 294, 295, 296, 370, 371]",ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of a misplaced strncpy and an off-by-one error.
204767," static v8::Handle<v8::Value> V8TestNamedConstructorConstructorCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestNamedConstructor.Constructor"");
 
     if (!args.IsConstructCall())
         return V8Proxy::throwTypeError(""DOM object constructor cannot be called as a function."");
 
     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)
         return args.Holder();
 
     Frame* frame = V8Proxy::retrieveFrameForCurrentContext();
     if (!frame)
         return V8Proxy::throwError(V8Proxy::ReferenceError, ""TestNamedConstructor constructor associated frame is unavailable"", args.GetIsolate());
 
     Document* document = frame->document();
 
      toV8(document, args.GetIsolate());
  
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
  
      ExceptionCode ec = 0;
      STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str1, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str2, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str3, MAYBE_MISSING_PARAMETER(args, 2, DefaultIsNullString));
 
     RefPtr<TestNamedConstructor> impl = TestNamedConstructor::createForJSConstructor(document, str1, str2, str3, ec);
     v8::Handle<v8::Object> wrapper = args.Holder();
     if (ec)
         goto fail;
 
     V8DOMWrapper::setDOMWrapper(wrapper, &V8TestNamedConstructorConstructor::info, impl.get());
     V8DOMWrapper::setJSWrapperForActiveDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper), args.GetIsolate());
     return args.Holder();
   fail:
     return throwError(ec, args.GetIsolate());
 }","[21, 20]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
2273,"static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC)
{
char b32[4], *buffer, *endbuffer, *savebuf;
phar_archive_data *mydata = NULL;
phar_entry_info entry;
php_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;
php_uint16 manifest_ver;
php_uint32 len;
long offset;
int sig_len, register_alias = 0, temp_alias = 0;
char *signature = NULL;

if (pphar) {
*pphar = NULL;
}

if (error) {
*error = NULL;
}


if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {
MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
}

buffer = b32;

if (3 != php_stream_read(fp, buffer, 3)) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}

if ((*buffer == ' ' || *buffer == '\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {
int nextchar;
halt_offset += 3;
if (EOF == (nextchar = php_stream_getc(fp))) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}

if ((char) nextchar == '\r') {

if (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\n') {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}
++halt_offset;
}

if ((char) nextchar == '\n') {
++halt_offset;
}
}


if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {
MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
}


buffer = b32;

if (4 != php_stream_read(fp, buffer, 4)) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at manifest length)"")
}

PHAR_GET_32(buffer, manifest_len);

if (manifest_len > 1048576 * 100) {

MAPPHAR_ALLOC_FAIL(""manifest cannot be larger than 100 MB in phar \""%s\"""")
}

buffer = (char *)emalloc(manifest_len);
savebuf = buffer;
endbuffer = buffer + manifest_len;

if (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
}


PHAR_GET_32(buffer, manifest_count);

if (manifest_count == 0) {
MAPPHAR_FAIL(""in phar \""%s\"", manifest claims to have zero entries.  Phars must have at least 1 entry"");
}


manifest_ver = (((unsigned char)buffer[0]) << 8)
+ ((unsigned char)buffer[1]);
buffer += 2;

if ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" is API version %1.u.%1.u.%1.u, and cannot be processed"", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);
}
return FAILURE;
}

PHAR_GET_32(buffer, manifest_flags);

manifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;
manifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;

manifest_flags |= compression;



if (manifest_flags & PHAR_HDR_SIGNATURE) {
char sig_buf[8], *sig_ptr = sig_buf;
off_t read_len;
size_t end_of_phar;

if (-1 == php_stream_seek(fp, -8, SEEK_END)
|| (read_len = php_stream_tell(fp)) < 20
|| 8 != php_stream_read(fp, sig_buf, 8)
|| memcmp(sig_buf+4, ""GBMB"", 4)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}

PHAR_GET_32(sig_ptr, sig_flags);

switch(sig_flags) {
case PHAR_SIG_OPENSSL: {
php_uint32 signature_len;
char *sig;
off_t whence;


if (-1 == php_stream_seek(fp, -12, SEEK_CUR)
|| 4 != php_stream_read(fp, sig_buf, 4)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" openssl signature length could not be read"", fname);
}
return FAILURE;
}

sig_ptr = sig_buf;
PHAR_GET_32(sig_ptr, signature_len);
sig = (char *) emalloc(signature_len);
whence = signature_len + 4;
whence = -whence;

if (-1 == php_stream_seek(fp, whence, SEEK_CUR)
|| !(end_of_phar = php_stream_tell(fp))
|| signature_len != php_stream_read(fp, sig, signature_len)) {
efree(savebuf);
efree(sig);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" openssl signature could not be read"", fname);
}
return FAILURE;
}

if (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
efree(sig);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" openssl signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
efree(sig);
}
break;
#if PHAR_HASH_OK
case PHAR_SIG_SHA512: {
unsigned char digest[64];

php_stream_seek(fp, -(8 + 64), SEEK_END);
read_len = php_stream_tell(fp);

if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}

if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" SHA512 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
case PHAR_SIG_SHA256: {
unsigned char digest[32];

php_stream_seek(fp, -(8 + 32), SEEK_END);
read_len = php_stream_tell(fp);

if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}

if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" SHA256 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
#else
case PHAR_SIG_SHA512:
case PHAR_SIG_SHA256:
efree(savebuf);
php_stream_close(fp);

if (error) {
spprintf(error, 0, ""phar \""%s\"" has a unsupported signature"", fname);
}
return FAILURE;
#endif
case PHAR_SIG_SHA1: {
unsigned char digest[20];

php_stream_seek(fp, -(8 + 20), SEEK_END);
read_len = php_stream_tell(fp);

if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}

if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" SHA1 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
case PHAR_SIG_MD5: {
unsigned char digest[16];

php_stream_seek(fp, -(8 + 16), SEEK_END);
read_len = php_stream_tell(fp);

if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}

if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" MD5 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
default:
efree(savebuf);
php_stream_close(fp);

if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken or unsupported signature"", fname);
}
return FAILURE;
}
} else if (PHAR_G(require_hash)) {
efree(savebuf);
php_stream_close(fp);

if (error) {
spprintf(error, 0, ""phar \""%s\"" does not have a signature"", fname);
}
return FAILURE;
} else {
sig_flags = 0;
sig_len = 0;
}


PHAR_GET_32(buffer, tmp_len);

if (buffer + tmp_len > endbuffer) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (buffer overrun)"");
}

if (manifest_len < 10 + tmp_len) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
}


if (tmp_len) {

if (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))
{
buffer[tmp_len] = '\0';
php_stream_close(fp);

if (signature) {
efree(signature);
}

if (error) {
spprintf(error, 0, ""cannot load phar \""%s\"" with implicit alias \""%s\"" under different alias \""%s\"""", fname, buffer, alias);
}

efree(savebuf);
return FAILURE;
}

alias_len = tmp_len;
alias = buffer;
buffer += tmp_len;
register_alias = 1;
} else if (!alias_len || !alias) {

alias = NULL;
alias_len = 0;
register_alias = 0;
} else if (alias_len) {
register_alias = 1;
temp_alias = 1;
}


if (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {

MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (too many manifest entries for size of manifest)"")
}

mydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));
mydata->is_persistent = PHAR_G(persist);


PHAR_GET_32(buffer, len);
if (mydata->is_persistent) {
mydata->metadata_len = len;
if(!len) {

PHAR_GET_32(buffer, len);
}
}
if(len > endbuffer - buffer) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (trying to read past buffer end)"");
}
if (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {
MAPPHAR_FAIL(""unable to read phar metadata in .phar file \""%s\"""");
}
buffer += len;


zend_hash_init(&mydata->manifest, manifest_count,
zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);
zend_hash_init(&mydata->mounted_dirs, 5,
zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
zend_hash_init(&mydata->virtual_dirs, manifest_count * 2,
zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
mydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);
#ifdef PHP_WIN32
phar_unixify_path_separators(mydata->fname, fname_len);
#endif
mydata->fname_len = fname_len;
offset = halt_offset + manifest_len + 4;
memset(&entry, 0, sizeof(phar_entry_info));
entry.phar = mydata;
entry.fp_type = PHAR_FP;
entry.is_persistent = mydata->is_persistent;

for (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {
if (buffer + 4 > endbuffer) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"")
}

PHAR_GET_32(buffer, entry.filename_len);

if (entry.filename_len == 0) {
MAPPHAR_FAIL(""zero-length filename encountered in phar \""%s\"""");
}

if (entry.is_persistent) {
entry.manifest_pos = manifest_index;
}

if (entry.filename_len + 20 > endbuffer - buffer) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
}

if ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {
entry.is_dir = 1;
} else {
entry.is_dir = 0;
}

phar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);
entry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);
buffer += entry.filename_len;
PHAR_GET_32(buffer, entry.uncompressed_filesize);
PHAR_GET_32(buffer, entry.timestamp);

if (offset == halt_offset + (int)manifest_len + 4) {
mydata->min_timestamp = entry.timestamp;
mydata->max_timestamp = entry.timestamp;
} else {
if (mydata->min_timestamp > entry.timestamp) {
mydata->min_timestamp = entry.timestamp;
} else if (mydata->max_timestamp < entry.timestamp) {
mydata->max_timestamp = entry.timestamp;
}
}

PHAR_GET_32(buffer, entry.compressed_filesize);
PHAR_GET_32(buffer, entry.crc32);
PHAR_GET_32(buffer, entry.flags);

if (entry.is_dir) {
entry.filename_len--;
entry.flags |= PHAR_ENT_PERM_DEF_DIR;
}

PHAR_GET_32(buffer, len);
if (entry.is_persistent) {
entry.metadata_len = len;
} else {
entry.metadata_len = 0;
}
if (len > endbuffer - buffer) {
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
}
if (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""unable to read file metadata in .phar file \""%s\"""");
}
buffer += len;

entry.offset = entry.offset_abs = offset;
offset += entry.compressed_filesize;

switch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {
case PHAR_ENT_COMPRESSED_GZ:
if (!PHAR_G(has_zlib)) {
if (entry.metadata) {
if (entry.is_persistent) {
free(entry.metadata);
} else {
zval_ptr_dtor(&entry.metadata);
}
}
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""zlib extension is required for gz compressed .phar file \""%s\"""");
}
break;
case PHAR_ENT_COMPRESSED_BZ2:
if (!PHAR_G(has_bz2)) {
if (entry.metadata) {
if (entry.is_persistent) {
free(entry.metadata);
} else {
zval_ptr_dtor(&entry.metadata);
}
}
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""bz2 extension is required for bzip2 compressed .phar file \""%s\"""");
}
break;
default:
if (entry.uncompressed_filesize != entry.compressed_filesize) {
if (entry.metadata) {
if (entry.is_persistent) {
free(entry.metadata);
} else {
zval_ptr_dtor(&entry.metadata);
}
}
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (compressed and uncompressed size does not match for uncompressed entry)"");
}
break;
}

manifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);

entry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);
phar_set_inode(&entry TSRMLS_CC);
zend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);
}

snprintf(mydata->version, sizeof(mydata->version), ""%u.%u.%u"", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);
mydata->internal_file_start = halt_offset + manifest_len + 4;
mydata->halt_offset = halt_offset;
mydata->flags = manifest_flags;
endbuffer = strrchr(mydata->fname, '/');

if (endbuffer) {
mydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);
if (mydata->ext == endbuffer) {
mydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);
}
if (mydata->ext) {
mydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;
}
}

mydata->alias = alias ?
pestrndup(alias, alias_len, mydata->is_persistent) :
pestrndup(mydata->fname, fname_len, mydata->is_persistent);
mydata->alias_len = alias ? alias_len : fname_len;
mydata->sig_flags = sig_flags;
mydata->fp = fp;
mydata->sig_len = sig_len;
mydata->signature = signature;
phar_request_initialize(TSRMLS_C);

if (register_alias) {
phar_archive_data **fd_ptr;

mydata->is_temporary_alias = temp_alias;

if (!phar_validate_alias(mydata->alias, mydata->alias_len)) {
signature = NULL;
fp = NULL;
MAPPHAR_FAIL(""Cannot open archive \""%s\"", invalid alias"");
}

if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {
if (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {
signature = NULL;
fp = NULL;
MAPPHAR_FAIL(""Cannot open archive \""%s\"", alias is already in use by existing archive"");
}
}

zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);
} else {
mydata->is_temporary_alias = 1;
}

zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);
efree(savebuf);

if (pphar) {
*pphar = mydata;
}

return SUCCESS;
}","[409, 423]",Integer overflow in the phar_parse_pharfile function in ext/phar/phar.c in PHP before 5.6.30 and 7.0.x before 7.0.15 allows remote attackers to cause a denial of service (memory consumption or application crash) via a truncated manifest entry in a PHAR archive.
203932," InputMethodDescriptors* CrosMock::CreateInputMethodDescriptors() {
  InputMethodDescriptors* descriptors = new InputMethodDescriptors;
 input_method::InputMethodDescriptors*
 CrosMock::CreateInputMethodDescriptors() {
   input_method::InputMethodDescriptors* descriptors =
       new input_method::InputMethodDescriptors;
    descriptors->push_back(
        input_method::GetFallbackInputMethodDescriptor());
    return descriptors;
 }","[3, 4, 5, 6, 2]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
198458," ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)
 {
     PCNetState *s = qemu_get_nic_opaque(nc);
     int is_padr = 0, is_bcast = 0, is_ladr = 0;
     uint8_t buf1[60];
     int remaining;
     int crc_err = 0;
     int size = size_;
 
     if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size ||
         (CSR_LOOP(s) && !s->looptest)) {
         return -1;
     }
 #ifdef PCNET_DEBUG
     printf(""pcnet_receive size=%d\n"", size);
 #endif
 
      
     if (size < MIN_BUF_SIZE) {
         memcpy(buf1, buf, size);
         memset(buf1 + size, 0, MIN_BUF_SIZE - size);
         buf = buf1;
         size = MIN_BUF_SIZE;
     }
 
     if (CSR_PROM(s)
         || (is_padr=padr_match(s, buf, size))
         || (is_bcast=padr_bcast(s, buf, size))
         || (is_ladr=ladr_match(s, buf, size))) {
 
         pcnet_rdte_poll(s);
 
         if (!(CSR_CRST(s) & 0x8000) && s->rdra) {
             struct pcnet_RMD rmd;
             int rcvrc = CSR_RCVRC(s)-1,i;
             hwaddr nrda;
             for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {
                 if (rcvrc <= 1)
                     rcvrc = CSR_RCVRL(s);
                 nrda = s->rdra +
                     (CSR_RCVRL(s) - rcvrc) *
                     (BCR_SWSTYLE(s) ? 16 : 8 );
                 RMDLOAD(&rmd, nrda);
                 if (GET_FIELD(rmd.status, RMDS, OWN)) {
 #ifdef PCNET_DEBUG_RMD
                     printf(""pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\n"",
                                 rcvrc, CSR_RCVRC(s));
 #endif
                     CSR_RCVRC(s) = rcvrc;
                     pcnet_rdte_poll(s);
                     break;
                 }
             }
         }
 
         if (!(CSR_CRST(s) & 0x8000)) {
 #ifdef PCNET_DEBUG_RMD
             printf(""pcnet - no buffer: RCVRC=%d\n"", CSR_RCVRC(s));
 #endif
             s->csr[0] |= 0x1000;  
             CSR_MISSC(s)++;
         } else {
             uint8_t *src = s->buffer;
             hwaddr crda = CSR_CRDA(s);
             struct pcnet_RMD rmd;
              int pktcount = 0;
  
              if (!s->looptest) {
                 if (size > 4092) {
 #ifdef PCNET_DEBUG_RMD
                     fprintf(stderr, ""pcnet: truncates rx packet.\n"");
 #endif
                     size = 4092;
                 }
                  memcpy(src, buf, size);
                   
                  src[size] = 0;
                 uint32_t fcs = ~0;
                 uint8_t *p = src;
 
                 while (p != &src[size])
                     CRC(fcs, *p++);
                 *(uint32_t *)p = htonl(fcs);
                 size += 4;
             } else {
                 uint32_t fcs = ~0;
                 uint8_t *p = src;
 
                 while (p != &src[size])
                     CRC(fcs, *p++);
                 crc_err = (*(uint32_t *)p != htonl(fcs));
             }
 
 #ifdef PCNET_DEBUG_MATCH
             PRINT_PKTHDR(buf);
 #endif
 
             RMDLOAD(&rmd, PHYSADDR(s,crda));
              
                 SET_FIELD(&rmd.status, RMDS, STP, 1);
 
 #define PCNET_RECV_STORE() do {                                 \
     int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \
     hwaddr rbadr = PHYSADDR(s, rmd.rbadr);          \
     s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \
     src += count; remaining -= count;                           \
     SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \
     RMDSTORE(&rmd, PHYSADDR(s,crda));                           \
     pktcount++;                                                 \
 } while (0)
 
             remaining = size;
             PCNET_RECV_STORE();
             if ((remaining > 0) && CSR_NRDA(s)) {
                 hwaddr nrda = CSR_NRDA(s);
 #ifdef PCNET_DEBUG_RMD
                 PRINT_RMD(&rmd);
 #endif
                 RMDLOAD(&rmd, PHYSADDR(s,nrda));
                 if (GET_FIELD(rmd.status, RMDS, OWN)) {
                     crda = nrda;
                     PCNET_RECV_STORE();
 #ifdef PCNET_DEBUG_RMD
                     PRINT_RMD(&rmd);
 #endif
                     if ((remaining > 0) && (nrda=CSR_NNRD(s))) {
                         RMDLOAD(&rmd, PHYSADDR(s,nrda));
                         if (GET_FIELD(rmd.status, RMDS, OWN)) {
                             crda = nrda;
                             PCNET_RECV_STORE();
                         }
                     }
                 }
             }
 
 #undef PCNET_RECV_STORE
 
             RMDLOAD(&rmd, PHYSADDR(s,crda));
             if (remaining == 0) {
                 SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);
                 SET_FIELD(&rmd.status, RMDS, ENP, 1);
                 SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);
                 SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);
                 SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);
                 if (crc_err) {
                     SET_FIELD(&rmd.status, RMDS, CRC, 1);
                     SET_FIELD(&rmd.status, RMDS, ERR, 1);
                 }
             } else {
                 SET_FIELD(&rmd.status, RMDS, OFLO, 1);
                 SET_FIELD(&rmd.status, RMDS, BUFF, 1);
                 SET_FIELD(&rmd.status, RMDS, ERR, 1);
             }
             RMDSTORE(&rmd, PHYSADDR(s,crda));
             s->csr[0] |= 0x0400;
 
 #ifdef PCNET_DEBUG
             printf(""RCVRC=%d CRDA=0x%08x BLKS=%d\n"",
                 CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);
 #endif
 #ifdef PCNET_DEBUG_RMD
             PRINT_RMD(&rmd);
 #endif
 
             while (pktcount--) {
                 if (CSR_RCVRC(s) <= 1)
                     CSR_RCVRC(s) = CSR_RCVRL(s);
                 else
                     CSR_RCVRC(s)--;
             }
 
             pcnet_rdte_poll(s);
 
         }
     }
 
     pcnet_poll(s);
     pcnet_update_irq(s);
 
     return size_;
 }","[69, 70, 71, 72, 73, 74]","Buffer overflow in the pcnet_receive function in hw/net/pcnet.c in QEMU, when a guest NIC has a larger MTU, allows remote attackers to cause a denial of service (guest OS crash) or execute arbitrary code via a large packet."
206901," ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
   const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
 #if BUILDFLAG(USE_ALLOCATOR_SHIM)
   if (cmdline->HasSwitch(switches::kMemlog) ||
       base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
     if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
       LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                  << "" specified with --"" << switches::kMemlog
                  << ""which are not compatible. Memlog will be disabled."";
       return Mode::kNone;
     }
 
     std::string mode;
     if (cmdline->HasSwitch(switches::kMemlog)) {
       mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
     } else {
       mode = base::GetFieldTrialParamValueByFeature(
            kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
      }
  
    if (mode == switches::kMemlogModeAll)
      return Mode::kAll;
    if (mode == switches::kMemlogModeMinimal)
      return Mode::kMinimal;
    if (mode == switches::kMemlogModeBrowser)
      return Mode::kBrowser;
    if (mode == switches::kMemlogModeGpu)
      return Mode::kGpu;
    if (mode == switches::kMemlogModeRendererSampling)
      return Mode::kRendererSampling;
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
                << switches::kMemlog;
     return ConvertStringToMode(mode);
    }
    return Mode::kNone;
  #else
   LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
       << ""--"" << switches::kMemlog
       << "" specified but it will have no effect because the use_allocator_shim ""
       << ""is not available in this build."";
   return Mode::kNone;
  #endif
  }","[33, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]",Use after free in PDFium in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file.
207278," ExtensionNavigationThrottle::WillStartOrRedirectRequest() {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   content::WebContents* web_contents = navigation_handle()->GetWebContents();
   ExtensionRegistry* registry =
       ExtensionRegistry::Get(web_contents->GetBrowserContext());
 
   const GURL& url = navigation_handle()->GetURL();
   bool url_has_extension_scheme = url.SchemeIs(kExtensionScheme);
   url::Origin target_origin = url::Origin::Create(url);
   const Extension* target_extension = nullptr;
   if (url_has_extension_scheme) {
     target_extension =
         registry->enabled_extensions().GetExtensionOrAppByURL(url);
   } else if (target_origin.scheme() == kExtensionScheme) {
     DCHECK(url.SchemeIsFileSystem() || url.SchemeIsBlob());
     target_extension =
         registry->enabled_extensions().GetByID(target_origin.host());
   } else {
     return content::NavigationThrottle::PROCEED;
   }
 
   if (!target_extension) {
     return content::NavigationThrottle::BLOCK_REQUEST;
   }
 
   if (target_extension->is_hosted_app()) {
     base::StringPiece resource_root_relative_path =
         url.path_piece().empty() ? base::StringPiece()
                                  : url.path_piece().substr(1);
     if (!IconsInfo::GetIcons(target_extension)
              .ContainsPath(resource_root_relative_path)) {
       return content::NavigationThrottle::BLOCK_REQUEST;
      }
    }
  
  if (navigation_handle()->IsInMainFrame()) {
    bool current_frame_is_extension_process =
        !!registry->enabled_extensions().GetExtensionOrAppByURL(
            navigation_handle()->GetStartingSiteInstance()->GetSiteURL());
    if (!url_has_extension_scheme && !current_frame_is_extension_process) {
      if (target_origin.scheme() == kExtensionScheme &&
          navigation_handle()->GetSuggestedFilename().has_value()) {
        return content::NavigationThrottle::PROCEED;
      }
      bool has_webview_permission =
          target_extension->permissions_data()->HasAPIPermission(
              APIPermission::kWebView);
      if (!has_webview_permission)
        return content::NavigationThrottle::CANCEL;
    
    
    
   bool current_frame_is_extension_process =
       !!registry->enabled_extensions().GetExtensionOrAppByURL(
           navigation_handle()->GetStartingSiteInstance()->GetSiteURL());
 
   if (!url_has_extension_scheme && !current_frame_is_extension_process) {
      
      
     if (target_origin.scheme() == kExtensionScheme &&
         navigation_handle()->GetSuggestedFilename().has_value()) {
       return content::NavigationThrottle::PROCEED;
      }
  
      
      
     bool has_webview_permission =
         target_extension->permissions_data()->HasAPIPermission(
             APIPermission::kWebView);
     if (!has_webview_permission)
       return content::NavigationThrottle::CANCEL;
   }
 
   if (navigation_handle()->IsInMainFrame()) {
      guest_view::GuestViewBase* guest =
          guest_view::GuestViewBase::FromWebContents(web_contents);
      if (url_has_extension_scheme && guest) {
       const std::string& owner_extension_id = guest->owner_host();
       const Extension* owner_extension =
           registry->enabled_extensions().GetByID(owner_extension_id);
 
       std::string partition_domain;
       std::string partition_id;
       bool in_memory = false;
       bool is_guest = WebViewGuest::GetGuestPartitionConfigForSite(
           navigation_handle()->GetStartingSiteInstance()->GetSiteURL(),
           &partition_domain, &partition_id, &in_memory);
 
       bool allowed = true;
       url_request_util::AllowCrossRendererResourceLoadHelper(
           is_guest, target_extension, owner_extension, partition_id, url.path(),
           navigation_handle()->GetPageTransition(), &allowed);
       if (!allowed)
         return content::NavigationThrottle::BLOCK_REQUEST;
     }
 
     return content::NavigationThrottle::PROCEED;
   }
 
   content::RenderFrameHost* parent = navigation_handle()->GetParentFrame();
 
   bool external_ancestor = false;
   for (auto* ancestor = parent; ancestor; ancestor = ancestor->GetParent()) {
     if (ancestor->GetLastCommittedOrigin() == target_origin)
       continue;
     if (url::Origin::Create(ancestor->GetLastCommittedURL()) == target_origin)
       continue;
     if (ancestor->GetLastCommittedURL().SchemeIs(
             content::kChromeDevToolsScheme))
       continue;
 
     external_ancestor = true;
     break;
   }
 
   if (external_ancestor) {
     if (!url_has_extension_scheme)
       return content::NavigationThrottle::CANCEL;
 
     if (!WebAccessibleResourcesInfo::IsResourceWebAccessible(target_extension,
                                                              url.path()))
       return content::NavigationThrottle::BLOCK_REQUEST;
 
     if (target_extension->is_platform_app())
       return content::NavigationThrottle::CANCEL;
 
     const Extension* parent_extension =
         registry->enabled_extensions().GetExtensionOrAppByURL(
             parent->GetSiteInstance()->GetSiteURL());
     if (parent_extension && parent_extension->is_platform_app())
       return content::NavigationThrottle::BLOCK_REQUEST;
   }
 
   return content::NavigationThrottle::PROCEED;
 }","[50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]",Insufficient validation of input in Blink in Google Chrome prior to 66.0.3359.170 allowed a remote attacker to perform privilege escalation via a crafted HTML page.
204123," void AutomationProvider::SendFindRequest(
     TabContents* tab_contents,
     bool with_json,
     const string16& search_string,
     bool forward,
     bool match_case,
     bool find_next,
     IPC::Message* reply_message) {
   int request_id = FindInPageNotificationObserver::kFindInPageRequestId;
   FindInPageNotificationObserver* observer =
       new FindInPageNotificationObserver(this,
                                          tab_contents,
                                          with_json,
                                          reply_message);
   if (!with_json) {
     find_in_page_observer_.reset(observer);
   }
    TabContentsWrapper* wrapper =
        TabContentsWrapper::GetCurrentWrapperForContents(tab_contents);
    if (wrapper)
    wrapper->GetFindManager()->set_current_find_request_id(request_id);
     wrapper->find_tab_helper()->set_current_find_request_id(request_id);
  
    tab_contents->render_view_host()->StartFinding(
        FindInPageNotificationObserver::kFindInPageRequestId,
       search_string,
       forward,
       match_case,
       find_next);
 }","[22, 21]","Google Chrome before 10.0.648.204 does not properly handle SVG text, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors that lead to a *stale pointer.*"
199601," PHP_FUNCTION(imageaffinematrixget)
 {
 	double affine[6];
 	long type;
 	zval *options;
 	zval **tmp;
 	int res = GD_FALSE, i;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l|z"", &type, &options) == FAILURE)  {
 		return;
 	}
 
 	switch((gdAffineStandardMatrix)type) {
 		case GD_AFFINE_TRANSLATE:
 		case GD_AFFINE_SCALE: {
 			double x, y;
 			if (Z_TYPE_P(options) != IS_ARRAY) {
  				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Array expected as options"");
  			}
  			if (zend_hash_find(HASH_OF(options), ""x"", sizeof(""x""), (void **)&tmp) != FAILURE) {
				convert_to_double_ex(tmp);
				x = Z_DVAL_PP(tmp);
 				if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
 					zval dval;
 					dval = **tmp;
 					zval_copy_ctor(&dval);
 					convert_to_double(&dval);
 					x = Z_DVAL(dval);
 				} else {
 					x = Z_DVAL_PP(tmp);
 				}
  			} else {
  				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing x position"");
  				RETURN_FALSE;
  			}
  
  			if (zend_hash_find(HASH_OF(options), ""y"", sizeof(""y""), (void **)&tmp) != FAILURE) {
				convert_to_double_ex(tmp);
				y = Z_DVAL_PP(tmp);
 				if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
 					zval dval;
 					dval = **tmp;
 					zval_copy_ctor(&dval);
 					convert_to_double(&dval);
 					y = Z_DVAL(dval);
 				} else {
 					y = Z_DVAL_PP(tmp);
 				}
  			} else {
  				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
  				RETURN_FALSE;
 			}
 			
 			if (type == GD_AFFINE_TRANSLATE) {
 				res = gdAffineTranslate(affine, x, y);
 			} else {
 				res = gdAffineScale(affine, x, y);
 			}
 			break;
 		}
 
 		case GD_AFFINE_ROTATE:
 		case GD_AFFINE_SHEAR_HORIZONTAL:
 		case GD_AFFINE_SHEAR_VERTICAL: {
 			double angle;
 
 			convert_to_double_ex(&options);
 			angle = Z_DVAL_P(options);
 
 			if (type == GD_AFFINE_SHEAR_HORIZONTAL) {
 				res = gdAffineShearHorizontal(affine, angle);
 			} else if (type == GD_AFFINE_SHEAR_VERTICAL) {
 				res = gdAffineShearVertical(affine, angle);
 			} else {
 				res = gdAffineRotate(affine, angle);
 			}
 			break;
 		}
 
 		default:
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid type for element %li"", type);
 			RETURN_FALSE;
 	}
 
 	if (res == GD_FALSE) {
 		RETURN_FALSE;
 	} else {
 		array_init(return_value);
 		for (i = 0; i < 6; i++) {
 			add_index_double(return_value, i, affine[i]);
 		}
 	}
 }","[23, 24, 25, 26, 27, 28, 29, 30, 31, 40, 41, 42, 43, 44, 45, 46, 47, 48, 21, 22, 38, 39]","ext/gd/gd.c in PHP 5.5.x before 5.5.9 does not check data types, which might allow remote attackers to obtain sensitive information by using a (1) string or (2) array data type in place of a numeric data type, as demonstrated by an imagecrop function call with a string for the x dimension value, a different vulnerability than CVE-2013-7226."
202828," static int aa_read_header(AVFormatContext *s)
 {
     int i, j, idx, largest_idx = -1;
     uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
     char key[128], val[128], codec_name[64] = {0};
     uint8_t output[24], dst[8], src[8];
     int64_t largest_size = -1, current_size = -1, chapter_pos;
     struct toc_entry {
         uint32_t offset;
         uint32_t size;
     } TOC[MAX_TOC_ENTRIES];
     uint32_t header_key_part[4];
     uint8_t header_key[16] = {0};
      AADemuxContext *c = s->priv_data;
      AVIOContext *pb = s->pb;
      AVStream *st;
     int ret;
  
       
      avio_skip(pb, 4);  
     avio_skip(pb, 4);  
     toc_size = avio_rb32(pb);  
     avio_skip(pb, 4);  
     if (toc_size > MAX_TOC_ENTRIES)
         return AVERROR_INVALIDDATA;
     for (i = 0; i < toc_size; i++) {  
         avio_skip(pb, 4);  
         TOC[i].offset = avio_rb32(pb);  
         TOC[i].size = avio_rb32(pb);  
     }
     avio_skip(pb, 24);  
     npairs = avio_rb32(pb);  
     if (npairs > MAX_DICTIONARY_ENTRIES)
         return AVERROR_INVALIDDATA;
     for (i = 0; i < npairs; i++) {
         memset(val, 0, sizeof(val));
         memset(key, 0, sizeof(key));
         avio_skip(pb, 1);  
         nkey = avio_rb32(pb);  
         nval = avio_rb32(pb);  
         avio_get_str(pb, nkey, key, sizeof(key));
         avio_get_str(pb, nval, val, sizeof(val));
         if (!strcmp(key, ""codec"")) {
             av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
             strncpy(codec_name, val, sizeof(codec_name) - 1);
         } else if (!strcmp(key, ""HeaderSeed"")) {
             av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
              header_seed = atoi(val);
          } else if (!strcmp(key, ""HeaderKey"")) {  
              av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);
            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
 
             ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                     &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
             if (ret != 4)
                 return AVERROR_INVALIDDATA;
 
              for (idx = 0; idx < 4; idx++) {
                  AV_WB32(&header_key[idx * 4], header_key_part[idx]);  
              }
             av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
             for (i = 0; i < 16; i++)
                 av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
             av_log(s, AV_LOG_DEBUG, ""\n"");
         } else {
             av_dict_set(&s->metadata, key, val, 0);
         }
     }
 
      
     if (c->aa_fixed_key_len != 16) {
         av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
         return AVERROR(EINVAL);
     }
 
      
     if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
         av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
         return AVERROR(EINVAL);
     }
 
      
     c->tea_ctx = av_tea_alloc();
     if (!c->tea_ctx)
         return AVERROR(ENOMEM);
     av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
     output[0] = output[1] = 0;  
     memcpy(output + 2, header_key, 16);
     idx = 0;
     for (i = 0; i < 3; i++) {  
         AV_WB32(src, header_seed);
         AV_WB32(src + 4, header_seed + 1);
         header_seed += 2;
         av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0);  
         for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
             output[idx] = output[idx] ^ dst[j];
         }
     }
     memcpy(c->file_key, output + 2, 16);  
     av_log(s, AV_LOG_DEBUG, ""File key is "");
     for (i = 0; i < 16; i++)
         av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
     av_log(s, AV_LOG_DEBUG, ""\n"");
 
      
     st = avformat_new_stream(s, NULL);
     if (!st) {
         av_freep(&c->tea_ctx);
         return AVERROR(ENOMEM);
     }
     st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
     if (!strcmp(codec_name, ""mp332"")) {
         st->codecpar->codec_id = AV_CODEC_ID_MP3;
         st->codecpar->sample_rate = 22050;
         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
         avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
     } else if (!strcmp(codec_name, ""acelp85"")) {
         st->codecpar->codec_id = AV_CODEC_ID_SIPR;
         st->codecpar->block_align = 19;
         st->codecpar->channels = 1;
         st->codecpar->sample_rate = 8500;
         st->codecpar->bit_rate = 8500;
         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
         avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
     } else if (!strcmp(codec_name, ""acelp16"")) {
         st->codecpar->codec_id = AV_CODEC_ID_SIPR;
         st->codecpar->block_align = 20;
         st->codecpar->channels = 1;
         st->codecpar->sample_rate = 16000;
         st->codecpar->bit_rate = 16000;
         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
         avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
     }
 
      
     for (i = 1; i < toc_size; i++) {  
         current_size = TOC[i].size;
         if (current_size > largest_size) {
             largest_idx = i;
             largest_size = current_size;
         }
     }
     start = TOC[largest_idx].offset;
     avio_seek(pb, start, SEEK_SET);
 
     st->start_time = 0;
     c->content_start = start;
     c->content_end = start + largest_size;
 
     while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
         int chapter_idx = s->nb_chapters;
         uint32_t chapter_size = avio_rb32(pb);
         if (chapter_size == 0) break;
         chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
         avio_skip(pb, 4 + chapter_size);
         if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
             chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                 return AVERROR(ENOMEM);
     }
 
     st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;
 
     ff_update_cur_dts(s, st, 0);
     avio_seek(pb, start, SEEK_SET);
     c->current_chapter_size = 0;
     c->seek_offset = 0;
 
     return 0;
 }","[17, 52, 53, 55, 56, 57, 51]",aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.
204254," void ThreadableBlobRegistry::addDataToStream(const KURL& url, PassRefPtr<RawData> streamData)
 void BlobRegistry::addDataToStream(const KURL& url, PassRefPtr<RawData> streamData)
  {
      if (isMainThread()) {
        blobRegistry().addDataToStream(url, streamData);
         if (WebBlobRegistry* registry = blobRegistry()) {
             WebThreadSafeData webThreadSafeData(streamData);
             registry->addDataToStream(url, webThreadSafeData);
         }
      } else {
          OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, streamData));
          callOnMainThread(&addDataToStreamTask, context.leakPtr());
     }
 }","[2, 6, 7, 8, 9, 5]","Google Chrome before 23.0.1271.91 on Mac OS X does not properly mitigate improper rendering behavior in the Intel GPU driver, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
9292,"int __close_fd_get_file(unsigned int fd, struct file **res)
{
struct files_struct *files = current->files;
struct file *file;
struct fdtable *fdt;

spin_lock(&files->file_lock);
fdt = files_fdtable(files);
if (fd >= fdt->max_fds)
goto out_unlock;
file = fdt->fd[fd];
if (!file)
goto out_unlock;
rcu_assign_pointer(fdt->fd[fd], NULL);
__put_unused_fd(files, fd);
spin_unlock(&files->file_lock);
get_file(file);
*res = file;
return filp_close(file, files);

out_unlock:
spin_unlock(&files->file_lock);
*res = NULL;
return -ENOENT;
}",[19],"The code in UEK6 U3 was missing an appropiate file descriptor count to be missing. This resulted in a use count error that allowed a file descriptor to a socket to be closed and freed while it was still in use by another portion of the kernel. An attack with local access can operate on the socket, and cause a denial of service. CVSS 3.1 Base Score 5.5 (Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H)."
198866," static void nfs4_open_confirm_release(void *calldata)
 {
 	struct nfs4_opendata *data = calldata;
 	struct nfs4_state *state = NULL;
 
 	 
 	if (data->cancelled == 0)
 		goto out_free;
 	 
 	if (!data->rpc_done)
  		goto out_free;
  	state = nfs4_opendata_to_nfs4_state(data);
  	if (!IS_ERR(state))
		nfs4_close_state(&data->path, state, data->o_arg.open_flags);
 		nfs4_close_state(&data->path, state, data->o_arg.fmode);
  out_free:
  	nfs4_opendata_put(data);
  }","[15, 14]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
207778," static int fx_command(effect_handle_t  self,
  uint32_t            cmdCode,
  uint32_t            cmdSize,
  void *pCmdData,
  uint32_t *replySize,
  void *pReplyData)
 {
  struct effect_s *effect = (struct effect_s *)self;
 
  if (effect == NULL)
  return -EINVAL;
 
 
  switch (cmdCode) {
  case EFFECT_CMD_INIT:
  if (pReplyData == NULL || *replySize != sizeof(int))
  return -EINVAL;
 
  *(int *)pReplyData = 0;
  break;
 
  case EFFECT_CMD_SET_CONFIG: {
  if (pCmdData    == NULL||
                     cmdSize     != sizeof(effect_config_t)||
                     pReplyData  == NULL||
  *replySize  != sizeof(int)) {
                 ALOGV(""fx_command() EFFECT_CMD_SET_CONFIG invalid args"");
  return -EINVAL;
  }
  *(int *)pReplyData = session_set_config(effect->session, (effect_config_t *)pCmdData);
  if (*(int *)pReplyData != 0)
  break;
 
  if (effect->state != EFFECT_STATE_ACTIVE)
  *(int *)pReplyData = effect_set_state(effect, EFFECT_STATE_CONFIG);
 
  } break;
 
  case EFFECT_CMD_GET_CONFIG:
  if (pReplyData == NULL ||
  *replySize != sizeof(effect_config_t)) {
                 ALOGV(""fx_command() EFFECT_CMD_GET_CONFIG invalid args"");
  return -EINVAL;
  }
 
             session_get_config(effect->session, (effect_config_t *)pReplyData);
  break;
 
  case EFFECT_CMD_RESET:
  break;
 
  case EFFECT_CMD_GET_PARAM: {
 
              if (pCmdData == NULL ||
                      cmdSize < (int)sizeof(effect_param_t) ||
                      pReplyData == NULL ||
                    *replySize < (int)sizeof(effect_param_t)) {
                     *replySize < (int)sizeof(effect_param_t) ||
                      
                     ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t)) {
                  ALOGV(""fx_command() EFFECT_CMD_GET_PARAM invalid args"");
                  return -EINVAL;
              }
  effect_param_t *p = (effect_param_t *)pCmdData;
 
             memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
             p = (effect_param_t *)pReplyData;
             p->status = -ENOSYS;
 
  } break;
 
  case EFFECT_CMD_SET_PARAM: {
  if (pCmdData == NULL||
                     cmdSize < (int)sizeof(effect_param_t) ||
                     pReplyData == NULL ||
  *replySize != sizeof(int32_t)) {
                 ALOGV(""fx_command() EFFECT_CMD_SET_PARAM invalid args"");
  return -EINVAL;
  }
  effect_param_t *p = (effect_param_t *) pCmdData;
 
  if (p->psize != sizeof(int32_t)) {
                 ALOGV(""fx_command() EFFECT_CMD_SET_PARAM invalid param format"");
  return -EINVAL;
  }
  *(int *)pReplyData = -ENOSYS;
  } break;
 
  case EFFECT_CMD_ENABLE:
  if (pReplyData == NULL || *replySize != sizeof(int)) {
                 ALOGV(""fx_command() EFFECT_CMD_ENABLE invalid args"");
  return -EINVAL;
  }
  *(int *)pReplyData = effect_set_state(effect, EFFECT_STATE_ACTIVE);
  break;
 
  case EFFECT_CMD_DISABLE:
  if (pReplyData == NULL || *replySize != sizeof(int)) {
                 ALOGV(""fx_command() EFFECT_CMD_DISABLE invalid args"");
  return -EINVAL;
  }
  *(int *)pReplyData  = effect_set_state(effect, EFFECT_STATE_CONFIG);
  break;
 
  case EFFECT_CMD_SET_DEVICE:
  case EFFECT_CMD_SET_INPUT_DEVICE:
  case EFFECT_CMD_SET_VOLUME:
  case EFFECT_CMD_SET_AUDIO_MODE:
  if (pCmdData == NULL ||
                     cmdSize != sizeof(uint32_t)) {
                 ALOGV(""fx_command() %s invalid args"",
                       cmdCode == EFFECT_CMD_SET_DEVICE ? ""EFFECT_CMD_SET_DEVICE"" :
                       cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? ""EFFECT_CMD_SET_INPUT_DEVICE"" :
                       cmdCode == EFFECT_CMD_SET_VOLUME ? ""EFFECT_CMD_SET_VOLUME"" :
                       cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? ""EFFECT_CMD_SET_AUDIO_MODE"" :
  """");
  return -EINVAL;
  }
             ALOGV(""fx_command() %s value %08x"",
                   cmdCode == EFFECT_CMD_SET_DEVICE ? ""EFFECT_CMD_SET_DEVICE"" :
                   cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? ""EFFECT_CMD_SET_INPUT_DEVICE"" :
                   cmdCode == EFFECT_CMD_SET_VOLUME ? ""EFFECT_CMD_SET_VOLUME"" :
                   cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? ""EFFECT_CMD_SET_AUDIO_MODE"":
  """",
  *(int *)pCmdData);
  break;
 
  default:
  return -EINVAL;
  }
  return 0;
 }","[58, 59, 60, 57]","Multiple buffer overflows in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allow attackers to gain privileges via a crafted application that provides an AudioEffect reply, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 28173666."
199897," static char *lxclock_name(const char *p, const char *n)
 {
 	int ret;
 	int len;
 	char *dest;
  	char *rundir;
  
  	 
  
 	 
	len = strlen(""/lock/lxc/"") + strlen(n) + strlen(p) + 3;
 	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
  	rundir = get_rundir();
  	if (!rundir)
  		return NULL;
 	len += strlen(rundir);
 
 	if ((dest = malloc(len)) == NULL) {
 		free(rundir);
  		return NULL;
  	}
  
	ret = snprintf(dest, len, ""%s/lock/lxc/%s"", rundir, p);
 	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
  	if (ret < 0 || ret >= len) {
  		free(dest);
  		free(rundir);
  		return NULL;
  	}
  	ret = mkdir_p(dest, 0755);
  	if (ret < 0) {
		 
		int l2 = 22 + strlen(n) + strlen(p);
		if (l2 > len) {
			char *d;
			d = realloc(dest, l2);
			if (!d) {
				free(dest);
				free(rundir);
				return NULL;
			}
			len = l2;
			dest = d;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s"", geteuid(), p);
		if (ret < 0 || ret >= len) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = mkdir_p(dest, 0755);
		if (ret < 0) {
			free(dest);
			free(rundir);
			return NULL;
		}
		ret = snprintf(dest, len, ""/tmp/%d/lxc%s/.%s"", geteuid(), p, n);
	} else
		ret = snprintf(dest, len, ""%s/lock/lxc/%s/.%s"", rundir, p, n);
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
  
 	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
  	free(rundir);
  	if (ret < 0 || ret >= len) {
  		free(dest);
  		return NULL;
 	}
 	return dest;
 }","[12, 24, 60, 61, 62, 63, 65, 11, 23, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]",lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.
208114," WORD32 ixheaacd_qmf_hbe_data_reinit(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,
                                     WORD16 *p_freq_band_tab[2],
                                     WORD16 *p_num_sfb, WORD32 upsamp_4_flag) {
   WORD32 synth_size, sfb, patch, stop_patch;
 
  if (ptr_hbe_txposer != NULL) {
     ptr_hbe_txposer->start_band = p_freq_band_tab[LOW][0];
     ptr_hbe_txposer->end_band = p_freq_band_tab[LOW][p_num_sfb[LOW]];
 
     ptr_hbe_txposer->synth_size =
  4 * ((ptr_hbe_txposer->start_band + 4) / 8 + 1);
     ptr_hbe_txposer->k_start =
         ixheaacd_start_subband2kL_tbl[ptr_hbe_txposer->start_band];
 
     ptr_hbe_txposer->upsamp_4_flag = upsamp_4_flag;
 
  if (upsamp_4_flag) {
  if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 16)
         ptr_hbe_txposer->k_start = 16 - ptr_hbe_txposer->synth_size;
  } else if (ptr_hbe_txposer->core_frame_length == 768) {
  if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 24)
         ptr_hbe_txposer->k_start = 24 - ptr_hbe_txposer->synth_size;
  }
 
     memset(ptr_hbe_txposer->synth_buf, 0, 1280 * sizeof(FLOAT32));
     synth_size = ptr_hbe_txposer->synth_size;
     ptr_hbe_txposer->synth_buf_offset = 18 * synth_size;
  switch (synth_size) {
  case 4:
         ptr_hbe_txposer->synth_cos_tab =
 
              (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;
          ptr_hbe_txposer->analy_cos_sin_tab =
              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;
        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
          break;
        case 8:
          ptr_hbe_txposer->synth_cos_tab =
              (FLOAT32 *)ixheaacd_synth_cos_table_kl_8;
          ptr_hbe_txposer->analy_cos_sin_tab =
              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_16;
        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
          break;
        case 12:
          ptr_hbe_txposer->synth_cos_tab =
              (FLOAT32 *)ixheaacd_synth_cos_table_kl_12;
          ptr_hbe_txposer->analy_cos_sin_tab =
              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_24;
        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;
        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;
         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;
         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;
          break;
        case 16:
          ptr_hbe_txposer->synth_cos_tab =
              (FLOAT32 *)ixheaacd_synth_cos_table_kl_16;
          ptr_hbe_txposer->analy_cos_sin_tab =
              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_32;
        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
          break;
        case 20:
          ptr_hbe_txposer->synth_cos_tab =
  (FLOAT32 *)ixheaacd_synth_cos_table_kl_20;
         ptr_hbe_txposer->analy_cos_sin_tab =
  (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_40;
  break;
  default:
         ptr_hbe_txposer->synth_cos_tab =
 
              (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;
          ptr_hbe_txposer->analy_cos_sin_tab =
              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;
        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;
         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;
      }
  
      ptr_hbe_txposer->synth_wind_coeff = ixheaacd_map_prot_filter(synth_size);
 
     memset(ptr_hbe_txposer->analy_buf, 0, 640 * sizeof(FLOAT32));
     synth_size = 2 * ptr_hbe_txposer->synth_size;
     ptr_hbe_txposer->analy_wind_coeff = ixheaacd_map_prot_filter(synth_size);
 
     memset(ptr_hbe_txposer->x_over_qmf, 0, MAX_NUM_PATCHES * sizeof(WORD32));
     sfb = 0;
  if (upsamp_4_flag) {
       stop_patch = MAX_NUM_PATCHES;
       ptr_hbe_txposer->max_stretch = MAX_STRETCH;
  } else {
       stop_patch = MAX_STRETCH;
  }
 
  for (patch = 1; patch <= stop_patch; patch++) {
  while (sfb <= p_num_sfb[LOW] &&
              p_freq_band_tab[LOW][sfb] <= patch * ptr_hbe_txposer->start_band)
         sfb++;
  if (sfb <= p_num_sfb[LOW]) {
  if ((patch * ptr_hbe_txposer->start_band -
              p_freq_band_tab[LOW][sfb - 1]) <= 3) {
           ptr_hbe_txposer->x_over_qmf[patch - 1] =
               p_freq_band_tab[LOW][sfb - 1];
  } else {
           WORD32 sfb = 0;
  while (sfb <= p_num_sfb[HIGH] &&
                  p_freq_band_tab[HIGH][sfb] <=
                      patch * ptr_hbe_txposer->start_band)
             sfb++;
           ptr_hbe_txposer->x_over_qmf[patch - 1] =
               p_freq_band_tab[HIGH][sfb - 1];
  }
  } else {
         ptr_hbe_txposer->x_over_qmf[patch - 1] = ptr_hbe_txposer->end_band;
         ptr_hbe_txposer->max_stretch = min(patch, MAX_STRETCH);
 
          break;
        }
      }
  }
  if (ptr_hbe_txposer->k_start < 0) {
    return -1;
     if (ptr_hbe_txposer->k_start < 0) {
       return -1;
     }
    }
    return 0;
  }","[37, 38, 47, 48, 57, 58, 67, 68, 84, 85, 131, 132, 133, 35, 36, 45, 46, 55, 56, 65, 66, 82, 83, 128, 129, 130]",In ixheaacd_real_synth_fft_p3 of ixheaacd_esbr_fft.c there is a possible out of bounds write due to a missing bounds check. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-9.0 Android ID: A-110769924
207948," void impeg2d_dec_pic_data_thread(dec_state_t *ps_dec)
 {
     WORD32 i4_continue_decode;
 
     WORD32 i4_cur_row, temp;
     UWORD32 u4_bits_read;
     WORD32 i4_dequeue_job;
     IMPEG2D_ERROR_CODES_T e_error;
 
     i4_cur_row = ps_dec->u2_mb_y + 1;
 
     i4_continue_decode = 1;
 
     i4_dequeue_job = 1;
  do
  {
  if(i4_cur_row > ps_dec->u2_num_vert_mb)
  {
             i4_continue_decode = 0;
  break;
  }
 
  {
  if((ps_dec->i4_num_cores> 1) && (i4_dequeue_job))
  {
  job_t s_job;
                 IV_API_CALL_STATUS_T e_ret;
                 UWORD8 *pu1_buf;
 
                 e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);
  if(e_ret != IV_SUCCESS)
  break;
 
  if(CMD_PROCESS == s_job.i4_cmd)
  {
                     pu1_buf = ps_dec->pu1_inp_bits_buf + s_job.i4_bistream_ofst;
                     impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), pu1_buf,
  (ps_dec->u4_num_inp_bytes - s_job.i4_bistream_ofst) + 8);
                     i4_cur_row      = s_job.i2_start_mb_y;
                     ps_dec->i4_start_mb_y = s_job.i2_start_mb_y;
                     ps_dec->i4_end_mb_y = s_job.i2_end_mb_y;
                     ps_dec->u2_mb_x = 0;
                     ps_dec->u2_mb_y = ps_dec->i4_start_mb_y;
                     ps_dec->u2_num_mbs_left = (ps_dec->i4_end_mb_y - ps_dec->i4_start_mb_y) * ps_dec->u2_num_horiz_mb;
 
  }
  else
  {
                     WORD32 start_row;
                     WORD32 num_rows;
                     start_row = s_job.i2_start_mb_y << 4;
                     num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);
                     num_rows -= start_row;
                     impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                                         ps_dec->ps_disp_frm_buf,
                                         start_row, num_rows);
  break;
 
  }
 
  }
             e_error = impeg2d_dec_slice(ps_dec);
 
  if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
  {
                 impeg2d_next_start_code(ps_dec);
  }
  }
 
   
  while(1)
  {
             u4_bits_read = impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,START_CODE_LEN);
 
              temp = u4_bits_read & 0xFF;
              i4_continue_decode = (((u4_bits_read >> 8) == 0x01) && (temp) && (temp <= 0xAF));
  
             if (1 == ps_dec->i4_num_cores && 0 == ps_dec->u2_num_mbs_left)
             {
                 i4_continue_decode = 0;
                 android_errorWriteLog(0x534e4554, ""26070014"");
             }
 
              if(i4_continue_decode)
              {
                   
  if((temp - 1) == i4_cur_row)
  {
                     i4_dequeue_job = 0;
  break;
  }
 
  if(temp < ps_dec->i4_end_mb_y)
  {
                     i4_cur_row = ps_dec->u2_mb_y;
  }
  else
  {
                     i4_dequeue_job = 1;
  }
  break;
 
  }
  else
  break;
  }
 
  }while(i4_continue_decode);
  if(ps_dec->i4_num_cores > 1)
  {
  while(1)
  {
  job_t s_job;
             IV_API_CALL_STATUS_T e_ret;
 
             e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);
  if(e_ret != IV_SUCCESS)
  break;
  if(CMD_FMTCONV == s_job.i4_cmd)
  {
                 WORD32 start_row;
                 WORD32 num_rows;
                 start_row = s_job.i2_start_mb_y << 4;
                 num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);
                 num_rows -= start_row;
                 impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                                     ps_dec->ps_disp_frm_buf,
                                     start_row, num_rows);
  }
  }
  }
  else
  {
  if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))
             impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,
                             ps_dec->ps_disp_frm_buf,
  0, ps_dec->u2_vertical_size);
  }
 }","[78, 79, 80, 81, 82, 83]","decoder/impeg2d_dec_hdr.c in mediaserver in Android 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a certain negative value, aka internal bug 26070014."
198491," static PHP_FUNCTION(gzopen)
 {
 	char *filename;
 	char *mode;
 	int filename_len, mode_len;
 	int flags = REPORT_ERRORS;
         php_stream *stream;
         long use_include_path = 0;
  
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ps|l"", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {
                 return;
         }
  
 	if (use_include_path) {
 		flags |= USE_PATH;
 	}
 
 	stream = php_stream_gzopen(NULL, filename, mode, flags, NULL, NULL STREAMS_CC TSRMLS_CC);
 
 	if (!stream) {
 		RETURN_FALSE;
 	}
 	php_stream_to_zval(stream, return_value);
 }","[11, 10]","PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read arbitrary files via crafted input to an application that calls the stream_resolve_include_path function in ext/standard/streamsfuncs.c, as demonstrated by a filename\0.extension attack that bypasses an intended configuration in which client users may read files with only one specific extension."
202128," static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {
 	size_t pos, nextpos = 0;
 	x86newTokenType last_type;
 	int size_token = 1;
 	bool explicit_size = false;
 	int reg_index = 0;
 	op->type = 0;
 	while (size_token) {
 		pos = nextpos;
 		last_type = getToken (str, &pos, &nextpos);
 
 		if (!r_str_ncasecmp (str + pos, ""ptr"", 3)) {
 			continue;
 		} else if (!r_str_ncasecmp (str + pos, ""byte"", 4)) {
 			op->type |= OT_MEMORY | OT_BYTE;
 			op->dest_size = OT_BYTE;
 			explicit_size = true;
 		} else if (!r_str_ncasecmp (str + pos, ""word"", 4)) {
 			op->type |= OT_MEMORY | OT_WORD;
 			op->dest_size = OT_WORD;
 			explicit_size = true;
 		} else if (!r_str_ncasecmp (str + pos, ""dword"", 5)) {
 			op->type |= OT_MEMORY | OT_DWORD;
 			op->dest_size = OT_DWORD;
 			explicit_size = true;
 		} else if (!r_str_ncasecmp (str + pos, ""qword"", 5)) {
 			op->type |= OT_MEMORY | OT_QWORD;
 			op->dest_size = OT_QWORD;
 			explicit_size = true;
 		} else if (!r_str_ncasecmp (str + pos, ""oword"", 5)) {
 			op->type |= OT_MEMORY | OT_OWORD;
 			op->dest_size = OT_OWORD;
 			explicit_size = true;
 		} else if (!r_str_ncasecmp (str + pos, ""tbyte"", 5)) {
 			op->type |= OT_MEMORY | OT_TBYTE;
 			op->dest_size = OT_TBYTE;
 			explicit_size = true;
 		} else {  
 			size_token = 0;
 		}
 	}
 
 	if (str[pos] == '[') {
 		if (!op->type) {
 			op->type = OT_MEMORY;
 		}
 		op->offset = op->scale[0] = op->scale[1] = 0;
 
 		ut64 temp = 1;
 		Register reg = X86R_UNDEFINED;
 		bool first_reg = true;
 		while (str[pos] != ']') {
 			if (pos > nextpos) {
 				break;
 			}
 			pos = nextpos;
 			if (!str[pos]) {
 				break;
 			}
 			last_type = getToken (str, &pos, &nextpos);
 
  			if (last_type == TT_SPECIAL) {
  				if (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {
  					if (reg != X86R_UNDEFINED) {
						op->regs[reg_index] = reg;
						op->scale[reg_index] = temp;
 						if (reg_index < 2) {
 							op->regs[reg_index] = reg;
 							op->scale[reg_index] = temp;
 						}
  						++reg_index;
  					} else {
  						op->offset += temp;
						op->regs[reg_index] = X86R_UNDEFINED;
 						if (reg_index < 2) {
 							op->regs[reg_index] = X86R_UNDEFINED;
 						}
  					}
  					temp = 1;
  					reg = X86R_UNDEFINED;
  				} else if (str[pos] == '*') {
 
 				}
 			}
 			else if (last_type == TT_WORD) {
 				ut32 reg_type = 0;
 
 				if (reg != X86R_UNDEFINED) {
 					op->type = 0;	 
 				}
 
 				nextpos = pos;
 				reg = parseReg (a, str, &nextpos, &reg_type);
 
 				if (first_reg) {
 					op->extended = false;
 					if (reg > 8) {
 						op->extended = true;
 						op->reg = reg - 9;
 					}
 					first_reg = false;
 				} else if (reg > 8) {
 					op->reg = reg - 9;
 				}
 				if (reg_type & OT_REGTYPE & OT_SEGMENTREG) {
 					op->reg = reg;
 					op->type = reg_type;
 					parse_segment_offset (a, str, &nextpos, op, reg_index);
 					return nextpos;
 				}
 
 				if (!explicit_size) {
 					op->type |= reg_type;
 				}
 				op->reg_size = reg_type;
 				op->explicit_size = explicit_size;
 
 				if (!(reg_type & OT_GPREG)) {
 					op->type = 0;	 
 				}
 			}
 			else {
 				char *p = strchr (str, '+');
 				op->offset_sign = 1;
 				if (!p) {
 					p = strchr (str, '-');
 					if (p) {
 						op->offset_sign = -1;
 					}
 				}
 				char * plus = strchr (str, '+');
 				char * minus = strchr (str, '-');
 				char * closeB = strchr (str, ']');
 				if (plus && minus && plus < closeB && minus < closeB) {
 					op->offset_sign = -1;
 				}
 				char *tmp;
 				tmp = malloc (strlen (str + pos) + 1);
 				strcpy (tmp, str + pos);
 				strtok (tmp, ""+-"");
 				st64 read = getnum (a, tmp);
 				free (tmp);
 				temp *= read;
 			}
 		}
 	} else if (last_type == TT_WORD) {    
 		nextpos = pos;
 		RFlagItem *flag;
 
 		if (isrepop) {
 			op->is_good_flag = false;
 			strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);
 			op->rep_op[MAX_REPOP_LENGTH - 1] = '\0';
 			return nextpos;
 		}
 
 		op->reg = parseReg (a, str, &nextpos, &op->type);
 
 		op->extended = false;
 		if (op->reg > 8) {
 			op->extended = true;
 			op->reg -= 9;
 		}
 		if (op->type & OT_REGTYPE & OT_SEGMENTREG) {
 			parse_segment_offset (a, str, &nextpos, op, reg_index);
 			return nextpos;
 		}
 		if (op->reg == X86R_UNDEFINED) {
 			op->is_good_flag = false;
 			if (a->num && a->num->value == 0) {
 				return nextpos;
 			}
 			op->type = OT_CONSTANT;
 			RCore *core = a->num? (RCore *)(a->num->userptr): NULL;
 			if (core && (flag = r_flag_get (core->flags, str))) {
 				op->is_good_flag = true;
 			}
 
 			char *p = strchr (str, '-');
 			if (p) {
 				op->sign = -1;
 				str = ++p;
 			}
 			op->immediate = getnum (a, str);
 		} else if (op->reg < X86R_UNDEFINED) {
 			strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);
 			op->rep_op[MAX_REPOP_LENGTH - 1] = '\0';
 		}
 	} else {                              
 		op->type = OT_CONSTANT;
 		op->sign = 1;
 		char *p = strchr (str, '-');
 		if (p) {
 			op->sign = -1;
 			str = ++p;
 		}
 		op->immediate = getnum (a, str);
 	}
 
 	return nextpos;
 }","[67, 68, 69, 70, 75, 76, 77, 65, 66, 74]","In radare2 prior to 3.1.1, the parseOperand function inside libr/asm/p/asm_x86_nz.c may allow attackers to cause a denial of service (application crash in libr/util/strbuf.c via a stack-based buffer over-read) by crafting an input file, a related issue to CVE-2018-20455."
201141," static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;
 
   MagickOffsetType
     offset,
     *page_table,
     scene;
 
   MemoryInfo
     *pixel_info;
 
   PCXInfo
     pcx_info;
 
   register const IndexPacket
     *indexes;
 
   register const PixelPacket
     *p;
 
   register ssize_t
     i,
     x;
 
   register unsigned char
     *q;
 
   size_t
     length;
 
   ssize_t
     y;
 
   unsigned char
     *pcx_colormap,
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
   page_table=(MagickOffsetType *) NULL;
   if ((LocaleCompare(image_info->magick,""DCX"") == 0) ||
       ((GetNextImageInList(image) != (Image *) NULL) &&
        (image_info->adjoin != MagickFalse)))
     {
        
       (void) WriteBlobLSBLong(image,0x3ADE68B1L);
       page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
         sizeof(*page_table));
       if (page_table == (MagickOffsetType *) NULL)
         ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
       for (scene=0; scene < 1024; scene++)
         (void) WriteBlobLSBLong(image,0x00000000L);
     }
   scene=0;
   do
   {
     if (page_table != (MagickOffsetType *) NULL)
       page_table[scene]=TellBlob(image);
      
     pcx_info.identifier=0x0a;
     pcx_info.version=5;
     pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;
     pcx_info.bits_per_pixel=8;
     if ((image->storage_class == PseudoClass) &&
         (SetImageMonochrome(image,&image->exception) != MagickFalse))
       pcx_info.bits_per_pixel=1;
     pcx_info.left=0;
     pcx_info.top=0;
     pcx_info.right=(unsigned short) (image->columns-1);
     pcx_info.bottom=(unsigned short) (image->rows-1);
     switch (image->units)
     {
       case UndefinedResolution:
       case PixelsPerInchResolution:
       default:
       {
         pcx_info.horizontal_resolution=(unsigned short) image->x_resolution;
         pcx_info.vertical_resolution=(unsigned short) image->y_resolution;
         break;
       }
       case PixelsPerCentimeterResolution:
       {
         pcx_info.horizontal_resolution=(unsigned short)
           (2.54*image->x_resolution+0.5);
         pcx_info.vertical_resolution=(unsigned short)
           (2.54*image->y_resolution+0.5);
         break;
       }
     }
     pcx_info.reserved=0;
     pcx_info.planes=1;
     if ((image->storage_class == DirectClass) || (image->colors > 256))
       {
         pcx_info.planes=3;
         if (image->matte != MagickFalse)
           pcx_info.planes++;
       }
     pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*
       pcx_info.bits_per_pixel+7)/8);
     pcx_info.palette_info=1;
     pcx_info.colormap_signature=0x0c;
      
     (void) WriteBlobByte(image,pcx_info.identifier);
     (void) WriteBlobByte(image,pcx_info.version);
     (void) WriteBlobByte(image,pcx_info.encoding);
     (void) WriteBlobByte(image,pcx_info.bits_per_pixel);
     (void) WriteBlobLSBShort(image,pcx_info.left);
     (void) WriteBlobLSBShort(image,pcx_info.top);
     (void) WriteBlobLSBShort(image,pcx_info.right);
     (void) WriteBlobLSBShort(image,pcx_info.bottom);
     (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);
     (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);
      
     pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,
       3*sizeof(*pcx_colormap));
     if (pcx_colormap == (unsigned char *) NULL)
       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
     (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));
     q=pcx_colormap;
     if ((image->storage_class == PseudoClass) && (image->colors <= 256))
       for (i=0; i < (ssize_t) image->colors; i++)
       {
         *q++=ScaleQuantumToChar(image->colormap[i].red);
         *q++=ScaleQuantumToChar(image->colormap[i].green);
         *q++=ScaleQuantumToChar(image->colormap[i].blue);
       }
     (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);
     (void) WriteBlobByte(image,pcx_info.reserved);
     (void) WriteBlobByte(image,pcx_info.planes);
     (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);
     (void) WriteBlobLSBShort(image,pcx_info.palette_info);
     for (i=0; i < 58; i++)
       (void) WriteBlobByte(image,'\0');
      length=(size_t) pcx_info.bytes_per_line;
      pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));
      if (pixel_info == (MemoryInfo *) NULL)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
       {
         pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);
         ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
       }
      pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
      q=pixels;
      if ((image->storage_class == DirectClass) || (image->colors > 256))
       {
          
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           q=pixels;
           for (i=0; i < pcx_info.planes; i++)
           {
             p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
             if (p == (const PixelPacket *) NULL)
               break;
             switch ((int) i)
             {
               case 0:
               {
                 for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
                 {
                   *q++=ScaleQuantumToChar(GetPixelRed(p));
                   p++;
                 }
                 break;
               }
               case 1:
               {
                 for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
                 {
                   *q++=ScaleQuantumToChar(GetPixelGreen(p));
                   p++;
                 }
                 break;
               }
               case 2:
               {
                 for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
                 {
                   *q++=ScaleQuantumToChar(GetPixelBlue(p));
                   p++;
                 }
                 break;
               }
               case 3:
               default:
               {
                 for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)
                 {
                   *q++=ScaleQuantumToChar((Quantum)
                     (GetPixelAlpha(p)));
                   p++;
                 }
                 break;
               }
             }
           }
           if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
       }
     else
       {
         if (pcx_info.bits_per_pixel > 1)
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
             if (p == (const PixelPacket *) NULL)
               break;
             indexes=GetVirtualIndexQueue(image);
             q=pixels;
             for (x=0; x < (ssize_t) image->columns; x++)
               *q++=(unsigned char) GetPixelIndex(indexes+x);
             if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                 image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
         else
           {
             register unsigned char
               bit,
               byte;
 
              
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
               if (p == (const PixelPacket *) NULL)
                 break;
               indexes=GetVirtualIndexQueue(image);
               bit=0;
               byte=0;
               q=pixels;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 byte<<=1;
                 if (GetPixelLuma(image,p) >= (QuantumRange/2.0))
                   byte|=0x01;
                 bit++;
                 if (bit == 8)
                   {
                     *q++=byte;
                     bit=0;
                     byte=0;
                   }
                 p++;
               }
               if (bit != 0)
                 *q++=byte << (8-bit);
               if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
           }
         (void) WriteBlobByte(image,pcx_info.colormap_signature);
         (void) WriteBlob(image,3*256,pcx_colormap);
       }
     pixel_info=RelinquishVirtualMemory(pixel_info);
     pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);
     if (page_table == (MagickOffsetType *) NULL)
       break;
     if (scene >= 1023)
       break;
     if (GetNextImageInList(image) == (Image *) NULL)
       break;
     image=SyncNextImageInList(image);
     status=SetImageProgress(image,SaveImagesTag,scene++,
       GetImageListLength(image));
     if (status == MagickFalse)
       break;
   } while (image_info->adjoin != MagickFalse);
   if (page_table != (MagickOffsetType *) NULL)
     {
        
       page_table[scene+1]=0;
       offset=SeekBlob(image,0L,SEEK_SET);
       if (offset < 0)
         ThrowWriterException(CorruptImageError,""ImproperImageHeader"");
       (void) WriteBlobLSBLong(image,0x3ADE68B1L);
       for (i=0; i <= (ssize_t) scene; i++)
         (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);
       page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);
     }
   if (status == MagickFalse)
     {
       char
         *message;
 
       message=GetExceptionMessage(errno);
       (void) ThrowMagickException(&image->exception,GetMagickModule(),
         FileOpenError,""UnableToWriteFile"",""`%s': %s"",image->filename,message);
       message=DestroyString(message);
     }
   (void) CloseBlob(image);
   return(MagickTrue);
 }","[149, 150, 151, 152, 148]",ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePCXImage in coders/pcx.c.
202489," BOOL SQLWriteFileDSN(			LPCSTR	pszFileName,
 								LPCSTR	pszAppName,
 								LPCSTR	pszKeyName,
 								LPCSTR	pszString )
 {
 	HINI	hIni;
 	char	szFileName[ODBC_FILENAME_MAX+1];
  
  	if ( pszFileName[0] == '/' )
  	{
		strncpy( szFileName, sizeof(szFileName) - 5, pszFileName );
 		strncpy( szFileName, pszFileName, sizeof(szFileName) - 5 );
  	}
  	else
  	{	
 		char szPath[ODBC_FILENAME_MAX+1];
 		*szPath = '\0';
 		_odbcinst_FileINI( szPath );
 		snprintf( szFileName, sizeof(szFileName) - 5, ""%s/%s"", szPath, pszFileName );
 	}
 
     if ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, "".dsn"" ))
     {
         strcat( szFileName, "".dsn"" );
     }
 
 #ifdef __OS2__
 	if ( iniOpen( &hIni, szFileName, ""#;"", '[', ']', '=', TRUE, 0L ) != INI_SUCCESS )
 #else
 	if ( iniOpen( &hIni, szFileName, ""#;"", '[', ']', '=', TRUE ) != INI_SUCCESS )
 #endif
 	{
        	inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, """" );
 		return FALSE;
 	}
 
 	 
 	if ( pszString == NULL && pszKeyName == NULL )
 	{
 		if ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS )
         {
 			iniObjectDelete( hIni );
         }
 	}
 	 
 	else if	( pszString == NULL )
 	{
 		if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, """" ) == INI_SUCCESS )
         {
 			iniPropertyDelete( hIni );
         }
 	}
 	else
 	{
 		 
 		if ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS )
         {
 			iniObjectInsert( hIni, (char *)pszAppName );
         }
 		 
 		if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, """" ) == INI_SUCCESS )
 		{
 			iniObjectSeek( hIni, (char *)pszAppName );
 			iniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString );
 		}
 		 
 		else
 		{
 			iniObjectSeek( hIni, (char *)pszAppName );
 			iniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString );
 		}
 	}
 
 	if ( iniCommit( hIni ) != INI_SUCCESS )
 	{
 		iniClose( hIni );
         inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, """" );
 		return FALSE;
 	}
 
 	iniClose( hIni );
 
 	return TRUE;
 }","[12, 11]","The SQLWriteFileDSN function in odbcinst/SQLWriteFileDSN.c in unixODBC 2.3.5 has strncpy arguments in the wrong order, which allows attackers to cause a denial of service or possibly have unspecified other impact."
6275,"static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)
{
int i;
BYTE iBitmapFormat;
BOOL compressed = FALSE;
CACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));

if (!cache_brush)
goto fail;

if (Stream_GetRemainingLength(s) < 6)
goto fail;

Stream_Read_UINT8(s, cache_brush->index);
Stream_Read_UINT8(s, iBitmapFormat);

if (iBitmapFormat >= ARRAYSIZE(BMF_BPP))
goto fail;

cache_brush->bpp = BMF_BPP[iBitmapFormat];
Stream_Read_UINT8(s, cache_brush->cx);
Stream_Read_UINT8(s, cache_brush->cy);
Stream_Read_UINT8(s, cache_brush->style);
Stream_Read_UINT8(s, cache_brush->length);

if ((cache_brush->cx == 8) && (cache_brush->cy == 8))
{
if (cache_brush->bpp == 1)
{
if (cache_brush->length != 8)
{
WLog_Print(update->log, WLOG_ERROR, ""incompatible 1bpp brush of length:%"" PRIu32 """",
cache_brush->length);
goto fail;
}


if (Stream_GetRemainingLength(s) < 8)
goto fail;

for (i = 7; i >= 0; i--)
{
Stream_Read_UINT8(s, cache_brush->data[i]);
}
}
else
{
if ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))
compressed = TRUE;
else if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))
compressed = TRUE;
else if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))
compressed = TRUE;

if (compressed != FALSE)
{

if (!update_decompress_brush(s, cache_brush->data, sizeof(cache_brush->data),
cache_brush->bpp))
goto fail;
}
else
{

UINT32 scanline = (cache_brush->bpp / 8) * 8;

if (Stream_GetRemainingLength(s) < scanline * 8)
goto fail;

for (i = 7; i >= 0; i--)
{
Stream_Read(s, &cache_brush->data[i * scanline], scanline);
}
}
}
}

return cache_brush;
fail:
free_cache_brush_order(update->context, cache_brush);
return NULL;
}","[4, 17, 20]","In FreeRDP before version 2.1.2, there is a global OOB read in update_read_cache_bitmap_v3_order. As a workaround, one can disable bitmap cache with -bitmap-cache (default). This is fixed in version 2.1.2."
205476," RenderFrameImpl::RenderFrameImpl(const CreateParams& params)
     : frame_(NULL),
       is_subframe_(false),
       is_local_root_(false),
       render_view_(params.render_view->AsWeakPtr()),
       routing_id_(params.routing_id),
       is_swapped_out_(false),
       render_frame_proxy_(NULL),
       is_detaching_(false),
       proxy_routing_id_(MSG_ROUTING_NONE),
 #if defined(ENABLE_PLUGINS)
       plugin_power_saver_helper_(NULL),
 #endif
       cookie_jar_(this),
       selection_text_offset_(0),
       selection_range_(gfx::Range::InvalidRange()),
       handling_select_range_(false),
       notification_permission_dispatcher_(NULL),
       web_user_media_client_(NULL),
       media_permission_dispatcher_(NULL),
       midi_dispatcher_(NULL),
 #if defined(OS_ANDROID)
       media_player_manager_(NULL),
 #endif
 #if defined(ENABLE_BROWSER_CDMS)
       cdm_manager_(NULL),
 #endif
 #if defined(VIDEO_HOLE)
       contains_media_player_(false),
 #endif
       has_played_media_(false),
       devtools_agent_(nullptr),
       geolocation_dispatcher_(NULL),
       push_messaging_dispatcher_(NULL),
       presentation_dispatcher_(NULL),
       screen_orientation_dispatcher_(NULL),
       manifest_manager_(NULL),
       accessibility_mode_(AccessibilityModeOff),
       renderer_accessibility_(NULL),
       weak_factory_(this) {
   std::pair<RoutingIDFrameMap::iterator, bool> result =
       g_routing_id_frame_map.Get().insert(std::make_pair(routing_id_, this));
   CHECK(result.second) << ""Inserting a duplicate item."";
 
   RenderThread::Get()->AddRoute(routing_id_, this);
 
   render_view_->RegisterRenderFrame(this);
 
 #if defined(OS_ANDROID)
   new GinJavaBridgeDispatcher(this);
 #endif
 
 #if defined(ENABLE_PLUGINS)
   plugin_power_saver_helper_ = new PluginPowerSaverHelper(this);
  #endif
  
    manifest_manager_ = new ManifestManager(this);
 
   GetServiceRegistry()->ConnectToRemoteService(mojo::GetProxy(&mojo_shell_));
  }","[58, 59]","Use-after-free vulnerability in modules/speech/SpeechSynthesis.cpp in Blink, as used in Google Chrome before 33.0.1750.149, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper handling of a certain utterance data structure."
6366,"service_info *FindServiceEventURLPath(
service_table *table, const char *eventURLPath)
{
service_info *finger = NULL;
uri_type parsed_url;
uri_type parsed_url_in;

if (table &&
parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==
HTTP_SUCCESS) {
finger = table->serviceList;
while (finger) {
if (finger->eventURL) {
if (parse_uri(finger->eventURL,
strlen(finger->eventURL),
&parsed_url) == HTTP_SUCCESS) {
if (!token_cmp(&parsed_url.pathquery,
&parsed_url_in.pathquery)) {
return finger;
}
}
}
finger = finger->next;
}
}

return NULL;
}","[8, 9, 10]",Portable UPnP SDK (aka libupnp) 1.12.1 and earlier allows remote attackers to cause a denial of service (crash) via a crafted SSDP message due to a NULL pointer dereference in the functions FindServiceControlURLPath and FindServiceEventURLPath in genlib/service_table/service_table.c.
198204," static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table TSRMLS_DC)
 {
 	size_t length;
 	int tag, format, components;
 	char *value_ptr, tagname[64], cbuf[32], *outside=NULL;
 	size_t byte_count, offset_val, fpos, fgot;
 	int64_t byte_count_signed;
 	xp_field_type *tmp_xp;
 #ifdef EXIF_DEBUG
 	char *dump_data;
 	int dump_free;
 #endif  
 
 	 
 	if (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {
 		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""corrupt EXIF header: maximum directory nesting level reached"");
 		return FALSE;
 	}
 	ImageInfo->ifd_nesting_level++;
 
 	tag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);
 	format = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);
 	components = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);
 
 	if (!format || format > NUM_FORMATS) {
 		 
 		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE"", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), format);
 		format = TAG_FMT_BYTE;
 		 
 	}
 
 	if (components < 0) {
 		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal components(%ld)"", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), components);
 		return FALSE;
 	}
 
 	byte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];
 
 	if (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {
 		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal byte_count"", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC));
 		return FALSE;
 	}
 
 	byte_count = (size_t)byte_count_signed;
 
 	if (byte_count > 4) {
 		offset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);
 		 
 		value_ptr = offset_base+offset_val;
          
 		if (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {
 			 
 			if (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {
 				if (value_ptr < dir_entry) {
 					 
 					 
 					exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)"", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, dir_entry);
 				} else {
 					 
 					 
 					exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)"", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, byte_count, offset_val+byte_count, IFDlength);
 				}
 				return FALSE;
 			}
 			if (byte_count>sizeof(cbuf)) {
 				 
 				value_ptr = safe_emalloc(byte_count, 1, 0);
 				outside = value_ptr;
 			} else {
 				 
 				memset(&cbuf, 0, sizeof(cbuf));
 				value_ptr = cbuf;
 			}
 
 			fpos = php_stream_tell(ImageInfo->infile);
 			php_stream_seek(ImageInfo->infile, offset_val, SEEK_SET);
 			fgot = php_stream_tell(ImageInfo->infile);
 			if (fgot!=offset_val) {
 				EFREE_IF(outside);
 				exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Wrong file pointer: 0x%08X != 0x%08X"", fgot, offset_val);
 				return FALSE;
 			}
 			fgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);
 			php_stream_seek(ImageInfo->infile, fpos, SEEK_SET);
 			if (fgot<byte_count) {
 				EFREE_IF(outside);
 				EXIF_ERRLOG_FILEEOF(ImageInfo)
 				return FALSE;
 			}
 		}
 	} else {
 		 
 		value_ptr = dir_entry+8;
 		offset_val= value_ptr-offset_base;
 	}
 
 	ImageInfo->sections_found |= FOUND_ANY_TAG;
 #ifdef EXIF_DEBUG
 	dump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr TSRMLS_CC);
 	exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s"", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?""ARRAY OF "":"""", exif_get_tagformat(format), dump_data);
 	if (dump_free) {
 		efree(dump_data);
 	}
 #endif
 
 	if (section_index==SECTION_THUMBNAIL) {
 		if (!ImageInfo->Thumbnail.data) {
 			switch(tag) {
 				case TAG_IMAGEWIDTH:
 				case TAG_COMP_IMAGE_WIDTH:
 					ImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 					break;
 
 				case TAG_IMAGEHEIGHT:
 				case TAG_COMP_IMAGE_HEIGHT:
 					ImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 					break;
 
 				case TAG_STRIP_OFFSETS:
 				case TAG_JPEG_INTERCHANGE_FORMAT:
 					 
 					ImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 					break;
 
 				case TAG_STRIP_BYTE_COUNTS:
 					if (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {
 						ImageInfo->Thumbnail.filetype = ImageInfo->FileType;
 					} else {
 						 
 						ImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;
 					}
 					ImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 					break;
 
 				case TAG_JPEG_INTERCHANGE_FORMAT_LEN:
 					if (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {
 						ImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;
 						ImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 					}
 					break;
 			}
 		}
 	} else {
 		if (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)
 		switch(tag) {
 			case TAG_COPYRIGHT:
 				 
 				if (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {
 					if (length<byte_count-1) {
                                                  
                                                 ImageInfo->CopyrightPhotographer  = estrdup(value_ptr);
                                                 ImageInfo->CopyrightEditor        = estrndup(value_ptr+length+1, byte_count-length-1);
                                               spprintf(&ImageInfo->Copyright, 0, ""%s, %s"", value_ptr, value_ptr+length+1);
                                                spprintf(&ImageInfo->Copyright, 0, ""%s, %s"", ImageInfo->CopyrightPhotographer, ImageInfo->CopyrightEditor);
                                                  
                                                  
                                                  
 					} else {
 						ImageInfo->Copyright = estrndup(value_ptr, byte_count);
 					}
 				}
 				break;
 
 			case TAG_USERCOMMENT:
 				ImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count TSRMLS_CC);
 				break;
 
 			case TAG_XP_TITLE:
 			case TAG_XP_COMMENTS:
 			case TAG_XP_AUTHOR:
 			case TAG_XP_KEYWORDS:
 			case TAG_XP_SUBJECT:
 				tmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);
 				ImageInfo->sections_found |= FOUND_WINXP;
 				ImageInfo->xp_fields.list = tmp_xp;
 				ImageInfo->xp_fields.count++;
 				exif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count TSRMLS_CC);
 				break;
 
 			case TAG_FNUMBER:
 				 
 				ImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 				break;
 
 			case TAG_APERTURE:
 			case TAG_MAX_APERTURE:
 				 
 				if (ImageInfo->ApertureFNumber == 0) {
 					ImageInfo->ApertureFNumber
 						= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)*0.5);
 				}
 				break;
 
 			case TAG_SHUTTERSPEED:
 				 
 				if (ImageInfo->ExposureTime == 0) {
 					ImageInfo->ExposureTime
 						= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)));
 				}
 				break;
 			case TAG_EXPOSURETIME:
 				ImageInfo->ExposureTime = -1;
 				break;
 
 			case TAG_COMP_IMAGE_WIDTH:
 				ImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 				break;
 
 			case TAG_FOCALPLANE_X_RES:
 				ImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 				break;
 
 			case TAG_SUBJECT_DISTANCE:
 				 
 				ImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);
 				break;
 
 			case TAG_FOCALPLANE_RESOLUTION_UNIT:
 				switch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)) {
 					case 1: ImageInfo->FocalplaneUnits = 25.4; break;  
 					case 2:
 						 
 						ImageInfo->FocalplaneUnits = 25.4;
 						break;
 
 					case 3: ImageInfo->FocalplaneUnits = 10;   break;   
 					case 4: ImageInfo->FocalplaneUnits = 1;    break;   
 					case 5: ImageInfo->FocalplaneUnits = .001; break;   
 				}
 				break;
 
 			case TAG_SUB_IFD:
 				if (format==TAG_FMT_IFD) {
 					 
 					 
 					 
 					exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Skip SUB IFD"");
 				}
 				break;
 
 			case TAG_MAKE:
 				ImageInfo->make = estrndup(value_ptr, byte_count);
 				break;
 			case TAG_MODEL:
 				ImageInfo->model = estrndup(value_ptr, byte_count);
 				break;
 
 			case TAG_MAKER_NOTE:
 				exif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement TSRMLS_CC);
 				break;
 
 			case TAG_EXIF_IFD_POINTER:
 			case TAG_GPS_IFD_POINTER:
 			case TAG_INTEROP_IFD_POINTER:
 				if (ReadNextIFD) {
 					char *Subdir_start;
 					int sub_section_index = 0;
 					switch(tag) {
 						case TAG_EXIF_IFD_POINTER:
 #ifdef EXIF_DEBUG
 							exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found EXIF"");
 #endif
 							ImageInfo->sections_found |= FOUND_EXIF;
 							sub_section_index = SECTION_EXIF;
 							break;
 						case TAG_GPS_IFD_POINTER:
 #ifdef EXIF_DEBUG
 							exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found GPS"");
 #endif
 							ImageInfo->sections_found |= FOUND_GPS;
 							sub_section_index = SECTION_GPS;
 							break;
 						case TAG_INTEROP_IFD_POINTER:
 #ifdef EXIF_DEBUG
 							exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found INTEROPERABILITY"");
 #endif
 							ImageInfo->sections_found |= FOUND_INTEROP;
 							sub_section_index = SECTION_INTEROP;
 							break;
 					}
 					Subdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);
 					if (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {
 						exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD Pointer"");
 						return FALSE;
 					}
 					if (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index TSRMLS_CC)) {
 						return FALSE;
 					}
 #ifdef EXIF_DEBUG
 					exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(sub_section_index));
 #endif
 				}
 		}
 	}
 	exif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table TSRMLS_CC), tag, format, components, value_ptr TSRMLS_CC);
 	EFREE_IF(outside);
 	return TRUE;
 }","[154, 153]","The exif_process_TIFF_in_JPEG function in ext/exif/exif.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 does not validate TIFF start data, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via crafted header data."
199161," static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 			    struct flowi *fl, struct sock *sk)
 {
 	struct sctp_association *asoc = t->asoc;
  	struct dst_entry *dst = NULL;
  	struct flowi6 *fl6 = &fl->u.ip6;
  	struct sctp_bind_addr *bp;
 	struct ipv6_pinfo *np = inet6_sk(sk);
  	struct sctp_sockaddr_entry *laddr;
  	union sctp_addr *baddr = NULL;
  	union sctp_addr *daddr = &t->ipaddr;
  	union sctp_addr dst_saddr;
 	struct in6_addr *final_p, final;
  	__u8 matchlen = 0;
  	__u8 bmatchlen;
  	sctp_scope_t scope;
 
 	memset(fl6, 0, sizeof(struct flowi6));
 	fl6->daddr = daddr->v6.sin6_addr;
 	fl6->fl6_dport = daddr->v6.sin6_port;
 	fl6->flowi6_proto = IPPROTO_SCTP;
 	if (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
 		fl6->flowi6_oif = daddr->v6.sin6_scope_id;
 
 	pr_debug(""%s: dst=%pI6 "", __func__, &fl6->daddr);
 
 	if (asoc)
 		fl6->fl6_sport = htons(asoc->base.bind_addr.port);
 
 	if (saddr) {
 		fl6->saddr = saddr->v6.sin6_addr;
 		fl6->fl6_sport = saddr->v6.sin6_port;
 
  		pr_debug(""src=%pI6 - "", &fl6->saddr);
  	}
  
	dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
 	final_p = fl6_update_dst(fl6, np->opt, &final);
 	dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
  	if (!asoc || saddr)
  		goto out;
  
 	bp = &asoc->base.bind_addr;
 	scope = sctp_scope(daddr);
 	 
 	if (!IS_ERR(dst)) {
 		 
 		sctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));
 		rcu_read_lock();
 		list_for_each_entry_rcu(laddr, &bp->address_list, list) {
 			if (!laddr->valid || (laddr->state != SCTP_ADDR_SRC))
 				continue;
 
 			 
 			if ((laddr->a.sa.sa_family == AF_INET6) &&
 			    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {
 				rcu_read_unlock();
 				goto out;
 			}
 		}
 		rcu_read_unlock();
 		 
 		dst_release(dst);
 		dst = NULL;
 	}
 
 	 
 	rcu_read_lock();
 	list_for_each_entry_rcu(laddr, &bp->address_list, list) {
 		if (!laddr->valid)
 			continue;
 		if ((laddr->state == SCTP_ADDR_SRC) &&
 		    (laddr->a.sa.sa_family == AF_INET6) &&
 		    (scope <= sctp_scope(&laddr->a))) {
 			bmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);
 			if (!baddr || (matchlen < bmatchlen)) {
 				baddr = &laddr->a;
 				matchlen = bmatchlen;
 			}
  		}
  	}
  	rcu_read_unlock();
 
  	if (baddr) {
  		fl6->saddr = baddr->v6.sin6_addr;
  		fl6->fl6_sport = baddr->v6.sin6_port;
		dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
 		final_p = fl6_update_dst(fl6, np->opt, &final);
 		dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
  	}
  
  out:
 	if (!IS_ERR_OR_NULL(dst)) {
 		struct rt6_info *rt;
 
 		rt = (struct rt6_info *)dst;
 		t->dst = dst;
 		t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
 		pr_debug(""rt6_dst:%pI6 rt6_src:%pI6\n"", &rt->rt6i_dst.addr,
 			 &fl6->saddr);
 	} else {
 		t->dst = NULL;
 
 		pr_debug(""no route\n"");
 	}
 }","[8, 13, 38, 39, 83, 88, 89, 37, 87]","The IPv6 SCTP implementation in net/sctp/ipv6.c in the Linux kernel through 3.11.1 uses data structures and function calls that do not trigger an intended configuration of IPsec encryption, which allows remote attackers to obtain sensitive information by sniffing the network."
8136,"static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,
int uncompressed_size, EXRThreadData *td)
{
int64_t version, lo_usize, lo_size;
int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;
int64_t ac_count, dc_count, ac_compression;
const int dc_w = td->xsize >> 3;
const int dc_h = td->ysize >> 3;
GetByteContext gb, agb;
int skip, ret;

if (compressed_size <= 88)
return AVERROR_INVALIDDATA;

version = AV_RL64(src + 0);
if (version != 2)
return AVERROR_INVALIDDATA;

lo_usize = AV_RL64(src + 8);
lo_size = AV_RL64(src + 16);
ac_size = AV_RL64(src + 24);
dc_size = AV_RL64(src + 32);
rle_csize = AV_RL64(src + 40);
rle_usize = AV_RL64(src + 48);
rle_raw_size = AV_RL64(src + 56);
ac_count = AV_RL64(src + 64);
dc_count = AV_RL64(src + 72);
ac_compression = AV_RL64(src + 80);

if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)
return AVERROR_INVALIDDATA;

bytestream2_init(&gb, src + 88, compressed_size - 88);
skip = bytestream2_get_le16(&gb);
if (skip < 2)
return AVERROR_INVALIDDATA;

bytestream2_skip(&gb, skip - 2);

if (lo_size > 0) {
if (lo_usize > uncompressed_size)
return AVERROR_INVALIDDATA;
bytestream2_skip(&gb, lo_size);
}

if (ac_size > 0) {
unsigned long dest_len = ac_count * 2LL;
GetByteContext agb = gb;

if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)
return AVERROR_INVALIDDATA;

av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);
if (!td->ac_data)
return AVERROR(ENOMEM);

switch (ac_compression) {
case 0:
ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);
if (ret < 0)
return ret;
break;
case 1:
if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||
dest_len != ac_count * 2LL)
return AVERROR_INVALIDDATA;
break;
default:
return AVERROR_INVALIDDATA;
}

bytestream2_skip(&gb, ac_size);
}

if (dc_size > 0) {
unsigned long dest_len = dc_count * 2LL;
GetByteContext agb = gb;

if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)
return AVERROR_INVALIDDATA;

av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);
if (!td->dc_data)
return AVERROR(ENOMEM);

if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||
(dest_len != dc_count * 2LL))
return AVERROR_INVALIDDATA;

s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);
s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);

bytestream2_skip(&gb, dc_size);
}

if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {
unsigned long dest_len = rle_usize;

av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);
if (!td->rle_data)
return AVERROR(ENOMEM);

av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);
if (!td->rle_raw_data)
return AVERROR(ENOMEM);

if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||
(dest_len != rle_usize))
return AVERROR_INVALIDDATA;

ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);
if (ret < 0)
return ret;
bytestream2_skip(&gb, rle_csize);
}

bytestream2_init(&agb, td->ac_data, ac_count * 2);

for (int y = 0; y < td->ysize; y += 8) {
for (int x = 0; x < td->xsize; x += 8) {
memset(td->block, 0, sizeof(td->block));

for (int j = 0; j < 3; j++) {
float *block = td->block[j];
const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;
uint16_t *dc = (uint16_t *)td->dc_data;
union av_intfloat32 dc_val;

dc_val.i = half2float(dc[idx], s->mantissatable,
s->exponenttable, s->offsettable);

block[0] = dc_val.f;
ac_uncompress(s, &agb, block);
dct_inverse(block);
}

{
const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;
const int o = s->nb_channels == 4;
float *bo = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;
float *go = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;
float *ro = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;
float *yb = td->block[0];
float *ub = td->block[1];
float *vb = td->block[2];

for (int yy = 0; yy < 8; yy++) {
for (int xx = 0; xx < 8; xx++) {
const int idx = xx + yy * 8;

convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);

bo[xx] = to_linear(bo[xx], scale);
go[xx] = to_linear(go[xx], scale);
ro[xx] = to_linear(ro[xx], scale);
}

bo += td->xsize * s->nb_channels;
go += td->xsize * s->nb_channels;
ro += td->xsize * s->nb_channels;
}
}
}
}

if (s->nb_channels < 4)
return 0;

for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {
uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;
uint8_t *ai0 = td->rle_raw_data + y * td->xsize;
uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;

for (int x = 0; x < td->xsize; x++) {
uint16_t ha = ai0[x] | (ai1[x] << 8);

ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);
}
}

return 0;
}","[75, 79]",dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked.
202741," static void load_xref_from_plaintext(FILE *fp, xref_t *xref)
 {
     int  i, buf_idx, obj_id, added_entries;
     char c, buf[32] = {0};
     long start, pos;
 
     start = ftell(fp);
 
      
     pos = xref->end;
     fseek(fp, pos, SEEK_SET);
     while (ftell(fp) != 0)
       if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))
         break;
       else
         SAFE_E(fseek(fp, --pos, SEEK_SET), 0, ""Failed seek to xref /Size.\n"");
  
      SAFE_E(fread(buf, 1, 21, fp), 21, ""Failed to load entry Size string.\n"");
      xref->n_entries = atoi(buf + strlen(""ize ""));
    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));
     xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));
  
       
      obj_id = 0;
     fseek(fp, xref->start + strlen(""xref""), SEEK_SET);
     added_entries = 0;
     for (i=0; i<xref->n_entries; i++)
     {
          
         c = fgetc(fp);
         while (c == '\n' || c == '\r')
           c = fgetc(fp);
 
          
         buf_idx = 0;
         while (c != '\n' && c != '\r' && !feof(fp) &&
                !ferror(fp) && buf_idx < sizeof(buf))
         {
             buf[buf_idx++] = c;
             c = fgetc(fp);
         }
         if (buf_idx >= sizeof(buf))
         {
             ERR(""Failed to locate newline character. ""
                 ""This might be a corrupt PDF.\n"");
             exit(EXIT_FAILURE);
         }
         buf[buf_idx] = '\0';
 
          
         if (strchr(buf, 't'))
           break;
 
          
         if (strlen(buf) > 17)
         {
             xref->entries[i].obj_id = obj_id++;
             xref->entries[i].offset = atol(strtok(buf, "" ""));
             xref->entries[i].gen_num = atoi(strtok(NULL, "" ""));
             xref->entries[i].f_or_n = buf[17];
             ++added_entries;
         }
         else
         {
             obj_id = atoi(buf);
             --i;
         }
     }
 
     xref->n_entries = added_entries;
     fseek(fp, start, SEEK_SET);
 }","[21, 20]","An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write."
203301," hcom_client_init
 (
 		OUT	p_hsm_com_client_hdl_t	*p_hdl,
 	IN		char					*server_path,
 	IN		char					*client_path,
 	IN		int						max_data_len
 )
 {
 	hsm_com_client_hdl_t	*hdl = NULL;
 	hsm_com_errno_t			res = HSM_COM_OK;
 	
 
 	if((strlen(server_path) > (HSM_COM_SVR_MAX_PATH - 1)) ||
 	   (strlen(server_path) == 0)){
 		res = HSM_COM_PATH_ERR;
 		goto cleanup;
 	}
 
 	if((strlen(client_path) > (HSM_COM_SVR_MAX_PATH - 1)) ||
 	   (strlen(client_path) == 0)){
 		res = HSM_COM_PATH_ERR;
 		goto cleanup;
 	}
 
 
 	if((hdl = calloc(1,sizeof(hsm_com_client_hdl_t))) == NULL)
 	{
 		res = HSM_COM_NO_MEM;
 		goto cleanup;
 	}
 
 	if((hdl->scr.scratch = malloc(max_data_len)) == NULL) 
 	{
 		res = HSM_COM_NO_MEM;
 		goto cleanup;
 	}
 
 	if((hdl->recv_buf = malloc(max_data_len)) == NULL) 
 	{
 		res = HSM_COM_NO_MEM;
 		goto cleanup;
 	}
 
 	if((hdl->send_buf = malloc(max_data_len)) == NULL) 
 	{
 		res = HSM_COM_NO_MEM;
 		goto cleanup;
 	}
 
 	hdl->scr.scratch_fill = 0;
 	hdl->scr.scratch_len = max_data_len;
 	hdl->buf_len = max_data_len;
 	hdl->trans_id = 1;
 
 
  	strcpy(hdl->s_path,server_path);
  	strcpy(hdl->c_path,client_path);
  
 	if (mkstemp(hdl->c_path) == -1)
 	{
 		res = HSM_COM_PATH_ERR;
 		goto cleanup;
 	}
  
  	hdl->client_state = HSM_COM_C_STATE_IN;
  
 	*p_hdl = hdl;
 
 	return res;
 
 cleanup:
 	if(hdl)
 	{
 		if (hdl->scr.scratch) {
 			free(hdl->scr.scratch);
 		}
 		if (hdl->recv_buf) {
 			free(hdl->recv_buf);
 		}
 		free(hdl);
 	}
 
 	return res;
 
 }","[59, 60, 61, 62, 63]",Race conditions in opa-fm before 10.4.0.0.196 and opa-ff before 10.4.0.0.197.
207298,"  NotificationsNativeHandler::NotificationsNativeHandler(ScriptContext* context)
      : ObjectBackedNativeHandler(context) {
    RouteFunction(
      ""GetNotificationImageSizes"",
       ""GetNotificationImageSizes"", ""notifications"",
        base::Bind(&NotificationsNativeHandler::GetNotificationImageSizes,
                   base::Unretained(this)));
  }","[5, 4]",The extensions subsystem in Google Chrome before 51.0.2704.63 allows remote attackers to bypass the Same Origin Policy via unspecified vectors.
202781,"  int insn_get_code_seg_params(struct pt_regs *regs)
  {
	struct desc_struct *desc;
 	struct desc_struct desc;
  	short sel;
  
  	if (v8086_mode(regs))
 		 
 		return INSN_CODE_SEG_PARAMS(2, 2);
 
 	sel = get_segment_selector(regs, INAT_SEG_REG_CS);
  	if (sel < 0)
  		return sel;
  
	desc = get_desc(sel);
	if (!desc)
 	if (!get_desc(&desc, sel))
  		return -EINVAL;
  
  	 
	if (!(desc->type & BIT(3)))
 	if (!(desc.type & BIT(3)))
  		return -EINVAL;
  
	switch ((desc->l << 1) | desc->d) {
 	switch ((desc.l << 1) | desc.d) {
  	case 0:  
 		return INSN_CODE_SEG_PARAMS(2, 2);
 	case 1:  
 		return INSN_CODE_SEG_PARAMS(4, 4);
 	case 2:  
 		return INSN_CODE_SEG_PARAMS(4, 8);
 	case 3:  
 		 
 	default:
 		return -EINVAL;
 	}
 }","[4, 17, 22, 26, 3, 15, 16, 21, 25]","In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation."
202218," int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,
 		     unsigned int *tag_out, size_t *taglen)
 {
 	const u8 *p = *buf;
 	size_t left = buflen, len;
 	unsigned int cla, tag, i;
 
 	if (left < 2)
 		return SC_ERROR_INVALID_ASN1_OBJECT;
 	*buf = NULL;
 	if (*p == 0xff || *p == 0) {
 		 
 		*taglen = 0;
 		*tag_out = SC_ASN1_TAG_EOC;
 		return SC_SUCCESS;
 	}
 	 
 	cla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);
 	tag = *p & SC_ASN1_TAG_PRIMITIVE;
 	p++;
 	left--;
 	if (tag == SC_ASN1_TAG_PRIMITIVE) {
 		 
 		size_t n = SC_ASN1_TAGNUM_SIZE - 1;
 		 
 		while (left-- != 0 && n != 0) {
 			tag <<= 8;
 			tag |= *p;
 			if ((*p++ & 0x80) == 0)
 				break;
 			n--;
 		}
 		if (left == 0 || n == 0)
 			 
 			return SC_ERROR_INVALID_ASN1_OBJECT;
 	}
 
 	 
  	len = *p & 0x7f;
  	if (*p++ & 0x80) {
  		unsigned int a = 0;
 		left--;
  		if (len > 4 || len > left)
  			return SC_ERROR_INVALID_ASN1_OBJECT;
  		left -= len;
 		for (i = 0; i < len; i++) {
 			a <<= 8;
 			a |= *p;
 			p++;
 		}
 		len = a;
 	}
 
 	*cla_out = cla;
 	*tag_out = tag;
 	*taglen = len;
 	*buf = p;
 
 	if (len > left)
 		return SC_ERROR_ASN1_END_OF_CONTENTS;
 
 	return SC_SUCCESS;
 }",[42],Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.
200894,"  int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {
  	op->len = 1;
  	op->op = buf[0];
	if (op->op > 0xbf) return 1;
 	if (op->op > 0xbf) {
 		return 1;
 	}
  	WasmOpDef *opdef = &opcodes[op->op];
  	switch (op->op) {
 	case WASM_OP_TRAP:
 	case WASM_OP_NOP:
 	case WASM_OP_ELSE:
 	case WASM_OP_RETURN:
 	case WASM_OP_DROP:
 	case WASM_OP_SELECT:
 	case WASM_OP_I32EQZ: 
 	case WASM_OP_I32EQ: 
 	case WASM_OP_I32NE: 
 	case WASM_OP_I32LTS: 
 	case WASM_OP_I32LTU: 
 	case WASM_OP_I32GTS: 
 	case WASM_OP_I32GTU: 
 	case WASM_OP_I32LES: 
 	case WASM_OP_I32LEU: 
 	case WASM_OP_I32GES: 
 	case WASM_OP_I32GEU: 
 	case WASM_OP_I64EQZ: 
 	case WASM_OP_I64EQ: 
 	case WASM_OP_I64NE: 
 	case WASM_OP_I64LTS: 
 	case WASM_OP_I64LTU: 
 	case WASM_OP_I64GTS: 
 	case WASM_OP_I64GTU: 
 	case WASM_OP_I64LES: 
 	case WASM_OP_I64LEU: 
 	case WASM_OP_I64GES: 
 	case WASM_OP_I64GEU: 
 	case WASM_OP_F32EQ: 
 	case WASM_OP_F32NE: 
 	case WASM_OP_F32LT: 
 	case WASM_OP_F32GT: 
 	case WASM_OP_F32LE: 
 	case WASM_OP_F32GE: 
 	case WASM_OP_F64EQ: 
 	case WASM_OP_F64NE: 
 	case WASM_OP_F64LT: 
 	case WASM_OP_F64GT: 
 	case WASM_OP_F64LE: 
 	case WASM_OP_F64GE: 
 	case WASM_OP_I32CLZ: 
 	case WASM_OP_I32CTZ: 
 	case WASM_OP_I32POPCNT: 
 	case WASM_OP_I32ADD: 
 	case WASM_OP_I32SUB: 
 	case WASM_OP_I32MUL: 
 	case WASM_OP_I32DIVS: 
 	case WASM_OP_I32DIVU: 
 	case WASM_OP_I32REMS: 
 	case WASM_OP_I32REMU: 
 	case WASM_OP_I32AND: 
 	case WASM_OP_I32OR: 
 	case WASM_OP_I32XOR: 
 	case WASM_OP_I32SHL: 
 	case WASM_OP_I32SHRS: 
 	case WASM_OP_I32SHRU: 
 	case WASM_OP_I32ROTL: 
 	case WASM_OP_I32ROTR: 
 	case WASM_OP_I64CLZ: 
 	case WASM_OP_I64CTZ: 
 	case WASM_OP_I64POPCNT: 
 	case WASM_OP_I64ADD: 
 	case WASM_OP_I64SUB: 
 	case WASM_OP_I64MUL: 
 	case WASM_OP_I64DIVS: 
 	case WASM_OP_I64DIVU: 
 	case WASM_OP_I64REMS: 
 	case WASM_OP_I64REMU: 
 	case WASM_OP_I64AND: 
 	case WASM_OP_I64OR: 
 	case WASM_OP_I64XOR: 
 	case WASM_OP_I64SHL: 
 	case WASM_OP_I64SHRS: 
 	case WASM_OP_I64SHRU: 
 	case WASM_OP_I64ROTL: 
 	case WASM_OP_I64ROTR: 
 	case WASM_OP_F32ABS: 
 	case WASM_OP_F32NEG: 
 	case WASM_OP_F32CEIL: 
 	case WASM_OP_F32FLOOR: 
 	case WASM_OP_F32TRUNC: 
 	case WASM_OP_F32NEAREST: 
 	case WASM_OP_F32SQRT: 
 	case WASM_OP_F32ADD: 
 	case WASM_OP_F32SUB: 
 	case WASM_OP_F32MUL: 
 	case WASM_OP_F32DIV: 
 	case WASM_OP_F32MIN: 
 	case WASM_OP_F32MAX: 
 	case WASM_OP_F32COPYSIGN: 
 	case WASM_OP_F64ABS: 
 	case WASM_OP_F64NEG: 
 	case WASM_OP_F64CEIL: 
 	case WASM_OP_F64FLOOR: 
 	case WASM_OP_F64TRUNC: 
 	case WASM_OP_F64NEAREST: 
 	case WASM_OP_F64SQRT: 
 	case WASM_OP_F64ADD: 
 	case WASM_OP_F64SUB: 
 	case WASM_OP_F64MUL: 
 	case WASM_OP_F64DIV: 
 	case WASM_OP_F64MIN: 
 	case WASM_OP_F64MAX: 
 	case WASM_OP_F64COPYSIGN: 
 	case WASM_OP_I32WRAPI64: 
 	case WASM_OP_I32TRUNCSF32: 
 	case WASM_OP_I32TRUNCUF32: 
 	case WASM_OP_I32TRUNCSF64: 
 	case WASM_OP_I32TRUNCUF64: 
 	case WASM_OP_I64EXTENDSI32: 
 	case WASM_OP_I64EXTENDUI32: 
 	case WASM_OP_I64TRUNCSF32: 
 	case WASM_OP_I64TRUNCUF32: 
 	case WASM_OP_I64TRUNCSF64: 
 	case WASM_OP_I64TRUNCUF64: 
 	case WASM_OP_F32CONVERTSI32: 
 	case WASM_OP_F32CONVERTUI32: 
 	case WASM_OP_F32CONVERTSI64: 
 	case WASM_OP_F32CONVERTUI64: 
 	case WASM_OP_F32DEMOTEF64: 
 	case WASM_OP_F64CONVERTSI32: 
 	case WASM_OP_F64CONVERTUI32: 
 	case WASM_OP_F64CONVERTSI64: 
 	case WASM_OP_F64CONVERTUI64: 
 	case WASM_OP_F64PROMOTEF32: 
 	case WASM_OP_I32REINTERPRETF32: 
 	case WASM_OP_I64REINTERPRETF64: 
 	case WASM_OP_F32REINTERPRETI32: 
 	case WASM_OP_F64REINTERPRETI64:
 	case WASM_OP_END:
 		{
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s"", opdef->txt);
 		}
 		break;
 	case WASM_OP_BLOCK:
 	case WASM_OP_LOOP:
 	case WASM_OP_IF:
 		{
 			st32 val = 0;
 			size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			switch (0x80 - val) {
 			case R_BIN_WASM_VALUETYPE_EMPTY:
 				snprintf (op->txt, R_ASM_BUFSIZE, ""%s"", opdef->txt);
 				break;
 			case R_BIN_WASM_VALUETYPE_i32:
 				snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result i32)"", opdef->txt);
 				break;
 			case R_BIN_WASM_VALUETYPE_i64:
 				snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result i64)"", opdef->txt);
 				break;
 			case R_BIN_WASM_VALUETYPE_f32:
 				snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result f32)"", opdef->txt);
 				break;
 			case R_BIN_WASM_VALUETYPE_f64:
 				snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result f64)"", opdef->txt);
 				break;
 			default:
 				snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result ?)"", opdef->txt);
 				break;
 			}
 			op->len += n;
 		}
 		break;
 	case WASM_OP_BR:
 	case WASM_OP_BRIF:
 	case WASM_OP_CALL:
 		{
 			ut32 val = 0;
 			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d"", opdef->txt, val);
 			op->len += n;
 		}
 		break;
 	case WASM_OP_BRTABLE:
  		{
  			ut32 count = 0, *table = NULL, def = 0;
  			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);
			if (!(n > 0 && n < buf_len)) goto err;
			if (!(table = calloc (count, sizeof (ut32)))) goto err;
 			if (!(n > 0 && n < buf_len)) {
 				goto err;
 			}
 			if (!(table = calloc (count, sizeof (ut32)))) {
 				goto err;
 			}
  			int i = 0;
  			op->len += n;
  			for (i = 0; i < count; i++) {
  				n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);
				if (!(op->len + n <= buf_len)) goto beach;
 				if (!(op->len + n <= buf_len)) {
 					goto beach;
 				}
  				op->len += n;
  			}
  			n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);
			if (!(n > 0 && n + op->len < buf_len)) goto beach;
 			if (!(n > 0 && n + op->len < buf_len)) {
 				goto beach;
 			}
  			op->len += n;
  			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d "", opdef->txt, count);
			for (i = 0; i < count && strlen (op->txt) < R_ASM_BUFSIZE; i++) {
				snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, ""%d "", table[i]);
 			for (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {
 				int optxtlen = strlen (op->txt);
 				snprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, ""%d "", table[i]);
  			}	
  			snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, ""%d"", def);
  			free (table);
  			break;
  			beach:
				free (table);
				goto err;
 			free (table);
 			goto err;
  		}
  		break;
  	case WASM_OP_CALLINDIRECT:
 		{
 			ut32 val = 0, reserved = 0;
 			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			op->len += n;
 			n = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);
 			if (!(n == 1 && op->len + n <= buf_len)) goto err;
 			reserved &= 0x1;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d %d"", opdef->txt, val, reserved);
 			op->len += n;
 		}
 		break;
 	case WASM_OP_GETLOCAL:
 	case WASM_OP_SETLOCAL:
 	case WASM_OP_TEELOCAL:
 	case WASM_OP_GETGLOBAL:
 	case WASM_OP_SETGLOBAL:
 		{
 			ut32 val = 0;
 			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d"", opdef->txt, val);
 			op->len += n;
 		}
 		break;
 	case WASM_OP_I32LOAD:
 	case WASM_OP_I64LOAD: 
 	case WASM_OP_F32LOAD: 
 	case WASM_OP_F64LOAD: 
 	case WASM_OP_I32LOAD8S: 
 	case WASM_OP_I32LOAD8U: 
 	case WASM_OP_I32LOAD16S: 
 	case WASM_OP_I32LOAD16U: 
 	case WASM_OP_I64LOAD8S: 
 	case WASM_OP_I64LOAD8U: 
 	case WASM_OP_I64LOAD16S: 
 	case WASM_OP_I64LOAD16U: 
 	case WASM_OP_I64LOAD32S: 
 	case WASM_OP_I64LOAD32U: 
 	case WASM_OP_I32STORE: 
 	case WASM_OP_I64STORE: 
 	case WASM_OP_F32STORE: 
 	case WASM_OP_F64STORE: 
 	case WASM_OP_I32STORE8: 
 	case WASM_OP_I32STORE16: 
 	case WASM_OP_I64STORE8: 
 	case WASM_OP_I64STORE16: 
 	case WASM_OP_I64STORE32: 
 		{
 			ut32 flag = 0, offset = 0;
 			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);
 			if (!(n > 0 && n < buf_len)) goto err;
 			op->len += n;
 			n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);
 			if (!(n > 0 && op->len + n <= buf_len)) goto err;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d %d"", opdef->txt, flag, offset);
 			op->len += n;
 		}
 		break;
 	case WASM_OP_CURRENTMEMORY:
 	case WASM_OP_GROWMEMORY:
 		{
 			ut32 reserved = 0;
 			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);
 			if (!(n == 1 && n < buf_len)) goto err;
 			reserved &= 0x1;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d"", opdef->txt, reserved); 
 			op->len += n;
 		}
 		break;
 
 	case WASM_OP_I32CONST:
 		{
 			st32 val = 0;
 			size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" PFMT32d, opdef->txt, val);
 			op->len += n;
 		}
 		break;
 	case WASM_OP_I64CONST:
 		{
 			st64 val = 0;
 			size_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" PFMT64d, opdef->txt, val);
 			op->len += n;
 		}
 		break;
 	case WASM_OP_F32CONST:
 		{
 			ut32 val = 0;
 			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			long double d =  (long double)val;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" LDBLFMT, opdef->txt, d);
 			op->len += n;
 		}
 		break;
 	case WASM_OP_F64CONST:
 		{
 			ut64 val = 0;
 			size_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);
 			if (!(n > 0 && n < buf_len)) goto err;
 			long double d =  (long double)val;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" LDBLFMT, opdef->txt, d);
 			op->len += n;
 		}
 		break;
 	default:
 		goto err;
 	}
 
 	return op->len;
 
 err:
 	op->len = 1;
  	snprintf (op->txt, R_ASM_BUFSIZE, ""invalid"");
  	return op->len;
  }","[5, 6, 7, 191, 192, 193, 194, 195, 196, 202, 203, 204, 209, 210, 211, 216, 217, 218, 226, 227, 4, 189, 190, 201, 208, 214, 215, 224, 225]",The wasm_dis function in libr/asm/arch/wasm/wasm.c in radare2 2.0.0 allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted WASM file that triggers an incorrect r_hex_bin2str call.
200871," int key_update(key_ref_t key_ref, const void *payload, size_t plen)
 {
 	struct key_preparsed_payload prep;
 	struct key *key = key_ref_to_ptr(key_ref);
 	int ret;
 
 	key_check(key);
 
 	 
 	ret = key_permission(key_ref, KEY_NEED_WRITE);
 	if (ret < 0)
 		return ret;
 
 	 
 	if (!key->type->update)
 		return -EOPNOTSUPP;
 
 	memset(&prep, 0, sizeof(prep));
 	prep.data = payload;
 	prep.datalen = plen;
 	prep.quotalen = key->type->def_datalen;
 	prep.expiry = TIME_T_MAX;
 	if (key->type->preparse) {
 		ret = key->type->preparse(&prep);
 		if (ret < 0)
 			goto error;
 	}
 
 	down_write(&key->sem);
  
  	ret = key->type->update(key, &prep);
  	if (ret == 0)
 		 
		clear_bit(KEY_FLAG_NEGATIVE, &key->flags);
 		mark_key_instantiated(key, 0);
  
  	up_write(&key->sem);
  
 error:
 	if (key->type->preparse)
 		key->type->free_preparse(&prep);
 	return ret;
 }","[35, 34]","The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the *negative* state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."
197948," pax_decode_header (struct tar_sparse_file *file)
 {
   if (file->stat_info->sparse_major > 0)
     {
       uintmax_t u;
       char nbuf[UINTMAX_STRSIZE_BOUND];
       union block *blk;
       char *p;
       size_t i;
       off_t start;
       
 #define COPY_BUF(b,buf,src) do                                     \
  {                                                                 \
    char *endp = b->buffer + BLOCKSIZE;                             \
    char *dst = buf;                                                \
    do                                                              \
      {                                                             \
        if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \
          {                                                         \
            ERROR ((0, 0, _(""%s: numeric overflow in sparse archive member""), \
 	          file->stat_info->orig_file_name));               \
            return false;                                           \
          }                                                         \
        if (src == endp)                                            \
  	 {                                                         \
  	   set_next_block_after (b);                               \
             b = find_next_block ();                                 \
            if (!b)                                                 \
              FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive""))); \
             src = b->buffer;                                        \
  	   endp = b->buffer + BLOCKSIZE;                           \
  	 }                                                         \
    while (*dst++ != '\n');                                         \
    dst[-1] = 0;                                                    \
  } while (0)
 
       start = current_block_ordinal ();
       set_next_block_after (current_header);
        start = current_block_ordinal ();
        set_next_block_after (current_header);
        blk = find_next_block ();
       if (!blk)
         FATAL_ERROR ((0, 0, _(""Unexpected EOF in archive"")));
        p = blk->buffer;
        COPY_BUF (blk,nbuf,p);
        if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))
 	}
       file->stat_info->sparse_map_size = u;
       file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,
 					     sizeof (*file->stat_info->sparse_map));
       file->stat_info->sparse_map_avail = 0;
       for (i = 0; i < file->stat_info->sparse_map_size; i++)
 	{
 	  struct sp_array sp;
 
 	  COPY_BUF (blk,nbuf,p);
 	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
 	    {
 	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
 		      file->stat_info->orig_file_name));
 	      return false;
 	    }
 	  sp.offset = u;
 	  COPY_BUF (blk,nbuf,p);
 	  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))
 	    {
 	      ERROR ((0, 0, _(""%s: malformed sparse archive member""),
 		      file->stat_info->orig_file_name));
 	      return false;
 	    }
 	  sp.numbytes = u;
 	  sparse_add_map (file->stat_info, &sp);
 	}
       set_next_block_after (blk);
 
       file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);
     }
 
   return true;
 }","[28, 29, 42, 43]",pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.
201390," static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
 static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,
 			 const void *data)
  {
 	u8 *buf;
  	int ret;
  
 	buf = kmemdup(data, size, GFP_NOIO);
 	if (!buf)
 		return -ENOMEM;
 
  	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
  			      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,
			      indx, data, size, 100);
 			      indx, buf, size, 100);
  	if (ret < 0)
  		netif_dbg(pegasus, drv, pegasus->net,
  			  ""%s returned %d\n"", __func__, ret);
 	kfree(buf);
  	return ret;
  }","[2, 3, 5, 8, 9, 10, 11, 15, 19, 14]","drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
198677,"  jbig2_text_region(Jbig2Ctx *ctx, Jbig2Segment *segment, const byte *segment_data)
  {
    int offset = 0;
     uint32_t offset = 0;
      Jbig2RegionSegmentInfo region_info;
      Jbig2TextRegionParams params;
      Jbig2Image *image = NULL;
      Jbig2SymbolDict **dicts = NULL;
    int n_dicts = 0;
     uint32_t n_dicts = 0;
      uint16_t flags = 0;
      uint16_t huffman_flags = 0;
      Jbig2ArithCx *GR_stats = NULL;
      int code = 0;
      Jbig2WordStream *ws = NULL;
      Jbig2ArithState *as = NULL;
    int table_index = 0;
     uint32_t table_index = 0;
      const Jbig2HuffmanParams *huffman_params = NULL;
  
       
     if (segment->data_length < 17)
         goto too_short;
     jbig2_get_region_segment_info(&region_info, segment_data);
     offset += 17;
 
      
     flags = jbig2_get_uint16(segment_data + offset);
     offset += 2;
 
     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""text region header flags 0x%04x"", flags);
 
      
     memset(&params, 0, sizeof(Jbig2TextRegionParams));
 
     params.SBHUFF = flags & 0x0001;
     params.SBREFINE = flags & 0x0002;
     params.LOGSBSTRIPS = (flags & 0x000c) >> 2;
     params.SBSTRIPS = 1 << params.LOGSBSTRIPS;
     params.REFCORNER = (Jbig2RefCorner)((flags & 0x0030) >> 4);
     params.TRANSPOSED = flags & 0x0040;
     params.SBCOMBOP = (Jbig2ComposeOp)((flags & 0x0180) >> 7);
     params.SBDEFPIXEL = flags & 0x0200;
      
     params.SBDSOFFSET = (flags & 0x7C00) >> 10;
     if (params.SBDSOFFSET > 0x0f)
         params.SBDSOFFSET -= 0x20;
     params.SBRTEMPLATE = flags & 0x8000;
 
     if (params.SBDSOFFSET) {
         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, ""text region has SBDSOFFSET %d"", params.SBDSOFFSET);
     }
 
     if (params.SBHUFF) {         
          
         huffman_flags = jbig2_get_uint16(segment_data + offset);
         offset += 2;
 
         if (huffman_flags & 0x8000)
             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""reserved bit 15 of text region huffman flags is not zero"");
     } else {                     
 
          
         if ((params.SBREFINE) && !(params.SBRTEMPLATE)) {
             params.sbrat[0] = segment_data[offset];
             params.sbrat[1] = segment_data[offset + 1];
             params.sbrat[2] = segment_data[offset + 2];
             params.sbrat[3] = segment_data[offset + 3];
             offset += 4;
         }
     }
 
      
     params.SBNUMINSTANCES = jbig2_get_uint32(segment_data + offset);
     offset += 4;
 
     if (params.SBHUFF) {
          
          
 
          
         switch (huffman_flags & 0x0003) {
         case 0:                 
             params.SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);
             break;
         case 1:                 
             params.SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_G);
             break;
         case 3:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom FS huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFFS = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         case 2:                 
         default:
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""text region specified invalid FS huffman table"");
             goto cleanup1;
             break;
         }
         if (params.SBHUFFFS == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified FS huffman table"");
             goto cleanup1;
         }
 
         switch ((huffman_flags & 0x000c) >> 2) {
         case 0:                 
             params.SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);
             break;
         case 1:                 
             params.SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_I);
             break;
         case 2:                 
             params.SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_J);
             break;
         case 3:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom DS huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFDS = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         }
         if (params.SBHUFFDS == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified DS huffman table"");
             goto cleanup1;
         }
 
         switch ((huffman_flags & 0x0030) >> 4) {
         case 0:                 
             params.SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);
             break;
         case 1:                 
             params.SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_L);
             break;
         case 2:                 
             params.SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_M);
             break;
         case 3:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom DT huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFDT = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         }
         if (params.SBHUFFDT == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified DT huffman table"");
             goto cleanup1;
         }
 
         switch ((huffman_flags & 0x00c0) >> 6) {
         case 0:                 
             params.SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);
             break;
         case 1:                 
             params.SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);
             break;
         case 3:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom RDW huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFRDW = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         case 2:                 
         default:
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""text region specified invalid RDW huffman table"");
             goto cleanup1;
             break;
         }
         if (params.SBHUFFRDW == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified RDW huffman table"");
             goto cleanup1;
         }
 
         switch ((huffman_flags & 0x0300) >> 8) {
         case 0:                 
             params.SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);
             break;
         case 1:                 
             params.SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);
             break;
         case 3:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom RDH huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFRDH = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         case 2:                 
         default:
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""text region specified invalid RDH huffman table"");
             goto cleanup1;
             break;
         }
         if (params.SBHUFFRDH == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified RDH huffman table"");
             goto cleanup1;
         }
 
         switch ((huffman_flags & 0x0c00) >> 10) {
         case 0:                 
             params.SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);
             break;
         case 1:                 
             params.SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);
             break;
         case 3:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom RDX huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFRDX = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         case 2:                 
         default:
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""text region specified invalid RDX huffman table"");
             goto cleanup1;
             break;
         }
         if (params.SBHUFFRDX == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified RDX huffman table"");
             goto cleanup1;
         }
 
         switch ((huffman_flags & 0x3000) >> 12) {
         case 0:                 
             params.SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);
             break;
         case 1:                 
             params.SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);
             break;
         case 3:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom RDY huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFRDY = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         case 2:                 
         default:
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""text region specified invalid RDY huffman table"");
             goto cleanup1;
             break;
         }
         if (params.SBHUFFRDY == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified RDY huffman table"");
             goto cleanup1;
         }
 
         switch ((huffman_flags & 0x4000) >> 14) {
         case 0:                 
             params.SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);
             break;
         case 1:                 
             huffman_params = jbig2_find_table(ctx, segment, table_index);
             if (huffman_params == NULL) {
                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Custom RSIZE huffman table not found (%d)"", table_index);
                 goto cleanup1;
             }
             params.SBHUFFRSIZE = jbig2_build_huffman_table(ctx, huffman_params);
             ++table_index;
             break;
         }
         if (params.SBHUFFRSIZE == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to allocate text region specified RSIZE huffman table"");
             goto cleanup1;
         }
 
         if (huffman_flags & 0x8000) {
             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""text region huffman flags bit 15 is set, contrary to spec"");
         }
 
          
          
     }
 
     jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number,
                 ""text region: %d x %d @ (%d,%d) %d symbols"", region_info.width, region_info.height, region_info.x, region_info.y, params.SBNUMINSTANCES);
 
      
     n_dicts = jbig2_sd_count_referred(ctx, segment);
     if (n_dicts != 0) {
         dicts = jbig2_sd_list_referred(ctx, segment);
     } else {
         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""text region refers to no symbol dictionaries!"");
         goto cleanup1;
     }
     if (dicts == NULL) {
          code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""unable to retrive symbol dictionaries! previous parsing error?"");
          goto cleanup1;
      } else {
        int index;
         uint32_t index;
  
          if (dicts[0] == NULL) {
              code = jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""unable to find first referenced symbol dictionary!"");
             goto cleanup1;
         }
         for (index = 1; index < n_dicts; index++)
             if (dicts[index] == NULL) {
                 jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, ""unable to find all referenced symbol dictionaries!"");
                 n_dicts = index;
             }
     }
 
      
     {
         int stats_size = params.SBRTEMPLATE ? 1 << 10 : 1 << 13;
 
         GR_stats = jbig2_new(ctx, Jbig2ArithCx, stats_size);
         if (GR_stats == NULL) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""could not allocate GR_stats"");
             goto cleanup1;
         }
         memset(GR_stats, 0, stats_size);
     }
 
     image = jbig2_image_new(ctx, region_info.width, region_info.height);
     if (image == NULL) {
         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""couldn't allocate text region image"");
         goto cleanup2;
     }
 
     ws = jbig2_word_stream_buf_new(ctx, segment_data + offset, segment->data_length - offset);
     if (ws == NULL) {
         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""couldn't allocate ws in text region image"");
         goto cleanup2;
     }
 
     as = jbig2_arith_new(ctx, ws);
     if (as == NULL) {
         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""couldn't allocate as in text region image"");
         goto cleanup2;
      }
  
      if (!params.SBHUFF) {
        int SBSYMCODELEN, index;
        int SBNUMSYMS = 0;
         uint32_t SBSYMCODELEN, index;
         uint32_t SBNUMSYMS = 0;
  
          for (index = 0; index < n_dicts; index++) {
              SBNUMSYMS += dicts[index]->n_symbols;
         }
 
         params.IADT = jbig2_arith_int_ctx_new(ctx);
         params.IAFS = jbig2_arith_int_ctx_new(ctx);
         params.IADS = jbig2_arith_int_ctx_new(ctx);
         params.IAIT = jbig2_arith_int_ctx_new(ctx);
         if ((params.IADT == NULL) || (params.IAFS == NULL) || (params.IADS == NULL) || (params.IAIT == NULL)) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""couldn't allocate text region image data"");
             goto cleanup3;
          }
  
           
        for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < SBNUMSYMS; SBSYMCODELEN++) {
         for (SBSYMCODELEN = 0; (1U << SBSYMCODELEN) < SBNUMSYMS; SBSYMCODELEN++) {
          }
          params.IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);
          params.IARI = jbig2_arith_int_ctx_new(ctx);
         params.IARDW = jbig2_arith_int_ctx_new(ctx);
         params.IARDH = jbig2_arith_int_ctx_new(ctx);
         params.IARDX = jbig2_arith_int_ctx_new(ctx);
         params.IARDY = jbig2_arith_int_ctx_new(ctx);
         if ((params.IAID == NULL) || (params.IARI == NULL) ||
                 (params.IARDW == NULL) || (params.IARDH == NULL) || (params.IARDX == NULL) || (params.IARDY == NULL)) {
             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""couldn't allocate text region image data"");
             goto cleanup4;
         }
     }
 
     code = jbig2_decode_text_region(ctx, segment, &params,
                                     (const Jbig2SymbolDict * const *)dicts, n_dicts, image,
                                     segment_data + offset, segment->data_length - offset, GR_stats, as, ws);
     if (code < 0) {
         jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""failed to decode text region image data"");
         goto cleanup4;
     }
 
     if ((segment->flags & 63) == 4) {
          
         segment->result = jbig2_image_clone(ctx, image);
     } else {
          
         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,
                     ""composing %dx%d decoded text region onto page at (%d, %d)"", region_info.width, region_info.height, region_info.x, region_info.y);
         jbig2_page_add_result(ctx, &ctx->pages[ctx->current_page], image, region_info.x, region_info.y, region_info.op);
     }
 
 cleanup4:
     if (!params.SBHUFF) {
         jbig2_arith_iaid_ctx_free(ctx, params.IAID);
         jbig2_arith_int_ctx_free(ctx, params.IARI);
         jbig2_arith_int_ctx_free(ctx, params.IARDW);
         jbig2_arith_int_ctx_free(ctx, params.IARDH);
         jbig2_arith_int_ctx_free(ctx, params.IARDX);
         jbig2_arith_int_ctx_free(ctx, params.IARDY);
     }
 
 cleanup3:
     if (!params.SBHUFF) {
         jbig2_arith_int_ctx_free(ctx, params.IADT);
         jbig2_arith_int_ctx_free(ctx, params.IAFS);
         jbig2_arith_int_ctx_free(ctx, params.IADS);
         jbig2_arith_int_ctx_free(ctx, params.IAIT);
     }
     jbig2_free(ctx->allocator, as);
     jbig2_word_stream_buf_free(ctx, ws);
 
 cleanup2:
     jbig2_free(ctx->allocator, GR_stats);
     jbig2_image_release(ctx, image);
 
 cleanup1:
     if (params.SBHUFF) {
         jbig2_release_huffman_table(ctx, params.SBHUFFFS);
         jbig2_release_huffman_table(ctx, params.SBHUFFDS);
         jbig2_release_huffman_table(ctx, params.SBHUFFDT);
         jbig2_release_huffman_table(ctx, params.SBHUFFRDX);
         jbig2_release_huffman_table(ctx, params.SBHUFFRDY);
         jbig2_release_huffman_table(ctx, params.SBHUFFRDW);
         jbig2_release_huffman_table(ctx, params.SBHUFFRDH);
         jbig2_release_huffman_table(ctx, params.SBHUFFRSIZE);
     }
     jbig2_free(ctx->allocator, dicts);
 
     return code;
 
 too_short:
     return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, ""Segment too short"");
 }","[4, 10, 18, 310, 356, 357, 374, 3, 9, 17, 309, 354, 355, 373]","ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript."
10132,"static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
struct nft_data_desc *desc, const struct nlattr *nla)
{
u8 genmask = nft_genmask_next(ctx->net);
struct nlattr *tb[NFTA_VERDICT_MAX + 1];
struct nft_chain *chain;
int err;

err = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,
nft_verdict_policy, NULL);
if (err < 0)
return err;

if (!tb[NFTA_VERDICT_CODE])
return -EINVAL;
data->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));

switch (data->verdict.code) {
default:
switch (data->verdict.code & NF_VERDICT_MASK) {
case NF_ACCEPT:
case NF_DROP:
case NF_QUEUE:
break;
default:
return -EINVAL;
}
fallthrough;
case NFT_CONTINUE:
case NFT_BREAK:
case NFT_RETURN:
break;
case NFT_JUMP:
case NFT_GOTO:
if (tb[NFTA_VERDICT_CHAIN]) {
chain = nft_chain_lookup(ctx->net, ctx->table,
tb[NFTA_VERDICT_CHAIN],
genmask);
} else if (tb[NFTA_VERDICT_CHAIN_ID]) {
chain = nft_chain_lookup_byid(ctx->net, ctx->table,
tb[NFTA_VERDICT_CHAIN_ID]);
if (IS_ERR(chain))
return PTR_ERR(chain);
} else {
return -EINVAL;
}

if (IS_ERR(chain))
return PTR_ERR(chain);
if (nft_is_base_chain(chain))
return -EOPNOTSUPP;
if (desc->flags & NFT_DATA_DESC_SETELEM &&
chain->flags & NFT_CHAIN_BINDING)
return -EINVAL;

chain->use++;
data->verdict.chain = chain;
break;
}

desc->len = sizeof(data->verdict);

return 0;
}",[52],An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.
199779," static void __net_exit sctp_net_exit(struct net *net)
 static void __net_exit sctp_defaults_exit(struct net *net)
  {
  	 
  	sctp_free_addr_wq(net);
  	sctp_free_local_addr_list(net);
  
	 
	inet_ctl_sock_destroy(net->sctp.ctl_sock);
  	sctp_dbg_objcnt_exit(net);
  
  	sctp_proc_exit(net);
  	cleanup_sctp_mibs(net);
  	sctp_sysctl_net_unregister(net);
  }","[2, 8, 9]","The sctp_init function in net/sctp/protocol.c in the Linux kernel before 4.2.3 has an incorrect sequence of protocol-initialization steps, which allows local users to cause a denial of service (panic or memory corruption) by creating SCTP sockets before all of the steps have finished."
9463,"xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,
const xmlChar *name, const xmlChar *value) {
xmlChar *ret, *dst;
const xmlChar *src;
xmlAttributePtr attrDecl = NULL;

if (doc == NULL) return(NULL);
if (elem == NULL) return(NULL);
if (name == NULL) return(NULL);
if (value == NULL) return(NULL);

if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {
xmlChar fn[50];
xmlChar *fullname;

fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);
if (fullname == NULL)
return(NULL);
if ((fullname != fn) && (fullname != elem->name))
xmlFree(fullname);
}
attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);
if ((attrDecl == NULL) && (doc->extSubset != NULL))
attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);

if (attrDecl == NULL)
return(NULL);
if (attrDecl->atype == XML_ATTRIBUTE_CDATA)
return(NULL);

ret = xmlStrdup(value);
if (ret == NULL)
return(NULL);
src = value;
dst = ret;
while (*src == 0x20) src++;
while (*src != 0) {
if (*src == 0x20) {
while (*src == 0x20) src++;
if (*src != 0)
*dst++ = 0x20;
} else {
*dst++ = *src++;
}
}
*dst = 0;
return(ret);
}","[3, 4, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46]",valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.
199560," void bpf_jit_compile(struct sk_filter *fp)
 {
 	u8 temp[64];
 	u8 *prog;
 	unsigned int proglen, oldproglen = 0;
 	int ilen, i;
 	int t_offset, f_offset;
 	u8 t_op, f_op, seen = 0, pass;
 	u8 *image = NULL;
 	u8 *func;
 	int pc_ret0 = -1;  
 	unsigned int cleanup_addr;  
 	unsigned int *addrs;
 	const struct sock_filter *filter = fp->insns;
 	int flen = fp->len;
 
 	if (!bpf_jit_enable)
 		return;
 
 	addrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);
 	if (addrs == NULL)
 		return;
 
 	 
 	for (proglen = 0, i = 0; i < flen; i++) {
 		proglen += 64;
 		addrs[i] = proglen;
 	}
 	cleanup_addr = proglen;  
 
 	for (pass = 0; pass < 10; pass++) {
 		 
 		proglen = 0;
 		prog = temp;
 
 		if (seen) {
 			EMIT4(0x55, 0x48, 0x89, 0xe5);  
 			EMIT4(0x48, 0x83, 0xec, 96);	 
 			 
 			if (seen & (SEEN_XREG | SEEN_DATAREF))
 				EMIT4(0x48, 0x89, 0x5d, 0xf8);  
 			if (seen & SEEN_XREG)
 				CLEAR_X();  
 
 			 
 			if (seen & SEEN_DATAREF) {
 				if (offsetof(struct sk_buff, len) <= 127)
 					 
 					EMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));
 				else {
 					 
 					EMIT3(0x44, 0x8b, 0x8f);
 					EMIT(offsetof(struct sk_buff, len), 4);
 				}
 				if (is_imm8(offsetof(struct sk_buff, data_len)))
 					 
 					EMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));
 				else {
 					EMIT3(0x44, 0x2b, 0x8f);
 					EMIT(offsetof(struct sk_buff, data_len), 4);
 				}
 
 				if (is_imm8(offsetof(struct sk_buff, data)))
 					 
 					EMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));
 				else {
 					 
 					EMIT3(0x4c, 0x8b, 0x87);
 					EMIT(offsetof(struct sk_buff, data), 4);
 				}
 			}
 		}
 
 		switch (filter[0].code) {
 		case BPF_S_RET_K:
 		case BPF_S_LD_W_LEN:
 		case BPF_S_ANC_PROTOCOL:
 		case BPF_S_ANC_IFINDEX:
 		case BPF_S_ANC_MARK:
 		case BPF_S_ANC_RXHASH:
 		case BPF_S_ANC_CPU:
 		case BPF_S_ANC_QUEUE:
 		case BPF_S_LD_W_ABS:
 		case BPF_S_LD_H_ABS:
 		case BPF_S_LD_B_ABS:
 			 
 			break;
 		default:
 			 
 			CLEAR_A();  
 		}
 
 		for (i = 0; i < flen; i++) {
 			unsigned int K = filter[i].k;
 
 			switch (filter[i].code) {
 			case BPF_S_ALU_ADD_X:  
 				seen |= SEEN_XREG;
 				EMIT2(0x01, 0xd8);		 
 				break;
 			case BPF_S_ALU_ADD_K:  
 				if (!K)
 					break;
 				if (is_imm8(K))
 					EMIT3(0x83, 0xc0, K);	 
 				else
 					EMIT1_off32(0x05, K);	 
 				break;
 			case BPF_S_ALU_SUB_X:  
 				seen |= SEEN_XREG;
 				EMIT2(0x29, 0xd8);		 
 				break;
 			case BPF_S_ALU_SUB_K:  
 				if (!K)
 					break;
 				if (is_imm8(K))
 					EMIT3(0x83, 0xe8, K);  
 				else
 					EMIT1_off32(0x2d, K);  
 				break;
 			case BPF_S_ALU_MUL_X:  
 				seen |= SEEN_XREG;
 				EMIT3(0x0f, 0xaf, 0xc3);	 
 				break;
 			case BPF_S_ALU_MUL_K:  
 				if (is_imm8(K))
 					EMIT3(0x6b, 0xc0, K);  
 				else {
 					EMIT2(0x69, 0xc0);		 
 					EMIT(K, 4);
 				}
 				break;
 			case BPF_S_ALU_DIV_X:  
 				seen |= SEEN_XREG;
 				EMIT2(0x85, 0xdb);	 
 				if (pc_ret0 != -1)
 					EMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));
 				else {
 					EMIT_COND_JMP(X86_JNE, 2 + 5);
 					CLEAR_A();
 					EMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4));  
 				}
 				EMIT4(0x31, 0xd2, 0xf7, 0xf3);  
 				break;
 			case BPF_S_ALU_DIV_K:  
 				EMIT3(0x48, 0x69, 0xc0);  
 				EMIT(K, 4);
 				EMIT4(0x48, 0xc1, 0xe8, 0x20);  
 				break;
 			case BPF_S_ALU_AND_X:
 				seen |= SEEN_XREG;
 				EMIT2(0x21, 0xd8);		 
 				break;
 			case BPF_S_ALU_AND_K:
 				if (K >= 0xFFFFFF00) {
 					EMIT2(0x24, K & 0xFF);  
 				} else if (K >= 0xFFFF0000) {
 					EMIT2(0x66, 0x25);	 
 					EMIT2(K, 2);
 				} else {
 					EMIT1_off32(0x25, K);	 
 				}
 				break;
 			case BPF_S_ALU_OR_X:
 				seen |= SEEN_XREG;
 				EMIT2(0x09, 0xd8);		 
 				break;
 			case BPF_S_ALU_OR_K:
 				if (is_imm8(K))
 					EMIT3(0x83, 0xc8, K);  
 				else
 					EMIT1_off32(0x0d, K);	 
 				break;
 			case BPF_S_ALU_LSH_X:  
 				seen |= SEEN_XREG;
 				EMIT4(0x89, 0xd9, 0xd3, 0xe0);	 
 				break;
 			case BPF_S_ALU_LSH_K:
 				if (K == 0)
 					break;
 				else if (K == 1)
 					EMIT2(0xd1, 0xe0);  
 				else
 					EMIT3(0xc1, 0xe0, K);
 				break;
 			case BPF_S_ALU_RSH_X:  
 				seen |= SEEN_XREG;
 				EMIT4(0x89, 0xd9, 0xd3, 0xe8);	 
 				break;
 			case BPF_S_ALU_RSH_K:  
 				if (K == 0)
 					break;
 				else if (K == 1)
 					EMIT2(0xd1, 0xe8);  
 				else
 					EMIT3(0xc1, 0xe8, K);
 				break;
 			case BPF_S_ALU_NEG:
 				EMIT2(0xf7, 0xd8);		 
 				break;
 			case BPF_S_RET_K:
 				if (!K) {
 					if (pc_ret0 == -1)
 						pc_ret0 = i;
 					CLEAR_A();
 				} else {
 					EMIT1_off32(0xb8, K);	 
 				}
 				 
 			case BPF_S_RET_A:
 				if (seen) {
 					if (i != flen - 1) {
 						EMIT_JMP(cleanup_addr - addrs[i]);
 						break;
 					}
 					if (seen & SEEN_XREG)
 						EMIT4(0x48, 0x8b, 0x5d, 0xf8);   
 					EMIT1(0xc9);		 
 				}
 				EMIT1(0xc3);		 
 				break;
 			case BPF_S_MISC_TAX:  
 				seen |= SEEN_XREG;
 				EMIT2(0x89, 0xc3);	 
 				break;
 			case BPF_S_MISC_TXA:  
 				seen |= SEEN_XREG;
 				EMIT2(0x89, 0xd8);	 
 				break;
 			case BPF_S_LD_IMM:  
 				if (!K)
 					CLEAR_A();
 				else
 					EMIT1_off32(0xb8, K);  
 				break;
 			case BPF_S_LDX_IMM:  
 				seen |= SEEN_XREG;
 				if (!K)
 					CLEAR_X();
 				else
 					EMIT1_off32(0xbb, K);  
 				break;
 			case BPF_S_LD_MEM:  
 				seen |= SEEN_MEM;
 				EMIT3(0x8b, 0x45, 0xf0 - K*4);
 				break;
 			case BPF_S_LDX_MEM:  
 				seen |= SEEN_XREG | SEEN_MEM;
 				EMIT3(0x8b, 0x5d, 0xf0 - K*4);
 				break;
 			case BPF_S_ST:  
 				seen |= SEEN_MEM;
 				EMIT3(0x89, 0x45, 0xf0 - K*4);
 				break;
 			case BPF_S_STX:  
 				seen |= SEEN_XREG | SEEN_MEM;
 				EMIT3(0x89, 0x5d, 0xf0 - K*4);
 				break;
 			case BPF_S_LD_W_LEN:  
 				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);
 				if (is_imm8(offsetof(struct sk_buff, len)))
 					 
 					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));
 				else {
 					EMIT2(0x8b, 0x87);
 					EMIT(offsetof(struct sk_buff, len), 4);
 				}
 				break;
 			case BPF_S_LDX_W_LEN:  
 				seen |= SEEN_XREG;
 				if (is_imm8(offsetof(struct sk_buff, len)))
 					 
 					EMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));
 				else {
 					EMIT2(0x8b, 0x9f);
 					EMIT(offsetof(struct sk_buff, len), 4);
 				}
 				break;
 			case BPF_S_ANC_PROTOCOL:  
 				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
 				if (is_imm8(offsetof(struct sk_buff, protocol))) {
 					 
 					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));
 				} else {
 					EMIT3(0x0f, 0xb7, 0x87);  
 					EMIT(offsetof(struct sk_buff, protocol), 4);
 				}
 				EMIT2(0x86, 0xc4);  
 				break;
 			case BPF_S_ANC_IFINDEX:
 				if (is_imm8(offsetof(struct sk_buff, dev))) {
 					 
 					EMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));
 				} else {
 					EMIT3(0x48, 0x8b, 0x87);  
 					EMIT(offsetof(struct sk_buff, dev), 4);
 				}
 				EMIT3(0x48, 0x85, 0xc0);	 
 				EMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));
 				BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
 				EMIT2(0x8b, 0x80);	 
 				EMIT(offsetof(struct net_device, ifindex), 4);
 				break;
 			case BPF_S_ANC_MARK:
 				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
 				if (is_imm8(offsetof(struct sk_buff, mark))) {
 					 
 					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));
 				} else {
 					EMIT2(0x8b, 0x87);
 					EMIT(offsetof(struct sk_buff, mark), 4);
 				}
 				break;
 			case BPF_S_ANC_RXHASH:
 				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);
 				if (is_imm8(offsetof(struct sk_buff, rxhash))) {
 					 
 					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));
 				} else {
 					EMIT2(0x8b, 0x87);
 					EMIT(offsetof(struct sk_buff, rxhash), 4);
 				}
 				break;
 			case BPF_S_ANC_QUEUE:
 				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);
 				if (is_imm8(offsetof(struct sk_buff, queue_mapping))) {
 					 
 					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));
 				} else {
 					EMIT3(0x0f, 0xb7, 0x87);  
 					EMIT(offsetof(struct sk_buff, queue_mapping), 4);
 				}
 				break;
 			case BPF_S_ANC_CPU:
 #ifdef CONFIG_SMP
 				EMIT4(0x65, 0x8b, 0x04, 0x25);  
 				EMIT((u32)(unsigned long)&cpu_number, 4);  
 #else
 				CLEAR_A();
 #endif
 				break;
 			case BPF_S_LD_W_ABS:
 				func = sk_load_word;
 common_load:			seen |= SEEN_DATAREF;
 				if ((int)K < 0)
 					goto out;
 				t_offset = func - (image + addrs[i]);
 				EMIT1_off32(0xbe, K);  
 				EMIT1_off32(0xe8, t_offset);  
 				break;
 			case BPF_S_LD_H_ABS:
 				func = sk_load_half;
 				goto common_load;
 			case BPF_S_LD_B_ABS:
 				func = sk_load_byte;
 				goto common_load;
 			case BPF_S_LDX_B_MSH:
 				if ((int)K < 0) {
 					if (pc_ret0 != -1) {
 						EMIT_JMP(addrs[pc_ret0] - addrs[i]);
 						break;
 					}
 					CLEAR_A();
 					EMIT_JMP(cleanup_addr - addrs[i]);
 					break;
 				}
 				seen |= SEEN_DATAREF | SEEN_XREG;
 				t_offset = sk_load_byte_msh - (image + addrs[i]);
 				EMIT1_off32(0xbe, K);	 
 				EMIT1_off32(0xe8, t_offset);  
 				break;
 			case BPF_S_LD_W_IND:
 				func = sk_load_word_ind;
 common_load_ind:		seen |= SEEN_DATAREF | SEEN_XREG;
 				t_offset = func - (image + addrs[i]);
 				EMIT1_off32(0xbe, K);	 
 				EMIT1_off32(0xe8, t_offset);	 
 				break;
 			case BPF_S_LD_H_IND:
 				func = sk_load_half_ind;
 				goto common_load_ind;
 			case BPF_S_LD_B_IND:
 				func = sk_load_byte_ind;
 				goto common_load_ind;
 			case BPF_S_JMP_JA:
 				t_offset = addrs[i + K] - addrs[i];
 				EMIT_JMP(t_offset);
 				break;
 			COND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);
 			COND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);
 			COND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);
 			COND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);
 			COND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);
 			COND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);
 			COND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);
 			COND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);
 
 cond_branch:			f_offset = addrs[i + filter[i].jf] - addrs[i];
 				t_offset = addrs[i + filter[i].jt] - addrs[i];
 
 				 
 				if (filter[i].jt == filter[i].jf) {
 					EMIT_JMP(t_offset);
 					break;
 				}
 
 				switch (filter[i].code) {
 				case BPF_S_JMP_JGT_X:
 				case BPF_S_JMP_JGE_X:
 				case BPF_S_JMP_JEQ_X:
 					seen |= SEEN_XREG;
 					EMIT2(0x39, 0xd8);  
 					break;
 				case BPF_S_JMP_JSET_X:
 					seen |= SEEN_XREG;
 					EMIT2(0x85, 0xd8);  
 					break;
 				case BPF_S_JMP_JEQ_K:
 					if (K == 0) {
 						EMIT2(0x85, 0xc0);  
 						break;
 					}
 				case BPF_S_JMP_JGT_K:
 				case BPF_S_JMP_JGE_K:
 					if (K <= 127)
 						EMIT3(0x83, 0xf8, K);  
 					else
 						EMIT1_off32(0x3d, K);  
 					break;
 				case BPF_S_JMP_JSET_K:
 					if (K <= 0xFF)
 						EMIT2(0xa8, K);  
 					else if (!(K & 0xFFFF00FF))
 						EMIT3(0xf6, 0xc4, K >> 8);  
 					else if (K <= 0xFFFF) {
 						EMIT2(0x66, 0xa9);  
 						EMIT(K, 2);
 					} else {
 						EMIT1_off32(0xa9, K);  
 					}
  					break;
  				}
  				if (filter[i].jt != 0) {
					if (filter[i].jf)
						t_offset += is_near(f_offset) ? 2 : 6;
 					if (filter[i].jf && f_offset)
 						t_offset += is_near(f_offset) ? 2 : 5;
  					EMIT_COND_JMP(t_op, t_offset);
  					if (filter[i].jf)
  						EMIT_JMP(f_offset);
 					break;
 				}
 				EMIT_COND_JMP(f_op, f_offset);
 				break;
 			default:
 				 
 				goto out;
 			}
 			ilen = prog - temp;
 			if (image) {
 				if (unlikely(proglen + ilen > oldproglen)) {
 					pr_err(""bpb_jit_compile fatal error\n"");
 					kfree(addrs);
 					module_free(NULL, image);
 					return;
 				}
 				memcpy(image + proglen, temp, ilen);
 			}
 			proglen += ilen;
 			addrs[i] = proglen;
 			prog = temp;
 		}
 		 
 		cleanup_addr = proglen - 1;  
 		if (seen)
 			cleanup_addr -= 1;  
 		if (seen & SEEN_XREG)
 			cleanup_addr -= 4;  
 
 		if (image) {
 			WARN_ON(proglen != oldproglen);
 			break;
 		}
 		if (proglen == oldproglen) {
 			image = module_alloc(max_t(unsigned int,
 						   proglen,
 						   sizeof(struct work_struct)));
 			if (!image)
 				goto out;
 		}
 		oldproglen = proglen;
 	}
 	if (bpf_jit_enable > 1)
 		pr_err(""flen=%d proglen=%u pass=%d image=%p\n"",
 		       flen, proglen, pass, image);
 
 	if (image) {
 		if (bpf_jit_enable > 1)
 			print_hex_dump(KERN_ERR, ""JIT code: "", DUMP_PREFIX_ADDRESS,
 				       16, 1, image, proglen, false);
 
 		bpf_flush_icache(image, image + proglen);
 
 		fp->bpf_func = (void *)image;
 	}
 out:
 	kfree(addrs);
 	return;
 }","[446, 447, 444, 445]","Off-by-one error in the bpf_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 3.1.8, when BPF JIT is enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges via a long jump after a conditional jump."
205172," bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,
                                              int render_view_id,
                                              const void* context,
                                              const GURL& url,
                                              const GURL& policy_url,
                                              webkit::WebPluginInfo* plugin) {
 bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,
                                                 int render_view_id,
                                                 const void* context,
                                                 const GURL& url,
                                                 const GURL& policy_url,
                                                 webkit::WebPluginInfo* plugin) {
    std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);
    if (it == plugin_state_.end()) {
      ADD_FAILURE() << ""No plug-in state for '"" << plugin->path.value() << ""'"";
     return false;
   }
   return it->second;
 }","[7, 8, 9, 10, 11, 12, 2, 3, 4, 5, 6]","Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in."
7588,"bool AES_GCM_EncryptContext::Encrypt(
const void *pPlaintextData, size_t cbPlaintextData,
const void *pIV,
void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

crypto_aead_aes256gcm_encrypt_afternm(
static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
nullptr,
static_cast<const unsigned char*>( pIV ),
static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
);

*pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

return true;
}","[7, 9, 10, 18]","Valve's Game Networking Sockets prior to version v1.2.0 improperly handles long encrypted messages in function AES_GCM_DecryptContext::Decrypt() when compiled using libsodium, leading to a Stack-Based Buffer Overflow and resulting in a memory corruption and possibly even a remote code execution."
202362,"  av_cold void ff_mpv_idct_init(MpegEncContext *s)
  {
     if (s->codec_id == AV_CODEC_ID_MPEG4)
         s->idsp.mpeg4_studio_profile = s->studio_profile;
      ff_idctdsp_init(&s->idsp, s->avctx);
  
       
     if (s->alternate_scan) {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);
     } else {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
     }
     ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
     ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
 }","[3, 4]","libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c."
204944," void SocketStream::Connect() {
   DCHECK(base::MessageLoop::current())
        << ""The current base::MessageLoop must exist"";
    DCHECK_EQ(base::MessageLoop::TYPE_IO, base::MessageLoop::current()->type())
        << ""The current base::MessageLoop must be TYPE_IO"";
  if (context_.get()) {
   if (context_) {
      context_->ssl_config_service()->GetSSLConfig(&server_ssl_config_);
      proxy_ssl_config_ = server_ssl_config_;
    }
   CheckPrivacyMode();
 
   DCHECK_EQ(next_state_, STATE_NONE);
 
   AddRef();   
   next_state_ = STATE_BEFORE_CONNECT;
   net_log_.BeginEvent(
       NetLog::TYPE_SOCKET_STREAM_CONNECT,
       NetLog::StringCallback(""url"", &url_.possibly_invalid_spec()));
   base::MessageLoop::current()->PostTask(
       FROM_HERE, base::Bind(&SocketStream::DoLoop, this, OK));
 }","[7, 6]",Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote servers to execute arbitrary code via crafted response traffic after a URL request.
8791,"static QSvgNode *createPathNode(QSvgNode *parent,
const QXmlStreamAttributes &attributes,
QSvgHandler *)
{
QStringRef data      = attributes.value(QLatin1String(""d""));

QPainterPath qpath;
qpath.setFillRule(Qt::WindingFill);

parsePathDataFast(data, qpath);

QSvgNode *path = new QSvgPath(parent, qpath);
return path;
}",[10],Qt SVG in Qt 5.0.0 through 5.15.2 and 6.0.0 through 6.2.1 has an out-of-bounds write in QtPrivate::QCommonArrayOps<QPainterPath::Element>::growAppend (called from QPainterPath::addPath and QPathClipper::intersect).
200335," static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 		unsigned long address, unsigned int *flags, int *nonblocking)
 {
 	unsigned int fault_flags = 0;
 	int ret;
 
 	 
 	if ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
 		return -ENOENT;
 	 
 	if ((*flags & FOLL_POPULATE) &&
 			(stack_guard_page_start(vma, address) ||
 			 stack_guard_page_end(vma, address + PAGE_SIZE)))
 		return -ENOENT;
 	if (*flags & FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (*flags & FOLL_REMOTE)
 		fault_flags |= FAULT_FLAG_REMOTE;
 	if (nonblocking)
 		fault_flags |= FAULT_FLAG_ALLOW_RETRY;
 	if (*flags & FOLL_NOWAIT)
 		fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;
 	if (*flags & FOLL_TRIED) {
 		VM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);
 		fault_flags |= FAULT_FLAG_TRIED;
 	}
 
 	ret = handle_mm_fault(vma, address, fault_flags);
 	if (ret & VM_FAULT_ERROR) {
 		if (ret & VM_FAULT_OOM)
 			return -ENOMEM;
 		if (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))
 			return *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;
 		if (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))
 			return -EFAULT;
 		BUG();
 	}
 
 	if (tsk) {
 		if (ret & VM_FAULT_MAJOR)
 			tsk->maj_flt++;
 		else
 			tsk->min_flt++;
 	}
 
 	if (ret & VM_FAULT_RETRY) {
 		if (nonblocking)
 			*nonblocking = 0;
 		return -EBUSY;
 	}
 
 	 
  	if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))
		*flags &= ~FOLL_WRITE;
 	        *flags |= FOLL_COW;
  	return 0;
  }","[55, 54]","Race condition in mm/gup.c in the Linux kernel 2.x through 4.x before 4.8.3 allows local users to gain privileges by leveraging incorrect handling of a copy-on-write (COW) feature to write to a read-only memory mapping, as exploited in the wild in October 2016, aka *Dirty COW.*"
200373,"  static char* getPreferredTag(const char* gf_tag)
{ 
 {
  	char* result = NULL;
  	int grOffset = 0;
  
 	grOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);
 	if(grOffset < 0) {
 		return NULL;
 	}
 	if( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){
 		 
 		result = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );
 	} else {
 		 
 		result = estrdup( LOC_GRANDFATHERED[grOffset] );
 	}
 	return result;
  }","[3, 2]","The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call."
200914," COMPAT_SYSCALL_DEFINE5(waitid,
 		int, which, compat_pid_t, pid,
 		struct compat_siginfo __user *, infop, int, options,
 		struct compat_rusage __user *, uru)
 {
 	struct rusage ru;
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);
 	int signo = 0;
  	if (err > 0) {
  		signo = SIGCHLD;
  		err = 0;
	}
	if (!err && uru) {
		 
		if (COMPAT_USE_64BIT_TIME)
			err = copy_to_user(uru, &ru, sizeof(ru));
		else
			err = put_compat_rusage(&ru, uru);
		if (err)
			return -EFAULT;
 		if (uru) {
 			 
 			if (COMPAT_USE_64BIT_TIME)
 				err = copy_to_user(uru, &ru, sizeof(ru));
 			else
 				err = put_compat_rusage(&ru, uru);
 			if (err)
 				return -EFAULT;
 		}
  	}
  
  	if (!infop)
 		return err;
 
 	user_access_begin();
 	unsafe_put_user(signo, &infop->si_signo, Efault);
 	unsafe_put_user(0, &infop->si_errno, Efault);
 	unsafe_put_user(info.cause, &infop->si_code, Efault);
 	unsafe_put_user(info.pid, &infop->si_pid, Efault);
 	unsafe_put_user(info.uid, &infop->si_uid, Efault);
 	unsafe_put_user(info.status, &infop->si_status, Efault);
 	user_access_end();
 	return err;
 Efault:
 	user_access_end();
 	return -EFAULT;
 }","[22, 23, 24, 25, 26, 27, 28, 29, 30, 13, 14, 15, 16, 17, 18, 19, 20, 21]","The waitid implementation in kernel/exit.c in the Linux kernel through 4.13.4 accesses rusage data structures in unintended cases, which allows local users to obtain sensitive information, and bypass the KASLR protection mechanism, via a crafted system call."
207107,"  void WebGL2RenderingContextBase::bindVertexArray(
      WebGLVertexArrayObject* vertex_array) {
  if (isContextLost())
   bool deleted;
   if (!CheckObjectToBeBound(""bindVertexArray"", vertex_array, deleted))
      return;
  if (vertex_array &&
      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {
   if (deleted) {
      SynthesizeGLError(GL_INVALID_OPERATION, ""bindVertexArray"",
                      ""invalid vertexArray"");
                       ""attempt to bind a deleted vertex array"");
      return;
    }
  
   if (vertex_array && !vertex_array->IsDefaultObject() &&
       vertex_array->Object()) {
     ContextGL()->BindVertexArrayOES(ObjectOrZero(vertex_array));
 
     vertex_array->SetHasEverBeenBound();
     SetBoundVertexArrayObject(vertex_array);
   } else {
     ContextGL()->BindVertexArrayOES(0);
     SetBoundVertexArrayObject(nullptr);
   }
 }","[4, 5, 9, 12, 3, 7, 8, 11]",Insufficient data validation in WebGL in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
204881," void WebContentsImpl::DidFailProvisionalLoadWithError(
     RenderViewHost* render_view_host,
     const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params) {
   VLOG(1) << ""Failed Provisional Load: "" << params.url.possibly_invalid_spec()
           << "", error_code: "" << params.error_code
           << "", error_description: "" << params.error_description
           << "", is_main_frame: "" << params.is_main_frame
           << "", showing_repost_interstitial: "" <<
             params.showing_repost_interstitial
           << "", frame_id: "" << params.frame_id;
   GURL validated_url(params.url);
   RenderProcessHost* render_process_host =
       render_view_host->GetProcess();
   RenderViewHost::FilterURL(render_process_host, false, &validated_url);
 
   if (net::ERR_ABORTED == params.error_code) {
     if (ShowingInterstitialPage()) {
       LOG(WARNING) << ""Discarding message during interstitial."";
        return;
      }
  
      render_manager_.RendererAbortedProvisionalLoad(render_view_host);
    }
  
    
    
    
    
    
    
    
    
    
   if (controller_.GetPendingEntry() != controller_.GetVisibleEntry())
     controller_.DiscardPendingEntry();
 
    FOR_EACH_OBSERVER(WebContentsObserver,
                      observers_,
                      DidFailProvisionalLoad(params.frame_id,
                                            params.is_main_frame,
                                            validated_url,
                                            params.error_code,
                                            params.error_description,
                                            render_view_host));
 }","[25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36]","Google Chrome before 30.0.1599.66 preserves pending NavigationEntry objects in certain invalid circumstances, which allows remote attackers to spoof the address bar via a URL with a malformed scheme, as demonstrated by a nonexistent:12121 URL."
8093,"static redisReply* oidc_cache_redis_command(request_rec *r,
oidc_cache_cfg_redis_t *context, const char *command) {

redisReply *reply = NULL;
int i = 0;


for (i = 0; i < OIDC_REDIS_MAX_TRIES; i++) {


if (oidc_cache_redis_connect(r, context) != APR_SUCCESS)
break;


reply = redisCommand(context->ctx, command);


if ((reply != NULL) && (reply->type != REDIS_REPLY_ERROR))

break;


oidc_error(r,
""Redis command (attempt=%d to %s:%d) failed, disconnecting: '%s' [%s]"",
i, context->host_str, context->port, context->ctx->errstr,
reply ? reply->str : ""<n/a>"");


oidc_cache_redis_reply_free(&reply);


oidc_cache_redis_free(context);
}

return reply;
}","[2, 8, 15, 35]","mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. When mod_auth_openidc versions prior to 2.4.9 are configured to use an unencrypted Redis cache (`OIDCCacheEncrypt off`, `OIDCSessionType server-cache`, `OIDCCacheType redis`), `mod_auth_openidc` wrongly performed argument interpolation before passing Redis requests to `hiredis`, which would perform it again and lead to an uncontrolled format string bug. Initial assessment shows that this bug does not appear to allow gaining arbitrary code execution, but can reliably provoke a denial of service by repeatedly crashing the Apache workers. This bug has been corrected in version 2.4.9 by performing argument interpolation only once, using the `hiredis` API. As a workaround, this vulnerability can be mitigated by setting `OIDCCacheEncrypt` to `on`, as cache keys are cryptographically hashed before use when this option is enabled."
7928,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
auto* params =
reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);
int axis = params->axis;
int num_inputs = node->inputs->size;



const TfLiteTensor* t0;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));
TfLiteType input_type = t0->type;
if (axis < 0) axis += t0->dims->size;
TF_LITE_ENSURE(context, axis >= 0);
TF_LITE_ENSURE(context, axis < t0->dims->size);

TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);
TF_LITE_ENSURE(context,
input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||
input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||
input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||
input_type == kTfLiteBool);



int sum_axis = t0->dims->data[axis];
for (int i = 1; i < num_inputs; ++i) {
const TfLiteTensor* t;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));
TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);
TF_LITE_ENSURE_EQ(context, t->type, input_type);
for (int d = 0; d < t0->dims->size; ++d) {
if (d == axis) {
sum_axis += t->dims->data[axis];
} else {
TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);
}
}
}

TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);
for (int d = 0; d < t0->dims->size; ++d) {
output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];
}

TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);

if (input_type == kTfLiteInt8) {


VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);
for (int i = 0; i < node->inputs->size; ++i) {
const TfLiteTensor* t;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));
TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);
TF_LITE_ENSURE_EQ(context, t->params.zero_point,
output->params.zero_point);
}
}

if (input_type == kTfLiteInt16) {

for (int i = 0; i < node->inputs->size; ++i) {
const TfLiteTensor* t = GetInput(context, node, i);
TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);
}
TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
}

return context->ResizeTensor(context, output, output_size);
}",[33],"TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
201010," mp_join_print(netdissect_options *ndo,
               const u_char *opt, u_int opt_len, u_char flags)
  {
          const struct mp_join *mpj = (const struct mp_join *) opt;
  
        if (!(opt_len == 12 && flags & TH_SYN) &&
         if (!(opt_len == 12 && (flags & TH_SYN)) &&
              !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&
            !(opt_len == 24 && flags & TH_ACK))
             !(opt_len == 24 && (flags & TH_ACK)))
                  return 0;
  
          if (opt_len != 24) {
                 if (mpj->sub_b & MP_JOIN_B)
                         ND_PRINT((ndo, "" backup""));
                 ND_PRINT((ndo, "" id %u"", mpj->addr_id));
         }
 
         switch (opt_len) {
         case 12:  
                 ND_PRINT((ndo, "" token 0x%x"" "" nonce 0x%x"",
                         EXTRACT_32BITS(mpj->u.syn.token),
                         EXTRACT_32BITS(mpj->u.syn.nonce)));
                 break;
         case 16:  
                 ND_PRINT((ndo, "" hmac 0x%"" PRIx64 "" nonce 0x%x"",
                         EXTRACT_64BITS(mpj->u.synack.mac),
                         EXTRACT_32BITS(mpj->u.synack.nonce)));
                 break;
         case 24: { 
                 size_t i;
                 ND_PRINT((ndo, "" hmac 0x""));
                 for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)
                         ND_PRINT((ndo, ""%02x"", mpj->u.ack.mac[i]));
         }
         default:
                 break;
         }
          return 1;
  }","[7, 10, 6, 9]","The MPTCP parser in tcpdump before 4.9.2 has a buffer over-read in print-mptcp.c, several functions."
202181," static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
 		       unsigned int cmd, unsigned long arg)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 	int retval;
 
 	switch (cmd) {
 	case TIOCOUTQ:
  		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
  	case TIOCINQ:
  		down_write(&tty->termios_rwsem);
		if (L_ICANON(tty))
 		if (L_ICANON(tty) && !L_EXTPROC(tty))
  			retval = inq_canon(ldata);
  		else
  			retval = read_cnt(ldata);
 		up_write(&tty->termios_rwsem);
 		return put_user(retval, (unsigned int __user *) arg);
 	default:
 		return n_tty_ioctl_helper(tty, file, cmd, arg);
 	}
 }","[13, 12]",drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ.
207167," DataPipeConsumerDispatcher::Deserialize(const void* data,
                                         size_t num_bytes,
                                         const ports::PortName* ports,
                                         size_t num_ports,
                                         PlatformHandle* handles,
                                         size_t num_handles) {
   if (num_ports != 1 || num_handles != 1 ||
       num_bytes != sizeof(SerializedState)) {
     return nullptr;
   }
  
    const SerializedState* state = static_cast<const SerializedState*>(data);
    if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||
      state->options.capacity_num_bytes < state->options.element_num_bytes) {
       state->options.capacity_num_bytes < state->options.element_num_bytes ||
       state->read_offset >= state->options.capacity_num_bytes ||
       state->bytes_available > state->options.capacity_num_bytes) {
      return nullptr;
    }
  
   NodeController* node_controller = Core::Get()->GetNodeController();
   ports::PortRef port;
   if (node_controller->node()->GetPort(ports[0], &port) != ports::OK)
     return nullptr;
 
   auto region_handle = CreateSharedMemoryRegionHandleFromPlatformHandles(
       std::move(handles[0]), PlatformHandle());
   auto region = base::subtle::PlatformSharedMemoryRegion::Take(
       std::move(region_handle),
       base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe,
       state->options.capacity_num_bytes,
       base::UnguessableToken::Deserialize(state->buffer_guid_high,
                                           state->buffer_guid_low));
   auto ring_buffer =
       base::UnsafeSharedMemoryRegion::Deserialize(std::move(region));
   if (!ring_buffer.IsValid()) {
     DLOG(ERROR) << ""Failed to deserialize shared buffer handle."";
     return nullptr;
   }
 
   scoped_refptr<DataPipeConsumerDispatcher> dispatcher =
       new DataPipeConsumerDispatcher(node_controller, port,
                                      std::move(ring_buffer), state->options,
                                      state->pipe_id);
 
   {
     base::AutoLock lock(dispatcher->lock_);
     dispatcher->read_offset_ = state->read_offset;
     dispatcher->bytes_available_ = state->bytes_available;
     dispatcher->new_data_available_ = state->bytes_available > 0;
      dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;
      if (!dispatcher->InitializeNoLock())
        return nullptr;
     if (state->options.capacity_num_bytes >
         dispatcher->ring_buffer_mapping_.mapped_size()) {
       return nullptr;
     }
      dispatcher->UpdateSignalsStateNoLock();
    }
  
   return dispatcher;
 }","[15, 16, 17, 54, 55, 56, 57, 14]",Missing validation in Mojo in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to potentially perform a sandbox escape via a crafted HTML page.
201368,"  IW_IMPL(int) iw_get_i32le(const iw_byte *b)
  {
	return (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));
 	return (iw_int32)(iw_uint32)((unsigned int)b[0] | ((unsigned int)b[1]<<8) |
 		((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24));
  }","[4, 5, 3]","libimageworsener.a in ImageWorsener before 1.3.1 has *left shift cannot be represented in type int* undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c."
201262,"  void grubfs_free (GrubFS *gf) {
  	if (gf) {
		if (gf->file && gf->file->device)
 		if (gf->file && gf->file->device) {
  			free (gf->file->device->disk);
 		}
  		free (gf->file);
  		free (gf);
 	}
 }","[4, 6, 3]","The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array."
202634,"  int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
  {
    uint32_t chan_chunk = 0, channel_layout = 0, bcount;
     uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
      unsigned char *channel_identities = NULL;
      unsigned char *channel_reorder = NULL;
      int64_t total_samples = 0, infilesize;
     CAFFileHeader caf_file_header;
     CAFChunkHeader caf_chunk_header;
     CAFAudioFormat caf_audio_format;
     int i;
 
     infilesize = DoGetFileSize (infile);
     memcpy (&caf_file_header, fourcc, 4);
 
     if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
         bcount != sizeof (CAFFileHeader) - 4)) {
             error_line (""%s is not a valid .CAF file!"", infilename);
             return WAVPACK_SOFT_ERROR;
     }
     else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
         !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
             error_line (""%s"", WavpackGetErrorMessage (wpc));
             return WAVPACK_SOFT_ERROR;
     }
 
     WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);
 
     if (caf_file_header.mFileVersion != 1) {
         error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
         return WAVPACK_SOFT_ERROR;
     }
 
 
     while (1) {
         if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
             bcount != sizeof (CAFChunkHeader)) {
                 error_line (""%s is not a valid .CAF file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
         }
         else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
             !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                 error_line (""%s"", WavpackGetErrorMessage (wpc));
                 return WAVPACK_SOFT_ERROR;
         }
 
         WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);
 
 
         if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
             int supported = TRUE;
 
             if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                 !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                 bcount != caf_chunk_header.mChunkSize) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     return WAVPACK_SOFT_ERROR;
              }
  
              WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
             desc_chunk = 1;
  
              if (debug_logging_mode) {
                  char formatstr [5];
 
                 memcpy (formatstr, caf_audio_format.mFormatID, 4);
                 formatstr [4] = 0;
                 error_line (""format = %s, flags = %x, sampling rate = %g"",
                     formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                 error_line (""packet = %d bytes and %d frames"",
                     caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                 error_line (""channels per frame = %d, bits per channel = %d"",
                     caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
             }
 
             if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                 supported = FALSE;
             else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                 caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                     supported = FALSE;
             else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                 supported = FALSE;
             else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                 ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                     supported = FALSE;
             else if (caf_audio_format.mFramesPerPacket != 1 ||
                 caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                 caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                 caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                     supported = FALSE;
 
             if (!supported) {
                 error_line (""%s is an unsupported .CAF format!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }
 
             config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
             config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
             config->bits_per_sample = caf_audio_format.mBitsPerChannel;
             config->num_channels = caf_audio_format.mChannelsPerFrame;
             config->sample_rate = (int) caf_audio_format.mSampleRate;
 
             if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                 config->qmode |= QMODE_BIG_ENDIAN;
 
             if (config->bytes_per_sample == 1)
                 config->qmode |= QMODE_SIGNED_BYTES;
 
             if (debug_logging_mode) {
                 if (config->float_norm_exp == 127)
                     error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                 else
                     error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                         config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
             }
         }
         else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
             CAFChannelLayout *caf_channel_layout;
 
             if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                 caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                     error_line (""this .CAF file has an invalid 'chan' chunk!"");
                     return WAVPACK_SOFT_ERROR;
             }
 
             if (debug_logging_mode)
                 error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);
 
             caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);
 
             if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                 bcount != caf_chunk_header.mChunkSize) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     free (caf_channel_layout);
                     return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     free (caf_channel_layout);
                     return WAVPACK_SOFT_ERROR;
             }
 
             WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
             chan_chunk = 1;
 
             if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                 error_line (""this CAF file already has channel order information!"");
                 free (caf_channel_layout);
                 return WAVPACK_SOFT_ERROR;
             }
 
             switch (caf_channel_layout->mChannelLayoutTag) {
                 case kCAFChannelLayoutTag_UseChannelDescriptions:
                     {
                         CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                         int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                         int label, cindex = 0, idents = 0;
 
                         if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                             num_descriptions != config->num_channels) {
                                 error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                 free (caf_channel_layout);
                                 return WAVPACK_SOFT_ERROR;
                         }
 
                         if (num_descriptions >= 256) {
                             error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                             break;
                         }
 
 
                         channel_reorder = malloc (num_descriptions);
                         memset (channel_reorder, -1, num_descriptions);
                         channel_identities = malloc (num_descriptions+1);
 
 
                         for (i = 0; i < num_descriptions; ++i) {
                             WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);
 
                             if (debug_logging_mode)
                                 error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                         }
 
 
                         for (label = 1; label <= 18; ++label)
                             for (i = 0; i < num_descriptions; ++i)
                                 if (descriptions [i].mChannelLabel == label) {
                                     config->channel_mask |= 1 << (label - 1);
                                     channel_reorder [i] = cindex++;
                                     break;
                                 }
 
 
                         for (i = 0; i < num_descriptions; ++i)
                             if (channel_reorder [i] == (unsigned char) -1) {
                                 uint32_t clabel = descriptions [i].mChannelLabel;
 
                                 if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                     channel_identities [idents++] = 0xff;
                                 else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                     channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                 else {
                                     error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                     channel_identities [idents++] = 0xff;
                                 }
 
                                 channel_reorder [i] = cindex++;
                             }
 
 
                         for (i = 0; i < num_descriptions; ++i)
                             if (channel_reorder [i] != i)
                                 break;
 
                         if (i == num_descriptions) {
                             free (channel_reorder);                  
                             channel_reorder = NULL;
                         }
                         else {
                             config->qmode |= QMODE_REORDERED_CHANS;  
                             channel_layout = num_descriptions;
                         }
 
                         if (!idents) {                               
                             free (channel_identities);
                             channel_identities = NULL;
                         }
                         else
                             channel_identities [idents] = 0;         
 
                         if (debug_logging_mode) {
                             error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                 caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                 caf_channel_layout->mNumberChannelDescriptions, idents);
 
 
                             if (channel_reorder && num_descriptions <= 8) {
                                 char reorder_string [] = ""12345678"";
 
                                 for (i = 0; i < num_descriptions; ++i)
                                     reorder_string [i] = channel_reorder [i] + '1';
 
                                 reorder_string [i] = 0;
                                 error_line (""reordering string = \""%s\""\n"", reorder_string);
                             }
                         }
                     }
 
                     break;
 
                 case kCAFChannelLayoutTag_UseChannelBitmap:
                     config->channel_mask = caf_channel_layout->mChannelBitmap;
 
                     if (debug_logging_mode)
                         error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                             caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);
 
                     break;
 
                 default:
                     for (i = 0; i < NUM_LAYOUTS; ++i)
                         if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                             config->channel_mask = layouts [i].mChannelBitmap;
                             channel_layout = layouts [i].mChannelLayoutTag;
 
                             if (layouts [i].mChannelReorder) {
                                 channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                 config->qmode |= QMODE_REORDERED_CHANS;
                             }
 
                             if (layouts [i].mChannelIdentities)
                                 channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);
 
                             if (debug_logging_mode)
                                 error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                     channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");
 
                             break;
                         }
 
                     if (i == NUM_LAYOUTS && debug_logging_mode)
                         error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                             caf_channel_layout->mChannelLayoutTag);
 
                     break;
             }
 
             free (caf_channel_layout);
         }
          else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {      
              uint32_t mEditCount;
  
            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
             if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                  bcount != sizeof (mEditCount)) {
                      error_line (""%s is not a valid .CAF file!"", infilename);
                      return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     return WAVPACK_SOFT_ERROR;
             }
 
             if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                 config->qmode |= QMODE_IGNORE_LENGTH;
 
                 if (infilesize && DoGetFilePosition (infile) != -1)
                     total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                 else
                     total_samples = -1;
             }
             else {
                 if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                     error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                     error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;
 
                 if (!total_samples) {
                     error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 if (total_samples > MAX_WAVPACK_SAMPLES) {
                     error_line (""%s has too many samples for WavPack!"", infilename);
                     return WAVPACK_SOFT_ERROR;
                 }
             }
 
             break;
         }
         else {           
 
             uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
             char *buff;
 
             if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                 error_line (""%s is not a valid .CAF file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }
 
             buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                     caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                     caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);
 
             if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                 bcount != bytes_to_copy ||
                 (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     free (buff);
                     return WAVPACK_SOFT_ERROR;
             }
 
             free (buff);
         }
     }
 
     if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
         config->channel_mask = 0x5 - config->num_channels;
 
     if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
         error_line (""%s"", WavpackGetErrorMessage (wpc));
         return WAVPACK_SOFT_ERROR;
     }
 
     if (channel_identities)
         free (channel_identities);
 
     if (channel_layout || channel_reorder) {
         if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
             error_line (""problem with setting channel layout (should not happen)"");
             return WAVPACK_SOFT_ERROR;
         }
 
         if (channel_reorder)
             free (channel_reorder);
     }
 
     return WAVPACK_NO_ERROR;
 }","[4, 66, 300, 3, 299]","WavPack 5.1.0 and earlier is affected by: CWE-457: Use of Uninitialized Variable. The impact is: Unexpected control flow, crashes, and segfaults. The component is: ParseCaffHeaderConfig (caff.c:486). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b."
204030," EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionRemoveEventListener(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
     if (!thisValue.inherits(&JSTestEventTarget::s_info))
         return throwVMTypeError(exec);
     JSTestEventTarget* castedThis = jsCast<JSTestEventTarget*>(asObject(thisValue));
      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);
      TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());
      if (exec->argumentCount() < 2)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      JSValue listener = exec->argument(1);
      if (!listener.isObject())
          return JSValue::encode(jsUndefined());
     impl->removeEventListener(ustringToAtomicString(exec->argument(0).toString(exec)->value(exec)), JSEventListener::create(asObject(listener), castedThis, false, currentWorld(exec)).get(), exec->argument(2).toBoolean(exec));
     return JSValue::encode(jsUndefined());
 }","[11, 10]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
202024," int perf_pmu_register(struct pmu *pmu, const char *name, int type)
 {
 	int cpu, ret;
 
 	mutex_lock(&pmus_lock);
 	ret = -ENOMEM;
 	pmu->pmu_disable_count = alloc_percpu(int);
 	if (!pmu->pmu_disable_count)
 		goto unlock;
 
 	pmu->type = -1;
 	if (!name)
 		goto skip_type;
 	pmu->name = name;
 
 	if (type < 0) {
 		type = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);
 		if (type < 0) {
 			ret = type;
 			goto free_pdc;
 		}
 	}
 	pmu->type = type;
 
 	if (pmu_bus_running) {
 		ret = pmu_dev_alloc(pmu);
 		if (ret)
 			goto free_idr;
 	}
 
 skip_type:
 	pmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);
 	if (pmu->pmu_cpu_context)
 		goto got_cpu_context;
 
 	ret = -ENOMEM;
 	pmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);
 	if (!pmu->pmu_cpu_context)
 		goto free_dev;
 
 	for_each_possible_cpu(cpu) {
 		struct perf_cpu_context *cpuctx;
 
 		cpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);
  		__perf_event_init_context(&cpuctx->ctx);
  		lockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);
  		lockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);
		cpuctx->ctx.type = cpu_context;
  		cpuctx->ctx.pmu = pmu;
  
  		__perf_cpu_hrtimer_init(cpuctx, cpu);
 
 		INIT_LIST_HEAD(&cpuctx->rotation_list);
 		cpuctx->unique_pmu = pmu;
 	}
 
 got_cpu_context:
 	if (!pmu->start_txn) {
 		if (pmu->pmu_enable) {
 			 
 			pmu->start_txn  = perf_pmu_start_txn;
 			pmu->commit_txn = perf_pmu_commit_txn;
 			pmu->cancel_txn = perf_pmu_cancel_txn;
 		} else {
 			pmu->start_txn  = perf_pmu_nop_void;
 			pmu->commit_txn = perf_pmu_nop_int;
 			pmu->cancel_txn = perf_pmu_nop_void;
 		}
 	}
 
 	if (!pmu->pmu_enable) {
 		pmu->pmu_enable  = perf_pmu_nop_void;
 		pmu->pmu_disable = perf_pmu_nop_void;
 	}
 
 	if (!pmu->event_idx)
 		pmu->event_idx = perf_event_idx_default;
 
 	list_add_rcu(&pmu->entry, &pmus);
 	ret = 0;
 unlock:
 	mutex_unlock(&pmus_lock);
 
 	return ret;
 
 free_dev:
 	device_del(pmu->dev);
 	put_device(pmu->dev);
 
 free_idr:
 	if (pmu->type >= PERF_TYPE_MAX)
 		idr_remove(&pmu_idr, pmu->type);
 
 free_pdc:
 	free_percpu(pmu->pmu_disable_count);
 	goto unlock;
 }",[48],"kernel/events/core.c in the Linux kernel before 3.19 mishandles counter grouping, which allows local users to gain privileges via a crafted application, related to the perf_pmu_register and perf_event_open functions."
202823,"  void prefetch_table(const void *tab, size_t len)
  {
    const volatile byte *vtab = tab;
    size_t i;
  
  for (i = 0; i < len; i += 8 * 32)
   for (i = 0; len - i >= 8 * 32; i += 8 * 32)
      {
        (void)vtab[i + 0 * 32];
        (void)vtab[i + 1 * 32];
       (void)vtab[i + 2 * 32];
       (void)vtab[i + 3 * 32];
       (void)vtab[i + 4 * 32];
       (void)vtab[i + 5 * 32];
        (void)vtab[i + 6 * 32];
        (void)vtab[i + 7 * 32];
      }
   for (; i < len; i += 32)
     {
       (void)vtab[i];
     }
  
    (void)vtab[len - 1];
  }","[7, 18, 19, 20, 21, 6]","In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)"
200939," atol10(const char *p, size_t char_cnt)
 {
  	uint64_t l;
  	int digit;
  
 	if (char_cnt == 0)
 		return (0);
 
  	l = 0;
  	digit = *p - '0';
  	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
 		l = (l * 10) + digit;
 		digit = *++p - '0';
 	}
 	return (l);
 }","[6, 7, 8]","libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c."
198762," struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 {
 	struct sk_buff *clone;
 	struct net_device *dev = skb->dev;
 	struct frag_hdr *fhdr;
 	struct nf_ct_frag6_queue *fq;
 	struct ipv6hdr *hdr;
 	int fhoff, nhoff;
 	u8 prevhdr;
 	struct sk_buff *ret_skb = NULL;
 
 	 
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
 		return skb;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
 		return skb;
 
 	clone = skb_clone(skb, GFP_ATOMIC);
 	if (clone == NULL) {
 		pr_debug(""Can't clone skb\n"");
 		return skb;
 	}
 
 	NFCT_FRAG6_CB(clone)->orig = skb;
 
 	if (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {
 		pr_debug(""message is too short.\n"");
 		goto ret_orig;
 	}
 
 	skb_set_transport_header(clone, fhoff);
  	hdr = ipv6_hdr(clone);
  	fhdr = (struct frag_hdr *)skb_transport_header(clone);
  
	if (!(fhdr->frag_off & htons(0xFFF9))) {
		pr_debug(""Invalid fragment offset\n"");
		 
		goto ret_orig;
	}
  	if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)
  		nf_ct_frag6_evictor();
  
 	fq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);
 	if (fq == NULL) {
 		pr_debug(""Can't find and can't create new queue\n"");
 		goto ret_orig;
 	}
 
 	spin_lock_bh(&fq->q.lock);
 
 	if (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {
 		spin_unlock_bh(&fq->q.lock);
 		pr_debug(""Can't insert skb to queue\n"");
 		fq_put(fq);
 		goto ret_orig;
 	}
 
 	if (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
 	    fq->q.meat == fq->q.len) {
 		ret_skb = nf_ct_frag6_reasm(fq, dev);
 		if (ret_skb == NULL)
 			pr_debug(""Can't reassemble fragmented packets\n"");
 	}
 	spin_unlock_bh(&fq->q.lock);
 
 	fq_put(fq);
 	return ret_skb;
 
 ret_orig:
 	kfree_skb(clone);
 	return skb;
 }","[38, 39, 40, 41, 42]","net/ipv6/netfilter/nf_conntrack_reasm.c in the Linux kernel before 2.6.34, when the nf_conntrack_ipv6 module is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via certain types of fragmented IPv6 packets."
6135,"void Jp2Image::readMetadata()
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cerr << ""Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file "" << io_->path() << std::endl;
#endif
if (io_->open() != 0)
{
throw Error(kerDataSourceOpenFailed, io_->path(), strError());
}
IoCloser closer(*io_);

if (!isJp2Type(*io_, true))
{
if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);
throw Error(kerNotAnImage, ""JPEG-2000"");
}

long              position  = 0;
Jp2BoxHeader      box       = {0,0};
Jp2BoxHeader      subBox    = {0,0};
Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};
Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))
{
position   = io_->tell();
box.length = getLong((byte*)&box.length, bigEndian);
box.type   = getLong((byte*)&box.type, bigEndian);
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: ""
<< ""Position: "" << position
<< "" box type: "" << toAscii(box.type)
<< "" length: "" << box.length
<< std::endl;
#endif

if (box.length == 0) return ;

if (box.length == 1)
{

}

switch(box.type)
{
case kJp2BoxTypeJp2Header:
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: JP2Header box found"" << std::endl;
#endif
long restore = io_->tell();

while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )
{
subBox.length = getLong((byte*)&subBox.length, bigEndian);
subBox.type   = getLong((byte*)&subBox.type, bigEndian);
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: ""
<< ""subBox = "" << toAscii(subBox.type) << "" length = "" << subBox.length << std::endl;
#endif
if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: ""
<< ""Color data found"" << std::endl;
#endif

const long pad = 3 ;
const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));

if (data_length > io_->size() - io_->tell()) {
throw Error(kerCorruptedMetadata);
}
DataBuf data(static_cast<long>(data_length));
io_->read(data.pData_,data.size_);
const long    iccLength = getULong(data.pData_+pad, bigEndian);


if (iccLength > data.size_ - pad) {
throw Error(kerCorruptedMetadata);
}
DataBuf icc(iccLength);
::memcpy(icc.pData_,data.pData_+pad,icc.size_);
#ifdef EXIV2_DEBUG_MESSAGES
const char* iccPath = ""/tmp/libexiv2_jp2.icc"";
FILE* f = fopen(iccPath,""wb"");
if ( f ) {
fwrite(icc.pData_,icc.size_,1,f);
fclose(f);
}
std::cout << ""Exiv2::Jp2Image::readMetadata: wrote iccProfile "" << icc.size_<< "" bytes to "" << iccPath << std::endl ;
#endif
setIccProfile(icc);
}

if( subBox.type == kJp2BoxTypeImageHeader)
{
io_->read((byte*)&ihdr, sizeof(ihdr));
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: Ihdr data found"" << std::endl;
#endif
ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);
ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);
ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);
ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);

pixelWidth_  = ihdr.imageWidth;
pixelHeight_ = ihdr.imageHeight;
}

io_->seek(restore,BasicIo::beg);
io_->seek(subBox.length, Exiv2::BasicIo::cur);
restore = io_->tell();
}
break;
}

case kJp2BoxTypeUuid:
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: UUID box found"" << std::endl;
#endif

if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))
{
DataBuf rawData;
long    bufRead;
bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;
bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;
bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;

if(bIsExif)
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: Exif data found"" << std::endl ;
#endif
rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));
bufRead = io_->read(rawData.pData_, rawData.size_);
if (io_->error()) throw Error(kerFailedToReadImageData);
if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);

if (rawData.size_ > 0)
{

long pos = (     (rawData.pData_[0]      == rawData.pData_[1])
&&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')
)  ? 0 : -1;


const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };
for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)
{
if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)
{
pos = i+sizeof(exifHeader);
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Reading non-standard UUID-EXIF_bad box in "" << io_->path() << std::endl;
#endif

}
}


if (pos >= 0 )
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: Exif header found at position "" << pos << std::endl;
#endif
ByteOrder bo = TiffParser::decode(exifData(),
iptcData(),
xmpData(),
rawData.pData_ + pos,
rawData.size_ - pos);
setByteOrder(bo);
}
}
else
{
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to decode Exif metadata."" << std::endl;
#endif
exifData_.clear();
}
}

if(bIsIPTC)
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: Iptc data found"" << std::endl;
#endif
rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));
bufRead = io_->read(rawData.pData_, rawData.size_);
if (io_->error()) throw Error(kerFailedToReadImageData);
if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);

if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))
{
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to decode IPTC metadata."" << std::endl;
#endif
iptcData_.clear();
}
}

if(bIsXMP)
{
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Exiv2::Jp2Image::readMetadata: Xmp data found"" << std::endl;
#endif
rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));
bufRead = io_->read(rawData.pData_, rawData.size_);
if (io_->error()) throw Error(kerFailedToReadImageData);
if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);
xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);

std::string::size_type idx = xmpPacket_.find_first_of('<');
if (idx != std::string::npos && idx > 0)
{
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Removing "" << static_cast<uint32_t>(idx)
<< "" characters from the beginning of the XMP packet"" << std::endl;
#endif
xmpPacket_ = xmpPacket_.substr(idx);
}

if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))
{
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to decode XMP metadata."" << std::endl;
#endif
}
}
}
break;
}

default:
{
break;
}
}


io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);
if (io_->error()) throw Error(kerFailedToReadImageData);
}

}","[24, 26, 55, 57, 112]","In Jp2Image::readMetadata() in jp2image.cpp in Exiv2 0.27.2, an input file can result in an infinite loop and hang, with high CPU consumption. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file."
201847," int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
 codetype type;
 unsigned short FAR *lens;
 unsigned codes;
 code FAR * FAR *table;
 unsigned FAR *bits;
 unsigned short FAR *work;
 {
     unsigned len;                
     unsigned sym;                
     unsigned min, max;           
     unsigned root;               
     unsigned curr;               
     unsigned drop;               
     int left;                    
     unsigned used;               
     unsigned huff;               
     unsigned incr;               
     unsigned fill;               
     unsigned low;                
     unsigned mask;               
     code here;                   
      code FAR *next;              
      const unsigned short FAR *base;      
      const unsigned short FAR *extra;     
    int end;                     
     unsigned match;              
      unsigned short count[MAXBITS+1];     
      unsigned short offs[MAXBITS+1];      
      static const unsigned short lbase[31] = {  
         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
     static const unsigned short lext[31] = {  
         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 198};
     static const unsigned short dbase[32] = {  
         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
         8193, 12289, 16385, 24577, 0, 0};
     static const unsigned short dext[32] = {  
         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
         28, 28, 29, 29, 64, 64};
 
      
 
      
     for (len = 0; len <= MAXBITS; len++)
         count[len] = 0;
     for (sym = 0; sym < codes; sym++)
         count[lens[sym]]++;
 
      
     root = *bits;
     for (max = MAXBITS; max >= 1; max--)
         if (count[max] != 0) break;
     if (root > max) root = max;
     if (max == 0) {                      
         here.op = (unsigned char)64;     
         here.bits = (unsigned char)1;
         here.val = (unsigned short)0;
         *(*table)++ = here;              
         *(*table)++ = here;
         *bits = 1;
         return 0;      
     }
     for (min = 1; min < max; min++)
         if (count[min] != 0) break;
     if (root < min) root = min;
 
      
     left = 1;
     for (len = 1; len <= MAXBITS; len++) {
         left <<= 1;
         left -= count[len];
         if (left < 0) return -1;         
     }
     if (left > 0 && (type == CODES || max != 1))
         return -1;                       
 
      
     offs[1] = 0;
     for (len = 1; len < MAXBITS; len++)
         offs[len + 1] = offs[len] + count[len];
 
      
     for (sym = 0; sym < codes; sym++)
         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
 
      
 
      
      switch (type) {
      case CODES:
          base = extra = work;     
        end = 19;
         match = 20;
          break;
      case LENS:
          base = lbase;
        base -= 257;
          extra = lext;
        extra -= 257;
        end = 256;
         match = 257;
          break;
      default:             
          base = dbase;
          extra = dext;
        end = -1;
         match = 0;
      }
  
       
     huff = 0;                    
     sym = 0;                     
     len = min;                   
     next = *table;               
     curr = root;                 
     drop = 0;                    
     low = (unsigned)(-1);        
     used = 1U << root;           
     mask = used - 1;             
 
      
     if ((type == LENS && used > ENOUGH_LENS) ||
         (type == DISTS && used > ENOUGH_DISTS))
         return 1;
 
      
      for (;;) {
           
          here.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
         if (work[sym] + 1 < match) {
              here.op = (unsigned char)0;
              here.val = work[sym];
          }
        else if ((int)(work[sym]) > end) {
            here.op = (unsigned char)(extra[work[sym]]);
            here.val = base[work[sym]];
         else if (work[sym] >= match) {
             here.op = (unsigned char)(extra[work[sym] - match]);
             here.val = base[work[sym] - match];
          }
          else {
              here.op = (unsigned char)(32 + 64);          
             here.val = 0;
         }
 
          
         incr = 1U << (len - drop);
         fill = 1U << curr;
         min = fill;                  
         do {
             fill -= incr;
             next[(huff >> drop) + fill] = here;
         } while (fill != 0);
 
          
         incr = 1U << (len - 1);
         while (huff & incr)
             incr >>= 1;
         if (incr != 0) {
             huff &= incr - 1;
             huff += incr;
         }
         else
             huff = 0;
 
          
         sym++;
         if (--(count[len]) == 0) {
             if (len == max) break;
             len = lens[work[sym]];
         }
 
          
         if (len > root && (huff & mask) != low) {
              
             if (drop == 0)
                 drop = root;
 
              
             next += min;             
 
              
             curr = len - drop;
             left = (int)(1 << curr);
             while (curr + drop < max) {
                 left -= count[curr + drop];
                 if (left <= 0) break;
                 curr++;
                 left <<= 1;
             }
 
              
             used += 1U << curr;
             if ((type == LENS && used > ENOUGH_LENS) ||
                 (type == DISTS && used > ENOUGH_DISTS))
                 return 1;
 
              
             low = huff & mask;
             (*table)[low].op = (unsigned char)curr;
             (*table)[low].bits = (unsigned char)root;
             (*table)[low].val = (unsigned short)(next - *table);
         }
     }
 
      
     if (huff != 0) {
         here.op = (unsigned char)64;             
         here.bits = (unsigned char)(len - drop);
         here.val = (unsigned short)0;
         next[huff] = here;
     }
 
      
     *table += used;
     *bits = root;
     return 0;
 }","[27, 97, 105, 111, 135, 142, 143, 144, 26, 96, 101, 103, 104, 110, 134, 139, 140, 141]",inftrees.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.
198678," void EC_GROUP_clear_free(EC_GROUP *group)
 	{
 	if (!group) return;
 
 	if (group->meth->group_clear_finish != 0)
 		group->meth->group_clear_finish(group);
 	else if (group->meth->group_finish != 0)
 		group->meth->group_finish(group);
 
 	EC_EX_DATA_clear_free_all_data(&group->extra_data);
 
 	if (group->generator != NULL)
  
         EC_EX_DATA_clear_free_all_data(&group->extra_data);
  
        if (group->mont_data)
                BN_MONT_CTX_free(group->mont_data);
 
         if (group->generator != NULL)
                 EC_POINT_clear_free(group->generator);
         BN_clear_free(&group->order);
 
 	OPENSSL_cleanse(group, sizeof *group);
 	OPENSSL_free(group);
 	}","[16, 17, 18]",A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.
201946," static bool check_allocations(ASS_Shaper *shaper, size_t new_size)
 {
     if (new_size > shaper->n_glyphs) {
         if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||
             !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||
              !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||
              !ASS_REALLOC_ARRAY(shaper->cmap, new_size))
              return false;
         shaper->n_glyphs = new_size;
      }
      return true;
  }",[9],The check_allocations function in libass/ass_shaper.c in libass before 0.13.4 allows remote attackers to cause a denial of service (memory allocation failure) via unspecified vectors.
6314,"jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)
{
uint32_t w, h;
uint32_t shift;
uint32_t leftbyte;
uint8_t *ss;
uint8_t *dd;
uint8_t leftmask, rightmask;
int early = x >= 0;
int late;
uint32_t bytewidth;
uint32_t syoffset = 0;

if (src == NULL)
return 0;




















w = src->width;
h = src->height;
shift = (x & 7);
ss = src->data - early;

if (x < 0) {
if (w < (uint32_t) -x)
w = 0;
else
w += x;
ss += (-x-1)>>3;
x = 0;
}
if (y < 0) {
if (h < (uint32_t) -y)
h = 0;
else
h += y;
syoffset = -y * src->stride;
y = 0;
}
if ((uint32_t)x + w > dst->width)
{
if (dst->width < (uint32_t)x)
w = 0;
else
w = dst->width - x;
}
if ((uint32_t)y + h > dst->height)
{
if (dst->height < (uint32_t)y)
h = 0;
else
h = dst->height - y;
}
#ifdef JBIG2_DEBUG
jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""compositing %dx%d at (%d, %d) after clipping"", w, h, x, y);
#endif


if ((w <= 0) || (h <= 0)) {
#ifdef JBIG2_DEBUG
jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""zero clipping region"");
#endif
return 0;
}

leftbyte = (uint32_t) x >> 3;
dd = dst->data + y * dst->stride + leftbyte;
bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;
leftmask = 255>>(x&7);
rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));
if (bytewidth == 1)
leftmask &= rightmask;
late = (ss + bytewidth >= src->data + ((src->width+7)>>3));
ss += syoffset;

switch(op)
{
case JBIG2_COMPOSE_OR:
jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_AND:
jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_XOR:
jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_XNOR:
jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
case JBIG2_COMPOSE_REPLACE:
jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);
break;
}

return 0;
}",[36],jbig2_image_compose in jbig2_image.c in Artifex jbig2dec before 0.18 has a heap-based buffer overflow.
206091," int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
     const RunFromHostProxyCallback& callback) {
   if (state_->run_called()) {
     if (!callback.is_null())
       callback.Run(PP_ERROR_FAILED);
     return PP_ERROR_FAILED;
   }
   state_->set_run_called();
   state_->set_run_callback(callback);
 
   scoped_refptr<State> state_protector(state_);
    {
      base::MessageLoop::ScopedNestableTaskAllower allow(
          base::MessageLoop::current());
     blink::WebView::willEnterModalLoop();
 
      base::MessageLoop::current()->Run();
 
     blink::WebView::didExitModalLoop();
    }
  
   return state_protector->result();
 }","[15, 16, 18, 19]","The PPB_Flash_MessageLoop_Impl::InternalRun function in content/renderer/pepper/ppb_flash_message_loop_impl.cc in the Pepper plugin in Google Chrome before 49.0.2623.75 mishandles nested message loops, which allows remote attackers to bypass the Same Origin Policy via a crafted web site."
207655," image_transform_png_set_expand_mod(PNG_CONST image_transform *this,
 image_transform_png_set_expand_mod(const image_transform *this,
      image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
     const transform_display *display)
  {
      
     if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
       image_pixel_convert_PLTE(that);
  else if (that->bit_depth < 8)  
 
        that->sample_depth = that->bit_depth = 8;
  
     if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);
       image_pixel_add_alpha(that, &display->this, 0 );
  
     this->next->mod(this->next, that, pp, display);
  }","[2, 5, 16, 4, 15]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
205882," HarfBuzzShaper::HarfBuzzShaper(const Font* font, const TextRun& run, const GlyphData* emphasisData,
     HashSet<const SimpleFontData*>* fallbackFonts, FloatRect* bounds)
     : Shaper(font, run, emphasisData, fallbackFonts, bounds)
     , m_normalizedBufferLength(0)
     , m_wordSpacingAdjustment(font->fontDescription().wordSpacing())
     , m_letterSpacing(font->fontDescription().letterSpacing())
      , m_expansionOpportunityCount(0)
      , m_fromIndex(0)
      , m_toIndex(m_run.length())
     , m_totalWidth(0)
  {
      m_normalizedBuffer = adoptArrayPtr(new UChar[m_run.length() + 1]);
      normalizeCharacters(m_run, m_run.length(), m_normalizedBuffer.get(), &m_normalizedBufferLength);
     setExpansion(m_run.expansion());
     setFontFeatures();
 }",[10],Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
201814," static MagickBooleanType GetMagickModulePath(const char *filename,
   MagickModuleType module_type,char *path,ExceptionInfo *exception)
 {
   char
     *module_path;
 
   assert(filename != (const char *) NULL);
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",filename);
    assert(path != (char *) NULL);
    assert(exception != (ExceptionInfo *) NULL);
    (void) CopyMagickString(path,filename,MaxTextExtent);
 #if defined(MAGICKCORE_INSTALLED_SUPPORT)
   if (strstr(path,""../"") != (char *) NULL)
     {
       errno=EPERM;
       (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,
         ""NotAuthorized"",""`%s'"",path);
       return(MagickFalse);
     }
 #endif
    module_path=(char *) NULL;
    switch (module_type)
    {
     case MagickImageCoderModule:
     default:
     {
       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
         ""Searching for coder module file \""%s\"" ..."",filename);
       module_path=GetEnvironmentValue(""MAGICK_CODER_MODULE_PATH"");
 #if defined(MAGICKCORE_CODER_PATH)
       if (module_path == (char *) NULL)
         module_path=AcquireString(MAGICKCORE_CODER_PATH);
 #endif
       break;
     }
     case MagickImageFilterModule:
     {
       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
         ""Searching for filter module file \""%s\"" ..."",filename);
       module_path=GetEnvironmentValue(""MAGICK_CODER_FILTER_PATH"");
 #if defined(MAGICKCORE_FILTER_PATH)
       if (module_path == (char *) NULL)
         module_path=AcquireString(MAGICKCORE_FILTER_PATH);
 #endif
       break;
     }
   }
   if (module_path != (char *) NULL)
     {
       register char
         *p,
         *q;
 
       for (p=module_path-1; p != (char *) NULL; )
       {
         (void) CopyMagickString(path,p+1,MaxTextExtent);
         q=strchr(path,DirectoryListSeparator);
         if (q != (char *) NULL)
           *q='\0';
         q=path+strlen(path)-1;
         if ((q >= path) && (*q != *DirectorySeparator))
           (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
         (void) ConcatenateMagickString(path,filename,MaxTextExtent);
         if (IsPathAccessible(path) != MagickFalse)
           {
             module_path=DestroyString(module_path);
             return(MagickTrue);
           }
         p=strchr(p+1,DirectoryListSeparator);
       }
       module_path=DestroyString(module_path);
     }
 #if defined(MAGICKCORE_INSTALLED_SUPPORT)
   else
 #if defined(MAGICKCORE_CODER_PATH)
     {
       const char
         *directory;
 
        
       switch (module_type)
       {
         case MagickImageCoderModule:
         default:
         {
           directory=MAGICKCORE_CODER_PATH;
           break;
         }
         case MagickImageFilterModule:
         {
           directory=MAGICKCORE_FILTER_PATH;
           break;
         }
       }
       (void) FormatLocaleString(path,MaxTextExtent,""%s%s"",directory,filename);
       if (IsPathAccessible(path) == MagickFalse)
         {
           ThrowFileException(exception,ConfigureWarning,
             ""UnableToOpenModuleFile"",path);
           return(MagickFalse);
         }
       return(MagickTrue);
     }
 #else
 #if defined(MAGICKCORE_WINDOWS_SUPPORT)
     {
       const char
         *registery_key;
 
       unsigned char
         *key_value;
 
        
       switch (module_type)
       {
         case MagickImageCoderModule:
         default:
         {
           registery_key=""CoderModulesPath"";
           break;
         }
         case MagickImageFilterModule:
         {
           registery_key=""FilterModulesPath"";
           break;
         }
       }
       key_value=NTRegistryKeyLookup(registery_key);
       if (key_value == (unsigned char *) NULL)
         {
           ThrowMagickException(exception,GetMagickModule(),ConfigureError,
             ""RegistryKeyLookupFailed"",""`%s'"",registery_key);
           return(MagickFalse);
         }
       (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",(char *) key_value,
         DirectorySeparator,filename);
       key_value=(unsigned char *) RelinquishMagickMemory(key_value);
       if (IsPathAccessible(path) == MagickFalse)
         {
           ThrowFileException(exception,ConfigureWarning,
             ""UnableToOpenModuleFile"",path);
           return(MagickFalse);
         }
       return(MagickTrue);
     }
 #endif
 #endif
 #if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)
 # error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined
 #endif
 #else
   {
     char
       *home;
 
     home=GetEnvironmentValue(""MAGICK_HOME"");
     if (home != (char *) NULL)
       {
          
 #if !defined(MAGICKCORE_POSIX_SUPPORT)
         (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",home,
           DirectorySeparator,filename);
 #else
         const char
           *directory;
 
         switch (module_type)
         {
           case MagickImageCoderModule:
           default:
           {
             directory=MAGICKCORE_CODER_RELATIVE_PATH;
             break;
           }
           case MagickImageFilterModule:
           {
             directory=MAGICKCORE_FILTER_RELATIVE_PATH;
             break;
           }
         }
         (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s"",home,
           directory,filename);
 #endif
         home=DestroyString(home);
         if (IsPathAccessible(path) != MagickFalse)
           return(MagickTrue);
       }
   }
   if (*GetClientPath() != '\0')
     {
        
 #if !defined(MAGICKCORE_POSIX_SUPPORT)
       (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",GetClientPath(),
         DirectorySeparator,filename);
 #else
       char
         prefix[MaxTextExtent];
 
       const char
         *directory;
 
       switch (module_type)
       {
         case MagickImageCoderModule:
         default:
         {
           directory=""coders"";
           break;
         }
         case MagickImageFilterModule:
         {
           directory=""filters"";
           break;
         }
       }
       (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);
       ChopPathComponents(prefix,1);
       (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s/%s"",prefix,
         MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);
 #endif
       if (IsPathAccessible(path) != MagickFalse)
         return(MagickTrue);
     }
 #if defined(MAGICKCORE_WINDOWS_SUPPORT)
   {
      
     if ((NTGetModulePath(""CORE_RL_magick_.dll"",path) != MagickFalse) ||
         (NTGetModulePath(""CORE_DB_magick_.dll"",path) != MagickFalse) ||
         (NTGetModulePath(""Magick.dll"",path) != MagickFalse))
       {
         (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
         (void) ConcatenateMagickString(path,filename,MaxTextExtent);
         if (IsPathAccessible(path) != MagickFalse)
           return(MagickTrue);
       }
   }
 #endif
   {
     char
       *home;
 
     home=GetEnvironmentValue(""XDG_CONFIG_HOME"");
     if (home == (char *) NULL)
       home=GetEnvironmentValue(""LOCALAPPDATA"");
     if (home == (char *) NULL)
       home=GetEnvironmentValue(""APPDATA"");
     if (home == (char *) NULL)
       home=GetEnvironmentValue(""USERPROFILE"");
     if (home != (char *) NULL)
       {
          
         (void) FormatLocaleString(path,MaxTextExtent,""%s%sImageMagick%s%s"",
           home,DirectorySeparator,DirectorySeparator,filename);
         home=DestroyString(home);
         if (IsPathAccessible(path) != MagickFalse)
           return(MagickTrue);
       }
     home=GetEnvironmentValue(""HOME"");
     if (home != (char *) NULL)
       {
          
         (void) FormatLocaleString(path,MaxTextExtent,
           ""%s%s.config%sImageMagick%s%s"",home,DirectorySeparator,
           DirectorySeparator,DirectorySeparator,filename);
         if (IsPathAccessible(path) != MagickFalse)
           {
             home=DestroyString(home);
             return(MagickTrue);
           }
          
         (void) FormatLocaleString(path,MaxTextExtent,""%s%s.magick%s%s"",home,
           DirectorySeparator,DirectorySeparator,filename);
         home=DestroyString(home);
         if (IsPathAccessible(path) != MagickFalse)
           return(MagickTrue);
       }
   }
    
   if (IsPathAccessible(path) != MagickFalse)
     return(MagickTrue);
   if (exception->severity < ConfigureError)
     ThrowFileException(exception,ConfigureWarning,""UnableToOpenModuleFile"",
       path);
 #endif
   return(MagickFalse);
 }","[12, 13, 14, 15, 16, 17, 18, 19, 20]",Directory traversal vulnerability in magick/module.c in ImageMagick 6.9.4-7 allows remote attackers to load arbitrary modules via unspecified vectors.
207443," void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst)
 void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst, size_t dst_len)
  {
      if (src == NULL || src_len == 0 || dst == NULL) {
          return;
  }
 
  const char32_t *cur_utf32 = src;
  const char32_t *end_utf32 = src + src_len;
 
      char *cur = dst;
      while (cur_utf32 < end_utf32) {
          size_t len = utf32_codepoint_utf8_length(*cur_utf32);
         LOG_ALWAYS_FATAL_IF(dst_len < len, ""%zu < %zu"", dst_len, len);
          utf32_codepoint_to_utf8((uint8_t *)cur, *cur_utf32++, len);
          cur += len;
         dst_len -= len;
      }
     LOG_ALWAYS_FATAL_IF(dst_len < 1, ""dst_len < 1: %zu < 1"", dst_len);
      *cur = '\0';
  }","[2, 14, 17, 19]","LibUtils in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 mishandles conversions between Unicode character encodings with different encoding widths, which allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow) via a crafted file, aka internal bug 29250543."
199587," txid_current_snapshot(PG_FUNCTION_ARGS)
 {
 	TxidSnapshot *snap;
 	uint32		nxip,
 				i,
 				size;
 	TxidEpoch	state;
 	Snapshot	cur;
 
 	cur = GetActiveSnapshot();
 	if (cur == NULL)
 		elog(ERROR, ""no active snapshot set"");
  
  	load_xid_epoch(&state);
  
 	 
 	StaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,
 					 ""possible overflow in txid_current_snapshot()"");
 
  	 
  	nxip = cur->xcnt;
  	size = TXID_SNAPSHOT_SIZE(nxip);
 	snap = palloc(size);
 	SET_VARSIZE(snap, size);
 
 	 
 	snap->xmin = convert_xid(cur->xmin, &state);
 	snap->xmax = convert_xid(cur->xmax, &state);
 	snap->nxip = nxip;
 	for (i = 0; i < nxip; i++)
 		snap->xip[i] = convert_xid(cur->xip[i], &state);
 
 	 
 	sort_snapshot(snap);
 
 	PG_RETURN_POINTER(snap);
 }","[16, 17, 18, 19]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions."
201414," static ssize_t read_mem(struct file *file, char __user *buf,
 			size_t count, loff_t *ppos)
 {
 	phys_addr_t p = *ppos;
 	ssize_t read, sz;
 	void *ptr;
 
 	if (p != *ppos)
 		return 0;
 
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 	read = 0;
 #ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
 	 
 	if (p < PAGE_SIZE) {
 		sz = size_inside_page(p, count);
 		if (sz > 0) {
 			if (clear_user(buf, sz))
 				return -EFAULT;
 			buf += sz;
 			p += sz;
 			count -= sz;
 			read += sz;
 		}
 	}
 #endif
  
  	while (count > 0) {
  		unsigned long remaining;
 		int allowed;
  
  		sz = size_inside_page(p, count);
  
		if (!range_is_allowed(p >> PAGE_SHIFT, count))
 		allowed = page_is_allowed(p >> PAGE_SHIFT);
 		if (!allowed)
  			return -EPERM;
 		if (allowed == 2) {
 			 
 			remaining = clear_user(buf, sz);
 		} else {
 			 
 			ptr = xlate_dev_mem_ptr(p);
 			if (!ptr)
 				return -EFAULT;
  
		 
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr)
			return -EFAULT;
 			remaining = copy_to_user(buf, ptr, sz);
 
 			unxlate_dev_mem_ptr(p, ptr);
 		}
  
		remaining = copy_to_user(buf, ptr, sz);
		unxlate_dev_mem_ptr(p, ptr);
  		if (remaining)
  			return -EFAULT;
  
 		buf += sz;
 		p += sz;
 		count -= sz;
 		read += sz;
 	}
 
 	*ppos += read;
 	return read;
 }","[31, 36, 37, 39, 40, 41, 42, 43, 44, 45, 46, 52, 53, 54, 55, 35, 48, 49, 50, 51, 57, 58]","The mm subsystem in the Linux kernel through 4.10.10 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c."
5832,"static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
size_t mincodes, size_t numcodes, unsigned maxbitlen)
{
unsigned error = 0;
while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--;
tree->maxbitlen = maxbitlen;
tree->numcodes = (unsigned)numcodes;
tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));
if(!tree->lengths) return 83;

memset(tree->lengths, 0, numcodes * sizeof(unsigned));

error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
if(!error) error = HuffmanTree_makeFromLengths2(tree);
return error;
}","[4, 8]","libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value."
206259," DrawingBuffer::DrawingBuffer(
     std::unique_ptr<WebGraphicsContext3DProvider> context_provider,
     std::unique_ptr<Extensions3DUtil> extensions_util,
     Client* client,
     bool discard_framebuffer_supported,
      bool want_alpha_channel,
      bool premultiplied_alpha,
      PreserveDrawingBuffer preserve,
    WebGLVersion web_gl_version,
     WebGLVersion webgl_version,
      bool want_depth,
      bool want_stencil,
      ChromiumImageUsage chromium_image_usage,
      const CanvasColorParams& color_params)
      : client_(client),
        preserve_drawing_buffer_(preserve),
      web_gl_version_(web_gl_version),
       webgl_version_(webgl_version),
        context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(
            std::move(context_provider)))),
        gl_(this->ContextProvider()->ContextGL()),
       extensions_util_(std::move(extensions_util)),
       discard_framebuffer_supported_(discard_framebuffer_supported),
       want_alpha_channel_(want_alpha_channel),
       premultiplied_alpha_(premultiplied_alpha),
       software_rendering_(this->ContextProvider()->IsSoftwareRendering()),
       want_depth_(want_depth),
       want_stencil_(want_stencil),
       color_space_(color_params.GetGfxColorSpace()),
       chromium_image_usage_(chromium_image_usage) {
   TRACE_EVENT_INSTANT0(""test_gpu"", ""DrawingBufferCreation"",
                        TRACE_EVENT_SCOPE_GLOBAL);
 }","[10, 18, 9, 17]",Heap buffer overflow in WebGL in Google Chrome prior to 61.0.3163.79 for Windows allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.
207612," transform_name(int t)
   
 {
  unsigned int i;
 
  
     t &= -t;  
  
   for (i=0; i<TTABLE_SIZE; ++i)
    for (i=0; i<TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)
     {
        if ((transform_info[i].transform & t) != 0)
           return transform_info[i].name;
  }
 
  return ""invalid transform"";
 }","[10, 9]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
200107," int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error)  
 {
 	phar_zip_dir_end locator;
 	char buf[sizeof(locator) + 65536];
 	zend_long size;
 	php_uint16 i;
 	phar_archive_data *mydata = NULL;
 	phar_entry_info entry = {0};
 	char *p = buf, *ext, *actual_alias = NULL;
 	char *metadata = NULL;
 
 	size = php_stream_tell(fp);
 
 	if (size > sizeof(locator) + 65536) {
 		 
 		size = sizeof(locator) + 65536;
 		if (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {
 			php_stream_close(fp);
 			if (error) {
 				spprintf(error, 4096, ""phar error: unable to search for end of central directory in zip-based phar \""%s\"""", fname);
 			}
 			return FAILURE;
 		}
 	} else {
 		php_stream_seek(fp, 0, SEEK_SET);
 	}
 
 	if (!php_stream_read(fp, buf, size)) {
 		php_stream_close(fp);
 		if (error) {
 			spprintf(error, 4096, ""phar error: unable to read in data to search for end of central directory in zip-based phar \""%s\"""", fname);
 		}
 		return FAILURE;
 	}
 
 	while ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {
 		if ((p - buf) + sizeof(locator) <= size && !memcmp(p + 1, ""K\5\6"", 3)) {
 			memcpy((void *)&locator, (void *) p, sizeof(locator));
 			if (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {
 				 
 				php_stream_close(fp);
 				if (error) {
 					spprintf(error, 4096, ""phar error: split archives spanning multiple zips cannot be processed in zip-based phar \""%s\"""", fname);
 				}
 				return FAILURE;
 			}
 
 			if (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {
 				if (error) {
 					spprintf(error, 4096, ""phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \""%s\"""", fname);
 				}
 				php_stream_close(fp);
 				return FAILURE;
 			}
 
 			mydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));
 			mydata->is_persistent = PHAR_G(persist);
 
 			 
 			if (PHAR_GET_16(locator.comment_len)) {
 
 				metadata = p + sizeof(locator);
 
 				if (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {
 					if (error) {
 						spprintf(error, 4096, ""phar error: corrupt zip archive, zip file comment truncated in zip-based phar \""%s\"""", fname);
 					}
 					php_stream_close(fp);
 					pefree(mydata, mydata->is_persistent);
 					return FAILURE;
 				}
 
 				mydata->metadata_len = PHAR_GET_16(locator.comment_len);
 
 				if (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len)) == FAILURE) {
 					mydata->metadata_len = 0;
 					 
 
 					ZVAL_NEW_STR(&mydata->metadata, zend_string_init(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent));
 				}
 			} else {
 				ZVAL_UNDEF(&mydata->metadata);
 			}
 
 			goto foundit;
 		}
 	}
 
 	php_stream_close(fp);
 
 	if (error) {
 		spprintf(error, 4096, ""phar error: end of central directory not found in zip-based phar \""%s\"""", fname);
 	}
 
 	return FAILURE;
 foundit:
 	mydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);
 #ifdef PHP_WIN32
 	phar_unixify_path_separators(mydata->fname, fname_len);
 #endif
 	mydata->is_zip = 1;
 	mydata->fname_len = fname_len;
 	ext = strrchr(mydata->fname, '/');
 
 	if (ext) {
 		mydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);
 		if (mydata->ext == ext) {
 			mydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);
 		}
 		if (mydata->ext) {
 			mydata->ext_len = (mydata->fname + fname_len) - mydata->ext;
 		}
 	}
 
 	 
 	 
 	php_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);
 	 
 	zend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),
 		zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);
 	zend_hash_init(&mydata->mounted_dirs, 5,
 		zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
 	zend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,
 		zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
 	entry.phar = mydata;
 	entry.is_zip = 1;
 	entry.fp_type = PHAR_FP;
 	entry.is_persistent = mydata->is_persistent;
 #define PHAR_ZIP_FAIL_FREE(errmsg, save) \
 			zend_hash_destroy(&mydata->manifest); \
 			mydata->manifest.u.flags = 0; \
 			zend_hash_destroy(&mydata->mounted_dirs); \
 			mydata->mounted_dirs.u.flags = 0; \
 			zend_hash_destroy(&mydata->virtual_dirs); \
 			mydata->virtual_dirs.u.flags = 0; \
 			php_stream_close(fp); \
 			zval_dtor(&mydata->metadata); \
 			if (mydata->signature) { \
 				efree(mydata->signature); \
 			} \
 			if (error) { \
 				spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
 			} \
 			pefree(mydata->fname, mydata->is_persistent); \
 			if (mydata->alias) { \
 				pefree(mydata->alias, mydata->is_persistent); \
 			} \
 			pefree(mydata, mydata->is_persistent); \
 			efree(save); \
 			return FAILURE;
 #define PHAR_ZIP_FAIL(errmsg) \
 			zend_hash_destroy(&mydata->manifest); \
 			mydata->manifest.u.flags = 0; \
 			zend_hash_destroy(&mydata->mounted_dirs); \
 			mydata->mounted_dirs.u.flags = 0; \
 			zend_hash_destroy(&mydata->virtual_dirs); \
 			mydata->virtual_dirs.u.flags = 0; \
 			php_stream_close(fp); \
 			zval_dtor(&mydata->metadata); \
 			if (mydata->signature) { \
 				efree(mydata->signature); \
 			} \
 			if (error) { \
 				spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
 			} \
 			pefree(mydata->fname, mydata->is_persistent); \
 			if (mydata->alias) { \
 				pefree(mydata->alias, mydata->is_persistent); \
 			} \
 			pefree(mydata, mydata->is_persistent); \
 			return FAILURE;
 
 	 
 	for (i = 0; i < PHAR_GET_16(locator.count); ++i) {
 		phar_zip_central_dir_file zipentry;
 		zend_off_t beforeus = php_stream_tell(fp);
 
 		if (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {
 			PHAR_ZIP_FAIL(""unable to read central directory entry, truncated"");
 		}
 
 		 
 		if (memcmp(""PK\1\2"", zipentry.signature, 4)) {
 			 
 			PHAR_ZIP_FAIL(""corrupted central directory entry, no magic signature"");
 		}
 
 		if (entry.is_persistent) {
 			entry.manifest_pos = i;
 		}
 
 		entry.compressed_filesize = PHAR_GET_32(zipentry.compsize);
 		entry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);
 		entry.crc32 = PHAR_GET_32(zipentry.crc32);
 		 
 		entry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);
 		entry.flags = PHAR_ENT_PERM_DEF_FILE;
 		entry.header_offset = PHAR_GET_32(zipentry.offset);
 		entry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +
 			PHAR_GET_16(zipentry.extra_len);
 
 		if (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {
 			PHAR_ZIP_FAIL(""Cannot process encrypted zip files"");
 		}
 
 		if (!PHAR_GET_16(zipentry.filename_len)) {
 			PHAR_ZIP_FAIL(""Cannot process zips created from stdin (zero-length filename)"");
 		}
 
 		entry.filename_len = PHAR_GET_16(zipentry.filename_len);
 		entry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);
 
 		if (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {
 			pefree(entry.filename, entry.is_persistent);
 			PHAR_ZIP_FAIL(""unable to read in filename from central directory, truncated"");
 		}
 
 		entry.filename[entry.filename_len] = '\0';
 
 		if (entry.filename[entry.filename_len - 1] == '/') {
 			entry.is_dir = 1;
 			if(entry.filename_len > 1) {
 				entry.filename_len--;
 			}
 			entry.flags |= PHAR_ENT_PERM_DEF_DIR;
 		} else {
 			entry.is_dir = 0;
 		}
 
 		if (entry.filename_len == sizeof("".phar/signature.bin"")-1 && !strncmp(entry.filename, "".phar/signature.bin"", sizeof("".phar/signature.bin"")-1)) {
 			size_t read;
 			php_stream *sigfile;
 			zend_off_t now;
 			char *sig;
 
 			now = php_stream_tell(fp);
 			pefree(entry.filename, entry.is_persistent);
 			sigfile = php_stream_fopen_tmpfile();
 			if (!sigfile) {
 				PHAR_ZIP_FAIL(""couldn't open temporary file"");
 			}
 
 			php_stream_seek(fp, 0, SEEK_SET);
 			 
 			php_stream_copy_to_stream_ex(fp, sigfile, entry.header_offset, NULL);
 			 
 			php_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);
 			 
 			php_stream_copy_to_stream_ex(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);
 			if (metadata) {
 				php_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));
 			}
  			php_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);
  			sig = (char *) emalloc(entry.uncompressed_filesize);
  			read = php_stream_read(fp, sig, entry.uncompressed_filesize);
			if (read != entry.uncompressed_filesize) {
 			if (read != entry.uncompressed_filesize || read <= 8) {
  				php_stream_close(sigfile);
  				efree(sig);
  				PHAR_ZIP_FAIL(""signature cannot be read"");
 			}
 			mydata->sig_flags = PHAR_GET_32(sig);
 			if (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error)) {
 				efree(sig);
 				if (error) {
 					char *save;
 					php_stream_close(sigfile);
 					spprintf(&save, 4096, ""signature cannot be verified: %s"", *error);
 					efree(*error);
 					PHAR_ZIP_FAIL_FREE(save, save);
 				} else {
 					php_stream_close(sigfile);
 					PHAR_ZIP_FAIL(""signature cannot be verified"");
 				}
 			}
 			php_stream_close(sigfile);
 			efree(sig);
 			 
 			if (i != PHAR_GET_16(locator.count) - 1) {
 				PHAR_ZIP_FAIL(""entries exist after signature, invalid phar"");
 			}
 
 			continue;
 		}
 
 		phar_add_virtual_dirs(mydata, entry.filename, entry.filename_len);
 
 		if (PHAR_GET_16(zipentry.extra_len)) {
 			zend_off_t loc = php_stream_tell(fp);
 			if (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len))) {
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""Unable to process extra field header for file in central directory"");
 			}
 			php_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);
 		}
 
 		switch (PHAR_GET_16(zipentry.compressed)) {
 			case PHAR_ZIP_COMP_NONE :
 				 
 				break;
 			case PHAR_ZIP_COMP_DEFLATE :
 				entry.flags |= PHAR_ENT_COMPRESSED_GZ;
 				if (!PHAR_G(has_zlib)) {
 					pefree(entry.filename, entry.is_persistent);
 					PHAR_ZIP_FAIL(""zlib extension is required"");
 				}
 				break;
 			case PHAR_ZIP_COMP_BZIP2 :
 				entry.flags |= PHAR_ENT_COMPRESSED_BZ2;
 				if (!PHAR_G(has_bz2)) {
 					pefree(entry.filename, entry.is_persistent);
 					PHAR_ZIP_FAIL(""bzip2 extension is required"");
 				}
 				break;
 			case 1 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (Shrunk) used in this zip"");
 			case 2 :
 			case 3 :
 			case 4 :
 			case 5 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (Reduce) used in this zip"");
 			case 6 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (Implode) used in this zip"");
 			case 7 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (Tokenize) used in this zip"");
 			case 9 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (Deflate64) used in this zip"");
 			case 10 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip"");
 			case 14 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (LZMA) used in this zip"");
 			case 18 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (IBM TERSE) used in this zip"");
 			case 19 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (IBM LZ77) used in this zip"");
 			case 97 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (WavPack) used in this zip"");
 			case 98 :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (PPMd) used in this zip"");
 			default :
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unsupported compression method (unknown) used in this zip"");
 		}
 
 		 
 		if (PHAR_GET_16(zipentry.comment_len)) {
 			if (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""unable to read in file comment, truncated"");
 			}
 
 			p = buf;
 			entry.metadata_len = PHAR_GET_16(zipentry.comment_len);
 
 			if (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len)) == FAILURE) {
 				entry.metadata_len = 0;
 				 
 
 				ZVAL_NEW_STR(&entry.metadata, zend_string_init(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent));
 			}
 		} else {
 			ZVAL_UNDEF(&entry.metadata);
 		}
 
 		if (!actual_alias && entry.filename_len == sizeof("".phar/alias.txt"")-1 && !strncmp(entry.filename, "".phar/alias.txt"", sizeof("".phar/alias.txt"")-1)) {
 			php_stream_filter *filter;
 			zend_off_t saveloc;
 			 
 			phar_zip_file_header local;
 
 			 
 			saveloc = php_stream_tell(fp);
 			php_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);
 
 			if (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (cannot read local file header for alias)"");
 			}
 
 			 
 			if (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {
 				pefree(entry.filename, entry.is_persistent);
 				PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (local header of alias does not match central directory)"");
 			}
 
 			 
 			entry.offset = entry.offset_abs =
 				sizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);
 			php_stream_seek(fp, entry.offset, SEEK_SET);
 			 
 			fp->writepos = 0;
 			fp->readpos = 0;
 			php_stream_seek(fp, entry.offset, SEEK_SET);
 			fp->writepos = 0;
 			fp->readpos = 0;
 			 
 
 			mydata->alias_len = entry.uncompressed_filesize;
 			if (entry.flags & PHAR_ENT_COMPRESSED_GZ) {
 				filter = php_stream_filter_create(""zlib.inflate"", NULL, php_stream_is_persistent(fp));
 
 				if (!filter) {
 					pefree(entry.filename, entry.is_persistent);
 					PHAR_ZIP_FAIL(""unable to decompress alias, zlib filter creation failed"");
 				}
 
 				php_stream_filter_append(&fp->readfilters, filter);
 
 				{
 					zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
 					if (str) {
 						entry.uncompressed_filesize = ZSTR_LEN(str);
 						actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
 						zend_string_release(str);
 					} else {
 						actual_alias = NULL;
 						entry.uncompressed_filesize = 0;
 					}
 				}
 
 				if (!entry.uncompressed_filesize || !actual_alias) {
 					pefree(entry.filename, entry.is_persistent);
 					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
 				}
 
 				php_stream_filter_flush(filter, 1);
 				php_stream_filter_remove(filter, 1);
 
 			} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {
 				filter = php_stream_filter_create(""bzip2.decompress"", NULL, php_stream_is_persistent(fp));
 
 				if (!filter) {
 					pefree(entry.filename, entry.is_persistent);
 					PHAR_ZIP_FAIL(""unable to read in alias, bzip2 filter creation failed"");
 				}
 
 				php_stream_filter_append(&fp->readfilters, filter);
 
 				{
 					zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
 					if (str) {
 						entry.uncompressed_filesize = ZSTR_LEN(str);
 						actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
 						zend_string_release(str);
 					} else {
 						actual_alias = NULL;
 						entry.uncompressed_filesize = 0;
 					}
 				}
 
 				if (!entry.uncompressed_filesize || !actual_alias) {
 					pefree(entry.filename, entry.is_persistent);
 					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
 				}
 
 				php_stream_filter_flush(filter, 1);
 				php_stream_filter_remove(filter, 1);
 			} else {
 				{
 					zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
 					if (str) {
 						entry.uncompressed_filesize = ZSTR_LEN(str);
 						actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
 						zend_string_release(str);
 					} else {
 						actual_alias = NULL;
 						entry.uncompressed_filesize = 0;
 					}
 				}
 
 				if (!entry.uncompressed_filesize || !actual_alias) {
 					pefree(entry.filename, entry.is_persistent);
 					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
 				}
 			}
 
 			 
 			php_stream_seek(fp, saveloc, SEEK_SET);
 		}
 
 		phar_set_inode(&entry);
 		zend_hash_str_add_mem(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry, sizeof(phar_entry_info));
 	}
 
 	mydata->fp = fp;
 
 	if (zend_hash_str_exists(&(mydata->manifest), "".phar/stub.php"", sizeof("".phar/stub.php"")-1)) {
 		mydata->is_data = 0;
 	} else {
 		mydata->is_data = 1;
 	}
 
 	zend_hash_str_add_ptr(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len, mydata);
 
 	if (actual_alias) {
 		phar_archive_data *fd_ptr;
 
 		if (!phar_validate_alias(actual_alias, mydata->alias_len)) {
 			if (error) {
 				spprintf(error, 4096, ""phar error: invalid alias \""%s\"" in zip-based phar \""%s\"""", actual_alias, fname);
 			}
 			efree(actual_alias);
 			zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
 			return FAILURE;
 		}
 
 		mydata->is_temporary_alias = 0;
 
 		if (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len))) {
 			if (SUCCESS != phar_free_alias(fd_ptr, actual_alias, mydata->alias_len)) {
 				if (error) {
 					spprintf(error, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with implicit alias, alias is already in use"", fname);
 				}
 				efree(actual_alias);
 				zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
 				return FAILURE;
 			}
 		}
 
 		mydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;
 
 		if (entry.is_persistent) {
 			efree(actual_alias);
 		}
 
 		zend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);
 	} else {
 		phar_archive_data *fd_ptr;
 
 		if (alias_len) {
 			if (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len))) {
 				if (SUCCESS != phar_free_alias(fd_ptr, alias, alias_len)) {
 					if (error) {
 						spprintf(error, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with explicit alias, alias is already in use"", fname);
 					}
 					zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
 					return FAILURE;
 				}
 			}
 
 			zend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);
 			mydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);
 			mydata->alias_len = alias_len;
 		} else {
 			mydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);
 			mydata->alias_len = fname_len;
 		}
 
 		mydata->is_temporary_alias = 1;
 	}
 
 	if (pphar) {
 		*pphar = mydata;
 	}
 
 	return SUCCESS;
 }
  ","[257, 256]","The ZIP signature-verification feature in PHP before 5.6.26 and 7.x before 7.0.11 does not ensure that the uncompressed_filesize field is large enough, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via a crafted PHAR archive, related to ext/phar/util.c and ext/phar/zip.c."
207963," INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 
  {
      stream_t *ps_stream = (stream_t *)pv_ctxt;
  
    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
 
     if (ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
      return;
  }","[7, 8, 9, 10, 11, 6]","libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591."
200042," horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)
 {
     int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;
     float fltsize = Fltsize;
 
 #define  CLAMP(v) ( (v<(float)0.)   ? 0				\
 		  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]	\
 		  : (v>(float)24.2) ? 2047			\
 		  : LogK1*log(v*LogK2) + 0.5 )
 
     mask = CODE_MASK;
     if (n >= stride) {
 	if (stride == 3) {
 	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
 	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
 	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
 	    n -= 3;
 	    while (n > 0) {
 		n -= 3;
 		wp += 3;
 		ip += 3;
 		r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
 		g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
 		b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
 	    }
 	} else if (stride == 4) {
 	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
 	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
 	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
 	    a2 = wp[3] = (uint16) CLAMP(ip[3]);
 	    n -= 4;
 	    while (n > 0) {
 		n -= 4;
 		wp += 4;
 		ip += 4;
 		r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
 		g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
 		b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
  		a1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;
  	    }
  	} else {
	    ip += n - 1;	 
	    wp += n - 1;	 
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]);
				wp[stride] -= wp[0];
				wp[stride] &= mask;
				wp--; ip--)
		n -= stride;
	    }
	    REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp--; ip--)
         REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)
         n -= stride;
         while (n > 0) {
             REPEAT(stride,
                 wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);
                 wp++; ip++)
             n -= stride;
         }
  	}
      }
  }","[53, 54, 55, 56, 57, 58, 59, 60, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52]","tools/tiffcrop.c in libtiff 4.0.6 has out-of-bounds write vulnerabilities in buffers. Reported as MSVR 35093, MSVR 35096, and MSVR 35097."
201568," static bool freelist_state_initialize(union freelist_init_state *state,
 				struct kmem_cache *cachep,
 				unsigned int count)
 {
 	bool ret;
 	unsigned int rand;
 
 	 
 	rand = get_random_int();
 
 	 
 	if (!cachep->random_seq) {
 		prandom_seed_state(&state->rnd_state, rand);
 		ret = false;
  	} else {
  		state->list = cachep->random_seq;
  		state->count = count;
		state->pos = 0;
		state->rand = rand;
 		state->pos = rand % count;
  		ret = true;
  	}
  	return ret;
 }","[20, 18, 19]",The freelist-randomization feature in mm/slab.c in the Linux kernel 4.8.x and 4.9.x before 4.9.5 allows local users to cause a denial of service (duplicate freelist entries and system crash) or possibly have unspecified other impact in opportunistic circumstances by leveraging the selection of a large value for a random number.
205772," void InitializePrinting(content::WebContents* web_contents) {
 #if BUILDFLAG(ENABLE_PRINT_PREVIEW)
   printing::PrintViewManager::CreateForWebContents(web_contents);
   printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
  #else
    printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
  #endif   
   CreateCompositeClientIfNeeded(web_contents, false  );
  }",[8],"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call."
200524," void arch_pick_mmap_layout(struct mm_struct *mm)
 {
 	unsigned long random_factor = 0UL;
 
  	if (current->flags & PF_RANDOMIZE)
  		random_factor = arch_mmap_rnd();
  
	mm->mmap_legacy_base = mmap_legacy_base(random_factor);
 	mm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;
  
  	if (mmap_is_legacy()) {
  		mm->mmap_base = mm->mmap_legacy_base;
 		mm->get_unmapped_area = arch_get_unmapped_area;
 	} else {
 		mm->mmap_base = mmap_base(random_factor);
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 	}
 }","[9, 8]","The arch_pick_mmap_layout function in arch/x86/mm/mmap.c in the Linux kernel through 4.5.2 does not properly randomize the legacy base address, which makes it easier for local users to defeat the intended restrictions on the ADDR_NO_RANDOMIZE flag, and bypass the ASLR protection mechanism for a setuid or setgid program, by disabling stack-consumption resource limits."
207369," int LE_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
  void *pCmdData, uint32_t *replySize, void *pReplyData) {
 
  LoudnessEnhancerContext * pContext = (LoudnessEnhancerContext *)self;
  int retsize;
 
  if (pContext == NULL || pContext->mState == LOUDNESS_ENHANCER_STATE_UNINITIALIZED) {
  return -EINVAL;
  }
 
  switch (cmdCode) {
  case EFFECT_CMD_INIT:
  if (pReplyData == NULL || *replySize != sizeof(int)) {
  return -EINVAL;
  }
  *(int *) pReplyData = LE_init(pContext);
 
          break;
      case EFFECT_CMD_SET_CONFIG:
          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
                || pReplyData == NULL || *replySize != sizeof(int)) {
                 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = LE_setConfig(pContext,
  (effect_config_t *) pCmdData);
  break;
  case EFFECT_CMD_GET_CONFIG:
  if (pReplyData == NULL ||
  *replySize != sizeof(effect_config_t)) {
  return -EINVAL;
  }
         LE_getConfig(pContext, (effect_config_t *)pReplyData);
  break;
  case EFFECT_CMD_RESET:
 
          LE_reset(pContext);
          break;
      case EFFECT_CMD_ENABLE:
        if (pReplyData == NULL || *replySize != sizeof(int)) {
         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pContext->mState != LOUDNESS_ENHANCER_STATE_INITIALIZED) {
  return -ENOSYS;
  }
         pContext->mState = LOUDNESS_ENHANCER_STATE_ACTIVE;
         ALOGV(""EFFECT_CMD_ENABLE() OK"");
  *(int *)pReplyData = 0;
  break;
  case EFFECT_CMD_DISABLE:
  if (pReplyData == NULL || *replySize != sizeof(int)) {
  return -EINVAL;
  }
  if (pContext->mState != LOUDNESS_ENHANCER_STATE_ACTIVE) {
  return -ENOSYS;
  }
         pContext->mState = LOUDNESS_ENHANCER_STATE_INITIALIZED;
         ALOGV(""EFFECT_CMD_DISABLE() OK"");
  *(int *)pReplyData = 0;
  break;
 
      case EFFECT_CMD_GET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL ||
             pReplyData == NULL || replySize == NULL ||
              *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
              return -EINVAL;
          }
         memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
  effect_param_t *p = (effect_param_t *)pReplyData;
         p->status = 0;
  *replySize = sizeof(effect_param_t) + sizeof(uint32_t);
  if (p->psize != sizeof(uint32_t)) {
             p->status = -EINVAL;
  break;
  }
  switch (*(uint32_t *)p->data) {
  case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:
             ALOGV(""get target gain(mB) = %d"", pContext->mTargetGainmB);
  *((int32_t *)p->data + 1) = pContext->mTargetGainmB;
             p->vsize = sizeof(int32_t);
  *replySize += sizeof(int32_t);
  break;
  default:
             p->status = -EINVAL;
  }
  } break;
 
      case EFFECT_CMD_SET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || *replySize != sizeof(int32_t)) {
             pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
              return -EINVAL;
          }
          *(int32_t *)pReplyData = 0;
  effect_param_t *p = (effect_param_t *)pCmdData;
  if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
  *(int32_t *)pReplyData = -EINVAL;
  break;
  }
  switch (*(uint32_t *)p->data) {
  case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:
             pContext->mTargetGainmB = *((int32_t *)p->data + 1);
             ALOGV(""set target gain(mB) = %d"", pContext->mTargetGainmB);
             LE_reset(pContext);  
  break;
  default:
  *(int32_t *)pReplyData = -EINVAL;
  }
  } break;
  case EFFECT_CMD_SET_DEVICE:
  case EFFECT_CMD_SET_VOLUME:
  case EFFECT_CMD_SET_AUDIO_MODE:
  break;
 
  default:
         ALOGW(""LE_command invalid command %d"",cmdCode);
  return -EINVAL;
  }
 
  return 0;
 }","[22, 41, 67, 95, 21, 40, 66, 94]","Multiple heap-based buffer overflows in libeffects in the Audio Policy Service in mediaserver in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application, aka internal bug 21953516."
200566," static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 {
 	int i;
 	unsigned char max_level = 0;
 	int unix_sock_count = 0;
 
 	if (too_many_unix_fds(current))
 		return -ETOOMANYREFS;
 
 	for (i = scm->fp->count - 1; i >= 0; i--) {
 		struct sock *sk = unix_get_socket(scm->fp->fp[i]);
 
 		if (sk) {
 			unix_sock_count++;
 			max_level = max(max_level,
 					unix_sk(sk)->recursion_level);
 		}
 	}
 	if (unlikely(max_level > MAX_RECURSION_LEVEL))
 		return -ETOOMANYREFS;
 
 	 
 	UNIXCB(skb).fp = scm_fp_dup(scm->fp);
 	if (!UNIXCB(skb).fp)
  		return -ENOMEM;
  
  	for (i = scm->fp->count - 1; i >= 0; i--)
		unix_inflight(scm->fp->fp[i]);
 		unix_inflight(scm->fp->user, scm->fp->fp[i]);
  	return max_level;
  }","[29, 28]",The Linux kernel before 4.5 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by leveraging incorrect tracking of descriptor ownership and sending each descriptor over a UNIX socket before closing it. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-4312.
207051,"  ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(
      ImageBitmapFactories& factory,
      base::Optional<IntRect> crop_rect,
      ScriptState* script_state,
      const ImageBitmapOptions* options)
    : loader_(
     : ContextLifecycleObserver(ExecutionContext::From(script_state)),
       loader_(
            FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),
        factory_(&factory),
        resolver_(ScriptPromiseResolver::Create(script_state)),
        crop_rect_(crop_rect),
        options_(options) {}","[7, 8, 6]",Incorrect object lifecycle management in Blink in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
7555,"GF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)
{
u32 Width, Height;
GF_ESD *esd;
char sdpLine[20000];
char mediaName[30], payloadName[30];
u32 mtype;

Width = Height = 0;
gf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);
mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);
if (gf_isom_is_video_handler_type(mtype))
gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);

gf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);


sprintf(sdpLine, ""m=%s 0 RTP/%s %d"", mediaName, tkHint->rtp_p->slMap.IV_length ? ""SAVP"" : ""AVP"", tkHint->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
if (tkHint->bandwidth) {
sprintf(sdpLine, ""b=AS:%d"", tkHint->bandwidth);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
if (tkHint->nb_chan) {
sprintf(sdpLine, ""a=rtpmap:%d %s/%d/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);
} else {
sprintf(sdpLine, ""a=rtpmap:%d %s/%d"", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);

if (AddSystemInfo) {
sprintf(sdpLine, ""a=mpeg4-esid:%d"", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}

sprintf(sdpLine, ""a=control:trackID=%d"", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);


if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {
sprintf(sdpLine, ""a=cliprect:0,0,%d,%d"", Height, Width);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}

else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {
sprintf(sdpLine, ""a=fmtp:%d octet-align=1"", tkHint->rtp_p->PayloadType);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}

else if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {
u32 w, h, i, m_w, m_h;
s32 tx, ty;
s16 l;

gf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);
m_w = w;
m_h = h;
for (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {
switch (gf_isom_get_media_type(tkHint->file, i+1)) {
case GF_ISOM_MEDIA_SCENE:
case GF_ISOM_MEDIA_VISUAL:
case GF_ISOM_MEDIA_AUXV:
case GF_ISOM_MEDIA_PICT:
gf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);
if (w>m_w) m_w = w;
if (h>m_h) m_h = h;
break;
default:
break;
}
}

gf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);

strcat(sdpLine, ""; tx3g="");
for (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {
u8 *tx3g;
char buffer[2000];
u32 tx3g_len, len;
gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);
len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);
gf_free(tx3g);
buffer[len] = 0;
if (i) strcat(sdpLine, "", "");
strcat(sdpLine, buffer);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}

else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {
sprintf(sdpLine, ""a=fmtp:%d maxptime=%d"", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}

else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {
GF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);
GF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);


if (avcc) {
sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);
} else {
sprintf(sdpLine, ""a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1"", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);
}

write_avc_config(sdpLine, avcc, svcc);

gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
gf_odf_avc_cfg_del(avcc);
gf_odf_avc_cfg_del(svcc);
}

else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {
esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);

if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
} else {
gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);

if (tkHint->rtp_p->slMap.IV_length) {
const char *kms;
gf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);
if (!strnicmp(kms, ""(key)"", 5) || !strnicmp(kms, ""(ipmp)"", 6) || !strnicmp(kms, ""(uri)"", 5)) {
strcat(sdpLine, ""; ISMACrypKey="");
} else {
strcat(sdpLine, ""; ISMACrypKey=(uri)"");
}
strcat(sdpLine, kms);
}

gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}

else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {
GF_BitStream *bs;
u8 *config_bytes;
u32 config_size;


bs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);
gf_bs_write_int(bs, 0, 1);
gf_bs_write_int(bs, 1, 1);
gf_bs_write_int(bs, 0, 6);
gf_bs_write_int(bs, 0, 4);
gf_bs_write_int(bs, 0, 3);


esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {

gf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);


gf_bs_write_int(bs, 0, 3);
gf_bs_write_int(bs, 0xff, 8);
gf_bs_write_int(bs, 0, 1);
gf_bs_write_int(bs, 0, 1);
gf_bs_get_content(bs, &config_bytes, &config_size);
gf_bs_del(bs);

gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
gf_free(config_bytes);
}
#if GPAC_ENABLE_3GPP_DIMS_RTP

else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {
GF_DIMSDescription dims;
gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);

gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);
sprintf(sdpLine, ""a=fmtp:%d Version-profile=%d"", tkHint->rtp_p->PayloadType, dims.profile);
if (! dims.fullRequestHost) {
char fmt[200];
strcat(sdpLine, "";useFullRequestHost=0"");
sprintf(fmt, "";pathComponents=%d"", dims.pathComponents);
strcat(sdpLine, fmt);
}
if (!dims.streamType) strcat(sdpLine, "";stream-type=secondary"");
if (dims.containsRedundant == 1) strcat(sdpLine, "";contains-redundant=main"");
else if (dims.containsRedundant == 2) strcat(sdpLine, "";contains-redundant=redundant"");

if (dims.textEncoding && strlen(dims.textEncoding)) {
strcat(sdpLine, "";text-encoding="");
strcat(sdpLine, dims.textEncoding);
}
if (dims.contentEncoding && strlen(dims.contentEncoding)) {
strcat(sdpLine, "";content-coding="");
strcat(sdpLine, dims.contentEncoding);
}
if (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {
strcat(sdpLine, "";content-script-types="");
strcat(sdpLine, dims.contentEncoding);
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
#endif

if (Width && Height) {
sprintf(sdpLine, ""a=framesize:%d %d-%d"", tkHint->rtp_p->PayloadType, Width, Height);
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}

esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);
if (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {
if (esd->decoderConfig->predefined_rvc_config) {
sprintf(sdpLine, ""a=rvc-config-predef:%d"", esd->decoderConfig->predefined_rvc_config);
} else {

if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {
sprintf(sdpLine, ""a=rvc-config:%s"", ""http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml"");
} else {
sprintf(sdpLine, ""a=rvc-config:%s"", ""http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml"");
}
}
gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);
}
if (esd) gf_odf_desc_del((GF_Descriptor *)esd);

gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);
return GF_OK;
}",[103],An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is an invalid pointer dereference in the function gf_hinter_track_finalize() in media_tools/isom_hinter.c.
206312," MediaControlsHeaderView::MediaControlsHeaderView() {
  SetLayoutManager(std::make_unique<views::BoxLayout>(
      views::BoxLayout::Orientation::kHorizontal, kMediaControlsHeaderInsets,
      kMediaControlsHeaderChildSpacing));
 MediaControlsHeaderView::MediaControlsHeaderView(
     base::OnceClosure close_button_cb)
     : close_button_cb_(std::move(close_button_cb)) {
   auto* layout = SetLayoutManager(std::make_unique<views::FlexLayout>());
   layout->SetInteriorMargin(kHeaderViewInsets);
  
    auto app_icon_view = std::make_unique<views::ImageView>();
    app_icon_view->SetImageSize(gfx::Size(kIconSize, kIconSize));
   app_icon_view->SetVerticalAlignment(views::ImageView::Alignment::kLeading);
   app_icon_view->SetHorizontalAlignment(views::ImageView::Alignment::kLeading);
   app_icon_view->SetBorder(views::CreateEmptyBorder(kIconPadding));
   app_icon_view->SetBackground(
       views::CreateRoundedRectBackground(SK_ColorWHITE, kIconCornerRadius));
   app_icon_view_ = AddChildView(std::move(app_icon_view));
 
   gfx::Font default_font;
   int font_size_delta = kHeaderTextFontSize - default_font.GetFontSize();
   gfx::Font font = default_font.Derive(font_size_delta, gfx::Font::NORMAL,
                                        gfx::Font::Weight::NORMAL);
   gfx::FontList font_list(font);
 
   auto app_name_view = std::make_unique<views::Label>();
   app_name_view->SetFontList(font_list);
    app_name_view->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    app_name_view->SetEnabledColor(SK_ColorWHITE);
    app_name_view->SetAutoColorReadabilityEnabled(false);
   app_name_view->SetBorder(views::CreateEmptyBorder(kAppNamePadding));
    app_name_view_ = AddChildView(std::move(app_name_view));
 
    
   auto spacer = std::make_unique<NonAccessibleView>();
   spacer->SetPreferredSize(kSpacerPreferredSize);
   spacer->SetProperty(views::kFlexBehaviorKey,
                       views::FlexSpecification::ForSizeRule(
                           views::MinimumFlexSizeRule::kScaleToMinimum,
                           views::MaximumFlexSizeRule::kUnbounded));
   AddChildView(std::move(spacer));
 
   auto close_button = CreateVectorImageButton(this);
   SetImageFromVectorIcon(close_button.get(), vector_icons::kCloseRoundedIcon,
                          kCloseButtonIconSize, gfx::kGoogleGrey700);
   close_button->SetPreferredSize(kCloseButtonSize);
   close_button->SetFocusBehavior(View::FocusBehavior::ALWAYS);
   base::string16 close_button_label(
       l10n_util::GetStringUTF16(IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_CLOSE));
   close_button->SetAccessibleName(close_button_label);
   close_button->SetVisible(false);
   close_button_ = AddChildView(std::move(close_button));
  }","[5, 6, 7, 8, 9, 31, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 2, 3, 4]","A timing attack in SVG rendering in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to extract pixel values from a cross-origin page being iframe'd via a crafted HTML page."
206809,"   void CreateFusionSensor(
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm) {
     auto callback =
          base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,
                     base::Unretained(this));
      SensorType type = fusion_algorithm->fused_type();
    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),
                                 std::move(fusion_algorithm), callback);
     PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),
                                  provider_.get(), std::move(fusion_algorithm),
                                  callback);
      EXPECT_TRUE(platform_sensor_fusion_callback_called_);
    }","[9, 10, 11, 7, 8]",Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.
204571," bool AddPolicyForGPU(CommandLine* cmd_line, sandbox::TargetPolicy* policy) {
 #if !defined(NACL_WIN64)   
   if (base::win::GetVersion() > base::win::VERSION_SERVER_2003) {
     if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==
         gfx::kGLImplementationDesktopName) {
       policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                             sandbox::USER_LIMITED);
       policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);
       policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
     } else {
       if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==
           gfx::kGLImplementationSwiftShaderName ||
           cmd_line->HasSwitch(switches::kReduceGpuSandbox)) {
         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                               sandbox::USER_LIMITED);
         policy->SetJobLevel(sandbox::JOB_LIMITED_USER,
                             JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS |
                             JOB_OBJECT_UILIMIT_DESKTOP |
                             JOB_OBJECT_UILIMIT_EXITWINDOWS |
                             JOB_OBJECT_UILIMIT_DISPLAYSETTINGS);
       } else {
         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                               sandbox::USER_RESTRICTED);
         policy->SetJobLevel(sandbox::JOB_LOCKDOWN,
                             JOB_OBJECT_UILIMIT_HANDLES);
       }
 
       policy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
     }
   } else {
     policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);
     policy->SetTokenLevel(sandbox::USER_UNPROTECTED,
                           sandbox::USER_LIMITED);
   }
 
   sandbox::ResultCode result = policy->AddRule(
       sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,
       sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,
       L""\\\\.\\pipe\\chrome.gpu.*"");
    if (result != sandbox::SBOX_ALL_OK)
      return false;
  
    
   result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,
                            sandbox::TargetPolicy::HANDLES_DUP_ANY,
                            L""Section"");
   if (result != sandbox::SBOX_ALL_OK)
     return false;
 
    AddGenericDllEvictionPolicy(policy);
  #endif
    return true;
  }","[43, 44, 45, 46, 47, 48, 49]","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
201017," ip_optprint(netdissect_options *ndo,
             register const u_char *cp, u_int length)
 {
 	register u_int option_len;
 	const char *sep = """";
 
 	for (; length > 0; cp += option_len, length -= option_len) {
 		u_int option_code;
 
 		ND_PRINT((ndo, ""%s"", sep));
 		sep = "","";
 
 		ND_TCHECK(*cp);
 		option_code = *cp;
 
 		ND_PRINT((ndo, ""%s"",
 		          tok2str(ip_option_values,""unknown %u"",option_code)));
 
 		if (option_code == IPOPT_NOP ||
                     option_code == IPOPT_EOL)
 			option_len = 1;
 
 		else {
 			ND_TCHECK(cp[1]);
 			option_len = cp[1];
 			if (option_len < 2) {
 				ND_PRINT((ndo, "" [bad length %u]"", option_len));
 				return;
 			}
 		}
 
 		if (option_len > length) {
 			ND_PRINT((ndo, "" [bad length %u]"", option_len));
 			return;
 		}
 
 		ND_TCHECK2(*cp, option_len);
 
 		switch (option_code) {
 		case IPOPT_EOL:
  			return;
  
  		case IPOPT_TS:
			ip_printts(ndo, cp, option_len);
 			if (ip_printts(ndo, cp, option_len) == -1)
 				goto trunc;
  			break;
  
  		case IPOPT_RR:        
 		case IPOPT_SSRR:
 		case IPOPT_LSRR:
 			if (ip_printroute(ndo, cp, option_len) == -1)
 				goto trunc;
 			break;
 
 		case IPOPT_RA:
 			if (option_len < 4) {
 				ND_PRINT((ndo, "" [bad length %u]"", option_len));
 				break;
 			}
 			ND_TCHECK(cp[3]);
 			if (EXTRACT_16BITS(&cp[2]) != 0)
 				ND_PRINT((ndo, "" value %u"", EXTRACT_16BITS(&cp[2])));
 			break;
 
 		case IPOPT_NOP:        
 		case IPOPT_SECURITY:
 		default:
 			break;
 		}
 	}
 	return;
 
 trunc:
 	ND_PRINT((ndo, ""%s"", tstr));
 }","[45, 46, 44]",The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printts().
201433," brcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
 		       struct cfg80211_mgmt_tx_params *params, u64 *cookie)
 {
 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
 	struct ieee80211_channel *chan = params->chan;
 	const u8 *buf = params->buf;
 	size_t len = params->len;
 	const struct ieee80211_mgmt *mgmt;
 	struct brcmf_cfg80211_vif *vif;
 	s32 err = 0;
 	s32 ie_offset;
 	s32 ie_len;
 	struct brcmf_fil_action_frame_le *action_frame;
 	struct brcmf_fil_af_params_le *af_params;
 	bool ack;
 	s32 chan_nr;
 	u32 freq;
 
 	brcmf_dbg(TRACE, ""Enter\n"");
 
 	*cookie = 0;
 
 	mgmt = (const struct ieee80211_mgmt *)buf;
 
 	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
 		brcmf_err(""Driver only allows MGMT packet type\n"");
 		return -EPERM;
 	}
 
 	vif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);
 
 	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
 		 
 		 
 		 
 		 
 		 
 		 
 		 
 		 
 		 
 		 
 		 
 		ie_offset =  DOT11_MGMT_HDR_LEN +
 			     DOT11_BCN_PRB_FIXED_LEN;
 		ie_len = len - ie_offset;
 		if (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)
 			vif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
 		err = brcmf_vif_set_mgmt_ie(vif,
 					    BRCMF_VNDR_IE_PRBRSP_FLAG,
 					    &buf[ie_offset],
 					    ie_len);
  		cfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,
  					GFP_KERNEL);
  	} else if (ieee80211_is_action(mgmt->frame_control)) {
 		if (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {
 			brcmf_err(""invalid action frame length\n"");
 			err = -EINVAL;
 			goto exit;
 		}
  		af_params = kzalloc(sizeof(*af_params), GFP_KERNEL);
  		if (af_params == NULL) {
  			brcmf_err(""unable to allocate frame\n"");
 			err = -ENOMEM;
 			goto exit;
 		}
 		action_frame = &af_params->action_frame;
 		 
 		action_frame->packet_id = cpu_to_le32(*cookie);
 		 
 		memcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);
 		memcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);
 		 
 		action_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);
 		 
 		if (chan)
 			freq = chan->center_freq;
 		else
 			brcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,
 					      &freq);
 		chan_nr = ieee80211_frequency_to_channel(freq);
 		af_params->channel = cpu_to_le32(chan_nr);
 
 		memcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],
 		       le16_to_cpu(action_frame->len));
 
 		brcmf_dbg(TRACE, ""Action frame, cookie=%lld, len=%d, freq=%d\n"",
 			  *cookie, le16_to_cpu(action_frame->len), freq);
 
 		ack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),
 						  af_params);
 
 		cfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,
 					GFP_KERNEL);
 		kfree(af_params);
 	} else {
 		brcmf_dbg(TRACE, ""Unhandled, fc=%04x!!\n"", mgmt->frame_control);
 		brcmf_dbg_hex_dump(true, buf, len, ""payload, len=%zu\n"", len);
 	}
 
 exit:
 	return err;
 }","[56, 57, 58, 59, 60]",The brcmf_cfg80211_mgmt_tx function in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux kernel before 4.12.3 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted NL80211_CMD_FRAME Netlink packet.
200685," get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)
 {
      static gpol_ret             ret;
      kadm5_ret_t         ret2;
      char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name,
        service_name;
     gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
     gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
      OM_uint32                   minor_stat;
      kadm5_principal_ent_rec     caller_ent;
      kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
 
     xdr_free(xdr_gpol_ret,  &ret);
 
     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
         goto exit_func;
 
     if ((ret.code = check_handle((void *)handle)))
         goto exit_func;
 
     ret.api_version = handle->api_version;
 
     funcname = ""kadm5_get_policy"";
 
     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
         ret.code = KADM5_FAILURE;
         goto exit_func;
     }
     prime_arg = arg->name;
 
     ret.code = KADM5_AUTH_GET;
     if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,
                                                        rqst2name(rqstp),
                                                        ACL_INQUIRE, NULL, NULL))
         ret.code = KADM5_OK;
     else {
         ret.code = kadm5_get_principal(handle->lhandle,
                                        handle->current_caller,
                                        &caller_ent,
                                        KADM5_PRINCIPAL_NORMAL_MASK);
         if (ret.code == KADM5_OK) {
             if (caller_ent.aux_attributes & KADM5_POLICY &&
                 strcmp(caller_ent.policy, arg->name) == 0) {
                 ret.code = KADM5_OK;
             } else ret.code = KADM5_AUTH_GET;
             ret2 = kadm5_free_principal_ent(handle->lhandle,
                                             &caller_ent);
             ret.code = ret.code ? ret.code : ret2;
         }
     }
 
     if (ret.code == KADM5_OK) {
         ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);
 
         if( ret.code != 0 )
             errmsg = krb5_get_error_message(handle->context, ret.code);
 
         log_done(funcname,
                  ((prime_arg == NULL) ? ""(null)"" : prime_arg), errmsg,
                  &client_name, &service_name, rqstp);
         if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
 
     } else {
          log_unauth(funcname, prime_arg,
                     &client_name, &service_name, rqstp);
      }
 exit_func:
      gss_release_buffer(&minor_stat, &client_name);
      gss_release_buffer(&minor_stat, &service_name);
exit_func:
      free_server_handle(handle);
      return &ret;
  
 }","[8, 9, 70, 6, 7, 73]",Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name.
351,"void Update(const char* str, size_t size) {
if (str_ == NULL)
str_ = str;
else if (on_heap_ || str_ + size != str) {


char* s = new char[size_ + size];
memcpy(s, str_, size_);
memcpy(s + size_, str, size);

if (on_heap_)
delete[] str_;
else
on_heap_ = true;

str_ = s;
}
size_ += size;
}",[4],"The Update method in src/node_http_parser.cc in Node.js before 0.6.17 and 0.7 before 0.7.8 does not properly check the length of a string, which allows remote attackers to obtain sensitive information (request header contents) and possibly spoof HTTP headers via a zero length string."
198791," static int ext4_fill_flex_info(struct super_block *sb)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
  	struct ext4_group_desc *gdp = NULL;
  	ext4_group_t flex_group_count;
  	ext4_group_t flex_group;
	int groups_per_flex = 0;
 	unsigned int groups_per_flex = 0;
  	size_t size;
  	int i;
  
  	sbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;
	groups_per_flex = 1 << sbi->s_log_groups_per_flex;
	if (groups_per_flex < 2) {
 	if (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {
  		sbi->s_log_groups_per_flex = 0;
  		return 1;
  	}
 	groups_per_flex = 1 << sbi->s_log_groups_per_flex;
  
  	 
  	flex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +
 			((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<
 			      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;
 	size = flex_group_count * sizeof(struct flex_groups);
 	sbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);
 	if (sbi->s_flex_groups == NULL) {
 		ext4_msg(sb, KERN_ERR, ""not enough memory for %u flex groups"",
 			 flex_group_count);
 		goto failed;
 	}
 
 	for (i = 0; i < sbi->s_groups_count; i++) {
 		gdp = ext4_get_group_desc(sb, i, NULL);
 
 		flex_group = ext4_flex_group(sbi, i);
 		atomic_add(ext4_free_inodes_count(sb, gdp),
 			   &sbi->s_flex_groups[flex_group].free_inodes);
 		atomic_add(ext4_free_group_clusters(sb, gdp),
 			   &sbi->s_flex_groups[flex_group].free_clusters);
 		atomic_add(ext4_used_dirs_count(sb, gdp),
 			   &sbi->s_flex_groups[flex_group].used_dirs);
 	}
 
 	return 1;
 failed:
 	return 0;
 }","[8, 15, 19, 7, 13, 14]","The ext4_fill_flex_info function in fs/ext4/super.c in the Linux kernel before 3.2.2, on the x86 platform and unspecified other platforms, allows user-assisted remote attackers to trigger inconsistent filesystem-groups data and possibly cause a denial of service via a malformed ext4 filesystem containing a super block with a large FLEX_BG group size (aka s_log_groups_per_flex value).  NOTE: this vulnerability exists because of an incomplete fix for CVE-2009-4307."
202567," static void sas_resume_port(struct asd_sas_phy *phy)
 {
 	struct domain_device *dev;
 	struct asd_sas_port *port = phy->port;
 	struct sas_ha_struct *sas_ha = phy->ha;
 	struct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);
 
 	if (si->dft->lldd_port_formed)
 		si->dft->lldd_port_formed(phy);
 
 	if (port->suspended)
 		port->suspended = 0;
 	else {
 		 
 		return;
 	}
 
 	 
 	list_for_each_entry(dev, &port->dev_list, dev_list_node) {
 		int i, rc;
 
  		rc = sas_notify_lldd_dev_found(dev);
  		if (rc) {
  			sas_unregister_dev(port, dev);
 			sas_destruct_devices(port);
  			continue;
  		}
  
 		if (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {
 			dev->ex_dev.ex_change_count = -1;
 			for (i = 0; i < dev->ex_dev.num_phys; i++) {
 				struct ex_phy *phy = &dev->ex_dev.ex_phy[i];
 
 				phy->phy_change_count = -1;
 			}
 		}
 	}
 
 	sas_discover_event(port, DISCE_RESUME);
 }",[25],"The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code."
7557,"static int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,
word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,
int saltLen, int bits, void* heap)
{
int   ret = 0;
int   hLen, i, o, maskLen, hiBits;
byte* m;
byte* s;
#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)
#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)
byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];
#else
byte* salt = NULL;
#endif
#else
byte salt[WC_MAX_DIGEST_SIZE];
#endif

#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)
if (pkcsBlockLen > RSA_MAX_SIZE/8) {
return MEMORY_E;
}
#endif

hLen = wc_HashGetDigestSize(hType);
if (hLen < 0)
return hLen;
if ((int)inputLen != hLen) {
return BAD_FUNC_ARG;
}

hiBits = (bits - 1) & 0x7;
if (hiBits == 0) {



*(pkcsBlock++) = 0;
pkcsBlockLen--;
}

if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {
saltLen = hLen;
#ifdef WOLFSSL_SHA512

if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {
saltLen = RSA_PSS_SALT_MAX_SZ;
}
#endif
}
#ifndef WOLFSSL_PSS_LONG_SALT
else if (saltLen > hLen) {
return PSS_SALTLEN_E;
}
#endif
#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER
else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {
return PSS_SALTLEN_E;
}
#else
else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {
saltLen = (int)pkcsBlockLen - hLen - 2;
if (saltLen < 0) {
return PSS_SALTLEN_E;
}
}
else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {
return PSS_SALTLEN_E;
}
#endif
if ((int)pkcsBlockLen - hLen < saltLen + 2) {
return PSS_SALTLEN_E;
}
maskLen = pkcsBlockLen - 1 - hLen;

#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)
#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,
DYNAMIC_TYPE_RSA_BUFFER);
if (salt == NULL) {
return MEMORY_E;
}
#endif
s = m = salt;
XMEMSET(m, 0, RSA_PSS_PAD_SZ);
m += RSA_PSS_PAD_SZ;
XMEMCPY(m, input, inputLen);
m += inputLen;
o = (int)(m - s);
if (saltLen > 0) {
ret = wc_RNG_GenerateBlock(rng, m, saltLen);
if (ret == 0) {
m += saltLen;
}
}
#else
s = m = pkcsBlock;
XMEMSET(m, 0, RSA_PSS_PAD_SZ);
m += RSA_PSS_PAD_SZ;
XMEMCPY(m, input, inputLen);
m += inputLen;
o = 0;
if (saltLen > 0) {
ret = wc_RNG_GenerateBlock(rng, salt, saltLen);
if (ret == 0) {
XMEMCPY(m, salt, saltLen);
m += saltLen;
}
}
#endif
if (ret == 0) {

ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);
}
if (ret == 0) {

pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;

ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);
}
if (ret == 0) {


if (hiBits)
pkcsBlock[0] &= (1 << hiBits) - 1;

m = pkcsBlock + maskLen - saltLen - 1;
*(m++) ^= 0x01;
for (i = 0; i < saltLen; i++) {
m[i] ^= salt[o + i];
}
}

#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)
#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)
if (salt != NULL) {
XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);
}
#endif
#endif
return ret;
}","[9, 10, 11, 12, 13, 14, 77, 79, 83, 96, 133, 135, 136, 139]",RsaPad_PSS in wolfcrypt/src/rsa.c in wolfSSL before 4.6.0 has an out-of-bounds write for certain relationships between key size and digest size.
206471,"  static sk_sp<SkImage> flipSkImageVertically(SkImage* input,
                                              AlphaDisposition alphaOp) {
  size_t width = static_cast<size_t>(input->width());
  size_t height = static_cast<size_t>(input->height());
   unsigned width = static_cast<unsigned>(input->width());
   unsigned height = static_cast<unsigned>(input->height());
    SkImageInfo info = SkImageInfo::MakeN32(input->width(), input->height(),
                                            (alphaOp == PremultiplyAlpha)
                                                ? kPremul_SkAlphaType
                                                : kUnpremul_SkAlphaType);
  size_t imageRowBytes = width * info.bytesPerPixel();
   unsigned imageRowBytes = width * info.bytesPerPixel();
    RefPtr<Uint8Array> imagePixels = copySkImageData(input, info);
    if (!imagePixels)
      return nullptr;
  for (size_t i = 0; i < height / 2; i++) {
    size_t topFirstElement = i * imageRowBytes;
    size_t topLastElement = (i + 1) * imageRowBytes;
    size_t bottomFirstElement = (height - 1 - i) * imageRowBytes;
   for (unsigned i = 0; i < height / 2; i++) {
     unsigned topFirstElement = i * imageRowBytes;
     unsigned topLastElement = (i + 1) * imageRowBytes;
     unsigned bottomFirstElement = (height - 1 - i) * imageRowBytes;
      std::swap_ranges(imagePixels->data() + topFirstElement,
                       imagePixels->data() + topLastElement,
                       imagePixels->data() + bottomFirstElement);
   }
   return newSkImageFromRaster(info, std::move(imagePixels), imageRowBytes);
 }","[5, 6, 12, 20, 21, 22, 23, 3, 4, 11, 16, 17, 18, 19]","Bad casting in bitmap manipulation in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
206893,"  void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
      MemoryDumpType dump_type,
      MemoryDumpLevelOfDetail level_of_detail,
      const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
    
    
    
   if (level_of_detail ==
       MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {
     bindings_.ReportBadMessage(
         ""Requested global memory dump using level of detail reserved for the ""
         ""heap profiler."");
     return;
   }
 
    auto adapter =
        [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
          bool success, uint64_t dump_guid,
          mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };
 
   QueuedRequest::Args args(dump_type, level_of_detail, {},
                            true  , base::kNullProcessId);
   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
 }","[5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]",Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .
206234," P2PQuicTransportImpl::P2PQuicTransportImpl(
     P2PQuicTransportConfig p2p_transport_config,
     std::unique_ptr<net::QuicChromiumConnectionHelper> helper,
     std::unique_ptr<quic::QuicConnection> connection,
     const quic::QuicConfig& quic_config,
     quic::QuicClock* clock)
     : quic::QuicSession(connection.get(),
                         nullptr  ,
                         quic_config,
                         quic::CurrentSupportedVersions()),
       helper_(std::move(helper)),
       connection_(std::move(connection)),
       perspective_(p2p_transport_config.is_server
                        ? quic::Perspective::IS_SERVER
                         : quic::Perspective::IS_CLIENT),
        packet_transport_(p2p_transport_config.packet_transport),
        delegate_(p2p_transport_config.delegate),
      clock_(clock) {
       clock_(clock),
       stream_write_buffer_size_(p2p_transport_config.stream_write_buffer_size) {
    DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
    DCHECK(delegate_);
    DCHECK(clock_);
    DCHECK(packet_transport_);
   DCHECK_GT(stream_write_buffer_size_, 0u);
    DCHECK_GT(p2p_transport_config.certificates.size(), 0u);
    if (p2p_transport_config.can_respond_to_crypto_handshake) {
      InitializeCryptoStream();
   }
   certificate_ = p2p_transport_config.certificates[0];
   packet_transport_->SetReceiveDelegate(this);
 }","[19, 20, 25, 18]","The TreeScope::adoptIfNeeded function in WebKit/Source/core/dom/TreeScope.cpp in the DOM implementation in Blink, as used in Google Chrome before 50.0.2661.102, does not prevent script execution during node-adoption operations, which allows remote attackers to bypass the Same Origin Policy via a crafted web site."
9634,"static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)
{
u32 i, sf_type;
void *slot_ptr;

DUMP_IND(sdump);
gf_fprintf(sdump->trace, ""<fieldValue name=\""%s\"" "", field.name);
if (gf_sg_vrml_is_sf_field(field.fieldType)) {
if (field.fieldType == GF_SG_VRML_SFNODE) {
gf_fprintf(sdump->trace, "">\n"");
sdump->indent++;
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""<node>"");
gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""</node>"");
sdump->indent--;
DUMP_IND(sdump);
gf_fprintf(sdump->trace, ""</fieldValue>\n"");
} else {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, "" value=\"""");
} else {
gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
}
gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);
gf_fprintf(sdump->trace, ""\""/>\n"");
}
} else {
GenMFField *mffield = (GenMFField *) field.far_ptr;
sf_type = gf_sg_vrml_get_sf_type(field.fieldType);

if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {
if (sf_type == GF_SG_VRML_SFNODE) {
GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;
gf_fprintf(sdump->trace, "">\n"");
sdump->indent++;
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""<nodes>"");
while (list) {
gf_dump_vrml_node(sdump, list->node, 1, NULL);
list = list->next;
}
if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""</nodes>"");
sdump->indent--;
DUMP_IND(sdump);
gf_fprintf(sdump->trace, ""</fieldValue>\n"");
} else {
if (sdump->X3DDump) {
gf_fprintf(sdump->trace, "" value=\"""");
} else {
gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
}
if (mffield) {
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
if (field.fieldType != GF_SG_VRML_MFNODE) {
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
}
}
}
gf_fprintf(sdump->trace, ""\""/>\n"");
}
}
}
}","[51, 52, 53, 54, 55, 56]",NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.
199528," string_modifier_check(struct magic_set *ms, struct magic *m)
 {
  	if ((ms->flags & MAGIC_CHECK) == 0)
  		return 0;
  
	if (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0) {
 	if ((m->type != FILE_REGEX || (m->str_flags & REGEX_LINE_COUNT) == 0) &&
 	    (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0)) {
  		file_magwarn(ms,
  		    ""'/BHhLl' modifiers are only allowed for pascal strings\n"");
  		return -1;
 	}
 	switch (m->type) {
 	case FILE_BESTRING16:
 	case FILE_LESTRING16:
 		if (m->str_flags != 0) {
 			file_magwarn(ms,
 			    ""no modifiers allowed for 16-bit strings\n"");
 			return -1;
 		}
 		break;
 	case FILE_STRING:
 	case FILE_PSTRING:
 		if ((m->str_flags & REGEX_OFFSET_START) != 0) {
 			file_magwarn(ms,
 			    ""'/%c' only allowed on regex and search\n"",
 			    CHAR_REGEX_OFFSET_START);
 			return -1;
 		}
 		break;
 	case FILE_SEARCH:
 		if (m->str_range == 0) {
 			file_magwarn(ms,
 			    ""missing range; defaulting to %d\n"",
                             STRING_DEFAULT_RANGE);
 			m->str_range = STRING_DEFAULT_RANGE;
 			return -1;
 		}
 		break;
 	case FILE_REGEX:
 		if ((m->str_flags & STRING_COMPACT_WHITESPACE) != 0) {
 			file_magwarn(ms, ""'/%c' not allowed on regex\n"",
 			    CHAR_COMPACT_WHITESPACE);
 			return -1;
 		}
 		if ((m->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {
 			file_magwarn(ms, ""'/%c' not allowed on regex\n"",
 			    CHAR_COMPACT_OPTIONAL_WHITESPACE);
 			return -1;
 		}
 		break;
 	default:
 		file_magwarn(ms, ""coding error: m->type=%d\n"",
 		    m->type);
 		return -1;
 	}
 	return 0;
 }","[7, 8, 6]","file before 5.19 does not properly restrict the amount of data read during a regex search, which allows remote attackers to cause a denial of service (CPU consumption) via a crafted file that triggers backtracking during processing of an awk rule.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7345."
201140," static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)
 {
   const char
     *option,
     *property;
 
   int
     jp2_status;
 
   MagickBooleanType
     status;
 
   opj_codec_t
     *jp2_codec;
 
   OPJ_COLOR_SPACE
     jp2_colorspace;
 
   opj_cparameters_t
     parameters;
 
   opj_image_cmptparm_t
     jp2_info[5];
 
   opj_image_t
     *jp2_image;
 
   opj_stream_t
     *jp2_stream;
 
   register ssize_t
     i;
 
   ssize_t
     y;
 
   unsigned int
     channels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
    
   opj_set_default_encoder_parameters(&parameters);
   for (i=1; i < 6; i++)
     if (((size_t) (1 << (i+2)) > image->columns) &&
         ((size_t) (1 << (i+2)) > image->rows))
       break;
   parameters.numresolution=i;
   option=GetImageOption(image_info,""jp2:number-resolutions"");
   if (option != (const char *) NULL)
     parameters.numresolution=StringToInteger(option);
   parameters.tcp_numlayers=1;
   parameters.tcp_rates[0]=0;   
   parameters.cp_disto_alloc=1;
   if ((image_info->quality != 0) && (image_info->quality != 100))
     {
       parameters.tcp_distoratio[0]=(double) image_info->quality;
       parameters.cp_fixed_quality=OPJ_TRUE;
     }
   if (image_info->extract != (char *) NULL)
     {
       RectangleInfo
         geometry;
 
       int
         flags;
 
        
       flags=ParseAbsoluteGeometry(image_info->extract,&geometry);
       parameters.cp_tdx=(int) geometry.width;
       parameters.cp_tdy=(int) geometry.width;
       if ((flags & HeightValue) != 0)
         parameters.cp_tdy=(int) geometry.height;
       if ((flags & XValue) != 0)
         parameters.cp_tx0=geometry.x;
       if ((flags & YValue) != 0)
         parameters.cp_ty0=geometry.y;
       parameters.tile_size_on=OPJ_TRUE;
     }
   option=GetImageOption(image_info,""jp2:quality"");
   if (option != (const char *) NULL)
     {
       register const char
         *p;
 
        
       p=option;
       for (i=0; sscanf(p,""%f"",&parameters.tcp_distoratio[i]) == 1; i++)
       {
         if (i >= 100)
           break;
         while ((*p != '\0') && (*p != ','))
           p++;
         if (*p == '\0')
           break;
         p++;
       }
       parameters.tcp_numlayers=i+1;
       parameters.cp_fixed_quality=OPJ_TRUE;
     }
   option=GetImageOption(image_info,""jp2:progression-order"");
   if (option != (const char *) NULL)
     {
       if (LocaleCompare(option,""LRCP"") == 0)
         parameters.prog_order=OPJ_LRCP;
       if (LocaleCompare(option,""RLCP"") == 0)
         parameters.prog_order=OPJ_RLCP;
       if (LocaleCompare(option,""RPCL"") == 0)
         parameters.prog_order=OPJ_RPCL;
       if (LocaleCompare(option,""PCRL"") == 0)
         parameters.prog_order=OPJ_PCRL;
       if (LocaleCompare(option,""CPRL"") == 0)
         parameters.prog_order=OPJ_CPRL;
     }
   option=GetImageOption(image_info,""jp2:rate"");
   if (option != (const char *) NULL)
     {
       register const char
         *p;
 
        
       p=option;
       for (i=0; sscanf(p,""%f"",&parameters.tcp_rates[i]) == 1; i++)
       {
         if (i > 100)
           break;
         while ((*p != '\0') && (*p != ','))
           p++;
         if (*p == '\0')
           break;
         p++;
       }
       parameters.tcp_numlayers=i+1;
       parameters.cp_disto_alloc=OPJ_TRUE;
     }
   if (image_info->sampling_factor != (const char *) NULL)
     (void) sscanf(image_info->sampling_factor,""%d,%d"",
        &parameters.subsampling_dx,&parameters.subsampling_dy);
    property=GetImageProperty(image,""comment"");
    if (property != (const char *) NULL)
    parameters.cp_comment=property;
     parameters.cp_comment=(char *) property;
    channels=3;
    jp2_colorspace=OPJ_CLRSPC_SRGB;
    if (image->colorspace == YUVColorspace)
     {
       jp2_colorspace=OPJ_CLRSPC_SYCC;
       parameters.subsampling_dx=2;
     }
   else
     {
       if (IsGrayColorspace(image->colorspace) != MagickFalse)
         {
           channels=1;
           jp2_colorspace=OPJ_CLRSPC_GRAY;
         }
       else
         (void) TransformImageColorspace(image,sRGBColorspace);
       if (image->matte != MagickFalse)
         channels++;
     }
   parameters.tcp_mct=channels == 3 ? 1 : 0;
   ResetMagickMemory(jp2_info,0,sizeof(jp2_info));
   for (i=0; i < (ssize_t) channels; i++)
   {
     jp2_info[i].prec=(unsigned int) image->depth;
     jp2_info[i].bpp=(unsigned int) image->depth;
     if ((image->depth == 1) &&
         ((LocaleCompare(image_info->magick,""JPT"") == 0) ||
          (LocaleCompare(image_info->magick,""JP2"") == 0)))
       {
         jp2_info[i].prec++;   
         jp2_info[i].bpp++;
       }
     jp2_info[i].sgnd=0;
     jp2_info[i].dx=parameters.subsampling_dx;
     jp2_info[i].dy=parameters.subsampling_dy;
     jp2_info[i].w=(unsigned int) image->columns;
     jp2_info[i].h=(unsigned int) image->rows;
   }
   jp2_image=opj_image_create(channels,jp2_info,jp2_colorspace);
   if (jp2_image == (opj_image_t *) NULL)
     ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
   jp2_image->x0=parameters.image_offset_x0;
   jp2_image->y0=parameters.image_offset_y0;
   jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*
     parameters.subsampling_dx+1);
   jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*
     parameters.subsampling_dx+1);
   if ((image->depth == 12) &&
       ((image->columns == 2048) || (image->rows == 1080) ||
        (image->columns == 4096) || (image->rows == 2160)))
     CinemaProfileCompliance(jp2_image,&parameters);
   if (channels == 4)
     jp2_image->comps[3].alpha=1;
   else
    if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))
      jp2_image->comps[1].alpha=1;
    
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register const PixelPacket
       *p;
 
     ssize_t
       x;
 
     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       for (i=0; i < (ssize_t) channels; i++)
       {
         double
           scale;
 
         register int
           *q;
 
         scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;
         q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*
           image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);
         switch (i)
         {
           case 0:
           {
             if (jp2_colorspace == OPJ_CLRSPC_GRAY)
               {
                 *q=(int) (scale*GetPixelLuma(image,p));
                 break;
               }
             *q=(int) (scale*p->red);
             break;
           }
           case 1:
           {
             if (jp2_colorspace == OPJ_CLRSPC_GRAY)
               {
                 *q=(int) (scale*(QuantumRange-p->opacity));
                 break;
               }
             *q=(int) (scale*p->green);
             break;
           }
           case 2:
           {
             *q=(int) (scale*p->blue);
             break;
           }
           case 3:
           {
             *q=(int) (scale*(QuantumRange-p->opacity));
             break;
           }
         }
       }
       p++;
     }
     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
       image->rows);
     if (status == MagickFalse)
       break;
   }
   if (LocaleCompare(image_info->magick,""JPT"") == 0)
     jp2_codec=opj_create_compress(OPJ_CODEC_JPT);
   else
     if (LocaleCompare(image_info->magick,""J2K"") == 0)
       jp2_codec=opj_create_compress(OPJ_CODEC_J2K);
     else
       jp2_codec=opj_create_compress(OPJ_CODEC_JP2);
   opj_set_warning_handler(jp2_codec,JP2WarningHandler,&image->exception);
   opj_set_error_handler(jp2_codec,JP2ErrorHandler,&image->exception);
   opj_setup_encoder(jp2_codec,&parameters,jp2_image);
   jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);
   opj_stream_set_read_function(jp2_stream,JP2ReadHandler);
   opj_stream_set_write_function(jp2_stream,JP2WriteHandler);
   opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);
   opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);
   opj_stream_set_user_data(jp2_stream,image,NULL);
   if (jp2_stream == (opj_stream_t *) NULL)
     ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
   jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);
   if (jp2_status == 0)
     ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
   if ((opj_encode(jp2_codec,jp2_stream) == 0) ||
       (opj_end_compress(jp2_codec,jp2_stream) == 0))
     {
       opj_stream_destroy(jp2_stream);
       opj_destroy_codec(jp2_codec);
       opj_image_destroy(jp2_image);
       ThrowWriterException(DelegateError,""UnableToEncodeImageFile"");
     }
    
   opj_stream_destroy(jp2_stream);
   opj_destroy_codec(jp2_codec);
   opj_image_destroy(jp2_image);
   (void) CloseBlob(image);
   return(MagickTrue);
 }","[150, 149]",ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteCALSImage in coders/cals.c.
203965,"   void StopInputMethodDaemon() {
     if (!initialized_successfully_)
       return;
 
      should_launch_ime_ = false;
      if (ibus_daemon_process_handle_ != base::kNullProcessHandle) {
        const base::ProcessId pid = base::GetProcId(ibus_daemon_process_handle_);
      if (!chromeos::StopInputMethodProcess(input_method_status_connection_)) {
       if (!ibus_controller_->StopInputMethodProcess()) {
          LOG(ERROR) << ""StopInputMethodProcess IPC failed. Sending SIGTERM to ""
                     << ""PID "" << pid;
          base::KillProcess(ibus_daemon_process_handle_, -1, false  );
       }
       VLOG(1) << ""ibus-daemon (PID="" << pid << "") is terminated"";
       ibus_daemon_process_handle_ = base::kNullProcessHandle;
     }
   }","[9, 8]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
205296," XSharedMemoryId AttachSharedMemory(Display* display, int shared_memory_key) {
   DCHECK(QuerySharedMemorySupport(display));
 
   XShmSegmentInfo shminfo;
   memset(&shminfo, 0, sizeof(shminfo));
   shminfo.shmid = shared_memory_key;
 
  if (!XShmAttach(display, &shminfo))
   if (!XShmAttach(display, &shminfo)) {
     LOG(WARNING) << ""X failed to attach to shared memory segment ""
                  << shminfo.shmid;
      NOTREACHED();
   } else {
     VLOG(1) << ""X attached to shared memory segment "" << shminfo.shmid;
   }
  
    return shminfo.shmseg;
  }","[9, 10, 11, 13, 14, 15, 8]","Google Chrome before 24.0.1312.52 on Linux uses weak permissions for shared memory segments, which has unspecified impact and attack vectors."
208130," bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
  size_t oldSize = mSize;
 
  size_t offset = 0;
  while (mSize >= 10 && offset <= mSize - 10) {
  if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
  break;
  }
 
  size_t dataSize;
  if (iTunesHack) {
             dataSize = U32_AT(&mData[offset + 4]);
  } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
  return false;
  }
 
  if (dataSize > mSize - 10 - offset) {
  return false;
  }
 
  uint16_t flags = U16_AT(&mData[offset + 8]);
  uint16_t prevFlags = flags;
 
  if (flags & 1) {
 
  if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
  return false;
  }
             memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
             mSize -= 4;
             dataSize -= 4;
 
             flags &= ~1;
  }
 
  if ((flags & 2) && (dataSize >= 2)) {
 
  size_t readOffset = offset + 11;
  size_t writeOffset = offset + 11;
  for (size_t i = 0; i + 1 < dataSize; ++i) {
  if (mData[readOffset - 1] == 0xff
  && mData[readOffset] == 0x00) {
  ++readOffset;
 
                      --mSize;
                      --dataSize;
                  }
                mData[writeOffset++] = mData[readOffset++];
                 if (i + 1 < dataSize) {
                      
                      
                      
                     mData[writeOffset++] = mData[readOffset++];
                 }
              }
              if (readOffset <= oldSize) {
                 memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
  } else {
                 ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                 android_errorWriteLog(0x534e4554, ""34618607"");
  }
 
  }
         flags &= ~2;
  if (flags != prevFlags || iTunesHack) {
  WriteSyncsafeInteger(&mData[offset + 4], dataSize);
             mData[offset + 8] = flags >> 8;
             mData[offset + 9] = flags & 0xff;
  }
 
         offset += 10 + dataSize;
  }
 
     memset(&mData[mSize], 0, oldSize - mSize);
 
  return true;
 }","[49, 50, 51, 52, 53, 54, 48]","An information disclosure vulnerability in the Android media framework (av) related to id3 unsynchronization. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-63100526."
207565," WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,
                                 WORD32 num_mb_skip,
                                 UWORD8 u1_is_idr_slice,
                                 UWORD16 u2_frame_num,
  pocstruct_t *ps_cur_poc,
                                 WORD32 prev_slice_err)
 {
     WORD32 i2_cur_mb_addr;
     UWORD32 u1_num_mbs, u1_num_mbsNby2;
     UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
     UWORD32 i2_mb_skip_run;
 
     UWORD32 u1_num_mbs_next, u1_end_of_row;
  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
     UWORD32 u1_slice_end;
     UWORD32 u1_tfr_n_mb;
     UWORD32 u1_decode_nmb;
  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
  deblk_mb_t *ps_cur_deblk_mb;
  dec_mb_info_t *ps_cur_mb_info;
  parse_pmbarams_t *ps_parse_mb_data;
     UWORD32 u1_inter_mb_type;
     UWORD32 u1_deblk_mb_type;
     UWORD16 u2_total_mbs_coded;
     UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
  parse_part_params_t *ps_part_info;
     WORD32 ret;
 
 
  if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
  {
         ih264d_err_pic_dispbuf_mgr(ps_dec);
  return 0;
  }
     ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
  if(prev_slice_err == 1)
  {
   
         ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;
 
 
  if(!ps_dec->u1_first_slice_in_stream)
  {
             ih264d_end_of_pic(ps_dec, u1_is_idr_slice,
                 ps_dec->ps_cur_slice->u2_frame_num);
             ps_dec->s_cur_pic_poc.u2_frame_num =
                 ps_dec->ps_cur_slice->u2_frame_num;
  }
 
  {
             WORD32 i, j, poc = 0;
 
             ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;
 
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
 
  if(ps_dec->ps_cur_pic != NULL)
                 poc = ps_dec->ps_cur_pic->i4_poc + 2;
 
             j = 0;
  for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
  if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
                        j = i;
  {
                 ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
                 ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;
                 ps_dec->ps_cur_slice->u1_nal_unit_type = 1;
                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
                         ps_dec->ps_cur_slice->u2_frame_num,
  &ps_dec->ps_pps[j]);
 
  if(ret != OK)
  {
  return ret;
  }
  }
 
             ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;
 
             ps_dec->u4_output_present = 0;
 
  {
                 ih264d_get_next_display_field(ps_dec,
                                               ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
   
 
  if(0 != ps_dec->s_disp_op.u4_error_code)
  {
                     ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
  }
  else
                     ps_dec->u4_output_present = 1;
  }
 
  if(ps_dec->u1_separate_parse == 1)
  {
  if(ps_dec->u4_dec_thread_created == 0)
  {
                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,
  (void *)ih264d_decode_picture_thread,
  (void *)ps_dec);
 
                     ps_dec->u4_dec_thread_created = 1;
  }
 
  if((ps_dec->u4_num_cores == 3) &&
  ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
  && (ps_dec->u4_bs_deblk_thread_created == 0))
  {
                     ps_dec->u4_start_recon_deblk = 0;
                     ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
  (void *)ih264d_recon_deblk_thread,
  (void *)ps_dec);
                     ps_dec->u4_bs_deblk_thread_created = 1;
 
                  }
              }
          }
         ps_dec->u4_first_slice_in_pic = 0;
      }
      else
      {
 
  dec_slice_struct_t *ps_parse_cur_slice;
         ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;
 
  if(ps_dec->u1_slice_header_done
  && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
  {
             u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;
 
  if(u1_num_mbs)
  {
                 ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
  }
  else
  {
  if(ps_dec->u1_separate_parse)
  {
                     ps_cur_mb_info = ps_dec->ps_nmb_info - 1;
  }
  else
  {
                     ps_cur_mb_info = ps_dec->ps_nmb_info
  + ps_dec->u4_num_mbs_prev_nmb - 1;
  }
  }
 
             ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
             ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;
 
             ps_dec->u1_mb_ngbr_availablity =
                     ps_cur_mb_info->u1_mb_ngbr_availablity;
 
             ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
             ps_dec->u2_cur_mb_addr--;
             ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;
 
  if(u1_num_mbs)
  {
  if (ps_dec->u1_pr_sl_type == P_SLICE
  || ps_dec->u1_pr_sl_type == B_SLICE)
  {
                     ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
                     ps_dec->ps_part = ps_dec->ps_parse_part_params;
  }
 
                 u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
                 u1_end_of_row = (!u1_num_mbs_next)
  && (!(u1_mbaff && (u1_num_mbs & 0x01)));
                 u1_slice_end = 1;
                 u1_tfr_n_mb = 1;
                 ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 
  if(ps_dec->u1_separate_parse)
  {
                     ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                     ps_dec->ps_nmb_info += u1_num_mbs;
  }
  else
  {
                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
  }
                 ps_dec->u2_total_mbs_coded += u1_num_mbs;
                 ps_dec->u1_mb_idx = 0;
                 ps_dec->u4_num_mbs_cur_nmb = 0;
  }
 
  if(ps_dec->u2_total_mbs_coded
  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
                 ps_dec->u1_pic_decode_done = 1;
  return 0;
  }
 
             ps_dec->u2_cur_slice_num++;
              ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
             ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
             ps_dec->ps_parse_cur_slice++;
 
  }
  else
  {
             ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
  + ps_dec->u2_cur_slice_num;
  }
  }
 
   
   
   
  {
         WORD32 num_entries;
         WORD32 size;
         UWORD8 *pu1_buf;
 
         num_entries = MAX_FRAMES;
  if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
  (0 == ps_dec->i4_display_delay))
  {
             num_entries = 1;
  }
         num_entries = ((2 * num_entries) + 1);
  if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)
  {
             num_entries *= 2;
  }
         size = num_entries * sizeof(void *);
         size += PAD_MAP_IDX_POC * sizeof(void *);
 
         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
         pu1_buf += size * ps_dec->u2_cur_slice_num;
         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
  }
 
     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
     ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
     ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;
 
  if(ps_dec->ps_cur_slice->u1_field_pic_flag)
         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;
 
     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
 
  if(ps_dec->u1_separate_parse)
  {
         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
  }
  else
  {
         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
  }
 
   
   
   
     u1_inter_mb_type = P_MB;
     u1_deblk_mb_type = D_INTER_MB;
 
     ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
     ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
     ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
   
   
   
     ps_dec->u1_slice_header_done = 2;
     ps_dec->u1_qp = ps_slice->u1_slice_qp;
     ih264d_update_qp(ps_dec, 0);
     u1_mb_idx = ps_dec->u1_mb_idx;
     ps_parse_mb_data = ps_dec->ps_parse_mb_data;
     u1_num_mbs = u1_mb_idx;
 
     u1_slice_end = 0;
     u1_tfr_n_mb = 0;
     u1_decode_nmb = 0;
     u1_num_mbsNby2 = 0;
     i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
     i2_mb_skip_run = num_mb_skip;
 
  while(!u1_slice_end)
  {
         UWORD8 u1_mb_type;
 
  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
  break;
 
         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
 
         ps_cur_mb_info->u1_Mux = 0;
         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;
 
         ps_cur_mb_info->u1_end_of_slice = 0;
 
   
         ps_parse_mb_data->u1_num_part = 1;
         ps_parse_mb_data->u1_isI_mb = 0;
 
   
   
   
   
  if (u1_mbaff)
             ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
  else
             ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
 
   
  if(ps_dec->u4_app_disable_deblk_frm == 0)
  {
             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                              ps_dec->u1_mb_ngbr_availablity,
                                              ps_dec->u1_cur_mb_fld_dec_flag);
  }
 
   
         ps_dec->i1_prev_mb_qp_delta = 0;
         ps_dec->u1_sub_mb_num = 0;
         ps_cur_mb_info->u1_mb_type = MB_SKIP;
         ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
         ps_cur_mb_info->u1_cbp = 0;
 
   
         ps_part_info = ps_dec->ps_part;
         ps_part_info->u1_is_direct = PART_DIRECT_16x16;
         ps_part_info->u1_sub_mb_num = 0;
         ps_dec->ps_part++;
 
   
         ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
 
         ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
         ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 
         i2_mb_skip_run--;
 
         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 
  if (u1_mbaff)
  {
             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
  }
 
   
   
   
         i2_cur_mb_addr++;
 
         u1_num_mbs++;
         u1_num_mbsNby2++;
         ps_parse_mb_data++;
 
   
   
   
   
   
         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
         u1_slice_end = !i2_mb_skip_run;
         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
  || u1_slice_end;
         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 
  if(u1_decode_nmb)
  {
             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
             u1_num_mbsNby2 = 0;
 
             ps_parse_mb_data = ps_dec->ps_parse_mb_data;
             ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
  if(ps_dec->u1_separate_parse)
  {
                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                 ps_dec->ps_nmb_info +=  u1_num_mbs;
  }
  else
  {
                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
                                             u1_tfr_n_mb, u1_end_of_row);
  }
             ps_dec->u2_total_mbs_coded += u1_num_mbs;
  if(u1_tfr_n_mb)
                 u1_num_mbs = 0;
             u1_mb_idx = u1_num_mbs;
             ps_dec->u1_mb_idx = u1_num_mbs;
  }
  }
 
     ps_dec->u4_num_mbs_cur_nmb = 0;
     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
  - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;
 
  
      H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", ps_dec->ps_cur_slice->u4_mbs_in_slice);
  
    ps_dec->u2_cur_slice_num++;
  
       
      if(ps_dec->u4_first_slice_in_pic != 0)
     {
          ps_dec->ps_parse_cur_slice++;
         ps_dec->u2_cur_slice_num++;
     }
  
      ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
      ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 
  if(ps_dec->u2_total_mbs_coded
  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
         ps_dec->u1_pic_decode_done = 1;
  }
 
  return 0;
 
 }","[125, 417, 419, 420, 413]","The ih264d decoder in mediaserver in Android 6.x before 2016-08-01 mishandles slice numbers, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28673410."
205685,"  void ChunkToLayerMapper::SwitchToChunk(const PaintChunk& chunk) {
    outset_for_raster_effects_ = chunk.outset_for_raster_effects;
  
  const auto& new_chunk_state = chunk.properties.GetPropertyTreeState();
   const auto& new_chunk_state = chunk.properties;
    if (new_chunk_state == chunk_state_)
      return;
  
   if (new_chunk_state == layer_state_) {
     has_filter_that_moves_pixels_ = false;
     transform_ = TransformationMatrix().Translate(-layer_offset_.x(),
                                                   -layer_offset_.y());
     clip_rect_ = FloatClipRect();
     chunk_state_ = new_chunk_state;
     return;
   }
 
   if (new_chunk_state.Transform() != chunk_state_.Transform()) {
     transform_ = GeometryMapper::SourceToDestinationProjection(
         new_chunk_state.Transform(), layer_state_.Transform());
     transform_.PostTranslate(-layer_offset_.x(), -layer_offset_.y());
   }
 
   bool new_has_filter_that_moves_pixels = has_filter_that_moves_pixels_;
   if (new_chunk_state.Effect() != chunk_state_.Effect()) {
     new_has_filter_that_moves_pixels = false;
     for (const auto* effect = new_chunk_state.Effect();
          effect && effect != layer_state_.Effect(); effect = effect->Parent()) {
       if (effect->HasFilterThatMovesPixels()) {
         new_has_filter_that_moves_pixels = true;
         break;
       }
     }
   }
 
   bool needs_clip_recalculation =
       new_has_filter_that_moves_pixels != has_filter_that_moves_pixels_ ||
       new_chunk_state.Clip() != chunk_state_.Clip();
   if (needs_clip_recalculation) {
     clip_rect_ =
         GeometryMapper::LocalToAncestorClipRect(new_chunk_state, layer_state_);
     if (!clip_rect_.IsInfinite())
       clip_rect_.MoveBy(FloatPoint(-layer_offset_.x(), -layer_offset_.y()));
   }
 
   chunk_state_ = new_chunk_state;
   has_filter_that_moves_pixels_ = new_has_filter_that_moves_pixels;
 }","[5, 4]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
8030,"int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)
{
if (!iter || !next)
return -1;

if (iter->in_range)
{
if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||
(!iter->down && (iter->range_cur == (iter->range_end + 1))))
{
iter->in_range = 0;
}
}

if (!iter->in_range)
{
iter->substr_cur = iter->substr_end;
if (iter->substr_cur == iter->eostr)
return 1;

while (!*(iter->substr_cur))
iter->substr_cur++;
iter->substr_end = strchr(iter->substr_cur, ',');
if (!iter->substr_end)
iter->substr_end = iter->eostr;
else
*(iter->substr_end) = '\0';

char *range_sep = strchr(iter->substr_cur, ':');
if (range_sep)
*range_sep++ = '\0';

if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)
return -1;
if (range_sep)
{
if (mutt_str_atoui(range_sep, &iter->range_end) != 0)
return -1;
}
else
iter->range_end = iter->range_cur;

iter->down = (iter->range_end < iter->range_cur);
iter->in_range = 1;
}

*next = iter->range_cur;
if (iter->down)
iter->range_cur--;
else
iter->range_cur++;

return 0;
}","[21, 22, 27]",Mutt 1.11.0 through 2.0.x before 2.0.7 (and NeoMutt 2019-10-25 through 2021-05-04) has a $imap_qresync issue in which imap/util.c has an out-of-bounds read in situations where an IMAP sequence set ends with a comma. NOTE: the $imap_qresync setting for QRESYNC is not enabled by default.
201897,"  int mif_validate(jas_stream_t *in)
  {
	uchar buf[MIF_MAGICLEN];
 	jas_uchar buf[MIF_MAGICLEN];
  	uint_fast32_t magic;
  	int i;
  	int n;
 
 	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);
 
 	 
 	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
 		return -1;
 	}
 
 	 
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 
 	 
 	if (n < MIF_MAGICLEN) {
 		return -1;
 	}
 
 	 
 	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
 	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
 	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
 	  buf[3];
 
 	 
 	if (magic != MIF_MAGIC) {
 		return -1;
 	}
 
 	return 0;
 }","[4, 3]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
198843," static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)
 {
 	unsigned char l, n = 0;
 	char callsign[11];
 
 	do {
 		switch (*p & 0xC0) {
 		case 0x00:
 			p   += 2;
 			n   += 2;
 			len -= 2;
 			break;
 
 		case 0x40:
 			p   += 3;
 			n   += 3;
 			len -= 3;
 			break;
 
 		case 0x80:
 			p   += 4;
 			n   += 4;
 			len -= 4;
 			break;
  
  		case 0xC0:
  			l = p[1];
 
 			 
 			if (l < 10 || l > 20)
 				return -1;
 
  			if (*p == FAC_CCITT_DEST_NSAP) {
  				memcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);
  				memcpy(callsign, p + 12,   l - 10);
 				callsign[l - 10] = '\0';
 				asc2ax(&facilities->source_call, callsign);
 			}
 			if (*p == FAC_CCITT_SRC_NSAP) {
 				memcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);
 				memcpy(callsign, p + 12, l - 10);
 				callsign[l - 10] = '\0';
 				asc2ax(&facilities->dest_call, callsign);
 			}
 			p   += l + 2;
 			n   += l + 2;
 			len -= l + 2;
 			break;
 		}
 	} while (*p != 0x00 && len > 0);
 
 	return n;
 }","[28, 29, 30, 31, 32]","The rose_parse_ccitt function in net/rose/rose_subr.c in the Linux kernel before 2.6.39 does not validate the FAC_CCITT_DEST_NSAP and FAC_CCITT_SRC_NSAP fields, which allows remote attackers to (1) cause a denial of service (integer underflow, heap memory corruption, and panic) via a small length value in data sent to a ROSE socket, or (2) conduct stack-based buffer overflow attacks via a large length value in data sent to a ROSE socket."
202997," icmp6_rrenum_print(netdissect_options *ndo, const u_char *bp, const u_char *ep)
 {
 	const struct icmp6_router_renum *rr6;
 	const char *cp;
 	const struct rr_pco_match *match;
 	const struct rr_pco_use *use;
 	char hbuf[NI_MAXHOST];
 	int n;
 
 	if (ep < bp)
 		return;
 	rr6 = (const struct icmp6_router_renum *)bp;
 	cp = (const char *)(rr6 + 1);
 
 	ND_TCHECK(rr6->rr_reserved);
 	switch (rr6->rr_code) {
 	case ICMP6_ROUTER_RENUMBERING_COMMAND:
 		ND_PRINT((ndo,""router renum: command""));
 		break;
 	case ICMP6_ROUTER_RENUMBERING_RESULT:
 		ND_PRINT((ndo,""router renum: result""));
 		break;
 	case ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET:
 		ND_PRINT((ndo,""router renum: sequence number reset""));
 		break;
 	default:
 		ND_PRINT((ndo,""router renum: code-#%d"", rr6->rr_code));
 		break;
 	}
 
         ND_PRINT((ndo,"", seq=%u"", EXTRACT_32BITS(&rr6->rr_seqnum)));
 
 	if (ndo->ndo_vflag) {
 #define F(x, y)	((rr6->rr_flags) & (x) ? (y) : """")
 		ND_PRINT((ndo,""[""));	 
 		if (rr6->rr_flags) {
 			ND_PRINT((ndo,""%s%s%s%s%s,"", F(ICMP6_RR_FLAGS_TEST, ""T""),
                                   F(ICMP6_RR_FLAGS_REQRESULT, ""R""),
                                   F(ICMP6_RR_FLAGS_FORCEAPPLY, ""A""),
                                   F(ICMP6_RR_FLAGS_SPECSITE, ""S""),
                                   F(ICMP6_RR_FLAGS_PREVDONE, ""P"")));
 		}
                 ND_PRINT((ndo,""seg=%u,"", rr6->rr_segnum));
                 ND_PRINT((ndo,""maxdelay=%u"", EXTRACT_16BITS(&rr6->rr_maxdelay)));
 		if (rr6->rr_reserved)
 			ND_PRINT((ndo,""rsvd=0x%x"", EXTRACT_32BITS(&rr6->rr_reserved)));
 		 
 		ND_PRINT((ndo,""]""));
 #undef F
 	}
 
 	if (rr6->rr_code == ICMP6_ROUTER_RENUMBERING_COMMAND) {
 		match = (const struct rr_pco_match *)cp;
 		cp = (const char *)(match + 1);
 
 		ND_TCHECK(match->rpm_prefix);
 
 		if (ndo->ndo_vflag > 1)
 			ND_PRINT((ndo,""\n\t""));
 		else
 			ND_PRINT((ndo,"" ""));
 		ND_PRINT((ndo,""match(""));	 
 		switch (match->rpm_code) {
 		case RPM_PCO_ADD:	ND_PRINT((ndo,""add"")); break;
 		case RPM_PCO_CHANGE:	ND_PRINT((ndo,""change"")); break;
 		case RPM_PCO_SETGLOBAL:	ND_PRINT((ndo,""setglobal"")); break;
 		default:		ND_PRINT((ndo,""#%u"", match->rpm_code)); break;
 		}
 
 		if (ndo->ndo_vflag) {
 			ND_PRINT((ndo,"",ord=%u"", match->rpm_ordinal));
 			ND_PRINT((ndo,"",min=%u"", match->rpm_minlen));
 			ND_PRINT((ndo,"",max=%u"", match->rpm_maxlen));
 		}
 		if (addrtostr6(&match->rpm_prefix, hbuf, sizeof(hbuf)))
 			ND_PRINT((ndo,"",%s/%u"", hbuf, match->rpm_matchlen));
 		else
 			ND_PRINT((ndo,"",?/%u"", match->rpm_matchlen));
 		 
 		ND_PRINT((ndo,"")""));
 
 		n = match->rpm_len - 3;
 		if (n % 4)
 			goto trunc;
 		n /= 4;
 		while (n-- > 0) {
 			use = (const struct rr_pco_use *)cp;
 			cp = (const char *)(use + 1);
 
 			ND_TCHECK(use->rpu_prefix);
 
 			if (ndo->ndo_vflag > 1)
 				ND_PRINT((ndo,""\n\t""));
 			else
 				ND_PRINT((ndo,"" ""));
 			ND_PRINT((ndo,""use(""));	 
 			if (use->rpu_flags) {
 #define F(x, y)	((use->rpu_flags) & (x) ? (y) : """")
 				ND_PRINT((ndo,""%s%s,"",
                                           F(ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME, ""V""),
                                           F(ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME, ""P"")));
 #undef F
 			}
 			if (ndo->ndo_vflag) {
 				ND_PRINT((ndo,""mask=0x%x,"", use->rpu_ramask));
 				ND_PRINT((ndo,""raflags=0x%x,"", use->rpu_raflags));
 				if (~use->rpu_vltime == 0)
 					ND_PRINT((ndo,""vltime=infty,""));
 				else
 					ND_PRINT((ndo,""vltime=%u,"",
                                                   EXTRACT_32BITS(&use->rpu_vltime)));
 				if (~use->rpu_pltime == 0)
 					ND_PRINT((ndo,""pltime=infty,""));
 				else
 					ND_PRINT((ndo,""pltime=%u,"",
                                                   EXTRACT_32BITS(&use->rpu_pltime)));
 			}
 			if (addrtostr6(&use->rpu_prefix, hbuf, sizeof(hbuf)))
 				ND_PRINT((ndo,""%s/%u/%u"", hbuf, use->rpu_uselen,
                                           use->rpu_keeplen));
 			else
 				ND_PRINT((ndo,""?/%u/%u"", use->rpu_uselen,
                                           use->rpu_keeplen));
 			 
                         ND_PRINT((ndo,"")""));
 		}
 	}
 
  	return;
  
  trunc:
	ND_PRINT((ndo,""[|icmp6]""));
 	ND_PRINT((ndo, ""%s"", icmp6_tstr));
  }","[133, 132]",The ICMPv6 parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp6.c.
201222," gsm_xsmp_client_disconnect (GsmXSMPClient *client)
 {
         if (client->priv->watch_id > 0) {
                 g_source_remove (client->priv->watch_id);
         }
 
         if (client->priv->conn != NULL) {
                 SmsCleanUp (client->priv->conn);
         }
 
         if (client->priv->ice_connection != NULL) {
                  IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                  IceCloseConnection (client->priv->ice_connection);
          }
        if (client->priv->protocol_timeout > 0) {
                g_source_remove (client->priv->protocol_timeout);
        }
  }","[15, 16, 17]","Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible."
201234," static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {
     _sx_sasl_t ctx = (_sx_sasl_t) p->private;
     _sx_sasl_sess_t sctx = NULL;
     char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;
     char hostname[256];
     int ret;
 #ifdef HAVE_SSL
     int i;
 #endif
     size_t buflen, outlen;
 
     assert(ctx);
     assert(ctx->cb);
 
      if(mech != NULL) {
          _sx_debug(ZONE, ""auth request from client (mechanism=%s)"", mech);
  
        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {
         if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {
               _sx_debug(ZONE, ""client requested mechanism (%s) that we didn't offer"", mech);
               _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);
               return;
         }
 
          
         ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);
         if(ret != GSASL_OK) {
             _sx_debug(ZONE, ""gsasl_server_start failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);
             return;
         }
 
          
         (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);
 
          
         sctx = gsasl_session_hook_get(sd);
         if (sctx != NULL) free(sctx);
 
          
         sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));
         sctx->s = s;
         sctx->ctx = ctx;
         gsasl_session_hook_set(sd, (void *) sctx);
         gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);
         gsasl_property_set(sd, GSASL_REALM, realm);
 
          
         hostname[0] = '\0';
         gethostname(hostname, 256);
         hostname[255] = '\0';
         gsasl_property_set(sd, GSASL_HOSTNAME, hostname);
 
          
         ext_id = NULL;
 #ifdef HAVE_SSL
         for(i = 0; i < s->env->nplugins; i++)
             if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)
                 ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;
         if (ext_id != NULL) {
              
             for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)
                 if (ext_id[i] != NULL) {
                     ctx->ext_id[i] = strdup(ext_id[i]);
                 } else {
                     ctx->ext_id[i] = NULL;
                     break;
                 }
         }
 #endif
 
         _sx_debug(ZONE, ""sasl context initialised for %d"", s->tag);
 
         s->plugin_data[p->index] = (void *) sd;
 
         if(strcmp(mech, ""ANONYMOUS"") == 0) {
              
             (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);
             buf = strdup(out);
             buflen = strlen(buf);
         } else if (strstr(in, ""<"") != NULL && strncmp(in, ""="", strstr(in, ""<"") - in ) == 0) {
              
              
             _sx_debug(ZONE, ""gsasl auth string is empty"");
             buf = strdup("""");
             buflen = strlen(buf);
         } else {
              
             ret = gsasl_base64_from(in, inlen, &buf, &buflen);
             if (ret != GSASL_OK) {
                 _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
                 _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
                 if(buf != NULL) free(buf);
                 return;
             }
         }
 
         ret = gsasl_step(sd, buf, buflen, &out, &outlen);
     }
 
     else {
          
         ret = gsasl_base64_from(in, inlen, &buf, &buflen);
         if (ret != GSASL_OK) {
             _sx_debug(ZONE, ""gsasl_base64_from failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
             return;
         }
 
         if(!sd) {
             _sx_debug(ZONE, ""response send before auth request enabling mechanism (decoded: %.*s)"", buflen, buf);
             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, ""response send before auth request enabling mechanism""), 0);
             if(buf != NULL) free(buf);
             return;
         }
         _sx_debug(ZONE, ""response from client (decoded: %.*s)"", buflen, buf);
         ret = gsasl_step(sd, buf, buflen, &out, &outlen);
     }
 
     if(buf != NULL) free(buf);
 
      
     if(ret == GSASL_OK) {
         _sx_debug(ZONE, ""sasl handshake completed"");
 
          
         ret = gsasl_base64_to(out, outlen, &buf, &buflen);
         if (ret == GSASL_OK) {
              
             _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);
             free(buf);
 
              
             ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;
             ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;
         }
         else {
             _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
             if(buf != NULL) free(buf);
         }
 
         if(out != NULL) free(out);
 
         return;
     }
 
      
     if(ret == GSASL_NEEDS_MORE) {
         _sx_debug(ZONE, ""sasl handshake in progress (challenge: %.*s)"", outlen, out);
 
          
         ret = gsasl_base64_to(out, outlen, &buf, &buflen);
         if (ret == GSASL_OK) {
             _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);
             free(buf);
         }
         else {
             _sx_debug(ZONE, ""gsasl_base64_to failed, no sasl for this conn; (%d): %s"", ret, gsasl_strerror(ret));
             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);
             if(buf != NULL) free(buf);
         }
 
         if(out != NULL) free(out);
 
         return;
     }
 
     if(out != NULL) free(out);
 
      
     _sx_debug(ZONE, ""sasl handshake failed; (%d): %s"", ret, gsasl_strerror(ret));
 
     switch (ret) {
         case GSASL_AUTHENTICATION_ERROR:
 	case GSASL_NO_ANONYMOUS_TOKEN:
 	case GSASL_NO_AUTHID:
 	case GSASL_NO_AUTHZID:
 	case GSASL_NO_PASSWORD:
 	case GSASL_NO_PASSCODE:
 	case GSASL_NO_PIN:
 	case GSASL_NO_SERVICE:
 	case GSASL_NO_HOSTNAME:
             out = _sasl_err_NOT_AUTHORIZED;
             break;
 	case GSASL_UNKNOWN_MECHANISM:
 	case GSASL_MECHANISM_PARSE_ERROR:
             out = _sasl_err_INVALID_MECHANISM;
             break;
 	case GSASL_BASE64_ERROR:
             out = _sasl_err_INCORRECT_ENCODING;
             break;
         default:
             out = _sasl_err_MALFORMED_REQUEST;
     }
     _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);
 }","[19, 18]","JabberD 2.x (aka jabberd2) before 2.6.1 allows anyone to authenticate using SASL ANONYMOUS, even when the sasl.anonymous c2s.xml option is not enabled."
202637," TEE_Result syscall_asymm_operate(unsigned long state,
 			const struct utee_attribute *usr_params,
 			size_t num_params, const void *src_data, size_t src_len,
 			void *dst_data, uint64_t *dst_len)
 {
 	TEE_Result res;
 	struct tee_cryp_state *cs;
 	struct tee_ta_session *sess;
 	uint64_t dlen64;
 	size_t dlen;
 	struct tee_obj *o;
 	void *label = NULL;
 	size_t label_len = 0;
 	size_t n;
 	int salt_len;
 	TEE_Attribute *params = NULL;
 	struct user_ta_ctx *utc;
 
 	res = tee_ta_get_current_session(&sess);
 	if (res != TEE_SUCCESS)
 		return res;
 	utc = to_user_ta_ctx(sess->ctx);
 
 	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
 	if (res != TEE_SUCCESS)
 		return res;
 
 	res = tee_mmu_check_access_rights(
 		utc,
 		TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,
 		(uaddr_t) src_data, src_len);
 	if (res != TEE_SUCCESS)
 		return res;
 
 	res = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));
 	if (res != TEE_SUCCESS)
 		return res;
 	dlen = dlen64;
 
 	res = tee_mmu_check_access_rights(
 		utc,
 		TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |
 			TEE_MEMORY_ACCESS_ANY_OWNER,
 		(uaddr_t) dst_data, dlen);
  	if (res != TEE_SUCCESS)
  		return res;
  
	params = malloc(sizeof(TEE_Attribute) * num_params);
 	size_t alloc_size = 0;
 
 	if (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))
 		return TEE_ERROR_OVERFLOW;
 
 	params = malloc(alloc_size);
  	if (!params)
  		return TEE_ERROR_OUT_OF_MEMORY;
  	res = copy_in_attrs(utc, usr_params, num_params, params);
 	if (res != TEE_SUCCESS)
 		goto out;
 
 	res = tee_obj_get(utc, cs->key1, &o);
 	if (res != TEE_SUCCESS)
 		goto out;
 	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
 		res = TEE_ERROR_GENERIC;
 		goto out;
 	}
 
 	switch (cs->algo) {
 	case TEE_ALG_RSA_NOPAD:
 		if (cs->mode == TEE_MODE_ENCRYPT) {
 			res = crypto_acipher_rsanopad_encrypt(o->attr, src_data,
 							      src_len, dst_data,
 							      &dlen);
 		} else if (cs->mode == TEE_MODE_DECRYPT) {
 			res = crypto_acipher_rsanopad_decrypt(o->attr, src_data,
 							      src_len, dst_data,
 							      &dlen);
 		} else {
 			 
 			res = TEE_ERROR_GENERIC;
 		}
 		break;
 
 	case TEE_ALG_RSAES_PKCS1_V1_5:
 	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:
 	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:
 	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:
 	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:
 	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:
 		for (n = 0; n < num_params; n++) {
 			if (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {
 				label = params[n].content.ref.buffer;
 				label_len = params[n].content.ref.length;
 				break;
 			}
 		}
 
 		if (cs->mode == TEE_MODE_ENCRYPT) {
 			res = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,
 							   label, label_len,
 							   src_data, src_len,
 							   dst_data, &dlen);
 		} else if (cs->mode == TEE_MODE_DECRYPT) {
 			res = crypto_acipher_rsaes_decrypt(
 					cs->algo, o->attr, label, label_len,
 					src_data, src_len, dst_data, &dlen);
 		} else {
 			res = TEE_ERROR_BAD_PARAMETERS;
 		}
 		break;
 
 #if defined(CFG_CRYPTO_RSASSA_NA1)
 	case TEE_ALG_RSASSA_PKCS1_V1_5:
 #endif
 	case TEE_ALG_RSASSA_PKCS1_V1_5_MD5:
 	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:
 	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:
 	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:
 	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:
 	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:
 	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:
 	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:
 	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:
 	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:
 	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:
 		if (cs->mode != TEE_MODE_SIGN) {
 			res = TEE_ERROR_BAD_PARAMETERS;
 			break;
 		}
 		salt_len = pkcs1_get_salt_len(params, num_params, src_len);
 		res = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,
 						 src_data, src_len, dst_data,
 						 &dlen);
 		break;
 
 	case TEE_ALG_DSA_SHA1:
 	case TEE_ALG_DSA_SHA224:
 	case TEE_ALG_DSA_SHA256:
 		res = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,
 					      src_len, dst_data, &dlen);
 		break;
 	case TEE_ALG_ECDSA_P192:
 	case TEE_ALG_ECDSA_P224:
 	case TEE_ALG_ECDSA_P256:
 	case TEE_ALG_ECDSA_P384:
 	case TEE_ALG_ECDSA_P521:
 		res = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,
 					      src_len, dst_data, &dlen);
 		break;
 
 	default:
 		res = TEE_ERROR_BAD_PARAMETERS;
 		break;
 	}
 
 out:
 	free(params);
 
 	if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
 		TEE_Result res2;
 
 		dlen64 = dlen;
 		res2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));
 		if (res2 != TEE_SUCCESS)
 			return res2;
 	}
 
 	return res;
 }","[49, 50, 51, 52, 53, 54, 48]",Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Code execution in the context of TEE core (kernel). The component is: optee_os. The fixed version is: 3.4.0 and later.
197857," plan_a (char const *filename)
 {
   char const *s;
   char const *lim;
   char const **ptr;
   char *buffer;
   lin iline;
   size_t size = instat.st_size;
 
    
   if (! (size == instat.st_size
 	 && (buffer = malloc (size ? size : (size_t) 1))))
     return false;
 
    
   if (size)
      {
        if (S_ISREG (instat.st_mode))
          {
	  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);
 	  int flags = O_RDONLY | binary_transput;
  	  size_t buffered = 0, n;
 	  int ifd;
 
 	  if (! follow_symlinks)
 	    flags |= O_NOFOLLOW;
 	  ifd = safe_open (filename, flags, 0);
  	  if (ifd < 0)
  	    pfatal (""can't open file %s"", quotearg (filename));
  
 		   
 		  size = buffered;
 		  break;
 		}
 	      if (n == (size_t) -1)
 		{
 		   
 		  close (ifd);
 		  free (buffer);
 		  return false;
 		}
 	      buffered += n;
 	    }
 
 	  if (close (ifd) != 0)
 	    read_fatal ();
 	}","[21, 23, 24, 25, 26, 27, 20]","In GNU patch through 2.7.6, the following of symlinks is mishandled in certain cases other than input files. This affects inp.c and util.c."
6094,"static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,
u64 remaining, u64 expires)
{
struct cfs_rq *cfs_rq;
u64 runtime;
u64 starting_runtime = remaining;

rcu_read_lock();
list_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,
throttled_list) {
struct rq *rq = rq_of(cfs_rq);
struct rq_flags rf;

rq_lock_irqsave(rq, &rf);
if (!cfs_rq_throttled(cfs_rq))
goto next;

runtime = -cfs_rq->runtime_remaining + 1;
if (runtime > remaining)
runtime = remaining;
remaining -= runtime;

cfs_rq->runtime_remaining += runtime;
cfs_rq->runtime_expires = expires;


if (cfs_rq->runtime_remaining > 0)
unthrottle_cfs_rq(cfs_rq);

next:
rq_unlock_irqrestore(rq, &rf);

if (!remaining)
break;
}
rcu_read_unlock();

return starting_runtime - remaining;
}",[24],"kernel/sched/fair.c in the Linux kernel before 5.3.9, when cpu.cfs_quota_us is used (e.g., with Kubernetes), allows attackers to cause a denial of service against non-cpu-bound applications by generating a workload that triggers unwanted slice expiration, aka CID-de53fd7aedb1. (In other words, although this slice expiration would typically be seen with benign workloads, it is possible that an attacker could calculate how many stray requests are required to force an entire Kubernetes cluster into a low-performance state caused by slice expiration, and ensure that a DDoS attack sent that number of stray requests. An attack does not affect the stability of the kernel; it only causes mismanagement of application execution.)"
207529,"  int venc_dev::venc_output_log_buffers(const char *buffer_addr, int buffer_len)
  {
     if (venc_handle->is_secure_session()) {
         DEBUG_PRINT_ERROR(""logging secure output buffers is not allowed!"");
         return -1;
     }
 
      if (!m_debug.outfile) {
          int size = 0;
          if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_MPEG4) {
            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.m4v"",
                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);
  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H264) {
            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.264"",
                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);
  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {
            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%ld_%ld_%p.265"",
                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);
  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H263) {
            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.263"",
                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);
  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_VP8) {
            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.ivf"",
                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);
  }
  if ((size > PROPERTY_VALUE_MAX) && (size < 0)) {
              DEBUG_PRINT_ERROR(""Failed to open output file: %s for logging size:%d"",
                                 m_debug.outfile_name, size);
  }
         m_debug.outfile = fopen(m_debug.outfile_name, ""ab"");
  if (!m_debug.outfile) {
             DEBUG_PRINT_ERROR(""Failed to open output file: %s for logging errno:%d"",
                                m_debug.outfile_name, errno);
             m_debug.outfile_name[0] = '\0';
  return -1;
  }
  }
  if (m_debug.outfile && buffer_len) {
         DEBUG_PRINT_LOW(""%s buffer_len:%d"", __func__, buffer_len);
         fwrite(buffer_addr, buffer_len, 1, m_debug.outfile);
  }
  return 0;
 }","[3, 4, 5, 6, 7]","The secure-session feature in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 mishandles heap pointers, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 28920116."
207528,"  int venc_dev::venc_input_log_buffers(OMX_BUFFERHEADERTYPE *pbuffer, int fd, int plane_offset) {
     if (venc_handle->is_secure_session()) {
         DEBUG_PRINT_ERROR(""logging secure input buffers is not allowed!"");
         return -1;
     }
 
      if (!m_debug.infile) {
          int size = snprintf(m_debug.infile_name, PROPERTY_VALUE_MAX, ""%s/input_enc_%lu_%lu_%p.yuv"",
                              m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);
  if ((size > PROPERTY_VALUE_MAX) && (size < 0)) {
              DEBUG_PRINT_ERROR(""Failed to open output file: %s for logging size:%d"",
                                 m_debug.infile_name, size);
  }
         m_debug.infile = fopen (m_debug.infile_name, ""ab"");
  if (!m_debug.infile) {
             DEBUG_PRINT_HIGH(""Failed to open input file: %s for logging"", m_debug.infile_name);
             m_debug.infile_name[0] = '\0';
  return -1;
  }
  }
  if (m_debug.infile && pbuffer && pbuffer->nFilledLen) {
  unsigned long i, msize;
  int stride = VENUS_Y_STRIDE(COLOR_FMT_NV12, m_sVenc_cfg.input_width);
  int scanlines = VENUS_Y_SCANLINES(COLOR_FMT_NV12, m_sVenc_cfg.input_height);
  unsigned char *pvirt,*ptemp;
 
  char *temp = (char *)pbuffer->pBuffer;
 
         msize = VENUS_BUFFER_SIZE(COLOR_FMT_NV12, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height);
  if (metadatamode == 1) {
             pvirt= (unsigned char *)mmap(NULL, msize, PROT_READ|PROT_WRITE,MAP_SHARED, fd, plane_offset);
  if (pvirt) {
                ptemp = pvirt;
  for (i = 0; i < m_sVenc_cfg.input_height; i++) {
                     fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile);
                     ptemp += stride;
  }
                ptemp = pvirt + (stride * scanlines);
  for(i = 0; i < m_sVenc_cfg.input_height/2; i++) {
                    fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile);
                    ptemp += stride;
  }
                munmap(pvirt, msize);
  } else if (pvirt == MAP_FAILED) {
                  DEBUG_PRINT_ERROR(""%s mmap failed"", __func__);
  return -1;
  }
  } else {
  for (i = 0; i < m_sVenc_cfg.input_height; i++) {
                  fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile);
                  temp += stride;
  }
 
             temp = (char *)pbuffer->pBuffer + (stride * scanlines);
 
  for(i = 0; i < m_sVenc_cfg.input_height/2; i++) {
                 fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile);
                 temp += stride;
  }
  }
  }
  return 0;
 }","[2, 3, 4, 5, 6]","The secure-session feature in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 mishandles heap pointers, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 28920116."
198864," static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)
 static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, fmode_t fmode, int flags, struct iattr *sattr, struct rpc_cred *cred)
  {
  	struct nfs4_exception exception = { };
  	struct nfs4_state *res;
  	int status;
  
  	do {
		status = _nfs4_do_open(dir, path, flags, sattr, cred, &res);
 		status = _nfs4_do_open(dir, path, fmode, flags, sattr, cred, &res);
  		if (status == 0)
  			break;
  		 
 		if (status == -NFS4ERR_BAD_SEQID) {
 			printk(KERN_WARNING ""NFS: v4 server %s ""
 					"" returned a bad sequence-id error!\n"",
 					NFS_SERVER(dir)->nfs_client->cl_hostname);
 			exception.retry = 1;
 			continue;
 		}
 		 
 		if (status == -NFS4ERR_BAD_STATEID) {
 			exception.retry = 1;
 			continue;
 		}
 		if (status == -EAGAIN) {
 			 
 			exception.retry = 1;
 			continue;
 		}
 		res = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),
 					status, &exception));
 	} while (exception.retry);
 	return res;
 }","[2, 10, 9]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
202631,"  _TIFFmalloc(tmsize_t s)
  {
         if (s == 0)
                 return ((void *) NULL);
 
  	return (malloc((size_t) s));
  }","[3, 4, 5]","The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither."
1833,"Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buffer,
unsigned int &size, const SessionProtocolWorkingState &state, string delta_monotonic)
{
char *pos = buffer;
const char *end = buffer + size;

pos += sizeof(boost::uint32_t);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REQUEST_URI""));
pos = appendData(pos, end, req->path.start->data, req->path.size);
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PATH_INFO""));
pos = appendData(pos, end, state.path.data(), state.path.size());
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SCRIPT_NAME""));
if (state.hasBaseURI) {
pos = appendData(pos, end, req->options.baseURI);
pos = appendData(pos, end, """", 1);
} else {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""""));
}

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""QUERY_STRING""));
pos = appendData(pos, end, state.queryString.data(), state.queryString.size());
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REQUEST_METHOD""));
pos = appendData(pos, end, state.methodStr);
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_NAME""));
pos = appendData(pos, end, state.serverName);
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_PORT""));
pos = appendData(pos, end, state.serverPort);
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_SOFTWARE""));
pos = appendData(pos, end, serverSoftware);
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""SERVER_PROTOCOL""));
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""HTTP/1.1""));

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REMOTE_ADDR""));
if (state.remoteAddr != NULL) {
pos = appendData(pos, end, state.remoteAddr);
pos = appendData(pos, end, """", 1);
} else {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""127.0.0.1""));
}

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REMOTE_PORT""));
if (state.remotePort != NULL) {
pos = appendData(pos, end, state.remotePort);
pos = appendData(pos, end, """", 1);
} else {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""0""));
}

if (state.remoteUser != NULL) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""REMOTE_USER""));
pos = appendData(pos, end, state.remoteUser);
pos = appendData(pos, end, """", 1);
}

if (state.contentType != NULL) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""CONTENT_TYPE""));
pos = appendData(pos, end, state.contentType);
pos = appendData(pos, end, """", 1);
}

if (state.contentLength != NULL) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""CONTENT_LENGTH""));
pos = appendData(pos, end, state.contentLength);
pos = appendData(pos, end, """", 1);
}

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PASSENGER_CONNECT_PASSWORD""));
pos = appendData(pos, end, req->session->getApiKey().toStaticString());
pos = appendData(pos, end, """", 1);

if (req->https) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""HTTPS""));
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""on""));
}

if (req->options.analytics) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PASSENGER_TXN_ID""));
pos = appendData(pos, end, req->options.transaction->getTxnId());
pos = appendData(pos, end, """", 1);

pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""PASSENGER_DELTA_MONOTONIC""));
pos = appendData(pos, end, delta_monotonic);
pos = appendData(pos, end, """", 1);
}

if (req->upgraded()) {
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""HTTP_CONNECTION""));
pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(""upgrade""));
}

ServerKit::HeaderTable::Iterator it(req->headers);
while (*it != NULL) {
if ((it->header->hash == HTTP_CONTENT_LENGTH.hash()
|| it->header->hash == HTTP_CONTENT_TYPE.hash()
|| it->header->hash == HTTP_CONNECTION.hash())
&& (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(""content-type""))
|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(""content-length""))
|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(""connection""))))
{
it.next();
continue;
}

pos = appendData(pos, end, P_STATIC_STRING(""HTTP_""));
const LString::Part *part = it->header->key.start;
while (part != NULL) {
char *start = pos;
pos = appendData(pos, end, part->data, part->size);
httpHeaderToScgiUpperCase((unsigned char *) start, pos - start);
part = part->next;
}
pos = appendData(pos, end, """", 1);

part = it->header->val.start;
while (part != NULL) {
pos = appendData(pos, end, part->data, part->size);
part = part->next;
}
pos = appendData(pos, end, """", 1);

it.next();
}

if (state.environmentVariablesData != NULL) {
pos = appendData(pos, end, state.environmentVariablesData, state.environmentVariablesSize);
}

Uint32Message::generate(buffer, pos - buffer - sizeof(boost::uint32_t));

size = pos - buffer;
return pos < end;
}","[108, 109, 110, 111, 112, 113]","agent/Core/Controller/SendRequest.cpp in Phusion Passenger before 4.0.60 and 5.0.x before 5.0.22, when used in Apache integration mode or in standalone mode without a filtering proxy, allows remote attackers to spoof headers passed to applications by using an _ (underscore) character instead of a - (dash) character in an HTTP header, as demonstrated by an X_User header."
206314,"  MediaControlsProgressView::MediaControlsProgressView(
      base::RepeatingCallback<void(double)> seek_callback)
      : seek_callback_(std::move(seek_callback)) {
    SetLayoutManager(std::make_unique<views::BoxLayout>(
      views::BoxLayout::Orientation::kVertical, kProgressViewInsets));
       views::BoxLayout::Orientation::kVertical, kProgressViewInsets,
       kProgressBarAndTimeSpacing));
  
  progress_bar_ = AddChildView(std::make_unique<views::ProgressBar>(5, false));
  progress_bar_->SetBorder(views::CreateEmptyBorder(kProgressBarInsets));
   progress_bar_ = AddChildView(
       std::make_unique<views::ProgressBar>(kProgressBarHeight, false));
  
    gfx::Font default_font;
   int font_size_delta = kProgressTimeFontSize - default_font.GetFontSize();
   gfx::Font font = default_font.Derive(font_size_delta, gfx::Font::NORMAL,
                                        gfx::Font::Weight::NORMAL);
   gfx::FontList font_list(font);
 
   auto time_view = std::make_unique<views::View>();
   auto* time_view_layout =
       time_view->SetLayoutManager(std::make_unique<views::FlexLayout>());
   time_view_layout->SetOrientation(views::LayoutOrientation::kHorizontal)
       .SetMainAxisAlignment(views::LayoutAlignment::kCenter)
       .SetCrossAxisAlignment(views::LayoutAlignment::kCenter)
       .SetCollapseMargins(true);
 
   auto progress_time = std::make_unique<views::Label>();
   progress_time->SetFontList(font_list);
   progress_time->SetEnabledColor(SK_ColorWHITE);
   progress_time->SetAutoColorReadabilityEnabled(false);
   progress_time_ = time_view->AddChildView(std::move(progress_time));
 
   auto time_spacing = std::make_unique<views::View>();
   time_spacing->SetPreferredSize(kTimeSpacingSize);
   time_spacing->SetProperty(views::kFlexBehaviorKey,
                             views::FlexSpecification::ForSizeRule(
                                 views::MinimumFlexSizeRule::kPreferred,
                                 views::MaximumFlexSizeRule::kUnbounded));
   time_view->AddChildView(std::move(time_spacing));
 
   auto duration = std::make_unique<views::Label>();
   duration->SetFontList(font_list);
   duration->SetEnabledColor(SK_ColorWHITE);
   duration->SetAutoColorReadabilityEnabled(false);
   duration_ = time_view->AddChildView(std::move(duration));
 
   AddChildView(std::move(time_view));
 }","[6, 7, 11, 12, 5, 9, 10]","A timing attack in SVG rendering in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to extract pixel values from a cross-origin page being iframe'd via a crafted HTML page."
206942,"  void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
      mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
    if (delegate_ != nullptr) {
      delegate_->OnInstrumentDetailsReady(response->method_name,
                                          response->stringified_details);
     delegate_ = nullptr;
   }
 }",[3],Object lifecycle issue in ServiceWorker in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.
197928," PHP_FUNCTION(openssl_seal)
 {
 	zval *pubkeys, *pubkey, *sealdata, *ekeys, *iv = NULL;
 	HashTable *pubkeysht;
 	EVP_PKEY **pkeys;
 	zend_resource ** key_resources;	 
 	int i, len1, len2, *eksl, nkeys, iv_len;
 	unsigned char iv_buf[EVP_MAX_IV_LENGTH + 1], *buf = NULL, **eks;
 	char * data;
 	size_t data_len;
 	char *method =NULL;
 	size_t method_len = 0;
 	const EVP_CIPHER *cipher;
 	EVP_CIPHER_CTX *ctx;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""sz/z/a/|sz/"", &data, &data_len,
 				&sealdata, &ekeys, &pubkeys, &method, &method_len, &iv) == FAILURE) {
 		return;
 	}
 	pubkeysht = Z_ARRVAL_P(pubkeys);
 	nkeys = pubkeysht ? zend_hash_num_elements(pubkeysht) : 0;
 	if (!nkeys) {
 		php_error_docref(NULL, E_WARNING, ""Fourth argument to openssl_seal() must be a non-empty array"");
 		RETURN_FALSE;
 	}
 
 	PHP_OPENSSL_CHECK_SIZE_T_TO_INT(data_len, data);
 
 	if (method) {
 		cipher = EVP_get_cipherbyname(method);
 		if (!cipher) {
 			php_error_docref(NULL, E_WARNING, ""Unknown signature algorithm."");
 			RETURN_FALSE;
 		}
 	} else {
 		cipher = EVP_rc4();
 	}
 
 	iv_len = EVP_CIPHER_iv_length(cipher);
 	if (!iv && iv_len > 0) {
 		php_error_docref(NULL, E_WARNING,
 				""Cipher algorithm requires an IV to be supplied as a sixth parameter"");
 		RETURN_FALSE;
 	}
 
 	pkeys = safe_emalloc(nkeys, sizeof(*pkeys), 0);
 	eksl = safe_emalloc(nkeys, sizeof(*eksl), 0);
 	eks = safe_emalloc(nkeys, sizeof(*eks), 0);
 	memset(eks, 0, sizeof(*eks) * nkeys);
 	key_resources = safe_emalloc(nkeys, sizeof(zend_resource*), 0);
 	memset(key_resources, 0, sizeof(zend_resource*) * nkeys);
 	memset(pkeys, 0, sizeof(*pkeys) * nkeys);
 
 	 
 	i = 0;
 	ZEND_HASH_FOREACH_VAL(pubkeysht, pubkey) {
 		pkeys[i] = php_openssl_evp_from_zval(pubkey, 1, NULL, 0, 0, &key_resources[i]);
 		if (pkeys[i] == NULL) {
 			php_error_docref(NULL, E_WARNING, ""not a public key (%dth member of pubkeys)"", i+1);
 			RETVAL_FALSE;
 			goto clean_exit;
 		}
 		eks[i] = emalloc(EVP_PKEY_size(pkeys[i]) + 1);
 		i++;
 	} ZEND_HASH_FOREACH_END();
 
 	ctx = EVP_CIPHER_CTX_new();
 	if (ctx == NULL || !EVP_EncryptInit(ctx,cipher,NULL,NULL)) {
 		EVP_CIPHER_CTX_free(ctx);
 		php_openssl_store_errors();
 		RETVAL_FALSE;
 		goto clean_exit;
 	}
 
 	 
         buf = emalloc(data_len + EVP_CIPHER_CTX_block_size(ctx));
         EVP_CIPHER_CTX_cleanup(ctx);
  
       if (!EVP_SealInit(ctx, cipher, eks, eksl, &iv_buf[0], pkeys, nkeys) ||
        if (EVP_SealInit(ctx, cipher, eks, eksl, &iv_buf[0], pkeys, nkeys) <= 0 ||
                         !EVP_SealUpdate(ctx, buf, &len1, (unsigned char *)data, (int)data_len) ||
                         !EVP_SealFinal(ctx, buf + len1, &len2)) {
                 efree(buf);
 		EVP_CIPHER_CTX_free(ctx);
 		php_openssl_store_errors();
 		RETVAL_FALSE;
 		goto clean_exit;
 	}
 
 	if (len1 + len2 > 0) {
 		zval_dtor(sealdata);
 		ZVAL_NEW_STR(sealdata, zend_string_init((char*)buf, len1 + len2, 0));
 		efree(buf);
 
 		zval_dtor(ekeys);
 		array_init(ekeys);
 		for (i=0; i<nkeys; i++) {
 			eks[i][eksl[i]] = '\0';
 			add_next_index_stringl(ekeys, (const char*)eks[i], eksl[i]);
 			efree(eks[i]);
 			eks[i] = NULL;
 		}
 
 		if (iv) {
 			zval_dtor(iv);
 			iv_buf[iv_len] = '\0';
 			ZVAL_NEW_STR(iv, zend_string_init((char*)iv_buf, iv_len, 0));
 		}
 	} else {
 		efree(buf);
 	}
 	RETVAL_LONG(len1 + len2);
 	EVP_CIPHER_CTX_free(ctx);
 
 clean_exit:
 	for (i=0; i<nkeys; i++) {
 		if (key_resources[i] == NULL && pkeys[i] != NULL) {
 			EVP_PKEY_free(pkeys[i]);
 		}
 		if (eks[i]) {
 			efree(eks[i]);
 		}
 	}
 	efree(eks);
 	efree(eksl);
 	efree(pkeys);
 	efree(key_resources);
 }","[80, 79]","In PHP before 5.6.31, 7.x before 7.0.21, and 7.1.x before 7.1.7, the openssl extension PEM sealing code did not check the return value of the OpenSSL sealing function, which could lead to a crash of the PHP interpreter, related to an interpretation conflict for a negative number in ext/openssl/openssl.c, and an OpenSSL documentation omission."
204538," bool AddPolicyForGPU(CommandLine* cmd_line, sandbox::TargetPolicy* policy) {
 #if !defined(NACL_WIN64)   
   if (base::win::GetVersion() > base::win::VERSION_SERVER_2003) {
     if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==
         gfx::kGLImplementationDesktopName) {
       policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                             sandbox::USER_LIMITED);
       policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);
       policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
     } else {
       if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==
           gfx::kGLImplementationSwiftShaderName ||
           cmd_line->HasSwitch(switches::kReduceGpuSandbox)) {
         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                               sandbox::USER_LIMITED);
         policy->SetJobLevel(sandbox::JOB_LIMITED_USER,
                             JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS |
                             JOB_OBJECT_UILIMIT_DESKTOP |
                             JOB_OBJECT_UILIMIT_EXITWINDOWS |
                             JOB_OBJECT_UILIMIT_DISPLAYSETTINGS);
       } else {
         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
                                sandbox::USER_RESTRICTED);
          policy->SetJobLevel(sandbox::JOB_LOCKDOWN,
                              JOB_OBJECT_UILIMIT_HANDLES);
          
          
          
         policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_UNTRUSTED);
        }
  
        policy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
     }
   } else {
     policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);
     policy->SetTokenLevel(sandbox::USER_UNPROTECTED,
                           sandbox::USER_LIMITED);
   }
 
   sandbox::ResultCode result = policy->AddRule(
       sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,
       sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,
       L""\\\\.\\pipe\\chrome.gpu.*"");
   if (result != sandbox::SBOX_ALL_OK)
     return false;
 
   result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,
                            sandbox::TargetPolicy::HANDLES_DUP_ANY,
                            L""Section"");
   if (result != sandbox::SBOX_ALL_OK)
     return false;
 
   AddGenericDllEvictionPolicy(policy);
 #endif
   return true;
 }","[26, 27, 28, 29]","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
6078,"void sqlite3EndTable(
Parse *pParse,
Token *pCons,
Token *pEnd,
u8 tabOpts,
Select *pSelect
){
Table *p;
sqlite3 *db = pParse->db;
int iDb;
Index *pIdx;

if( pEnd==0 && pSelect==0 ){
return;
}
assert( !db->mallocFailed );
p = pParse->pNewTable;
if( p==0 ) return;

if( pSelect==0 && isShadowTableName(db, p->zName) ){
p->tabFlags |= TF_Shadow;
}










if( db->init.busy ){
if( pSelect ){
sqlite3ErrorMsg(pParse, """");
return;
}
p->tnum = db->init.newTnum;
if( p->tnum==1 ) p->tabFlags |= TF_Readonly;
}

assert( (p->tabFlags & TF_HasPrimaryKey)==0
|| p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );
assert( (p->tabFlags & TF_HasPrimaryKey)!=0
|| (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );


if( tabOpts & TF_WithoutRowid ){
if( (p->tabFlags & TF_Autoincrement) ){
sqlite3ErrorMsg(pParse,
""AUTOINCREMENT not allowed on WITHOUT ROWID tables"");
return;
}
if( (p->tabFlags & TF_HasPrimaryKey)==0 ){
sqlite3ErrorMsg(pParse, ""PRIMARY KEY missing on table %s"", p->zName);
return;
}
p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;
convertToWithoutRowidTable(pParse, p);
}
iDb = sqlite3SchemaToIndex(db, p->pSchema);

#ifndef SQLITE_OMIT_CHECK


if( p->pCheck ){
sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);
}
#endif /* !defined(SQLITE_OMIT_CHECK) */
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
if( p->tabFlags & TF_HasGenerated ){
int ii, nNG = 0;
testcase( p->tabFlags & TF_HasVirtual );
testcase( p->tabFlags & TF_HasStored );
for(ii=0; ii<p->nCol; ii++){
u32 colFlags = p->aCol[ii].colFlags;
if( (colFlags & COLFLAG_GENERATED)!=0 ){
testcase( colFlags & COLFLAG_VIRTUAL );
testcase( colFlags & COLFLAG_STORED );
sqlite3ResolveSelfReference(pParse, p, NC_GenCol,
p->aCol[ii].pDflt, 0);
}else{
nNG++;
}
}
if( nNG==0 ){
sqlite3ErrorMsg(pParse, ""must have at least one non-generated column"");
return;
}
}
#endif


estimateTableWidth(p);
for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
estimateIndexWidth(pIdx);
}







if( !db->init.busy ){
int n;
Vdbe *v;
char *zType;
char *zType2;
char *zStmt;

v = sqlite3GetVdbe(pParse);
if( NEVER(v==0) ) return;

sqlite3VdbeAddOp1(v, OP_Close, 0);




if( p->pSelect==0 ){

zType = ""table"";
zType2 = ""TABLE"";
#ifndef SQLITE_OMIT_VIEW
}else{

zType = ""view"";
zType2 = ""VIEW"";
#endif
}














if( pSelect ){
SelectDest dest;
int regYield;
int addrTop;
int regRec;
int regRowid;
int addrInsLoop;
Table *pSelTab;

regYield = ++pParse->nMem;
regRec = ++pParse->nMem;
regRowid = ++pParse->nMem;
assert(pParse->nTab==1);
sqlite3MayAbort(pParse);
sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);
sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);
pParse->nTab = 2;
addrTop = sqlite3VdbeCurrentAddr(v) + 1;
sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);
if( pParse->nErr ) return;
pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);
if( pSelTab==0 ) return;
assert( p->aCol==0 );
p->nCol = p->nNVCol = pSelTab->nCol;
p->aCol = pSelTab->aCol;
pSelTab->nCol = 0;
pSelTab->aCol = 0;
sqlite3DeleteTable(db, pSelTab);
sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);
sqlite3Select(pParse, pSelect, &dest);
if( pParse->nErr ) return;
sqlite3VdbeEndCoroutine(v, regYield);
sqlite3VdbeJumpHere(v, addrTop - 1);
addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);
VdbeCoverage(v);
sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);
sqlite3TableAffinity(v, p, 0);
sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);
sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);
sqlite3VdbeGoto(v, addrInsLoop);
sqlite3VdbeJumpHere(v, addrInsLoop);
sqlite3VdbeAddOp1(v, OP_Close, 1);
}


if( pSelect ){
zStmt = createTableStmt(db, p);
}else{
Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;
n = (int)(pEnd2->z - pParse->sNameToken.z);
if( pEnd2->z[0]!=';' ) n += pEnd2->n;
zStmt = sqlite3MPrintf(db,
""CREATE %s %.*s"", zType2, n, pParse->sNameToken.z
);
}





sqlite3NestedParse(pParse,
""UPDATE %Q.%s ""
""SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q ""
""WHERE rowid=#%d"",
db->aDb[iDb].zDbSName, MASTER_NAME,
zType,
p->zName,
p->zName,
pParse->regRoot,
zStmt,
pParse->regRowid
);
sqlite3DbFree(db, zStmt);
sqlite3ChangeCookie(pParse, iDb);

#ifndef SQLITE_OMIT_AUTOINCREMENT



if( (p->tabFlags & TF_Autoincrement)!=0 ){
Db *pDb = &db->aDb[iDb];
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
if( pDb->pSchema->pSeqTab==0 ){
sqlite3NestedParse(pParse,
""CREATE TABLE %Q.sqlite_sequence(name,seq)"",
pDb->zDbSName
);
}
}
#endif


sqlite3VdbeAddParseSchemaOp(v, iDb,
sqlite3MPrintf(db, ""tbl_name='%q' AND type!='trigger'"", p->zName));
}



if( db->init.busy ){
Table *pOld;
Schema *pSchema = p->pSchema;
assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);
if( pOld ){
assert( p==pOld );
sqlite3OomFault(db);
return;
}
pParse->pNewTable = 0;
db->mDbFlags |= DBFLAG_SchemaChange;

#ifndef SQLITE_OMIT_ALTERTABLE
if( !p->pSelect ){
const char *zName = (const char *)pParse->sNameToken.z;
int nName;
assert( !pSelect && pCons && pEnd );
if( pCons->z==0 ){
pCons = pEnd;
}
nName = (int)((const char *)pCons->z - zName);
p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);
}
#endif
}
}",[20],"SQLite 3.30.1 mishandles certain SELECT statements with a nonexistent VIEW, leading to an application crash."
202886," 		void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)
 		{
 			std::string idx = request::findValue(&req, ""idx"");
 			if (idx == """") {
  				return;
  			}
  			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%s"", idx.c_str());
 			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%d"", atol(idx.c_str()));
  			if (result.empty())
  				return;
  			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());
 			std::string oname = ""floorplan"";
 			if (result[0][0].size() > 10)
 			{
 				if (result[0][0][0] == 'P')
 					oname += "".png"";
 				else if (result[0][0][0] == -1)
 					oname += "".jpg"";
 				else if (result[0][0][0] == 'B')
 					oname += "".bmp"";
 				else if (result[0][0][0] == 'G')
 					oname += "".gif"";
 			}
 			reply::add_header_attachment(&rep, oname);
 		}","[9, 8]",Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.
201759," static Image *ReadOTBImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define GetBit(a,i) (((a) >> (i)) & 1L)
 
   Image
     *image;
 
   int
     byte;
 
   MagickBooleanType
     status;
 
   register IndexPacket
     *indexes;
 
   register ssize_t
     x;
 
   register PixelPacket
     *q;
 
   ssize_t
     y;
 
   unsigned char
     bit,
     info,
     depth;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   info=(unsigned char) ReadBlobByte(image);
   if (GetBit(info,4) == 0)
     {
       image->columns=(size_t) ReadBlobByte(image);
       image->rows=(size_t) ReadBlobByte(image);
     }
   else
     {
       image->columns=(size_t) ReadBlobMSBShort(image);
       image->rows=(size_t) ReadBlobMSBShort(image);
     }
   if ((image->columns == 0) || (image->rows == 0))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   depth=(unsigned char) ReadBlobByte(image);
   if (depth != 1)
     ThrowReaderException(CoderError,""OnlyLevelZerofilesSupported"");
   if (AcquireImageColormap(image,2) == MagickFalse)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   if (image_info->ping != MagickFalse)
     {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
     
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
     if (q == (PixelPacket *) NULL)
       break;
     indexes=GetAuthenticIndexQueue(image);
     bit=0;
     byte=0;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       if (bit == 0)
         {
           byte=ReadBlobByte(image);
           if (byte == EOF)
             ThrowReaderException(CorruptImageError,""CorruptImage"");
         }
       SetPixelIndex(indexes+x,(byte & (0x01 << (7-bit))) ?
         0x00 : 0x01);
       bit++;
       if (bit == 8)
         bit=0;
     }
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
     if (image->previous == (Image *) NULL)
       {
         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
         if (status == MagickFalse)
           break;
       }
   }
   (void) SyncImage(image);
   if (EOFBlob(image) != MagickFalse)
     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
       image->filename);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[70, 71, 72, 73, 74, 75]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
207318,"  exsltStrPaddingFunction (xmlXPathParserContextPtr ctxt, int nargs) {
    int number, str_len = 0;
    xmlChar *str = NULL, *ret = NULL, *tmp;
     int number, str_len = 0, str_size = 0;
     xmlChar *str = NULL, *ret = NULL;
  
      if ((nargs < 1) || (nargs > 2)) {
  	xmlXPathSetArityError(ctxt);
 	return;
     }
 
      if (nargs == 2) {
  	str = xmlXPathPopString(ctxt);
  	str_len = xmlUTF8Strlen(str);
 	str_size = xmlStrlen(str);
      }
      if (str_len == 0) {
  	if (str != NULL) xmlFree(str);
  	str = xmlStrdup((const xmlChar *) "" "");
  	str_len = 1;
 	str_size = 1;
      }
  
      number = (int) xmlXPathPopNumber(ctxt);
 
     if (number <= 0) {
 	xmlXPathReturnEmptyString(ctxt);
 	xmlFree(str);
 	return;
      }
  
      while (number >= str_len) {
	ret = xmlStrncat(ret, str, str_len);
 	ret = xmlStrncat(ret, str, str_size);
  	number -= str_len;
      }
    tmp = xmlUTF8Strndup (str, number);
    ret = xmlStrcat(ret, tmp);
    if (tmp != NULL)
	xmlFree (tmp);
     if (number > 0) {
 	str_size = xmlUTF8Strsize(str, number);
 	ret = xmlStrncat(ret, str, str_size);
     }
  
      xmlXPathReturnString(ctxt, ret);
  
     if (str != NULL)
 	xmlFree(str);
 }","[4, 5, 15, 21, 34, 41, 42, 43, 44, 2, 3, 33, 37, 38, 39, 40]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
205299,"  TransportDIB* TransportDIB::Create(size_t size, uint32 sequence_num) {
  const int shmkey = shmget(IPC_PRIVATE, size, 0666);
   const int shmkey = shmget(IPC_PRIVATE, size, 0600);
    if (shmkey == -1) {
      DLOG(ERROR) << ""Failed to create SysV shared memory region""
                  << "" errno:"" << errno;
      return NULL;
   } else {
     VLOG(1) << ""Created SysV shared memory region "" << shmkey;
    }
  
    void* address = shmat(shmkey, NULL  , 0  );
   shmctl(shmkey, IPC_RMID, 0);
   if (address == kInvalidAddress)
     return NULL;
 
   TransportDIB* dib = new TransportDIB;
 
   dib->key_.shmkey = shmkey;
   dib->address_ = address;
   dib->size_ = size;
   return dib;
 }","[3, 8, 9, 2]","Google Chrome before 24.0.1312.52 on Linux uses weak permissions for shared memory segments, which has unspecified impact and attack vectors."
9478,"void Compute(OpKernelContext *ctx) override {
const Tensor *indices_t, *values_t, *shape_t, *dense_t;
OP_REQUIRES_OK(ctx, ctx->input(""sp_indices"", &indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""sp_values"", &values_t));
OP_REQUIRES_OK(ctx, ctx->input(""sp_shape"", &shape_t));
OP_REQUIRES_OK(ctx, ctx->input(""dense"", &dense_t));


OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),
errors::InvalidArgument(
""Input sp_indices should be a matrix but received shape: "",
indices_t->shape().DebugString()));
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(values_t->shape()) &&
TensorShapeUtils::IsVector(shape_t->shape()),
errors::InvalidArgument(
""Inputs sp_values and sp_shape should be vectors ""
""but received shapes: "",
values_t->shape().DebugString(), "" and "",
shape_t->shape().DebugString()));
OP_REQUIRES(
ctx, TensorShapeUtils::IsVector(shape_t->shape()),
errors::InvalidArgument(""Input sp_shape must be a vector. Got: "",
shape_t->shape().DebugString()));
OP_REQUIRES(
ctx, values_t->dim_size(0) == indices_t->dim_size(0),
errors::InvalidArgument(
""The first dimension of values and indices should match. ("",
values_t->dim_size(0), "" vs. "", indices_t->dim_size(0), "")""));
OP_REQUIRES(
ctx, shape_t->shape().dim_size(0) == indices_t->shape().dim_size(1),
errors::InvalidArgument(
""Number of dimensions must match second dimension of indices. "",
""Got "", shape_t->shape().dim_size(0),
"" dimensions, indices shape: "", indices_t->shape().DebugString()));
OP_REQUIRES(ctx, shape_t->NumElements() > 0,
errors::InvalidArgument(
""The shape argument requires at least one element.""));

const auto indices_mat = indices_t->matrix<int64_t>();
const auto shape_vec = shape_t->vec<int64_t>();
const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));
const auto rhs_dims = BCast::FromShape(dense_t->shape());
BCast b(lhs_dims, rhs_dims, false);



auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {
if (lhs.size() < rhs.size()) return false;
for (size_t i = 0; i < rhs.size(); ++i) {
if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;
}
return true;
};
OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),
errors::InvalidArgument(
""SparseDenseBinaryOpShared broadcasts dense to sparse ""
""only; got incompatible shapes: ["",
absl::StrJoin(lhs_dims, "",""), ""] vs. ["",
absl::StrJoin(rhs_dims, "",""), ""]""));

Tensor *output_values = nullptr;
Tensor dense_gathered;
const int64_t nnz = indices_t->dim_size(0);
OP_REQUIRES_OK(ctx,
ctx->allocate_output(0, TensorShape({nnz}), &output_values));
OP_REQUIRES_OK(
ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),
&dense_gathered));
bool op_is_div = false;
if (absl::StrContains(ctx->op_kernel().type_string_view(), ""Div"")) {
op_is_div = true;
}






auto dense_gathered_flat = dense_gathered.flat<T>();
const int ndims = lhs_dims.size();
switch (ndims) {
#define CASE(NDIM)                                                             \
  case NDIM: {                                                                 \
    TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \
        dense_t->shaped<T, NDIM>(b.y_reshape())                                \
            .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \
    Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \
    bool indices_valid = true;                                                 \
    for (int i = 0; i < nnz; ++i) {                                            \
      for (int d = 0; d < NDIM; ++d) {                                         \
        idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \
        if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \
          indices_valid = false;                                               \
        }                                                                      \
      }                                                                        \
      OP_REQUIRES(                                                             \
          ctx, indices_valid,                                                  \
          errors::InvalidArgument(""Provided indices are out-of-bounds w.r.t. "" \
                                  ""dense side with broadcasted shape""));       \
      dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \
      if (op_is_div) {                                                         \
        OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \
                    errors::InvalidArgument(                                   \
                        ""SparseDenseCwiseDiv cannot divide by zero,""           \
                        ""but input dense tensor contains zero ""));             \
      }                                                                        \
    }                                                                          \
    break;                                                                     \
  }

CASE(1);
CASE(2);
CASE(3);
CASE(4);
CASE(5);
default:
OP_REQUIRES(
ctx, false,
errors::InvalidArgument(""Only tensors with ranks between 1 and 5 ""
""are currently supported.  Tensor rank: "",
ndims));
#undef CASE
}

output_values->flat<T>().device(ctx->eigen_device<Device>()) =
values_t->flat<T>().binaryExpr(dense_gathered_flat,
typename Functor::func());
}",[42],"Tensorflow is an Open Source Machine Learning Framework. The implementations of `Sparse*Cwise*` ops are vulnerable to integer overflows. These can be used to trigger large allocations (so, OOM based denial of service) or `CHECK`-fails when building new `TensorShape` objects (so, assert failures based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
205985," const SystemProfileProto& MetricsLog::RecordEnvironment(
     DelegatingProvider* delegating_provider) {
   DCHECK(!has_environment_);
   has_environment_ = true;
 
   SystemProfileProto* system_profile = uma_proto()->mutable_system_profile();
 
   WriteMetricsEnableDefault(client_->GetMetricsReportingDefaultState(),
                             system_profile);
 
   std::string brand_code;
    if (client_->GetBrand(&brand_code))
      system_profile->set_brand_code(brand_code);
  
  SystemProfileProto::Hardware::CPU* cpu =
      system_profile->mutable_hardware()->mutable_cpu();
  base::CPU cpu_info;
  cpu->set_vendor_name(cpu_info.vendor_name());
  cpu->set_signature(cpu_info.signature());
  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());
    delegating_provider->ProvideSystemProfileMetrics(system_profile);
  
    return *system_profile;
 }","[15, 16, 17, 18, 19, 20]",Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.
207580," int main(int argc, char **argv) {
  if (!parse_args(argc, argv)) {
     usage(argv[0]);
  }
 
  if (bond && discoverable) {
     fprintf(stderr, ""Can only select either bond or discoverable, not both\n"");
     usage(argv[0]);
  }
 
  if (sco_listen && sco_connect) {
     fprintf(stderr, ""Can only select either sco_listen or sco_connect, not both\n"");
     usage(argv[0]);
  }
 
  if (!bond && !discover && !discoverable && !up && !get_name && !set_name && !sco_listen && !sco_connect) {
     fprintf(stderr, ""Must specify one command\n"");
     usage(argv[0]);
  }
 
  if (signal(SIGINT, sig_handler) == SIG_ERR) {
     fprintf(stderr, ""Will be unable to catch signals\n"");
  }
 
   fprintf(stdout, ""Bringing up bluetooth adapter\n"");
  if (!hal_open(callbacks_get_adapter_struct())) {
     fprintf(stderr, ""Unable to open Bluetooth HAL.\n"");
  return 1;
 
    }
  
    if (discover) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
  
      fprintf(stdout, ""Starting to start discovery\n"");
     CALL_AND_WAIT(bt_interface->start_discovery(), discovery_state_changed);
     fprintf(stdout, ""Started discovery for %d seconds\n"", timeout_in_sec);
 
     sleep(timeout_in_sec);
 
     fprintf(stdout, ""Starting to cancel discovery\n"");
     CALL_AND_WAIT(bt_interface->cancel_discovery(), discovery_state_changed);
     fprintf(stdout, ""Cancelled discovery after %d seconds\n"", timeout_in_sec);
 
    }
  
    if (discoverable) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
  
      bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
 
  int rc = bt_interface->set_adapter_property(property);
     fprintf(stdout, ""Set rc:%d device as discoverable for %d seconds\n"", rc, timeout_in_sec);
 
     sleep(timeout_in_sec);
 
     property_free(property);
  }
 
  if (bond) {
  if (bdaddr_is_empty(&bt_remote_bdaddr)) {
       fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
 
        exit(1);
      }
  
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
  
      int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0  );
     fprintf(stdout, ""Started bonding:%d for %d seconds\n"", rc, timeout_in_sec);
 
     sleep(timeout_in_sec);
 
    }
  
    if (up) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
  
      fprintf(stdout, ""Waiting for %d seconds\n"", timeout_in_sec);
     sleep(timeout_in_sec);
 
    }
  
    if (get_name) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
      int error;
      CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
  if (error != BT_STATUS_SUCCESS) {
       fprintf(stderr, ""Unable to get adapter property\n"");
       exit(1);
  }
  bt_property_t *property = adapter_get_property(BT_PROPERTY_BDNAME);
  const bt_bdname_t *name = property_as_name(property);
  if (name)
       printf(""Queried bluetooth device name:%s\n"", name->name);
  else
       printf(""No name\n"");
 
    }
  
    if (set_name) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
  
      bt_property_t *property = property_new_name(bd_name);
     printf(""Setting bluetooth device name to:%s\n"", bd_name);
  int error;
     CALL_AND_WAIT(error = bt_interface->set_adapter_property(property), adapter_properties);
  if (error != BT_STATUS_SUCCESS) {
       fprintf(stderr, ""Unable to set adapter property\n"");
       exit(1);
  }
     CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
  if (error != BT_STATUS_SUCCESS) {
       fprintf(stderr, ""Unable to get adapter property\n"");
       exit(1);
  }
     property_free(property);
     sleep(timeout_in_sec);
 
    }
  
    if (sco_listen) {
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
  
      bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
     CALL_AND_WAIT(bt_interface->set_adapter_property(property), adapter_properties);
     property_free(property);
 
  const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
 
  int rfcomm_fd = INVALID_FD;
  int error = sock->listen(BTSOCK_RFCOMM, ""meow"", (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
  if (error != BT_STATUS_SUCCESS) {
       fprintf(stderr, ""Unable to listen for incoming RFCOMM socket: %d\n"", error);
       exit(1);
  }
 
  int sock_fd = INVALID_FD;
     error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0);
  if (error != BT_STATUS_SUCCESS) {
       fprintf(stderr, ""Unable to listen for incoming SCO sockets: %d\n"", error);
       exit(1);
  }
     fprintf(stdout, ""Waiting for incoming SCO connections...\n"");
     sleep(timeout_in_sec);
  }
 
  if (sco_connect) {
  if (bdaddr_is_empty(&bt_remote_bdaddr)) {
       fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");
 
        exit(1);
      }
  
    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
      fprintf(stdout, ""BT adapter is up\n"");
  
      const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
 
  int rfcomm_fd = INVALID_FD;
  int error = sock->connect(&bt_remote_bdaddr, BTSOCK_RFCOMM, (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
  if (error != BT_STATUS_SUCCESS) {
       fprintf(stderr, ""Unable to connect to RFCOMM socket: %d.\n"", error);
       exit(1);
  }
 
     WAIT(acl_state_changed);
 
     fprintf(stdout, ""Establishing SCO connection...\n"");
 
  int sock_fd = INVALID_FD;
     error = sock->connect(&bt_remote_bdaddr, BTSOCK_SCO, NULL, 5, &sock_fd, 0);
  if (error != BT_STATUS_SUCCESS) {
       fprintf(stderr, ""Unable to connect to SCO socket: %d.\n"", error);
       exit(1);
  }
     sleep(timeout_in_sec);
  }
 
   CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);
   fprintf(stdout, ""BT adapter is down\n"");
 }","[34, 51, 72, 84, 94, 113, 136, 170, 33, 50, 71, 83, 93, 112, 135, 169]","Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683."
204673," string16 ExtensionInstallUI::Prompt::GetDialogTitle(
     const Extension* extension) const {
   if (type_ == INSTALL_PROMPT) {
      return l10n_util::GetStringUTF16(extension->is_app() ?
          IDS_EXTENSION_INSTALL_APP_PROMPT_TITLE :
          IDS_EXTENSION_INSTALL_EXTENSION_PROMPT_TITLE);
  } else if (type_ == INLINE_INSTALL_PROMPT) {
    return l10n_util::GetStringFUTF16(
      kTitleIds[type_], l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
    } else {
      return l10n_util::GetStringUTF16(kTitleIds[type_]);
    }
 }","[7, 8, 9]","Skia, as used in Google Chrome before 19.0.1084.52, allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
201715," MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)
 {
    size_t
      extent;
  
  if (CheckMemoryOverflow(count,quantum) != MagickFalse)
   if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
      return((void *) NULL);
    extent=count*quantum;
    return(AcquireMagickMemory(extent));
 }","[7, 6]","magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving *too many exceptions,* which trigger a buffer overflow."
206968,"   void StoreExistingGroupExistingCache() {
 
      MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);
     EXPECT_EQ(kDefaultEntrySize + kDefaultEntryPadding,
               storage()->usage_map_[kOrigin]);
  
      base::Time now = base::Time::Now();
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::MASTER, 1, 100));
     cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT,
                                                1,
                                                100,
                                                10));
      cache_->set_update_time(now);
  
      PushNextTask(base::BindOnce(
         &AppCacheStorageImplTest::Verify_StoreExistingGroupExistingCache,
         base::Unretained(this), now));
 
     EXPECT_EQ(cache_.get(), group_->newest_complete_cache());
     storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());
     EXPECT_FALSE(delegate()->stored_group_success_);
   }","[5, 6, 10, 11, 12, 13, 4, 9]",Resource size information leakage in Blink in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
6405,"PYBIND11_MODULE(_pywrap_tfe, m) {
py::class_<TFE_Executor> TFE_Executor_class(m, ""TFE_Executor"");
py::class_<TFE_ContextOptions> TFE_ContextOptions_class(m,
""TFE_ContextOptions"");
py::class_<TFE_MonitoringCounter0> TFE_MonitoringCounter0_class(
m, ""TFE_MonitoringCounter0"");
py::class_<TFE_MonitoringCounter1> TFE_MonitoringCounter1_class(
m, ""TFE_MonitoringCounter1"");
py::class_<TFE_MonitoringCounter2> TFE_MonitoringCounter2_class(
m, ""TFE_MonitoringCounter2"");
py::class_<TFE_MonitoringStringGauge0> TFE_MonitoringStringGauge0_class(
m, ""TFE_MonitoringStringGauge0"");
py::class_<TFE_MonitoringStringGauge1> TFE_MonitoringStringGauge1_class(
m, ""TFE_MonitoringStringGauge1"");
py::class_<TFE_MonitoringStringGauge2> TFE_MonitoringStringGauge2_class(
m, ""TFE_MonitoringStringGauge2"");
py::class_<TFE_MonitoringIntGauge0> TFE_MonitoringIntGauge0_class(
m, ""TFE_MonitoringIntGauge0"");
py::class_<TFE_MonitoringIntGauge1> TFE_MonitoringIntGauge1_class(
m, ""TFE_MonitoringIntGauge1"");
py::class_<TFE_MonitoringIntGauge2> TFE_MonitoringIntGauge2_class(
m, ""TFE_MonitoringIntGauge2"");
py::class_<TFE_MonitoringBoolGauge0> TFE_MonitoringBoolGauge0_class(
m, ""TFE_MonitoringBoolGauge0"");
py::class_<TFE_MonitoringBoolGauge1> TFE_MonitoringBoolGauge1_class(
m, ""TFE_MonitoringBoolGauge1"");
py::class_<TFE_MonitoringBoolGauge2> TFE_MonitoringBoolGauge2_class(
m, ""TFE_MonitoringBoolGauge2"");
py::class_<TFE_MonitoringCounterCell> TFE_MonitoringCounterCell_class(
m, ""TFE_MonitoringCounterCell"");
py::class_<TFE_MonitoringIntGaugeCell> TFE_MonitoringIntGaugeCell_class(
m, ""TFE_MonitoringIntGaugeCell"");
py::class_<TFE_MonitoringStringGaugeCell> TFE_MonitoringStringGaugeCell_class(
m, ""TFE_MonitoringStringGaugeCell"");
py::class_<TFE_MonitoringBoolGaugeCell> TFE_MonitoringBoolGaugeCell_class(
m, ""TFE_MonitoringBoolGaugeCell"");
py::class_<TFE_MonitoringSamplerCell> TFE_MonitoringSamplerCell_class(
m, ""TFE_MonitoringSamplerCell"");
py::class_<TFE_MonitoringBuckets> TFE_MonitoringBuckets_class(
m, ""TFE_MonitoringBuckets"");
py::class_<TFE_MonitoringSampler0> TFE_MonitoringSampler0_class(
m, ""TFE_MonitoringSampler0"");
py::class_<TFE_MonitoringSampler1> TFE_MonitoringSampler1_class(
m, ""TFE_MonitoringSampler1"");
py::class_<TFE_MonitoringSampler2> TFE_MonitoringSampler2_class(
m, ""TFE_MonitoringSampler2"");
py::class_<TFE_CancellationManager> TFE_CancellationManager_class(
m, ""TFE_CancellationManager"");

py::class_<TF_DeviceList> TF_DeviceList_class(m, ""TF_DeviceList"");
py::class_<TF_Function> TF_Function_class(m, ""TF_Function"");

m.def(""TFE_Py_RegisterExceptionClass"", [](const py::handle& e) {
return tensorflow::PyoOrThrow(TFE_Py_RegisterExceptionClass(e.ptr()));
});
m.def(""TFE_Py_RegisterFallbackExceptionClass"", [](const py::handle& e) {
return tensorflow::PyoOrThrow(
TFE_Py_RegisterFallbackExceptionClass(e.ptr()));
});

m.def(
""TFE_GetTotalMemoryUsage"", [](py::handle& ctx, const char* device_name) {
tensorflow::EagerContext* context = tensorflow::ContextFromInterface(
reinterpret_cast<tensorflow::ImmediateExecutionContext*>(
tensorflow::InputTFE_Context(ctx)));

tensorflow::DeviceNameUtils::ParsedName input_device_name;
if (!tensorflow::DeviceNameUtils::ParseFullOrLocalName(
device_name, &input_device_name)) {
tensorflow::ThrowValueError(
absl::StrFormat(""Failed parsing device name: '%s'"", device_name)
.c_str());
}

std::vector<tensorflow::Device*> devices =
context->local_device_mgr()->ListDevices();

tensorflow::Device* matched_device = nullptr;
for (int device_idx = 0; device_idx < devices.size(); device_idx++) {
tensorflow::Device* device = devices[device_idx];

if (tensorflow::DeviceNameUtils::AreCompatibleDevNames(
input_device_name, device->parsed_name())) {
if (device->device_type() == tensorflow::DEVICE_CPU) {
tensorflow::ThrowValueError(
""CPU does not support getting allocator information"");
}

if (matched_device != nullptr) {
tensorflow::ThrowValueError(
absl::StrFormat(
""Multiple devices matching the provided string ""
""'%s': '%s' and ""
""'%s' "",
device_name, matched_device->name(), device->name())
.c_str());
}
matched_device = device;
}
}

if (matched_device == nullptr) {
tensorflow::ThrowValueError(
absl::StrFormat(""No matching devices found for '%s'"", device_name)
.c_str());
}

tensorflow::AllocatorAttributes attrs;
tensorflow::Allocator* allocator = matched_device->GetAllocator(attrs);

if (absl::optional<tensorflow::AllocatorStats> stats =
allocator->GetStats()) {
return stats->bytes_in_use;
}

tensorflow::ThrowTypeError(
absl::StrFormat(""Allocator stats not available for device '%s'"",
matched_device->name())
.c_str());
});


m.def(""TF_SetXlaEnableLazyCompilation"", &TF_SetXlaEnableLazyCompilation);
m.def(""TF_SetTfXlaCpuGlobalJit"", &TF_SetTfXlaCpuGlobalJit);
m.def(""TF_SetXlaAutoJitMode"", &TF_SetXlaAutoJitMode);
m.def(""TF_SetXlaConstantFoldingDisabled"", &TF_SetXlaConstantFoldingDisabled);
m.def(""TF_GetXlaConstantFoldingDisabled"", &TF_GetXlaConstantFoldingDisabled);
m.def(""TF_SetXlaMinClusterSize"", &TF_SetXlaMinClusterSize);
m.def(""TF_GetCompilerIr"", &tensorflow::TFE_GetCompilerIr);


m.def(""TF_IsMlirBridgeEnabled"", [] {
return tensorflow::GetMlirCommonFlags()->tf_mlir_enable_mlir_bridge;
});
m.def(""TF_EnableMlirBridge"", [](bool enabled) {
tensorflow::GetMlirCommonFlags()->tf_mlir_enable_mlir_bridge = enabled;
});
m.def(""TF_EnableXlaDevices"", [] {
tensorflow::GetXlaDeviceFlags()->tf_xla_enable_xla_devices = true;
});


m.def(
""TFE_NewContext"",
[](const TFE_ContextOptions* opts) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_Context* context = TFE_NewContext(opts, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return tensorflow::PyoOrThrow(tensorflow::OutputTFE_Context(context));
},
py::return_value_policy::reference);
m.def(""TFE_DeleteContext"", [](py::handle& o) {
TFE_DeleteContext(tensorflow::InputTFE_Context(o));
});
m.def(
""TFE_ContextListDevices"",
[](py::handle& o) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_ContextListDevices(tensorflow::InputTFE_Context(o),
status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_HostAddressSpace"", [](py::handle& o, TF_Buffer& buf) {
TFE_HostAddressSpace(tensorflow::InputTFE_Context(o), &buf);
});
m.def(""TFE_ContextAddFunction"", [](py::handle& ctx, TF_Function* func) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextAddFunction(tensorflow::InputTFE_Context(ctx), func,
status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextAddFunctionDef"",
[](py::handle& ctx, const char* serialized_function_def, size_t size) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextAddFunctionDef(tensorflow::InputTFE_Context(ctx),
serialized_function_def, size,
status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextGetFunctionDef"",
[](py::handle& ctx, const char* function_name, TF_Buffer& buf) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextGetFunctionDef(tensorflow::InputTFE_Context(ctx),
function_name, &buf, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextRemoveFunction"", [](py::handle& ctx, const char* name) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextRemoveFunction(tensorflow::InputTFE_Context(ctx), name,
status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextHasFunction"", [](py::handle& ctx, const char* name) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_ContextHasFunction(tensorflow::InputTFE_Context(ctx), name);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
});
m.def(""TFE_ContextEnableRunMetadata"", [](py::handle& ctx) {
TFE_ContextEnableRunMetadata(tensorflow::InputTFE_Context(ctx));
});
m.def(""TFE_ContextDisableRunMetadata"", [](py::handle& ctx) {
TFE_ContextEnableRunMetadata(tensorflow::InputTFE_Context(ctx));
});
m.def(""TFE_ContextEnableGraphCollection"", [](py::handle& ctx) {
TFE_ContextEnableGraphCollection(tensorflow::InputTFE_Context(ctx));
});
m.def(""TFE_ContextDisableGraphCollection"", [](py::handle& ctx) {
TFE_ContextDisableGraphCollection(tensorflow::InputTFE_Context(ctx));
});
m.def(""TFE_ContextExportRunMetadata"", [](py::handle& ctx, TF_Buffer& buf) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextExportRunMetadata(tensorflow::InputTFE_Context(ctx), &buf,
status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextClearCaches"", [](py::handle& o) {
TFE_ContextClearCaches(tensorflow::InputTFE_Context(o));
});
m.def(""TFE_GetContextId"", [](py::handle& ctx) {
return TFE_GetContextId(tensorflow::InputTFE_Context(ctx));
});
m.def(""TFE_ContextGetDevicePlacementPolicy"", [](py::handle& ctx) {
return TFE_ContextGetDevicePlacementPolicy(
tensorflow::InputTFE_Context(ctx));
});
m.def(""TFE_ContextSetThreadLocalDevicePlacementPolicy"",
[](py::handle& ctx, TFE_ContextDevicePlacementPolicy policy) {
TFE_ContextSetThreadLocalDevicePlacementPolicy(
tensorflow::InputTFE_Context(ctx), policy);
});
m.def(""TFE_ContextSetServerDef"", [](py::handle& ctx, int keep_alive_secs,
py::bytes proto) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
tensorflow::Safe_TF_BufferPtr buf =
tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));
TFE_ContextSetServerDef(tensorflow::InputTFE_Context(ctx), keep_alive_secs,
buf.get()->data, buf.get()->length, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextUpdateServerDef"", [](py::handle& ctx, int keep_alive_secs,
py::bytes proto) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
tensorflow::Safe_TF_BufferPtr buf =
tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));
Py_BEGIN_ALLOW_THREADS;
TFE_ContextUpdateServerDef(tensorflow::InputTFE_Context(ctx),
keep_alive_secs, buf.get()->data,
buf.get()->length, status.get());
Py_END_ALLOW_THREADS;
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextCheckAlive"", [](py::handle& ctx, const char* worker_name) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
bool output = TFE_ContextCheckAlive(tensorflow::InputTFE_Context(ctx),
worker_name, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
});
m.def(""TFE_ContextSyncExecutors"", [](py::handle& ctx) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextAsyncWait(tensorflow::InputTFE_Context(ctx), status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextClearExecutors"", [](py::handle& ctx) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextAsyncWait(tensorflow::InputTFE_Context(ctx), status.get());


});
m.def(""TFE_ContextSetSoftDevicePlacement"", [](py::handle& ctx, bool enable) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextSetSoftDevicePlacement(tensorflow::InputTFE_Context(ctx), enable,
status.get());
});
m.def(""TFE_ContextSetLogDevicePlacement"", [](py::handle& ctx, bool enable) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_ContextSetSoftDevicePlacement(tensorflow::InputTFE_Context(ctx), enable,
status.get());
});


m.def(
""TFE_NewExecutor"",
[](const bool is_async) {
TFE_Executor* exc = TFE_NewExecutor(is_async);
return exc;
},
py::return_value_policy::reference);
m.def(""TFE_DeleteExecutor"", &TFE_DeleteExecutor);
m.def(""TFE_ExecutorIsAsync"", &TFE_ExecutorIsAsync);
m.def(""TFE_ExecutorWaitForAllPendingNodes"", [](TFE_Executor& exc) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());

Py_BEGIN_ALLOW_THREADS;
TFE_ExecutorWaitForAllPendingNodes(&exc, status.get());
Py_END_ALLOW_THREADS;
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ExecutorClearError"", &TFE_ExecutorClearError);
m.def(""TFE_ContextSetExecutorForThread"", [](py::handle& ctx,
TFE_Executor& exc) {
TFE_ContextSetExecutorForThread(tensorflow::InputTFE_Context(ctx), &exc);
});
m.def(
""TFE_ContextGetExecutorForThread"",
[](py::handle& o) {
return TFE_ContextGetExecutorForThread(tensorflow::InputTFE_Context(o));
},
py::return_value_policy::reference);

m.def(""TFE_OpNameGetAttrType"",
[](py::handle& ctx, const char* op_or_function_name,
const char* attr_name) {
int temp = 0;
unsigned char* is_list = reinterpret_cast<unsigned char*>(&temp);
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_OpNameGetAttrType(tensorflow::InputTFE_Context(ctx),
op_or_function_name, attr_name,
is_list, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
#if PY_MAJOR_VERSION < 3
PyObject* output_pyo = PyInt_FromLong(output);
#else
PyObject* output_pyo = PyLong_FromLong(output);
#endif
if (*is_list == 1) {
PyObject* list = PyList_New(1);
PyList_SetItem(list, 0, output_pyo);
return tensorflow::PyoOrThrow(list);
}
return tensorflow::PyoOrThrow(output_pyo);
});
m.def(""TFE_Py_InitEagerTensor"", [](const py::handle& o) {
return tensorflow::PyoOrThrow(TFE_Py_InitEagerTensor(o.ptr()));
});
m.def(""TFE_Py_PackEagerTensors"",
[](const py::handle& context, const py::handle& handles) {
return tensorflow::TFE_Py_PackEagerTensors_wrapper(context, handles);
});
m.def(""TFE_Py_SetEagerTensorProfiler"", &TFE_Py_SetEagerTensorProfiler);
m.def(""TFE_Py_RegisterJVPFunction"", [](const py::handle& o) {
return tensorflow::PyoOrThrow(TFE_Py_RegisterJVPFunction(o.ptr()));
});
m.def(""TFE_Py_RegisterGradientFunction"", [](const py::handle& o) {
return tensorflow::PyoOrThrow(TFE_Py_RegisterGradientFunction(o.ptr()));
});
m.def(""TFE_Py_Execute"",
[](const py::handle& context, const char* device_name,
const char* op_name, const py::handle& inputs,
const py::handle& attrs, const py::handle& num_outputs) {
return tensorflow::TFE_Py_ExecuteCancelable_wrapper(
context, device_name, op_name, inputs, attrs.ptr(), nullptr,
num_outputs);
});
m.def(
""TFE_Py_ExecuteCancelable"",
[](const py::handle& context, const char* device_name,
const char* op_name, const py::handle& inputs, const py::handle& attrs,
TFE_CancellationManager& cancellation_manager,
const py::handle& num_outputs) {
return tensorflow::TFE_Py_ExecuteCancelable_wrapper(
context, device_name, op_name, inputs, attrs.ptr(),
&cancellation_manager, num_outputs);
});
m.def(""TFE_Py_FastPathExecute"", [](const py::args args) {

return tensorflow::PyoOrThrow(TFE_Py_FastPathExecute_C(args.ptr()));
});
m.def(""TFE_Py_RecordGradient"",
[](const py::handle& op_name, const py::handle& inputs,
const py::handle& attrs, const py::handle& results,
const py::handle& forward_pass_name_scope) {
return tensorflow::PyoOrThrow(TFE_Py_RecordGradient(
op_name.ptr(), inputs.ptr(), attrs.ptr(), results.ptr(),
forward_pass_name_scope.ptr()));
});
m.def(""TFE_Py_UID"", []() { return tensorflow::PyoOrThrow(TFE_Py_UID()); });


m.def(""TFE_Py_TapeSetNew"", [](const py::handle& persistent,
const py::handle& watch_accessed_variables) {
return tensorflow::PyoOrThrow(
TFE_Py_TapeSetNew(persistent.ptr(), watch_accessed_variables.ptr()));
});
m.def(""TFE_Py_TapeSetAdd"",
[](const py::handle& tape) { TFE_Py_TapeSetAdd(tape.ptr()); });
m.def(""TFE_Py_TapeSetRemove"",
[](const py::handle& tape) { TFE_Py_TapeSetRemove(tape.ptr()); });
m.def(""TFE_Py_TapeSetStopOnThread"", &TFE_Py_TapeSetStopOnThread);
m.def(""TFE_Py_TapeSetRestartOnThread"", &TFE_Py_TapeSetRestartOnThread);
m.def(""TFE_Py_TapeSetIsStopped"",
[]() { return tensorflow::PyoOrThrow(TFE_Py_TapeSetIsStopped()); });
m.def(""TFE_Py_TapeSetIsEmpty"",
[]() { return tensorflow::PyoOrThrow(TFE_Py_TapeSetIsEmpty()); });
m.def(""TFE_Py_TapeSetShouldRecordBackprop"", [](const py::handle& tensors) {
return tensorflow::PyoOrThrow(
TFE_Py_TapeSetShouldRecordBackprop(tensors.ptr()));
});
m.def(""TFE_Py_TapeSetPossibleGradientTypes"", [](const py::handle& tensors) {
return tensorflow::PyoOrThrow(
TFE_Py_TapeSetPossibleGradientTypes(tensors.ptr()));
});
m.def(""TFE_Py_TapeSetDeleteTrace"", &TFE_Py_TapeSetDeleteTrace);
m.def(""TFE_Py_TapeSetRecordOperation"",
[](const py::handle& op_type, const py::handle& output_tensors,
const py::handle& input_tensors, const py::handle& backward_function,
const py::handle& forward_function) {
return tensorflow::PyoOrThrow(TFE_Py_TapeSetRecordOperation(
op_type.ptr(), output_tensors.ptr(), input_tensors.ptr(),
backward_function.ptr(), forward_function.ptr()));
});
m.def(
""TFE_Py_TapeSetRecordOperationBackprop"",
[](const py::handle& op_type, const py::handle& output_tensors,
const py::handle& input_tensors, const py::handle& backward_function) {
return tensorflow::PyoOrThrow(TFE_Py_TapeSetRecordOperationBackprop(
op_type.ptr(), output_tensors.ptr(), input_tensors.ptr(),
backward_function.ptr()));
});
m.def(
""TFE_Py_TapeSetRecordOperationForwardprop"",
[](const py::handle& op_type, const py::handle& output_tensors,
const py::handle& input_tensors, const py::handle& backward_function,
const py::handle& forwardprop_output_indices) {
return tensorflow::PyoOrThrow(TFE_Py_TapeSetRecordOperationForwardprop(
op_type.ptr(), output_tensors.ptr(), input_tensors.ptr(),
backward_function.ptr(), forwardprop_output_indices.ptr()));
});
m.def(""TFE_Py_TapeGradient"",
[](const py::handle& tape, const py::handle& target,
const py::handle& sources, const py::handle& output_gradients,
const py::handle& sources_raw,
const py::handle& unconnected_gradients) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
PyObject* output = TFE_Py_TapeGradient(
tape.ptr(), target.ptr(), sources.ptr(), output_gradients.ptr(),
sources_raw.ptr(), unconnected_gradients.ptr(), status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return tensorflow::PyoOrThrow(output);
});

m.def(""TFE_Py_TapeVariableAccessed"", [](const py::handle& variable) {
TFE_Py_TapeVariableAccessed(variable.ptr());
});
m.def(""TFE_Py_TapeWatch"",
[](const py::handle& tape, const py::handle& tensor) {
TFE_Py_TapeWatch(tape.ptr(), tensor.ptr());
});
m.def(""TFE_Py_TapeWatchVariable"",
[](const py::handle& tape, const py::handle& variable) {
TFE_Py_TapeWatchVariable(tape.ptr(), variable.ptr());
});
m.def(""TFE_Py_TapeWatchedVariables"", [](const py::handle& tape) {
return tensorflow::PyoOrThrow(TFE_Py_TapeWatchedVariables(tape.ptr()));
});


m.def(""TFE_Py_VariableWatcherNew"",
[]() { return tensorflow::PyoOrThrow(TFE_Py_VariableWatcherNew()); });
m.def(""TFE_Py_VariableWatcherRemove"", [](const py::handle& variable_watcher) {
TFE_Py_VariableWatcherRemove(variable_watcher.ptr());
});
m.def(""TFE_Py_VariableWatcherVariableAccessed"",
[](const py::handle& variable) {
TFE_Py_VariableWatcherVariableAccessed(variable.ptr());
});
m.def(""TFE_Py_VariableWatcherWatchedVariables"",
[](const py::handle& variable_watcher) {
return tensorflow::PyoOrThrow(
TFE_Py_VariableWatcherWatchedVariables(variable_watcher.ptr()));
});


m.def(""TFE_Py_ForwardAccumulatorNew"", [](bool use_batch) {
return tensorflow::PyoOrThrow(TFE_Py_ForwardAccumulatorNew(use_batch));
});

m.def(""TFE_Py_ForwardAccumulatorSetAdd"", [](const py::handle& accumulator) {
return tensorflow::PyoOrThrow(
TFE_Py_ForwardAccumulatorSetAdd(accumulator.ptr()));
});
m.def(""TFE_Py_ForwardAccumulatorSetRemove"",
[](const py::handle& accumulator) {
TFE_Py_ForwardAccumulatorSetRemove(accumulator.ptr());
});

m.def(""TFE_Py_ForwardAccumulatorWatch"",
[](const py::handle& accumulator, const py::handle& tensor,
const py::handle& tangent) {
TFE_Py_ForwardAccumulatorWatch(accumulator.ptr(), tensor.ptr(),
tangent.ptr());
});
m.def(""TFE_Py_ForwardAccumulatorJVP"",
[](const py::handle& accumulator, const py::handle& tensor) {
return tensorflow::PyoOrThrow(
TFE_Py_ForwardAccumulatorJVP(accumulator.ptr(), tensor.ptr()));
});
m.def(""TFE_Py_ForwardAccumulatorPushState"", []() {
return tensorflow::PyoOrThrow(TFE_Py_ForwardAccumulatorPushState());
});
m.def(""TFE_Py_ForwardAccumulatorPopState"", []() {
return tensorflow::PyoOrThrow(TFE_Py_ForwardAccumulatorPopState());
});
m.def(""TFE_Py_PackJVPs"", [](const py::handle& tensors) {
return tensorflow::PyoOrThrow(TFE_Py_PackJVPs(tensors.ptr()));
});


m.def(""TFE_NewContextOptions"", &TFE_NewContextOptions,
py::return_value_policy::reference);
m.def(""TFE_ContextOptionsSetConfig"", [](TFE_ContextOptions* options,
py::bytes proto) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
tensorflow::Safe_TF_BufferPtr buf =
tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));
TFE_ContextOptionsSetConfig(options, buf.get()->data, buf.get()->length,
status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_ContextOptionsSetDevicePlacementPolicy"",
&TFE_ContextOptionsSetDevicePlacementPolicy);
m.def(""TFE_ContextOptionsSetLazyRemoteInputsCopy"",
&TFE_ContextOptionsSetLazyRemoteInputsCopy);
m.def(""TFE_ContextOptionsSetTfrt"", &TFE_ContextOptionsSetTfrt);
m.def(""TFE_ContextOptionsSetAsync"", &TFE_ContextOptionsSetAsync);
m.def(""TFE_DeleteContextOptions"", &TFE_DeleteContextOptions,
py::return_value_policy::reference);


m.def(""TFE_Py_TensorShapeSlice"",
[](const py::handle& tensors, int slice_dim) {
return tensorflow::PyoOrThrow(
TFE_Py_TensorShapeSlice(tensors.ptr(), slice_dim));
});
m.def(""TFE_Py_TensorShapeOnDevice"", [](const py::handle& tensors,
int slice_dim) {
return tensorflow::PyoOrThrow(TFE_Py_TensorShapeOnDevice(tensors.ptr()));
});
m.def(""TFE_Py_EnableInteractivePythonLogging"",
&TFE_Py_EnableInteractivePythonLogging);


m.def(""TFE_Py_SetEagerContext"", [](const py::handle& o) {
return tensorflow::PyoOrThrow(TFE_Py_SetEagerContext(o.ptr()));
});
m.def(""TFE_ContextStartStep"", [](py::handle& o) {
TFE_ContextStartStep(tensorflow::InputTFE_Context(o.ptr()));
});
m.def(""TFE_ContextEndStep"", [](py::handle& o) {
TFE_ContextEndStep(tensorflow::InputTFE_Context(o.ptr()));
});
m.def(""TFE_Py_RegisterVSpace"", [](const py::handle& o) {
return tensorflow::PyoOrThrow(TFE_Py_RegisterVSpace(o.ptr()));
});
m.def(""TFE_Py_EncodeArg"",
[](const py::handle& o, bool include_tensor_ranks_only) {
return tensorflow::PyoOrThrow(
TFE_Py_EncodeArg(o.ptr(), include_tensor_ranks_only));
});
m.def(""TFE_EnableCollectiveOps"", [](const py::handle& ctx, py::bytes proto) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
tensorflow::Safe_TF_BufferPtr buf =
tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));
TFE_EnableCollectiveOps(tensorflow::InputTFE_Context(ctx), buf.get()->data,
buf.get()->length, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TFE_AbortCollectiveOps"", [](const py::handle& ctx, int code,
const char* message) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TF_SetStatus(status.get(), static_cast<TF_Code>(code), message);
TFE_AbortCollectiveOps(tensorflow::InputTFE_Context(ctx), status.get());
});
m.def(""TFE_CollectiveOpsCheckPeerHealth"",
[](const py::handle& ctx, const char* task) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
TFE_CollectiveOpsCheckPeerHealth(tensorflow::InputTFE_Context(ctx),
task, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});
m.def(""TF_ListPhysicalDevices"", &tensorflow::TF_ListPhysicalDevices);
m.def(""TF_GetDeviceDetails"", &tensorflow::TF_GetDeviceDetails);
m.def(""TF_DeleteDeviceList"", &TF_DeleteDeviceList,
py::return_value_policy::reference);
m.def(""TF_DeviceListCount"", &TF_DeviceListCount);
m.def(""TF_DeviceListName"", [](const TF_DeviceList* list, int index) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TF_DeviceListName(list, index, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
});
m.def(""TF_DeviceListType"", [](const TF_DeviceList* list, int index) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TF_DeviceListType(list, index, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
});

m.def(""TF_PickUnusedPortOrDie"", &TF_PickUnusedPortOrDie);


m.def(""TFE_MonitoringCounterCellIncrementBy"",
&TFE_MonitoringCounterCellIncrementBy);
m.def(""TFE_MonitoringCounterCellValue"", &TFE_MonitoringCounterCellValue);
m.def(
""TFE_MonitoringNewCounter0"",
[](const char* name, const char* description) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_MonitoringNewCounter0(name, status.get(), description);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteCounter0"", &TFE_MonitoringDeleteCounter0,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellCounter0"", &TFE_MonitoringGetCellCounter0,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewCounter1"",
[](const char* name, const char* description, const char* label1) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_MonitoringNewCounter1(name, status.get(), description, label1);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteCounter1"", &TFE_MonitoringDeleteCounter1,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellCounter1"", &TFE_MonitoringGetCellCounter1,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewCounter2"",
[](const char* name, const char* description, const char* label1,
const char* label2) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewCounter2(name, status.get(), description,
label1, label2);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteCounter2"", &TFE_MonitoringDeleteCounter2,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellCounter2"", &TFE_MonitoringGetCellCounter2,
py::return_value_policy::reference);


m.def(""TFE_MonitoringIntGaugeCellSet"", &TFE_MonitoringIntGaugeCellSet);
m.def(""TFE_MonitoringIntGaugeCellValue"", &TFE_MonitoringIntGaugeCellValue);
m.def(
""TFE_MonitoringNewIntGauge0"",
[](const char* name, const char* description) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_MonitoringNewIntGauge0(name, status.get(), description);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteIntGauge0"", &TFE_MonitoringDeleteIntGauge0,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellIntGauge0"", &TFE_MonitoringGetCellIntGauge0,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewIntGauge1"",
[](const char* name, const char* description, const char* label1) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_MonitoringNewIntGauge1(name, status.get(), description, label1);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteIntGauge1"", &TFE_MonitoringDeleteIntGauge1,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellIntGauge1"", &TFE_MonitoringGetCellIntGauge1,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewIntGauge2"",
[](const char* name, const char* description, const char* label1,
const char* label2) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewIntGauge2(name, status.get(),
description, label1, label2);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteIntGauge2"", &TFE_MonitoringDeleteIntGauge2,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellIntGauge2"", &TFE_MonitoringGetCellIntGauge2,
py::return_value_policy::reference);
m.def(""TFE_MonitoringStringGaugeCellSet"", &TFE_MonitoringStringGaugeCellSet);
m.def(""TFE_MonitoringStringGaugeCellValue"",
&TFE_MonitoringStringGaugeCellValue);
m.def(
""TFE_MonitoringNewStringGauge0"",
[](const char* name, const char* description) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_MonitoringNewStringGauge0(name, status.get(), description);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);


m.def(""TFE_MonitoringDeleteStringGauge0"", &TFE_MonitoringDeleteStringGauge0);
m.def(""TFE_MonitoringGetCellStringGauge0"", &TFE_MonitoringGetCellStringGauge0,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewStringGauge1"",
[](const char* name, const char* description, const char* label1) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewStringGauge1(name, status.get(),
description, label1);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteStringGauge1"", &TFE_MonitoringDeleteStringGauge1);
m.def(""TFE_MonitoringGetCellStringGauge1"", &TFE_MonitoringGetCellStringGauge1,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewStringGauge2"",
[](const char* name, const char* description, const char* label1,
const char* label2) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewStringGauge2(
name, status.get(), description, label1, label2);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteStringGauge2"", &TFE_MonitoringDeleteStringGauge2);
m.def(""TFE_MonitoringGetCellStringGauge2"", &TFE_MonitoringGetCellStringGauge2,
py::return_value_policy::reference);


m.def(""TFE_MonitoringBoolGaugeCellSet"", &TFE_MonitoringBoolGaugeCellSet);
m.def(""TFE_MonitoringBoolGaugeCellValue"", &TFE_MonitoringBoolGaugeCellValue);
m.def(
""TFE_MonitoringNewBoolGauge0"",
[](const char* name, const char* description) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_MonitoringNewBoolGauge0(name, status.get(), description);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteBoolGauge0"", &TFE_MonitoringDeleteBoolGauge0,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellBoolGauge0"", &TFE_MonitoringGetCellBoolGauge0,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewBoolGauge1"",
[](const char* name, const char* description, const char* label1) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewBoolGauge1(name, status.get(),
description, label1);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteBoolGauge1"", &TFE_MonitoringDeleteBoolGauge1,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellBoolGauge1"", &TFE_MonitoringGetCellBoolGauge1,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewBoolGauge2"",
[](const char* name, const char* description, const char* label1,
const char* label2) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewBoolGauge2(name, status.get(),
description, label1, label2);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteBoolGauge2"", &TFE_MonitoringDeleteBoolGauge2,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellBoolGauge2"", &TFE_MonitoringGetCellBoolGauge2,
py::return_value_policy::reference);


m.def(""TFE_MonitoringSamplerCellAdd"", &TFE_MonitoringSamplerCellAdd);
m.def(""TFE_MonitoringSamplerCellValue"", &TFE_MonitoringSamplerCellValue);
m.def(""TFE_MonitoringNewExponentialBuckets"",
&TFE_MonitoringNewExponentialBuckets,
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteBuckets"", &TFE_MonitoringDeleteBuckets,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewSampler0"",
[](const char* name, TFE_MonitoringBuckets* buckets,
const char* description) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output =
TFE_MonitoringNewSampler0(name, buckets, status.get(), description);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteSampler0"", &TFE_MonitoringDeleteSampler0,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellSampler0"", &TFE_MonitoringGetCellSampler0,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewSampler1"",
[](const char* name, TFE_MonitoringBuckets* buckets,
const char* description, const char* label1) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewSampler1(name, buckets, status.get(),
description, label1);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteSampler1"", &TFE_MonitoringDeleteSampler1,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellSampler1"", &TFE_MonitoringGetCellSampler1,
py::return_value_policy::reference);
m.def(
""TFE_MonitoringNewSampler2"",
[](const char* name, TFE_MonitoringBuckets* buckets,
const char* description, const char* label1, const char* label2) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
auto output = TFE_MonitoringNewSampler2(name, buckets, status.get(),
description, label1, label2);
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
return output;
},
py::return_value_policy::reference);
m.def(""TFE_MonitoringDeleteSampler2"", &TFE_MonitoringDeleteSampler2,
py::return_value_policy::reference);
m.def(""TFE_MonitoringGetCellSampler2"", &TFE_MonitoringGetCellSampler2,
py::return_value_policy::reference);


m.def(""TFE_NewCancellationManager"", &TFE_NewCancellationManager,
py::return_value_policy::reference);
m.def(""TFE_CancellationManagerIsCancelled"",
&TFE_CancellationManagerIsCancelled);
m.def(""TFE_CancellationManagerStartCancel"",
&TFE_CancellationManagerStartCancel);
m.def(""TFE_DeleteCancellationManager"", &TFE_DeleteCancellationManager,
py::return_value_policy::reference);

m.def(""TFE_ClearScalarCache"", &tensorflow::TFE_ClearScalarCache);


m.def(""TF_NewBufferFromString"", &TF_NewBufferFromString,
py::return_value_policy::reference);


m.def(""TFE_ToDlpackCapsule"", [](py::handle& o) {
PyObject* eager_tensor_pyobject_ptr = o.ptr();
TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
void* dlm_ptr = tensorflow::TFE_HandleToDLPack(thandle, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());

py::capsule capsule(
dlm_ptr, tensorflow::kDlTensorCapsuleName, [](PyObject* capsule) {
if (PyCapsule_IsValid(capsule, tensorflow::kDlTensorCapsuleName)) {
void* dlm_rptr =
PyCapsule_GetPointer(capsule, tensorflow::kDlTensorCapsuleName);
if (dlm_rptr) {
tensorflow::TFE_CallDLManagedTensorDeleter(dlm_rptr);
PyCapsule_SetDestructor(capsule, nullptr);
}
}
});
return capsule;
});

m.def(""TFE_FromDlpackCapsule"", [](const py::capsule& pycapsule,
const py::handle& context) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
if (absl::string_view(pycapsule.name()) !=
tensorflow::kDlTensorCapsuleName) {
status->status = tensorflow::errors::InvalidArgument(
""DLPack tensor must be a capsule with name \""dltensor\"", got \""%s\"". ""
""Note that a DLPack tensor may be consumed at most once."",
absl::string_view(pycapsule.name()));
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
}

TFE_TensorHandle* thandle = tensorflow::TFE_HandleFromDLPack(
pycapsule, status.get(), tensorflow::InputTFE_Context(context));

tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());

PyCapsule_SetName(pycapsule.ptr(), ""used_dltensor"");
PyCapsule_SetDestructor(pycapsule.ptr(), nullptr);

PyObject* pyhandle = EagerTensorFromHandle(thandle);
return tensorflow::PyoOrThrow(pyhandle);
});

m.def(""TFE_Py_RegisterCustomDevice"", [](const py::handle& context,
const py::capsule& device,
const char* device_name,
const py::capsule& device_info) {
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
if (absl::string_view(device.name()) != ""TFE_CustomDevice"") {
status->status = tensorflow::errors::InvalidArgument(
""Expected a capsule named 'TFE_CustomDevice' for the `device` ""
""argument, got "",
absl::string_view(device.name()));
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
}
if (absl::string_view(device_info.name()) !=
""TFE_CustomDevice_DeviceInfo"") {
status->status = tensorflow::errors::InvalidArgument(
""Expected a capsule named 'TFE_CustomDevice_DeviceInfo' for ""
""the `device_info` argument, got "",
absl::string_view(device_info.name()));
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
}

PyCapsule_SetDestructor(device_info.ptr(), nullptr);
TFE_RegisterCustomDevice(
tensorflow::InputTFE_Context(context),
*reinterpret_cast<TFE_CustomDevice*>(
PyCapsule_GetPointer(device.ptr(), ""TFE_CustomDevice"")),
device_name,
PyCapsule_GetPointer(device_info.ptr(), ""TFE_CustomDevice_DeviceInfo""),
status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());
});

py::class_<EagerContextThreadLocalDataWrapper>(m,
""EagerContextThreadLocalData"")
.def(py::init<py::handle, py::handle, py::handle>(),
py::arg(""py_eager_context""), py::arg(""is_eager""),
py::arg(""device_spec""))
.def_property(""is_eager"",
&EagerContextThreadLocalDataWrapper::get_is_eager,
&EagerContextThreadLocalDataWrapper::set_is_eager)
.def_property(
""invoking_op_callbacks"",
&EagerContextThreadLocalDataWrapper::get_invoking_op_callbacks,
&EagerContextThreadLocalDataWrapper::set_invoking_op_callbacks)
.def_property(""device_name"",
&EagerContextThreadLocalDataWrapper::get_device_name,
&EagerContextThreadLocalDataWrapper::set_device_name)
.def_property(""scope_name"",
&EagerContextThreadLocalDataWrapper::get_scope_name,
&EagerContextThreadLocalDataWrapper::set_scope_name)
.def_property(""device_spec"",
&EagerContextThreadLocalDataWrapper::get_device_spec,
&EagerContextThreadLocalDataWrapper::set_device_spec)
.def_property(
""function_call_options"",
&EagerContextThreadLocalDataWrapper::get_function_call_options,
&EagerContextThreadLocalDataWrapper::set_function_call_options)
.def_property(""executor"",
&EagerContextThreadLocalDataWrapper::get_executor,
&EagerContextThreadLocalDataWrapper::set_executor)
.def_property(""op_callbacks"",
&EagerContextThreadLocalDataWrapper::get_op_callbacks,
&EagerContextThreadLocalDataWrapper::set_op_callbacks);



py::enum_<TFE_ContextDevicePlacementPolicy>(
m, ""TFE_ContextDevicePlacementPolicy"")
.value(""TFE_DEVICE_PLACEMENT_EXPLICIT"", TFE_DEVICE_PLACEMENT_EXPLICIT)
.value(""TFE_DEVICE_PLACEMENT_WARN"", TFE_DEVICE_PLACEMENT_WARN)
.value(""TFE_DEVICE_PLACEMENT_SILENT"", TFE_DEVICE_PLACEMENT_SILENT)
.value(""TFE_DEVICE_PLACEMENT_SILENT_FOR_INT32"",
TFE_DEVICE_PLACEMENT_SILENT_FOR_INT32)
.export_values();

py::enum_<TF_AttrType>(m, ""TF_AttrType"")
.value(""TF_ATTR_STRING"", TF_ATTR_STRING)
.value(""TF_ATTR_INT"", TF_ATTR_INT)
.value(""TF_ATTR_FLOAT"", TF_ATTR_FLOAT)
.value(""TF_ATTR_BOOL"", TF_ATTR_BOOL)
.value(""TF_ATTR_TYPE"", TF_ATTR_TYPE)
.value(""TF_ATTR_SHAPE"", TF_ATTR_SHAPE)
.value(""TF_ATTR_TENSOR"", TF_ATTR_TENSOR)
.value(""TF_ATTR_PLACEHOLDER"", TF_ATTR_PLACEHOLDER)
.value(""TF_ATTR_FUNC"", TF_ATTR_FUNC)
.export_values();
};","[904, 907]","In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1."
198437," gsicc_open_search(const char* pname, int namelen, gs_memory_t *mem_gc,
                   const char* dirname, int dirlen, stream**strp)
 {
     char *buffer;
     stream* str;
 
      
     if ( dirname != NULL) {
          
         buffer = (char *) gs_alloc_bytes(mem_gc, namelen + dirlen + 1,
                                      ""gsicc_open_search"");
         if (buffer == NULL)
             return_error(gs_error_VMerror);
         strcpy(buffer, dirname);
         strcat(buffer, pname);
          
         buffer[namelen + dirlen] = '\0';
         str = sfopen(buffer, ""r"", mem_gc);
         gs_free_object(mem_gc, buffer, ""gsicc_open_search"");
         if (str != NULL) {
             *strp = str;
 	    return 0;
         }
      }
  
       
    str = sfopen(pname, ""r"", mem_gc);
    if (str != NULL) {
        *strp = str;
        return 0;
     if (gs_check_file_permission(mem_gc, pname, namelen, ""r"") >= 0) {
         str = sfopen(pname, ""r"", mem_gc);
         if (str != NULL) {
             *strp = str;
             return 0;
         }
      }
  
         
                         strlen(DEFAULT_DIR_ICC),""gsicc_open_search"");
     if (buffer == NULL)
         return_error(gs_error_VMerror);
     strcpy(buffer, DEFAULT_DIR_ICC);
     strcat(buffer, pname);
      
     buffer[namelen + strlen(DEFAULT_DIR_ICC)] = '\0';
     str = sfopen(buffer, ""r"", mem_gc);
     gs_free_object(mem_gc, buffer, ""gsicc_open_search"");
     if (str == NULL) {
         gs_warn1(""Could not find %s "",pname);
     }
     *strp = str;
     return 0;
 }","[31, 32, 33, 34, 35, 36, 27, 28, 29, 30]",The PS Interpreter in Ghostscript 9.18 and 9.20 allows remote attackers to execute arbitrary code via crafted userparams.
206897,"  void ManifestChangeNotifier::DidChangeManifest() {
    
   if (!ManifestManager::CanFetchManifest(render_frame()))
     return;
 
    if (weak_factory_.HasWeakPtrs())
      return;
  
   if (!render_frame()->GetWebFrame()->IsLoading()) {
     render_frame()
         ->GetTaskRunner(blink::TaskType::kUnspecedLoading)
         ->PostTask(FROM_HERE,
                    base::BindOnce(&ManifestChangeNotifier::ReportManifestChange,
                                   weak_factory_.GetWeakPtr()));
     return;
   }
   ReportManifestChange();
 }","[2, 3, 4, 5]",Failure to disallow PWA installation from CSP sandboxed pages in AppManifest in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to access privileged APIs via a crafted HTML page.
5865,"fribidi_get_par_embedding_levels_ex (

const FriBidiCharType *bidi_types,
const FriBidiBracketType *bracket_types,
const FriBidiStrIndex len,

FriBidiParType *pbase_dir,

FriBidiLevel *embedding_levels
)
{
FriBidiLevel base_level_per_iso_level[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];
FriBidiLevel base_level, max_level = 0;
FriBidiParType base_dir;
FriBidiRun *main_run_list = NULL, *explicits_list = NULL, *pp;
fribidi_boolean status = false;
int max_iso_level = 0;

if UNLIKELY
(!len)
{
status = true;
goto out;
}

DBG (""in fribidi_get_par_embedding_levels"");

fribidi_assert (bidi_types);
fribidi_assert (pbase_dir);
fribidi_assert (embedding_levels);


{

main_run_list = run_list_encode_bidi_types (bidi_types, bracket_types, len);
if UNLIKELY
(!main_run_list) goto out;
}




base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);
if (!FRIBIDI_IS_STRONG (*pbase_dir))


{
int valid_isolate_count = 0;
for_run_list (pp, main_run_list)
{
if (RL_TYPE(pp) == FRIBIDI_TYPE_PDI)
{

if (valid_isolate_count>0)
valid_isolate_count--;
}
else if (FRIBIDI_IS_ISOLATE(RL_TYPE(pp)))
valid_isolate_count++;
else if (valid_isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (pp)))
{
base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));
*pbase_dir = FRIBIDI_LEVEL_TO_DIR (base_level);
break;
}
}
}
base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);
DBG2 (""  base level : %c"", fribidi_char_from_level (base_level));
DBG2 (""  base dir   : %s"", fribidi_get_bidi_type_name (base_dir));

base_level_per_iso_level[0] = base_level;

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_types_re (main_run_list);
}
# endif	/* DEBUG */


DBG (""explicit levels and directions"");
{
FriBidiLevel level, new_level = 0;
int isolate_level = 0;
FriBidiCharType override, new_override;
FriBidiStrIndex i;
int stack_size, over_pushed, first_interval;
int valid_isolate_count = 0;
int isolate_overflow = 0;
int isolate = 0;
struct
{
FriBidiCharType override;
FriBidiLevel level;
int isolate;
int isolate_level;
} status_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];
FriBidiRun temp_link;
FriBidiRun *run_per_isolate_level[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];

memset(run_per_isolate_level, 0, sizeof(run_per_isolate_level[0])
* FRIBIDI_BIDI_MAX_RESOLVED_LEVELS);





explicits_list = new_run_list ();
if UNLIKELY
(!explicits_list) goto out;








level = base_level;
override = FRIBIDI_TYPE_ON;

stack_size = 0;
over_pushed = 0;
first_interval = 0;
valid_isolate_count = 0;
isolate_overflow = 0;

for_run_list (pp, main_run_list)
{
FriBidiCharType this_type = RL_TYPE (pp);
RL_ISOLATE_LEVEL (pp) = isolate_level;

if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))
{
if (FRIBIDI_IS_STRONG (this_type))
{










new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);
for (i = RL_LEN (pp); i; i--)
{
new_level =
((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -
FRIBIDI_DIR_TO_LEVEL (this_type);
isolate = 0;
PUSH_STATUS;
}
}
else if (this_type == FRIBIDI_TYPE_PDF)
{



for (i = RL_LEN (pp); i; i--)
{
if (stack_size && status_stack[stack_size-1].isolate != 0)
break;
POP_STATUS;
}
}



RL_LEVEL (pp) = FRIBIDI_SENTINEL;
temp_link.next = pp->next;
move_node_before (pp, explicits_list);
pp = &temp_link;
}
else if (this_type == FRIBIDI_TYPE_PDI)

{
for (i = RL_LEN (pp); i; i--)
{
if (isolate_overflow > 0)
{
isolate_overflow--;
RL_LEVEL (pp) = level;
}

else if (valid_isolate_count > 0)
{



while (stack_size && !status_stack[stack_size-1].isolate)
POP_STATUS;
over_pushed = 0;
POP_STATUS;
isolate_level-- ;
valid_isolate_count--;
RL_LEVEL (pp) = level;
RL_ISOLATE_LEVEL (pp) = isolate_level;
}
else
{

RL_TYPE (pp) = FRIBIDI_TYPE_ON;
RL_LEVEL (pp) = level;
}
}
}
else if (FRIBIDI_IS_ISOLATE(this_type))
{

new_override = FRIBIDI_TYPE_ON;
isolate = 1;
if (this_type == FRIBIDI_TYPE_LRI)
new_level = level + 2 - (level%2);
else if (this_type == FRIBIDI_TYPE_RLI)
new_level = level + 1 + (level%2);
else if (this_type == FRIBIDI_TYPE_FSI)
{



FriBidiRun *fsi_pp;
int isolate_count = 0;
int fsi_base_level = 0;
for_run_list (fsi_pp, pp)
{
if (RL_TYPE(fsi_pp) == FRIBIDI_TYPE_PDI)
{
isolate_count--;
if (valid_isolate_count < 0)
break;
}
else if (FRIBIDI_IS_ISOLATE(RL_TYPE(fsi_pp)))
isolate_count++;
else if (isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (fsi_pp)))
{
fsi_base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (fsi_pp));
break;
}
}


if (FRIBIDI_LEVEL_IS_RTL (fsi_base_level))
new_level = level + 1 + (level%2);
else
new_level = level + 2 - (level%2);
}

RL_LEVEL (pp) = level;
RL_ISOLATE_LEVEL (pp) = isolate_level++;
base_level_per_iso_level[isolate_level] = new_level;

if (!FRIBIDI_IS_NEUTRAL (override))
RL_TYPE (pp) = override;

if (new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)
{
valid_isolate_count++;
PUSH_STATUS;
level = new_level;
}
else
isolate_overflow += 1;
}
else if (this_type == FRIBIDI_TYPE_BS)
{



break;
}
else
{






RL_LEVEL (pp) = level;
if (!FRIBIDI_IS_NEUTRAL (override))
RL_TYPE (pp) = override;
}
}


for_run_list (pp, main_run_list)
{
int isolate_level = RL_ISOLATE_LEVEL (pp);
if (run_per_isolate_level[isolate_level])
{
run_per_isolate_level[isolate_level]->next_isolate = pp;
pp->prev_isolate = run_per_isolate_level[isolate_level];
}
run_per_isolate_level[isolate_level] = pp;
}


level = base_level;
override = FRIBIDI_TYPE_ON;
stack_size = 0;
over_pushed = 0;
}










compact_list (main_run_list);

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_types_re (main_run_list);
print_bidi_string (bidi_types, len);
print_resolved_levels (main_run_list);
print_resolved_types (main_run_list);
}
# endif	/* DEBUG */


max_iso_level = 0;
DBG (""resolving weak types"");
{
int last_strong_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];
FriBidiCharType prev_type_orig;
fribidi_boolean w4;

last_strong_stack[0] = base_dir;

for_run_list (pp, main_run_list)
{
register FriBidiCharType prev_type, this_type, next_type;
FriBidiRun *ppp_prev, *ppp_next;
int iso_level;

ppp_prev = get_adjacent_run(pp, false, false);
ppp_next = get_adjacent_run(pp, true, false);

this_type = RL_TYPE (pp);
iso_level = RL_ISOLATE_LEVEL(pp);

if (iso_level > max_iso_level)
max_iso_level = iso_level;

if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))
prev_type = RL_TYPE(ppp_prev);
else
prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));

if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))
next_type = RL_TYPE(ppp_next);
else
next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));

if (FRIBIDI_IS_STRONG (prev_type))
last_strong_stack[iso_level] = prev_type;









if (this_type == FRIBIDI_TYPE_NSM)
{

if (FRIBIDI_IS_ISOLATE (RL_TYPE (pp->prev)))
RL_TYPE(pp) = FRIBIDI_TYPE_ON;

if (RL_LEVEL (ppp_prev) == RL_LEVEL (pp))
{
if (ppp_prev == pp->prev)
pp = merge_with_prev (pp);
}
else
RL_TYPE (pp) = prev_type;

if (prev_type == next_type && RL_LEVEL (pp) == RL_LEVEL (pp->next))
{
if (ppp_next == pp->next)
pp = merge_with_prev (pp->next);
}
continue;
}


if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_AL)
{
RL_TYPE (pp) = FRIBIDI_TYPE_AN;



if (next_type == FRIBIDI_TYPE_NSM)
RL_TYPE (ppp_next) = FRIBIDI_TYPE_AN;
}
}


last_strong_stack[0] = base_dir;




w4 = true;



prev_type_orig = FRIBIDI_TYPE_ON;


for_run_list (pp, main_run_list)
{
register FriBidiCharType prev_type, this_type, next_type;
int iso_level;
FriBidiRun *ppp_prev, *ppp_next;

this_type = RL_TYPE (pp);
iso_level = RL_ISOLATE_LEVEL(pp);

ppp_prev = get_adjacent_run(pp, false, false);
ppp_next = get_adjacent_run(pp, true, false);

if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))
prev_type = RL_TYPE(ppp_prev);
else
prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));

if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))
next_type = RL_TYPE(ppp_next);
else
next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));

if (FRIBIDI_IS_STRONG (prev_type))
last_strong_stack[iso_level] = prev_type;




if (this_type == FRIBIDI_TYPE_AL)
{
RL_TYPE (pp) = FRIBIDI_TYPE_RTL;
w4 = true;
prev_type_orig = FRIBIDI_TYPE_ON;
continue;
}




if (w4
&& RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)
&& FRIBIDI_IS_NUMBER (prev_type_orig)
&& prev_type_orig == next_type
&& (prev_type_orig == FRIBIDI_TYPE_EN
|| this_type == FRIBIDI_TYPE_CS))
{
RL_TYPE (pp) = prev_type;
this_type = RL_TYPE (pp);
}
w4 = true;



if (this_type == FRIBIDI_TYPE_ET
&& (prev_type_orig == FRIBIDI_TYPE_EN
|| next_type == FRIBIDI_TYPE_EN))
{
RL_TYPE (pp) = FRIBIDI_TYPE_EN;
w4 = false;
this_type = RL_TYPE (pp);
}


if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))
RL_TYPE (pp) = FRIBIDI_TYPE_ON;


if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_LTR)
{
RL_TYPE (pp) = FRIBIDI_TYPE_LTR;
prev_type_orig = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?
FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);
}
else
prev_type_orig = PREV_TYPE_OR_SOR (pp->next);
}
}

compact_neutrals (main_run_list);

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_resolved_levels (main_run_list);
print_resolved_types (main_run_list);
}
# endif	/* DEBUG */



DBG (""resolving neutral types - N0"");
{

int num_iso_levels = max_iso_level + 1;
FriBidiPairingNode *pairing_nodes = NULL;
FriBidiRun *local_bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL][LOCAL_BRACKET_SIZE];
FriBidiRun **bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];
int bracket_stack_size[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];
int last_level = RL_LEVEL(main_run_list);
int last_iso_level = 0;

memset(bracket_stack, 0, sizeof(bracket_stack[0])*num_iso_levels);
memset(bracket_stack_size, 0, sizeof(bracket_stack_size[0])*num_iso_levels);




{
int iso_level;
for (iso_level=0; iso_level < LOCAL_BRACKET_SIZE; iso_level++)
bracket_stack[iso_level] = local_bracket_stack[iso_level];

for (iso_level=LOCAL_BRACKET_SIZE; iso_level < num_iso_levels; iso_level++)
bracket_stack[iso_level] = fribidi_malloc (sizeof (bracket_stack[0])
* FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS);
}


for_run_list (pp, main_run_list)
{
int level = RL_LEVEL(pp);
int iso_level = RL_ISOLATE_LEVEL(pp);
FriBidiBracketType brack_prop = RL_BRACKET_TYPE(pp);




if (level != last_level && last_iso_level == iso_level)
bracket_stack_size[last_iso_level] = 0;

if (brack_prop!= FRIBIDI_NO_BRACKET
&& RL_TYPE(pp)==FRIBIDI_TYPE_ON)
{
if (FRIBIDI_IS_BRACKET_OPEN(brack_prop))
{
if (bracket_stack_size[iso_level]==FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS)
break;


bracket_stack[iso_level][bracket_stack_size[iso_level]++] = pp;
}
else
{
int stack_idx = bracket_stack_size[iso_level] - 1;
while (stack_idx >= 0)
{
FriBidiBracketType se_brack_prop = RL_BRACKET_TYPE(bracket_stack[iso_level][stack_idx]);
if (FRIBIDI_BRACKET_ID(se_brack_prop) == FRIBIDI_BRACKET_ID(brack_prop))
{
bracket_stack_size[iso_level] = stack_idx;

pairing_nodes = pairing_nodes_push(pairing_nodes,
bracket_stack[iso_level][stack_idx],
pp);
break;
}
stack_idx--;
}
}
}
last_level = level;
last_iso_level = iso_level;
}


sort_pairing_nodes(&pairing_nodes);

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_pairing_nodes (pairing_nodes);
}
# endif	/* DEBUG */


{
FriBidiPairingNode *ppairs = pairing_nodes;
while (ppairs)
{
int iso_level = ppairs->open->isolate_level;
int embedding_level = base_level_per_iso_level[iso_level];


fribidi_boolean found = false;
FriBidiRun *ppn;
for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)
{
FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);



int this_level = RL_LEVEL (ppn) +
(FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));


if (FRIBIDI_IS_STRONG (this_type) && this_level == embedding_level)
{
RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = this_level%2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;
found = true;
break;
}
}



if (!found)
{

int prec_strong_level = embedding_level;
int iso_level = RL_ISOLATE_LEVEL(ppairs->open);
for (ppn = ppairs->open->prev; ppn->type != FRIBIDI_TYPE_SENTINEL; ppn=ppn->prev)
{
FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);
if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)
{
prec_strong_level = RL_LEVEL (ppn) +
(FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));

break;
}
}

for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)
{
FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);
if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)
{




RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = prec_strong_level % 2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;
RL_LEVEL(ppairs->open) = RL_LEVEL(ppairs->close) = prec_strong_level;
found = true;
break;
}
}
}

ppairs = ppairs->next;
}

free_pairing_nodes(pairing_nodes);

if (num_iso_levels >= LOCAL_BRACKET_SIZE)
{
int i;

for (i=LOCAL_BRACKET_SIZE; i<num_iso_levels; i++)
fribidi_free(bracket_stack[i]);
}


{
const FriBidiBracketType NoBracket = FRIBIDI_NO_BRACKET;
for_run_list (pp, main_run_list)
pp->bracket_type = NoBracket;
compact_neutrals (main_run_list);
}
}

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_resolved_levels (main_run_list);
print_resolved_types (main_run_list);
}
# endif	/* DEBUG */
}

DBG (""resolving neutral types - N1+N2"");
{
for_run_list (pp, main_run_list)
{
FriBidiCharType prev_type, this_type, next_type;
FriBidiRun *ppp_prev, *ppp_next;

ppp_prev = get_adjacent_run(pp, false, false);
ppp_next = get_adjacent_run(pp, true, false);



this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));

if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))
prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_prev));
else
prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));

if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))
next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_next));
else
next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));

if (FRIBIDI_IS_NEUTRAL (this_type))
RL_TYPE (pp) = (prev_type == next_type) ?
prev_type :
FRIBIDI_EMBEDDING_DIRECTION (pp);
}
}

compact_list (main_run_list);

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_resolved_levels (main_run_list);
print_resolved_types (main_run_list);
}
# endif	/* DEBUG */


DBG (""resolving implicit levels"");
{
max_level = base_level;

for_run_list (pp, main_run_list)
{
FriBidiCharType this_type;
int level;

this_type = RL_TYPE (pp);
level = RL_LEVEL (pp);



if (FRIBIDI_IS_NUMBER (this_type))
RL_LEVEL (pp) = (level + 2) & ~1;
else
RL_LEVEL (pp) =
level +
(FRIBIDI_LEVEL_IS_RTL (level) ^ FRIBIDI_DIR_TO_LEVEL (this_type));

if (RL_LEVEL (pp) > max_level)
max_level = RL_LEVEL (pp);
}
}

compact_list (main_run_list);

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_bidi_string (bidi_types, len);
print_resolved_levels (main_run_list);
print_resolved_types (main_run_list);
}
# endif	/* DEBUG */



DBG (""reinserting explicit codes"");
if UNLIKELY
(explicits_list->next != explicits_list)
{
register FriBidiRun *p;
register fribidi_boolean stat =
shadow_run_list (main_run_list, explicits_list, true);
explicits_list = NULL;
if UNLIKELY
(!stat) goto out;



p = main_run_list->next;
if (p != main_run_list && p->level == FRIBIDI_SENTINEL)
p->level = base_level;
for_run_list (p, main_run_list) if (p->level == FRIBIDI_SENTINEL)
p->level = p->prev->level;
}

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_types_re (main_run_list);
print_resolved_levels (main_run_list);
print_resolved_types (main_run_list);
}
# endif	/* DEBUG */

DBG (""reset the embedding levels, 1, 2, 3."");
{
register int j, state, pos;
register FriBidiCharType char_type;
register FriBidiRun *p, *q, *list;









list = new_run_list ();
if UNLIKELY
(!list) goto out;
q = list;
state = 1;
pos = len - 1;
for (j = len - 1; j >= -1; j--)
{

if (j >= 0)
char_type = bidi_types[j];
else
char_type = FRIBIDI_TYPE_ON;
if (!state && FRIBIDI_IS_SEPARATOR (char_type))
{
state = 1;
pos = j;
}
else if (state &&
!(FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(char_type)
|| FRIBIDI_IS_ISOLATE(char_type)))
{
state = 0;
p = new_run ();
if UNLIKELY
(!p)
{
free_run_list (list);
goto out;
}
p->pos = j + 1;
p->len = pos - j;
p->type = base_dir;
p->level = base_level;
move_node_before (p, q);
q = p;
}
}
if UNLIKELY
(!shadow_run_list (main_run_list, list, false)) goto out;
}

# if DEBUG
if UNLIKELY
(fribidi_debug_status ())
{
print_types_re (main_run_list);
print_resolved_levels (main_run_list);
print_resolved_types (main_run_list);
}
# endif	/* DEBUG */

{
FriBidiStrIndex pos = 0;
for_run_list (pp, main_run_list)
{
register FriBidiStrIndex l;
register FriBidiLevel level = pp->level;
for (l = pp->len; l; l--)
embedding_levels[pos++] = level;
}
}

status = true;

out:
DBG (""leaving fribidi_get_par_embedding_levels"");

if (main_run_list)
free_run_list (main_run_list);
if UNLIKELY
(explicits_list) free_run_list (explicits_list);

return status ? max_level + 1 : 0;
}",[253],"A buffer overflow in the fribidi_get_par_embedding_levels_ex() function in lib/fribidi-bidi.c of GNU FriBidi through 1.0.7 allows an attacker to cause a denial of service or possibly execute arbitrary code by delivering crafted text content to a user, when this content is then rendered by an application that uses FriBidi for text layout calculations. Examples include any GNOME or GTK+ based application that uses Pango for text layout, as this internally uses FriBidi for bidirectional text layout. For example, the attacker can construct a crafted text file to be opened in GEdit, or a crafted IRC message to be viewed in HexChat."
205669,"      PaintPropertyTreeBuilderFragmentContext()
    : current_effect(EffectPaintPropertyNode::Root()) {
     : current_effect(&EffectPaintPropertyNode::Root()) {
    current.clip = absolute_position.clip = fixed_position.clip =
      ClipPaintPropertyNode::Root();
       &ClipPaintPropertyNode::Root();
    current.transform = absolute_position.transform = fixed_position.transform =
      TransformPaintPropertyNode::Root();
       &TransformPaintPropertyNode::Root();
    current.scroll = absolute_position.scroll = fixed_position.scroll =
      ScrollPaintPropertyNode::Root();
       &ScrollPaintPropertyNode::Root();
  }","[3, 6, 9, 12, 2, 5, 8, 11]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
203772,"  NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame(
      BrowserFrame* browser_frame,
      BrowserView* browser_view) {
  if (views::Widget::IsPureViews())
   if (views::Widget::IsPureViews() &&
       views::ViewsDelegate::views_delegate->GetDefaultParentView())
      return new BrowserFrameViews(browser_frame, browser_view);
    return new BrowserFrameGtk(browser_frame, browser_view);
  }","[5, 6, 4]",Use-after-free vulnerability in Google Chrome before 14.0.835.163 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to plug-in handling.
206291," RenderFrameHostManager::RenderFrameHostManager(
     FrameTreeNode* frame_tree_node,
     RenderFrameHostDelegate* render_frame_delegate,
     RenderWidgetHostDelegate* render_widget_delegate,
     Delegate* delegate)
     : frame_tree_node_(frame_tree_node),
        delegate_(delegate),
        render_frame_delegate_(render_frame_delegate),
        render_widget_delegate_(render_widget_delegate),
      interstitial_page_(nullptr),
        weak_factory_(this) {
    DCHECK(frame_tree_node_);
  }",[10],Inappropriate implementation in interstitials in Google Chrome prior to 60.0.3112.78 for Mac allowed a remote attacker to spoof the contents of the omnibox via a crafted HTML page.
7621,"ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {
size_t total_buffer_size = CalculateTotalMessageSize(msg);

MessageWriter input;
input.Push(sockfd);
input.Push<uint64_t>(msg->msg_namelen);
input.Push<uint64_t>(total_buffer_size);
input.Push<uint64_t>(msg->msg_controllen);
input.Push(msg->msg_flags);
input.Push(flags);

MessageReader output;

const auto status = NonSystemCallDispatcher(
::asylo::host_call::kRecvMsgHandler, &input, &output);
CheckStatusAndParamCount(status, output, ""enc_untrusted_recvmsg"", 2,
false);

ssize_t result = output.next<ssize_t>();
int klinux_errno = output.next<int>();



if (result == -1) {
errno = FromkLinuxErrorNumber(klinux_errno);
return result;
}

auto msg_name_extent = output.next();

if (msg_name_extent.size() <= msg->msg_namelen) {
msg->msg_namelen = msg_name_extent.size();
}
memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);



auto msg_iov_extent = output.next();
size_t total_bytes = msg_iov_extent.size();
size_t bytes_copied = 0;
for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {
size_t bytes_to_copy =
std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);
memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,
bytes_to_copy);
bytes_copied += bytes_to_copy;
}

auto msg_control_extent = output.next();

if (msg_control_extent.size() <= msg->msg_controllen) {
msg->msg_controllen = msg_control_extent.size();
}
memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);

return result;
}",[29],An arbitrary memory read vulnerability in Asylo versions up to 0.6.0 allows an untrusted attacker to make a call to enc_untrusted_recvmsg using an attacker controlled result parameter. The parameter size is unchecked allowing the attacker to read memory locations outside of the intended buffer size including memory addresses within the secure enclave. We recommend upgrading or past commit fa6485c5d16a7355eab047d4a44345a73bc9131e
208447," long ContentEncoding::ParseEncryptionEntry(
    long long start,
    long long size,
    IMkvReader* pReader,
    ContentEncryption* encryption) {
 long ContentEncoding::ParseEncryptionEntry(long long start, long long size,
                                            IMkvReader* pReader,
                                            ContentEncryption* encryption) {
    assert(pReader);
    assert(encryption);
  
  long long pos = start;
  const long long stop = start + size;
 
  
    while (pos < stop) {
      long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
     const long status = ParseElementHeader(pReader, pos, stop, id, size);
     if (status < 0)   
        return status;
  
      if (id == 0x7E1) {
       encryption->algo = UnserializeUInt(pReader, pos, size);
  if (encryption->algo != 5)
 
          return E_FILE_FORMAT_INVALID;
      } else if (id == 0x7E2) {
      delete[] encryption->key_id;
       delete[] encryption -> key_id;
        encryption->key_id = NULL;
        encryption->key_id_len = 0;
  
  if (size <= 0)
  return E_FILE_FORMAT_INVALID;
 
  const size_t buflen = static_cast<size_t>(size);
  typedef unsigned char* buf_t;
  const buf_t buf = new (std::nothrow) unsigned char[buflen];
 
        if (buf == NULL)
          return -1;
  
      const int read_status = pReader->Read(pos, buflen, buf);
       const int read_status =
           pReader->Read(pos, static_cast<long>(buflen), buf);
        if (read_status) {
        delete [] buf;
         delete[] buf;
          return status;
        }
  
       encryption->key_id = buf;
 
        encryption->key_id_len = buflen;
      } else if (id == 0x7E3) {
      delete[] encryption->signature;
       delete[] encryption -> signature;
        encryption->signature = NULL;
        encryption->signature_len = 0;
  
  if (size <= 0)
  return E_FILE_FORMAT_INVALID;
 
  const size_t buflen = static_cast<size_t>(size);
  typedef unsigned char* buf_t;
  const buf_t buf = new (std::nothrow) unsigned char[buflen];
 
        if (buf == NULL)
          return -1;
  
      const int read_status = pReader->Read(pos, buflen, buf);
       const int read_status =
           pReader->Read(pos, static_cast<long>(buflen), buf);
        if (read_status) {
        delete [] buf;
         delete[] buf;
          return status;
        }
  
       encryption->signature = buf;
 
        encryption->signature_len = buflen;
      } else if (id == 0x7E4) {
      delete[] encryption->sig_key_id;
       delete[] encryption -> sig_key_id;
        encryption->sig_key_id = NULL;
        encryption->sig_key_id_len = 0;
  
  if (size <= 0)
  return E_FILE_FORMAT_INVALID;
 
  const size_t buflen = static_cast<size_t>(size);
  typedef unsigned char* buf_t;
  const buf_t buf = new (std::nothrow) unsigned char[buflen];
 
        if (buf == NULL)
          return -1;
  
      const int read_status = pReader->Read(pos, buflen, buf);
       const int read_status =
           pReader->Read(pos, static_cast<long>(buflen), buf);
        if (read_status) {
        delete [] buf;
         delete[] buf;
          return status;
        }
  
       encryption->sig_key_id = buf;
       encryption->sig_key_id_len = buflen;
  } else if (id == 0x7E5) {
       encryption->sig_algo = UnserializeUInt(pReader, pos, size);
  } else if (id == 0x7E6) {
       encryption->sig_hash_algo = UnserializeUInt(pReader, pos, size);
 
      } else if (id == 0x7E7) {
        const long status = ParseContentEncAESSettingsEntry(
          pos,
          size,
          pReader,
          &encryption->aes_settings);
           pos, size, pReader, &encryption->aes_settings);
        if (status)
          return status;
      }
  
     pos += size;   
      assert(pos <= stop);
    }
  
    return 0;
  }","[6, 7, 8, 23, 34, 49, 50, 53, 62, 77, 78, 81, 90, 105, 106, 109, 126, 2, 3, 4, 5, 18, 19, 20, 21, 22, 33, 48, 52, 61, 76, 80, 89, 104, 108, 122, 123, 124, 125]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
207930," WORD32 ih264d_parse_bslice(dec_struct_t * ps_dec, UWORD16 u2_first_mb_in_slice)
 {
  dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
  dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
     UWORD8 u1_ref_idx_re_flag_lx;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
 
     UWORD32 u4_temp, ui_temp1;
     WORD32 i_temp;
     WORD32 ret;
 
   
   
   
  {
         WORD8 *pi1_buf;
         WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
         WORD32 *pi4_mv = (WORD32*)pi2_mv;
         WORD16 *pi16_refFrame;
         pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
         pi16_refFrame = (WORD16*)pi1_buf;
  *pi4_mv = 0;
  *(pi4_mv + 1) = 0;
  *pi16_refFrame = OUT_OF_RANGE_REF;
         ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
         ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
  }
 
     ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
                     ps_bitstrm);
     COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
                     ps_slice->u1_num_ref_idx_active_override_flag);
 
     u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
     ui_temp1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];
  if(ps_slice->u1_num_ref_idx_active_override_flag)
  {
         u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
                         u4_temp - 1);
         ui_temp1 = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT(""SH: num_ref_idx_l1_active_minus1"",
                         ui_temp1 - 1);
  }
 
  {
         UWORD8 u1_max_ref_idx = MAX_FRAMES;
  if(ps_slice->u1_field_pic_flag)
  {
             u1_max_ref_idx = MAX_FRAMES << 1;
  }
  if((u4_temp > u1_max_ref_idx) || (ui_temp1 > u1_max_ref_idx))
  {
  return ERROR_NUM_REF;
  }
         ps_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
         ps_slice->u1_num_ref_idx_lx_active[1] = ui_temp1;
  }
   
   
   
   
 
  {
         UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
  != ps_dec->ps_cur_slice->u1_slice_type);
  if(ps_dec->u1_first_pb_nal_in_pic
  || (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
  || ps_dec->u1_num_ref_idx_lx_active_prev
  != ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0])
             ih264d_init_ref_idx_lx_b(ps_dec);
  if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
             ps_dec->u1_first_pb_nal_in_pic = 0;
  }
   
     ps_dec->u1_num_ref_idx_lx_active_prev =
                     ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
 
     u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",u1_ref_idx_re_flag_lx);
 
   
  if(u1_ref_idx_re_flag_lx)
  {
         WORD8 ret;
         ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
         ret = ih264d_ref_idx_reordering(ps_dec, 0);
  if(ret == -1)
  return ERROR_REFIDX_ORDER_T;
  }
  else
         ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
 
     u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l1"",u1_ref_idx_re_flag_lx);
 
   
  if(u1_ref_idx_re_flag_lx)
  {
         WORD8 ret;
         ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];
         ret = ih264d_ref_idx_reordering(ps_dec, 1);
  if(ret == -1)
  return ERROR_REFIDX_ORDER_T;
  }
  else
         ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];
 
   
  {
  void **ppv_map_ref_idx_to_poc_lx;
         WORD8 idx;
  struct pic_buffer_t *ps_pic;
 
         ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
         ppv_map_ref_idx_to_poc_lx[0] = 0;
         ppv_map_ref_idx_to_poc_lx++;
  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
                         idx++)
  {
             ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
             ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
  }
 
         ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
 
         ppv_map_ref_idx_to_poc_lx[0] = 0;
         ppv_map_ref_idx_to_poc_lx++;
  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                         idx++)
  {
             ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
             ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
  }
 
  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
  {
  void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
 
  ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
  + TOP_LIST_FLD_L0;
             ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
  + BOT_LIST_FLD_L0;
 
  ppv_map_ref_idx_to_poc_lx_t[0] = 0;
  ppv_map_ref_idx_to_poc_lx_t++;
             ppv_map_ref_idx_to_poc_lx_b[0] = 0;
             ppv_map_ref_idx_to_poc_lx_b++;
  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
                             idx++)
  {
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
  ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                 ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);
 
                 ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
  ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;
 
  ppv_map_ref_idx_to_poc_lx_t += 2;
                 ppv_map_ref_idx_to_poc_lx_b += 2;
  }
 
  ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
  + TOP_LIST_FLD_L1;
             ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
  + BOT_LIST_FLD_L1;
 
  ppv_map_ref_idx_to_poc_lx_t[0] = 0;
  ppv_map_ref_idx_to_poc_lx_t++;
             ppv_map_ref_idx_to_poc_lx_b[0] = 0;
             ppv_map_ref_idx_to_poc_lx_b++;
  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                             idx++)
  {
                 UWORD8 u1_tmp_idx = idx << 1;
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
  ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);
                 ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);
 
                 ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;
  ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;
 
  }
  }
 
  if(ps_dec->u4_num_cores >= 3)
  {
             WORD32 num_entries;
             WORD32 size;
 
             num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
             num_entries = 2 * ((2 * num_entries) + 1);
 
             size = num_entries * sizeof(void *);
             size += PAD_MAP_IDX_POC * sizeof(void *);
 
             memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
                ps_dec->ppv_map_ref_idx_to_poc,
                size);
  }
 
  }
 
  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag
  && (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))
  {
         ih264d_convert_frm_mbaff_list(ps_dec);
  }
 
  if(ps_pps->u1_wted_bipred_idc == 1)
  {
         ret = ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);
  if(ret != OK)
  return ret;
         ih264d_form_pred_weight_matrix(ps_dec);
         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
  }
  else if(ps_pps->u1_wted_bipred_idc == 2)
  {
   
         ps_slice->u2_log2Y_crwd = 0x0505;
         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
         ih264d_get_implicit_weights(ps_dec);
  }
  else
         ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
 
     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
                     ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
   
 
      if(ps_slice->u1_nal_ref_idc != 0)
      {
          if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
         {
             i_temp = ih264d_read_mmco_commands(ps_dec);
             if (i_temp < 0)
             {
                 return ERROR_DBP_MANAGER_T;
             }
             ps_dec->u4_bitoffset = i_temp;
         }
          else
              ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
      }
   
 
  if(ps_pps->u1_entropy_coding_mode == CABAC)
  {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
  if(u4_temp > MAX_CABAC_INIT_IDC)
  {
  return ERROR_INV_SLICE_HDR_T;
  }
         ps_slice->u1_cabac_init_idc = u4_temp;
         COPYTHECONTEXT(""SH: cabac_init_idc"",ps_slice->u1_cabac_init_idc);
  }
 
   
     i_temp = ps_pps->u1_pic_init_qp
  + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
  if((i_temp < 0) || (i_temp > 51))
  {
  return ERROR_INV_RANGE_QP_T;
  }
     ps_slice->u1_slice_qp = i_temp;
     COPYTHECONTEXT(""SH: slice_qp_delta"",
  (WORD8)(ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));
 
  if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
  {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
  if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
  {
  return ERROR_INV_SLICE_HDR_T;
  } COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);
         ps_slice->u1_disable_dblk_filter_idc = u4_temp;
  if(u4_temp != 1)
  {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
  << 1;
  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
  {
  return ERROR_INV_SLICE_HDR_T;
  }
             ps_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                             ps_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
  << 1;
  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
  {
  return ERROR_INV_SLICE_HDR_T;
  }
             ps_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                             ps_slice->i1_slice_beta_offset >> 1);
 
  }
  else
  {
             ps_slice->i1_slice_alpha_c0_offset = 0;
             ps_slice->i1_slice_beta_offset = 0;
  }
  }
  else
  {
         ps_slice->u1_disable_dblk_filter_idc = 0;
         ps_slice->i1_slice_alpha_c0_offset = 0;
         ps_slice->i1_slice_beta_offset = 0;
  }
 
     ps_dec->u1_slice_header_done = 2;
 
  if(ps_pps->u1_entropy_coding_mode)
  {
         SWITCHOFFTRACE; SWITCHONTRACECABAC;
         ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
         ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cabac;
         ih264d_init_cabac_contexts(B_SLICE, ps_dec);
 
  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
  else
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
  }
  else
  {
         SWITCHONTRACE; SWITCHOFFTRACECABAC;
         ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
         ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cavlc;
  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
  else
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
  }
 
     ret = ih264d_cal_col_pic(ps_dec);
  if(ret != OK)
  return ret;
     ps_dec->u1_B = 1;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb;
     ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_slice, u2_first_mb_in_slice);
  if(ret != OK)
  return ret;
  return OK;
 }","[239, 240, 241, 242, 243, 244, 245, 246, 238]","The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142."
204682," void ResourceDispatcherHostImpl::PauseRequest(int child_id,
                                               int request_id,
                                               bool pause) {
   GlobalRequestID global_id(child_id, request_id);
   PendingRequestList::iterator i = pending_requests_.find(global_id);
   if (i == pending_requests_.end()) {
     DVLOG(1) << ""Pausing a request that wasn't found"";
     return;
   }
 
   ResourceRequestInfoImpl* info =
       ResourceRequestInfoImpl::ForRequest(i->second);
   int pause_count = info->pause_count() + (pause ? 1 : -1);
   if (pause_count < 0) {
     NOTREACHED();   
     return;
   }
   info->set_pause_count(pause_count);
 
   VLOG(1) << ""To pause ("" << pause << ""): "" << i->second->url().spec();
 
    if (info->pause_count() == 0) {
      MessageLoop::current()->PostTask(FROM_HERE,
        base::Bind(
            &ResourceDispatcherHostImpl::ResumeRequest,
            weak_factory_.GetWeakPtr(),
            global_id));
         base::Bind(&ResourceDispatcherHostImpl::ResumeRequest,
                    AsWeakPtr(), global_id));
    }
  }","[28, 29, 24, 25, 26, 27]","The WebSockets implementation in Google Chrome before 19.0.1084.52 does not properly handle use of SSL, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via unspecified vectors."
198053," void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const QString &target, const QByteArray &message) {
   QByteArray ctcp;
 
   QByteArray dequotedMessage = lowLevelDequote(message);
 
   CtcpType ctcptype = messageType == Message::Notice
     ? CtcpReply
     : CtcpQuery;
 
   Message::Flags flags = (messageType == Message::Notice && !network()->isChannelName(target))
     ? Message::Redirected
     : Message::None;
 
    int xdelimPos = -1;
    int xdelimEndPos = -1;
    int spacePos = -1;
   QList<QByteArray> replies;
    while((xdelimPos = dequotedMessage.indexOf(XDELIM)) != -1) {
      if(xdelimPos > 0)
        displayMsg(messageType, target, userDecode(target, dequotedMessage.left(xdelimPos)), prefix, flags);
     xdelimEndPos = dequotedMessage.indexOf(XDELIM, xdelimPos + 1);
     if(xdelimEndPos == -1) {
       xdelimEndPos = dequotedMessage.count();
     }
     ctcp = xdelimDequote(dequotedMessage.mid(xdelimPos + 1, xdelimEndPos - xdelimPos - 1));
     dequotedMessage = dequotedMessage.mid(xdelimEndPos + 1);
 
     QString ctcpcmd = userDecode(target, ctcp.left(spacePos));
     QString ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));
 
     spacePos = ctcp.indexOf(' ');
     if(spacePos != -1) {
       ctcpcmd = userDecode(target, ctcp.left(spacePos));
       ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));
     } else {
       ctcpcmd = userDecode(target, ctcp);
       ctcpparam = QString();
        ctcpparam = QString();
      }
  
    handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam));
     if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ctcpcmd.toUpper())) {
       QString reply_;
       handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam), Q_ARG(QString, reply_));
       if(ctcptype == CtcpQuery && !reply_.isNull()) {
         replies << lowLevelQuote(pack(serverEncode(ctcpcmd), userEncode(nickFromMask(prefix), reply_)));
       }
     }
   }
   if(ctcptype == CtcpQuery && !replies.isEmpty()) {
     packedReply(nickFromMask(prefix), replies);
    }
  
    if(!dequotedMessage.isEmpty())
 void CtcpHandler::query(const QString &bufname, const QString &ctcpTag, const QString &message) {
   QList<QByteArray> params;
   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));
   emit putCmd(""PRIVMSG"", params);
 }
 
 void CtcpHandler::reply(const QString &bufname, const QString &ctcpTag, const QString &message) {
   QList<QByteArray> params;
   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));
   emit putCmd(""NOTICE"", params);
 }
 
 void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {
   Q_UNUSED(ctcptype)
   emit displayMsg(Message::Action, typeByTarget(target), target, param, prefix);
 }
    emit putCmd(""NOTICE"", params);
  }","[17, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 41]",ctcphandler.cpp in Quassel before 0.6.3 and 0.7.x before 0.7.1 allows remote attackers to cause a denial of service (unresponsive IRC) via multiple Client-To-Client Protocol (CTCP) requests in a PRIVMSG message.
199232," fb_mmap(struct file *file, struct vm_area_struct * vma)
  {
  	struct fb_info *info = file_fb_info(file);
  	struct fb_ops *fb;
	unsigned long off;
 	unsigned long mmio_pgoff;
  	unsigned long start;
  	u32 len;
  
  	if (!info)
  		return -ENODEV;
	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
		return -EINVAL;
	off = vma->vm_pgoff << PAGE_SHIFT;
  	fb = info->fbops;
  	if (!fb)
  		return -ENODEV;
 	mutex_lock(&info->mm_lock);
 	if (fb->fb_mmap) {
 		int res;
 		res = fb->fb_mmap(info, vma);
 		mutex_unlock(&info->mm_lock);
  		return res;
  	}
  
 	 
  	start = info->fix.smem_start;
	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
	if (off >= len) {
		 
		off -= len;
		if (info->var.accel_flags) {
			mutex_unlock(&info->mm_lock);
			return -EINVAL;
		}
 	len = info->fix.smem_len;
 	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;
 	if (vma->vm_pgoff >= mmio_pgoff) {
 		vma->vm_pgoff -= mmio_pgoff;
  		start = info->fix.mmio_start;
		len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);
 		len = info->fix.mmio_len;
  	}
  	mutex_unlock(&info->mm_lock);
	start &= PAGE_MASK;
	if ((vma->vm_end - vma->vm_start + off) > len)
		return -EINVAL;
	off += start;
	vma->vm_pgoff = off >> PAGE_SHIFT;
	 
 
  	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
	fb_pgprotect(file, vma, off);
	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
			     vma->vm_end - vma->vm_start, vma->vm_page_prot))
		return -EAGAIN;
	return 0;
 	fb_pgprotect(file, vma, start);
 
 	return vm_iomap_memory(vma, start, len);
  }","[6, 36, 37, 38, 39, 42, 51, 58, 59, 60, 5, 12, 13, 14, 28, 29, 30, 31, 32, 33, 34, 35, 41, 45, 46, 47, 48, 49, 50, 53, 54, 55, 56, 57]","Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program."
197779," void CairoOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
 				int width, int height,
 				GfxImageColorMap *colorMap,
 				Stream *maskStr,
 				int maskWidth, int maskHeight,
 				GfxImageColorMap *maskColorMap)
 {
   ImageStream *maskImgStr;
   maskImgStr = new ImageStream(maskStr, maskWidth,
 				       maskColorMap->getNumPixelComps(),
 				       maskColorMap->getBits());
   maskImgStr->reset();
  
    int row_stride = (maskWidth + 3) & ~3;
    unsigned char *maskBuffer;
  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);
   maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);
    unsigned char *maskDest;
    cairo_surface_t *maskImage;
    cairo_pattern_t *maskPattern;
   Guchar *pix;
   int y;
   for (y = 0; y < maskHeight; y++) {
     maskDest = (unsigned char *) (maskBuffer + y * row_stride);
     pix = maskImgStr->getLine();
     maskColorMap->getGrayLine (pix, maskDest, maskWidth);
   }
 
   maskImage = cairo_image_surface_create_for_data (maskBuffer, CAIRO_FORMAT_A8,
 						 maskWidth, maskHeight, row_stride);
 
   delete maskImgStr;
   maskStr->close();
 
   unsigned char *buffer;
   unsigned int *dest;
   cairo_surface_t *image;
   cairo_pattern_t *pattern;
   ImageStream *imgStr;
   cairo_matrix_t matrix;
    cairo_matrix_t maskMatrix;
    int is_identity_transform;
  
  buffer = (unsigned char *)gmalloc (width * height * 4);
   buffer = (unsigned char *)gmallocn3 (width, height, 4);
  
     
    imgStr = new ImageStream(str, width,
 			   colorMap->getNumPixelComps(),
 			   colorMap->getBits());
   imgStr->reset();
   
    
   is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||
 		  (colorMap->getColorSpace()->getMode() == csICCBased && 
 		   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);
 
   for (y = 0; y < height; y++) {
     dest = (unsigned int *) (buffer + y * 4 * width);
     pix = imgStr->getLine();
     colorMap->getRGBLine (pix, dest, width);
   }
 
   image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,
 						 width, height, width * 4);
 
   if (image == NULL) {
     delete imgStr;
     return;
   }
   pattern = cairo_pattern_create_for_surface (image);
   maskPattern = cairo_pattern_create_for_surface (maskImage);
   if (pattern == NULL) {
     delete imgStr;
     return;
   }
 
   LOG (printf (""drawSoftMaskedImage %dx%d\n"", width, height));
 
   cairo_matrix_init_translate (&matrix, 0, height);
   cairo_matrix_scale (&matrix, width, -height);
 
   cairo_matrix_init_translate (&maskMatrix, 0, maskHeight);
   cairo_matrix_scale (&maskMatrix, maskWidth, -maskHeight);
 
   cairo_pattern_set_matrix (pattern, &matrix);
   cairo_pattern_set_matrix (maskPattern, &maskMatrix);
 
   cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);
   cairo_pattern_set_filter (maskPattern, CAIRO_FILTER_BILINEAR);
   cairo_set_source (cairo, pattern);
   cairo_mask (cairo, maskPattern);
 
   if (cairo_shape) {
 #if 0
     cairo_rectangle (cairo_shape, 0., 0., width, height);
     cairo_fill (cairo_shape);
 #else
     cairo_save (cairo_shape);
      
      
     cairo_set_source (cairo_shape, pattern);
     cairo_mask (cairo_shape, pattern);
     cairo_restore (cairo_shape);
 #endif
   }
 
   cairo_pattern_destroy (maskPattern);
   cairo_surface_destroy (maskImage);
   cairo_pattern_destroy (pattern);
   cairo_surface_destroy (image);
   free (buffer);
   free (maskBuffer);
 
   delete imgStr;
 }","[17, 45, 16, 44]","Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791."
199011,"  static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct perf_sample_data *data,
  				    struct pt_regs *regs)
  {
  	struct hw_perf_event *hwc = &event->hw;
 	int throttle = 0;
 
 	data->period = event->hw.last_period;
 	if (!overflow)
 		overflow = perf_swevent_set_period(event);
 
 	if (hwc->interrupts == MAX_INTERRUPTS)
  		return;
  
  	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 		if (__perf_event_overflow(event, throttle,
  					    data, regs)) {
  			 
 			break;
 		}
 		throttle = 1;
 	}
  }","[3, 18, 2, 17]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
199538," cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,
     const void *p, size_t tail, int line)
  {
  	const char *b = (const char *)sst->sst_tab;
  	const char *e = ((const char *)p) + tail;
 	size_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?
 	    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);
  	(void)&line;
	if (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)
 	if (e >= b && (size_t)(e - b) <= ss * sst->sst_len)
  		return 0;
  	DPRINTF((""%d: offset begin %p < end %p || %"" SIZE_T_FORMAT ""u""
  	    "" > %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""
  	    SIZE_T_FORMAT ""u]\n"", line, b, e, (size_t)(e - b),
	    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));
 	    ss * sst->sst_len, ss, sst->sst_len));
  	errno = EFTYPE;
  	return -1;
  }","[6, 7, 10, 16, 9, 15]","The cdf_check_stream_offset function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, relies on incorrect sector-size data, which allows remote attackers to cause a denial of service (application crash) via a crafted stream offset in a CDF file."
198769," i915_gem_execbuffer2(struct drm_device *dev, void *data,
 		     struct drm_file *file)
 {
 	struct drm_i915_gem_execbuffer2 *args = data;
  	struct drm_i915_gem_exec_object2 *exec2_list = NULL;
  	int ret;
  
	if (args->buffer_count < 1) {
 	if (args->buffer_count < 1 ||
 	    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {
  		DRM_DEBUG(""execbuf2 with %d buffers\n"", args->buffer_count);
  		return -EINVAL;
  	}
 
 	exec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,
 			     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);
 	if (exec2_list == NULL)
 		exec2_list = drm_malloc_ab(sizeof(*exec2_list),
 					   args->buffer_count);
 	if (exec2_list == NULL) {
 		DRM_DEBUG(""Failed to allocate exec list for %d buffers\n"",
 			  args->buffer_count);
 		return -ENOMEM;
 	}
 	ret = copy_from_user(exec2_list,
 			     (struct drm_i915_relocation_entry __user *)
 			     (uintptr_t) args->buffers_ptr,
 			     sizeof(*exec2_list) * args->buffer_count);
 	if (ret != 0) {
 		DRM_DEBUG(""copy %d exec entries failed %d\n"",
 			  args->buffer_count, ret);
 		drm_free_large(exec2_list);
 		return -EFAULT;
 	}
 
 	ret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);
 	if (!ret) {
 		 
 		ret = copy_to_user((struct drm_i915_relocation_entry __user *)
 				   (uintptr_t) args->buffers_ptr,
 				   exec2_list,
 				   sizeof(*exec2_list) * args->buffer_count);
 		if (ret) {
 			ret = -EFAULT;
 			DRM_DEBUG(""failed to copy %d exec entries ""
 				  ""back to user (%d)\n"",
 				  args->buffer_count, ret);
 		}
 	}
 
 	drm_free_large(exec2_list);
 	return ret;
 }","[9, 10, 8]",Integer overflow in the i915_gem_execbuffer2 function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.
208148,"      BufferMeta(const sp<GraphicBuffer> &graphicBuffer, OMX_U32 portIndex)
          : mGraphicBuffer(graphicBuffer),
          mIsBackup(false),
          mPortIndex(portIndex) {
           mCopyFromOmx(false),
           mCopyToOmx(false),
           mPortIndex(portIndex),
           mBackup(NULL) {
      }","[5, 6, 7, 8, 3, 4]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
8773,"int amf_namf_comm_handle_n1_n2_message_transfer(
ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)
{
int status;

amf_ue_t *amf_ue = NULL;
amf_sess_t *sess = NULL;

ogs_pkbuf_t *n1buf = NULL;
ogs_pkbuf_t *n2buf = NULL;

ogs_pkbuf_t *gmmbuf = NULL;
ogs_pkbuf_t *ngapbuf = NULL;

char *supi = NULL;
uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;

ogs_sbi_message_t sendmsg;
ogs_sbi_response_t *response = NULL;

OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;
OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;
OpenAPI_n1_message_container_t *n1MessageContainer = NULL;
OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;
OpenAPI_n2_info_container_t *n2InfoContainer = NULL;
OpenAPI_n2_sm_information_t *smInfo = NULL;
OpenAPI_n2_info_content_t *n2InfoContent = NULL;
OpenAPI_ref_to_binary_data_t *ngapData = NULL;

ogs_assert(stream);
ogs_assert(recvmsg);

N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;
if (!N1N2MessageTransferReqData) {
ogs_error(""No N1N2MessageTransferReqData"");
return OGS_ERROR;
}

if (N1N2MessageTransferReqData->is_pdu_session_id == false) {
ogs_error(""No PDU Session Identity"");
return OGS_ERROR;
}
pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;

supi = recvmsg->h.resource.component[1];
if (!supi) {
ogs_error(""No SUPI"");
return OGS_ERROR;
}

amf_ue = amf_ue_find_by_supi(supi);
if (!amf_ue) {
ogs_error(""No UE context [%s]"", supi);
return OGS_ERROR;
}

sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);
if (!sess) {
ogs_error(""[%s] No PDU Session Context [%d]"",
amf_ue->supi, pdu_session_id);
return OGS_ERROR;
}

n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;
if (n1MessageContainer) {
n1MessageContent = n1MessageContainer->n1_message_content;
if (!n1MessageContent || !n1MessageContent->content_id) {
ogs_error(""No n1MessageContent"");
return OGS_ERROR;
}

n1buf = ogs_sbi_find_part_by_content_id(
recvmsg, n1MessageContent->content_id);
if (!n1buf) {
ogs_error(""[%s] No N1 SM Content"", amf_ue->supi);
return OGS_ERROR;
}





n1buf = ogs_pkbuf_copy(n1buf);
ogs_assert(n1buf);
}

n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;
if (n2InfoContainer) {
smInfo = n2InfoContainer->sm_info;
if (!smInfo) {
ogs_error(""No smInfo"");
return OGS_ERROR;
}
n2InfoContent = smInfo->n2_info_content;
if (!n2InfoContent) {
ogs_error(""No n2InfoContent"");
return OGS_ERROR;
}

ngapData = n2InfoContent->ngap_data;
if (!ngapData || !ngapData->content_id) {
ogs_error(""No ngapData"");
return OGS_ERROR;
}
n2buf = ogs_sbi_find_part_by_content_id(
recvmsg, ngapData->content_id);
if (!n2buf) {
ogs_error(""[%s] No N2 SM Content"", amf_ue->supi);
return OGS_ERROR;
}





n2buf = ogs_pkbuf_copy(n2buf);
ogs_assert(n2buf);
}

memset(&sendmsg, 0, sizeof(sendmsg));

status = OGS_SBI_HTTP_STATUS_OK;

memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));
N1N2MessageTransferRspData.cause =
OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;

sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;

switch (n2InfoContent->ngap_ie_type) {
case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:
if (!n2buf) {
ogs_error(""[%s] No N2 SM Content"", amf_ue->supi);
return OGS_ERROR;
}

if (n1buf) {
gmmbuf = gmm_build_dl_nas_transport(sess,
OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);
ogs_assert(gmmbuf);
}

if (gmmbuf) {
ran_ue_t *ran_ue = NULL;





ran_ue = ran_ue_cycle(amf_ue->ran_ue);
ogs_assert(ran_ue);

if (sess->pdu_session_establishment_accept) {
ogs_pkbuf_free(sess->pdu_session_establishment_accept);
sess->pdu_session_establishment_accept = NULL;
}

if (ran_ue->initial_context_setup_request_sent == true) {
ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(
sess, gmmbuf, n2buf);
ogs_assert(ngapbuf);
} else {
ngapbuf = ngap_sess_build_initial_context_setup_request(
sess, gmmbuf, n2buf);
ogs_assert(ngapbuf);

ran_ue->initial_context_setup_request_sent = true;
}

if (SESSION_CONTEXT_IN_SMF(sess)) {








if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)
ogs_error(""nas_5gs_send_to_gnb() failed"");
} else {
sess->pdu_session_establishment_accept = ngapbuf;
}

} else {




if (CM_IDLE(amf_ue)) {
ogs_sbi_server_t *server = NULL;
ogs_sbi_header_t header;
ogs_sbi_client_t *client = NULL;
ogs_sockaddr_t *addr = NULL;

if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {
ogs_error(""[%s:%d] No n1-n2-failure-notification-uri"",
amf_ue->supi, sess->psi);
return OGS_ERROR;
}

addr = ogs_sbi_getaddr_from_uri(
N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);
if (!addr) {
ogs_error(""[%s:%d] Invalid URI [%s]"",
amf_ue->supi, sess->psi,
N1N2MessageTransferReqData->
n1n2_failure_txf_notif_uri);
return OGS_ERROR;;
}

client = ogs_sbi_client_find(addr);
if (!client) {
client = ogs_sbi_client_add(addr);
ogs_assert(client);
}
OGS_SETUP_SBI_CLIENT(&sess->paging, client);

ogs_freeaddrinfo(addr);

status = OGS_SBI_HTTP_STATUS_ACCEPTED;
N1N2MessageTransferRspData.cause =
OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;


server = ogs_sbi_server_from_stream(stream);
ogs_assert(server);

memset(&header, 0, sizeof(header));
header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;
header.api.version = (char *)OGS_SBI_API_V1;
header.resource.component[0] =
(char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;
header.resource.component[1] = amf_ue->supi;
header.resource.component[2] =
(char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;
header.resource.component[3] = sess->sm_context_ref;

sendmsg.http.location = ogs_sbi_server_uri(server, &header);


AMF_SESS_STORE_PAGING_INFO(
sess, sendmsg.http.location,
N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);


AMF_SESS_STORE_N2_TRANSFER(
sess, pdu_session_resource_setup_request, n2buf);

ogs_assert(OGS_OK == ngap_send_paging(amf_ue));

} else if (CM_CONNECTED(amf_ue)) {
ogs_assert(OGS_OK ==
ngap_send_pdu_resource_setup_request(sess, n2buf));

} else {

ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi);
ogs_assert_if_reached();

}

}
break;

case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:
if (!n1buf) {
ogs_error(""[%s] No N1 SM Content"", amf_ue->supi);
return OGS_ERROR;
}
if (!n2buf) {
ogs_error(""[%s] No N2 SM Content"", amf_ue->supi);
return OGS_ERROR;
}

if (CM_IDLE(amf_ue)) {
ogs_sbi_server_t *server = NULL;
ogs_sbi_header_t header;

status = OGS_SBI_HTTP_STATUS_ACCEPTED;
N1N2MessageTransferRspData.cause =
OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;


server = ogs_sbi_server_from_stream(stream);
ogs_assert(server);

memset(&header, 0, sizeof(header));
header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;
header.api.version = (char *)OGS_SBI_API_V1;
header.resource.component[0] =
(char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;
header.resource.component[1] = amf_ue->supi;
header.resource.component[2] =
(char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;
header.resource.component[3] = sess->sm_context_ref;

sendmsg.http.location = ogs_sbi_server_uri(server, &header);


AMF_SESS_STORE_PAGING_INFO(
sess, sendmsg.http.location, NULL);


AMF_SESS_STORE_5GSM_MESSAGE(sess,
OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,
n1buf, n2buf);

ogs_assert(OGS_OK == ngap_send_paging(amf_ue));

} else if (CM_CONNECTED(amf_ue)) {
gmmbuf = gmm_build_dl_nas_transport(sess,
OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);
ogs_assert(gmmbuf);

ngapbuf = ngap_build_pdu_session_resource_modify_request(
sess, gmmbuf, n2buf);
ogs_assert(ngapbuf);

if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)
ogs_error(""nas_5gs_send_to_gnb() failed"");

} else {
ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi);
ogs_assert_if_reached();
}

break;

case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:
if (!n2buf) {
ogs_error(""[%s] No N2 SM Content"", amf_ue->supi);
return OGS_ERROR;
}

if (n1buf)
ogs_pkbuf_free(n1buf);

if (CM_IDLE(amf_ue)) {
if (n2buf)
ogs_pkbuf_free(n2buf);

if (N1N2MessageTransferReqData->is_skip_ind == true &&
N1N2MessageTransferReqData->skip_ind == true) {
N1N2MessageTransferRspData.cause =
OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;
} else {
ogs_fatal(""[%s] No skipInd"", amf_ue->supi);
ogs_assert_if_reached();
}

} else if (CM_CONNECTED(amf_ue)) {
ngapbuf = ngap_build_pdu_session_resource_release_command(
sess, NULL, n2buf);
ogs_assert(ngapbuf);

if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)
ogs_error(""nas_5gs_send_to_gnb() failed"");

} else {
ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi);
ogs_assert_if_reached();
}
break;

default:
ogs_error(""Not implemented ngap_ie_type[%d]"",
n2InfoContent->ngap_ie_type);
ogs_assert_if_reached();
}

response = ogs_sbi_build_response(&sendmsg, status);
ogs_assert(response);
ogs_assert(true == ogs_sbi_server_send_response(stream, response));

if (sendmsg.http.location)
ogs_free(sendmsg.http.location);

return OGS_OK;
}","[30, 94, 100, 130, 367, 368]",A null pointer dereference in src/amf/namf-handler.c in Open5GS 2.3.6 and earlier allows remote attackers to Denial of Service via a crafted sbi request to amf.
7460,"static void __xen_evtchn_do_upcall(void)
{
struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);
int cpu = smp_processor_id();

do {
vcpu_info->evtchn_upcall_pending = 0;

xen_evtchn_handle_events(cpu);

BUG_ON(!irqs_disabled());

virt_rmb();

} while (vcpu_info->evtchn_upcall_pending);
}","[6, 13]","An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5."
197896," static void become_daemon(const char *pidfile)
 {
 #ifndef _WIN32
     pid_t pid, sid;
 
     pid = fork();
     if (pid < 0) {
         exit(EXIT_FAILURE);
     }
     if (pid > 0) {
         exit(EXIT_SUCCESS);
     }
 
     if (pidfile) {
         if (!ga_open_pidfile(pidfile)) {
             g_critical(""failed to create pidfile"");
             exit(EXIT_FAILURE);
          }
      }
  
    umask(0);
     umask(S_IRWXG | S_IRWXO);
      sid = setsid();
      if (sid < 0) {
          goto fail;
     }
     if ((chdir(""/"")) < 0) {
         goto fail;
     }
 
     reopen_fd_to_null(STDIN_FILENO);
     reopen_fd_to_null(STDOUT_FILENO);
     reopen_fd_to_null(STDERR_FILENO);
     return;
 
 fail:
     if (pidfile) {
         unlink(pidfile);
     }
     g_critical(""failed to daemonize"");
     exit(EXIT_FAILURE);
 #endif
 }","[22, 21]","The qemu guest agent in Qemu 1.4.1 and earlier, as used by Xen, when started in daemon mode, uses weak permissions for certain files, which allows local users to read and write to these files."
205951," bool OutOfProcessInstance::Init(uint32_t argc,
                                  const char* argn[],
                                  const char* argv[]) {
    
    
    pp::Var document_url_var = pp::URLUtil_Dev::Get()->GetDocumentURL(this);
  std::string document_url = document_url_var.is_string() ?
      document_url_var.AsString() : std::string();
   if (!document_url_var.is_string())
     return false;
   std::string document_url = document_url_var.AsString();
    std::string extension_url = std::string(kChromeExtension);
  bool in_extension =
      !document_url.compare(0, extension_url.size(), extension_url);
  if (in_extension) {
    for (uint32_t i = 0; i < argc; ++i) {
      if (strcmp(argn[i], ""full-frame"") == 0) {
        full_ = true;
        break;
      }
   std::string print_preview_url = std::string(kChromePrint);
   if (!base::StringPiece(document_url).starts_with(kChromeExtension) &&
       !base::StringPiece(document_url).starts_with(kChromePrint)) {
     return false;
   }
 
    
   for (uint32_t i = 0; i < argc; ++i) {
     if (strcmp(argn[i], ""full-frame"") == 0) {
       full_ = true;
       break;
      }
    }
  
   if (full_)
     SetPluginToHandleFindRequests();
 
   pp::VarDictionary translated_strings;
   translated_strings.Set(kType, kJSSetTranslatedStringsType);
   translated_strings.Set(kJSGetPasswordString,
       GetLocalizedString(PP_RESOURCESTRING_PDFGETPASSWORD));
   translated_strings.Set(kJSLoadingString,
       GetLocalizedString(PP_RESOURCESTRING_PDFLOADING));
   translated_strings.Set(kJSLoadFailedString,
       GetLocalizedString(PP_RESOURCESTRING_PDFLOAD_FAILED));
   PostMessage(translated_strings);
 
   text_input_.reset(new pp::TextInput_Dev(this));
 
   const char* stream_url = nullptr;
   const char* original_url = nullptr;
   const char* headers = nullptr;
   bool is_material = false;
   for (uint32_t i = 0; i < argc; ++i) {
     if (strcmp(argn[i], ""src"") == 0)
       original_url = argv[i];
     else if (strcmp(argn[i], ""stream-url"") == 0)
       stream_url = argv[i];
     else if (strcmp(argn[i], ""headers"") == 0)
       headers = argv[i];
     else if (strcmp(argn[i], ""is-material"") == 0)
       is_material = true;
     else if (strcmp(argn[i], ""top-toolbar-height"") == 0)
       base::StringToInt(argv[i], &top_toolbar_height_);
   }
 
   if (is_material)
     background_color_ = kBackgroundColorMaterial;
   else
     background_color_ = kBackgroundColor;
 
   if (!original_url)
     return false;
 
   if (!stream_url)
     stream_url = original_url;
 
   if (IsPrintPreviewUrl(original_url))
     return true;
 
   LoadUrl(stream_url);
   url_ = original_url;
   return engine_->New(original_url, headers);
 }","[4, 5, 9, 10, 11, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 7, 8, 13, 14, 15, 16, 17, 18, 19, 20]","The PDF viewer in Google Chrome before 46.0.2490.86 does not properly restrict scripting messages and API exposure, which allows remote attackers to bypass the Same Origin Policy via an unintended embedder or unintended plugin loading, related to pdf.js and out_of_process_instance.cc."
202818,"  decompileAction(int n, SWF_ACTION *actions, int maxn)
  {
	if( n > maxn ) SWF_error(""Action overflow!!"");
  
  #ifdef DEBUG
  	fprintf(stderr,""%d:\tACTION[%3.3d]: %s\n"",
  	        actions[n].SWF_ACTIONRECORD.Offset, n, 
  	        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));
  #endif
  
	switch(actions[n].SWF_ACTIONRECORD.ActionCode)
 	switch(OpCode(actions, n, maxn))
  	{
  	case SWFACTION_END:
  		return 0;
 
 	case SWFACTION_CONSTANTPOOL:
 		decompileCONSTANTPOOL(&actions[n]);
 		return 0;
 
 	case SWFACTION_GOTOLABEL:
 		return decompileGOTOFRAME(n, actions, maxn,1);
 
 	case SWFACTION_GOTOFRAME:
 		return decompileGOTOFRAME(n, actions, maxn,0);
 
 	case SWFACTION_GOTOFRAME2:
 		return decompileGOTOFRAME2(n, actions, maxn);
 
 	case SWFACTION_WAITFORFRAME:
 		decompileWAITFORFRAME(&actions[n]);
 		return 0;
 
 	case SWFACTION_GETURL2:
 		decompileGETURL2(&actions[n]);
 		return 0;
 
 	case SWFACTION_GETURL:
 		decompileGETURL(&actions[n]);
 		return 0;
 
 	case SWFACTION_PUSH:
 		decompilePUSH(&actions[n]);
 		return 0;
 
 	case SWFACTION_PUSHDUP:
 		decompilePUSHDUP(&actions[n]);
 		return 0;
 
 	case SWFACTION_STACKSWAP:
 		decompileSTACKSWAP(&actions[n]);	
 		return 0;
 
 	case SWFACTION_SETPROPERTY:
 		decompileSETPROPERTY(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_GETPROPERTY:
 		decompileGETPROPERTY(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_GETTIME:
 		return decompileGETTIME(n, actions, maxn);
 
 	case SWFACTION_TRACE:
 		decompileTRACE(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_CALLFRAME:
 		decompileCALLFRAME(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_EXTENDS:
 		decompileEXTENDS(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_INITOBJECT:
 		decompileINITOBJECT(n, actions, maxn);
 		return 0;	        
 
 	case SWFACTION_NEWOBJECT:
 		decompileNEWOBJECT(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_NEWMETHOD:
 		decompileNEWMETHOD(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_GETMEMBER:
 		decompileGETMEMBER(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_SETMEMBER:
 		decompileSETMEMBER(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_GETVARIABLE:
 		decompileGETVARIABLE(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_SETVARIABLE:
 		decompileSETVARIABLE(n, actions, maxn, 0);
 		return 0;
 
 	case SWFACTION_DEFINELOCAL:
 		decompileSETVARIABLE(n, actions, maxn, 1);
 		return 0;
 
 	case SWFACTION_DEFINELOCAL2:
 		decompileDEFINELOCAL2(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_DECREMENT:
 		return decompileINCR_DECR(n, actions, maxn, 0);
 
 	case SWFACTION_INCREMENT:
 		return decompileINCR_DECR(n, actions, maxn,1);
 
 	case SWFACTION_STOREREGISTER:
 		decompileSTOREREGISTER(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_JUMP:
 		return decompileJUMP(n, actions, maxn);
 
 	case SWFACTION_RETURN:
 		decompileRETURN(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_LOGICALNOT:
 		return decompileLogicalNot(n, actions, maxn);
 
 	case SWFACTION_IF:
 		return decompileIF(n, actions, maxn);
 
 	case SWFACTION_WITH:
 		decompileWITH(n, actions, maxn);
 		return 0;
 
 	case SWFACTION_ENUMERATE:
 		return decompileENUMERATE(n, actions, maxn, 0);
 
 	case SWFACTION_ENUMERATE2 :
 		return decompileENUMERATE(n, actions, maxn,1);
 
 	case SWFACTION_INITARRAY:
 		return decompileINITARRAY(n, actions, maxn);
 
 	case SWFACTION_DEFINEFUNCTION:	
 		return decompileDEFINEFUNCTION(n, actions, maxn,0);
 
 	case SWFACTION_DEFINEFUNCTION2:
 		return decompileDEFINEFUNCTION(n, actions, maxn,1);
 
 	case SWFACTION_CALLFUNCTION:
 		return decompileCALLFUNCTION(n, actions, maxn);
 
 	case SWFACTION_CALLMETHOD:
 		return decompileCALLMETHOD(n, actions, maxn);
 
 	case SWFACTION_INSTANCEOF:
 	case SWFACTION_SHIFTLEFT:
 	case SWFACTION_SHIFTRIGHT:
 	case SWFACTION_SHIFTRIGHT2:        
 	case SWFACTION_ADD:
 	case SWFACTION_ADD2:
 	case SWFACTION_SUBTRACT:
 	case SWFACTION_MULTIPLY:
 	case SWFACTION_DIVIDE:
 	case SWFACTION_MODULO:
 	case SWFACTION_BITWISEAND:
 	case SWFACTION_BITWISEOR:
 	case SWFACTION_BITWISEXOR:
 	case SWFACTION_EQUAL:
 	case SWFACTION_EQUALS2:
 	case SWFACTION_LESS2:
 	case SWFACTION_LOGICALAND:
 	case SWFACTION_LOGICALOR:
 	case SWFACTION_GREATER:
 	case SWFACTION_LESSTHAN:
 	case SWFACTION_STRINGEQ:
 	case SWFACTION_STRINGCOMPARE:
 	case SWFACTION_STRICTEQUALS:
 		return decompileArithmeticOp(n, actions, maxn);
 
 	case SWFACTION_POP:
 		pop();
 		return 0;
 
 	case SWFACTION_STARTDRAG:
 		return decompileSTARTDRAG(n, actions, maxn);
 
 	case SWFACTION_DELETE:
 		return decompileDELETE(n, actions, maxn,0);
 
 	case SWFACTION_DELETE2:
 		return decompileDELETE(n, actions, maxn,1);
 
 	case SWFACTION_TARGETPATH:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""targetPath"");
 
 	case SWFACTION_TYPEOF:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""typeof"");
 
 	case SWFACTION_ORD:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""ord"");
 
 	case SWFACTION_CHR:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""chr"");
 
 	case SWFACTION_INT:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""int"");
 
 	case SWFACTION_TOSTRING:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""String"");     
 
 	case SWFACTION_TONUMBER:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""Number"");
 
 	case SWFACTION_RANDOMNUMBER:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""random"");
 
 	case SWFACTION_STRINGLENGTH:
 		return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""length"");
 
 	case SWFACTION_PLAY:
 		return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""play"");
 
 	case SWFACTION_STOP:
 		return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""stop"");
 
 	case SWFACTION_NEXTFRAME:
 		return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""nextFrame"");
 
 	case SWFACTION_PREVFRAME:
 		return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""prevFrame"");
 
 	case SWFACTION_ENDDRAG:
 		return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""stopDrag"");
 
 	case SWFACTION_STOPSOUNDS:
 		return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""stopAllSounds"");   
 
 	case SWFACTION_TOGGLEQUALITY:
 		return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""toggleHighQuality"");      
 
 	case SWFACTION_MBSUBSTRING:
 	case SWFACTION_SUBSTRING:
 		return decompileSUBSTRING(n, actions, maxn);
 
 	case SWFACTION_STRINGCONCAT:
 		return decompileSTRINGCONCAT(n, actions, maxn);
 
 	case SWFACTION_REMOVECLIP:
 		return decompileREMOVECLIP(n, actions, maxn);
 
 	case SWFACTION_DUPLICATECLIP:
 		return decompileDUPLICATECLIP(n, actions, maxn);
 
 	case SWFACTION_SETTARGET:
 		return decompileSETTARGET(n, actions, maxn,0);
 
 	case SWFACTION_SETTARGET2:
 		return decompileSETTARGET(n, actions, maxn,1);
 
 	case SWFACTION_IMPLEMENTSOP:
 		return decompileIMPLEMENTS(n, actions, maxn);
 
 	case SWFACTION_CASTOP:
 		return decompileCAST(n, actions, maxn);
 
 	case SWFACTION_THROW:
 		return decompileTHROW(n, actions, maxn);
 
 	case SWFACTION_TRY:
 		return decompileTRY(n, actions, maxn);
 
 	default:
 		outputSWF_ACTION(n,&actions[n]);
 		return 0;
 	}
 }","[12, 3, 11]",Ming (aka libming) 0.4.8 has a heap buffer overflow and underflow in the decompileCAST function in util/decompile.c in libutil.a. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted SWF file.
206955," bool AppCacheDatabase::FindEntry(int64_t cache_id,
                                  const GURL& url,
                                  EntryRecord* record) {
   DCHECK(record);
   if (!LazyOpen(kDontCreate))
      return false;
  
    static const char kSql[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""SELECT cache_id, url, flags, response_id, response_size, padding_size ""
       ""FROM Entries""
        ""  WHERE cache_id = ? AND url = ?"";
  
    sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
   statement.BindInt64(0, cache_id);
   statement.BindString(1, url.spec());
 
   if (!statement.Step())
     return false;
 
   ReadEntryRecord(statement, record);
   DCHECK(record->cache_id == cache_id);
   DCHECK(record->url == url);
   return true;
 }","[10, 11, 9]",Resource size information leakage in Blink in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
201727," static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   char
     explicit_vr[MaxTextExtent],
     implicit_vr[MaxTextExtent],
     magick[MaxTextExtent],
     photometric[MaxTextExtent];
 
   DCMStreamInfo
     *stream_info;
 
   Image
     *image;
 
   int
     *bluemap,
     datum,
     *greenmap,
     *graymap,
     index,
     *redmap;
 
   MagickBooleanType
     explicit_file,
     explicit_retry,
     polarity,
     sequence,
     use_explicit;
 
   MagickOffsetType
     offset;
 
   Quantum
     *scale;
 
   register IndexPacket
     *indexes;
 
   register ssize_t
     i,
     x;
 
   register PixelPacket
     *q;
 
   register unsigned char
     *p;
 
   size_t
     bits_allocated,
     bytes_per_pixel,
     colors,
     depth,
     height,
     length,
     mask,
     max_value,
     number_scenes,
     quantum,
     samples_per_pixel,
     signed_data,
     significant_bits,
     status,
     width,
     window_width;
 
   ssize_t
     count,
     scene,
     window_center,
     y;
 
   unsigned char
     *data;
 
   unsigned short
     group,
     element;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   image->depth=8UL;
   image->endian=LSBEndian;
    
   stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));
   if (stream_info == (DCMStreamInfo *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));
   count=ReadBlob(image,128,(unsigned char *) magick);
   if (count != 128)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   count=ReadBlob(image,4,(unsigned char *) magick);
   if ((count != 4) || (LocaleNCompare(magick,""DICM"",4) != 0))
     {
       offset=SeekBlob(image,0L,SEEK_SET);
       if (offset < 0)
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
    
   (void) CopyMagickString(photometric,""MONOCHROME1 "",MaxTextExtent);
   bits_allocated=8;
   bytes_per_pixel=1;
   polarity=MagickFalse;
   data=(unsigned char *) NULL;
   depth=8;
   element=0;
   explicit_vr[2]='\0';
   explicit_file=MagickFalse;
   colors=0;
   redmap=(int *) NULL;
   greenmap=(int *) NULL;
   bluemap=(int *) NULL;
   graymap=(int *) NULL;
   height=0;
   max_value=255UL;
   mask=0xffff;
   number_scenes=1;
   samples_per_pixel=1;
   scale=(Quantum *) NULL;
   sequence=MagickFalse;
   signed_data=(~0UL);
   significant_bits=0;
   use_explicit=MagickFalse;
   explicit_retry = MagickFalse;
   width=0;
   window_center=0;
   window_width=0;
   for (group=0; (group != 0x7FE0) || (element != 0x0010) ||
                 (sequence != MagickFalse); )
   {
      
     image->offset=(ssize_t) TellBlob(image);
     group=ReadBlobLSBShort(image);
     element=ReadBlobLSBShort(image);
     if ((group != 0x0002) && (image->endian == MSBEndian))
       {
         group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));
         element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));
       }
     quantum=0;
      
     for (i=0; dicom_info[i].group < 0xffff; i++)
       if ((group == dicom_info[i].group) && (element == dicom_info[i].element))
         break;
     (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MaxTextExtent);
     count=ReadBlob(image,2,(unsigned char *) explicit_vr);
     if (count != 2)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      
     if ((explicit_file == MagickFalse) && (group != 0x0002))
       explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&
         (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?
         MagickTrue : MagickFalse;
     use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||
       (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;
     if ((use_explicit != MagickFalse) && (strcmp(implicit_vr,""xs"") == 0))
       (void) CopyMagickString(implicit_vr,explicit_vr,MaxTextExtent);
     if ((use_explicit == MagickFalse) || (strcmp(implicit_vr,""!!"") == 0))
       {
         offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);
         if (offset < 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         quantum=4;
       }
     else
       {
          
         quantum=2;
         if ((strcmp(explicit_vr,""OB"") == 0) ||
             (strcmp(explicit_vr,""UN"") == 0) ||
             (strcmp(explicit_vr,""OW"") == 0) || (strcmp(explicit_vr,""SQ"") == 0))
           {
             (void) ReadBlobLSBShort(image);
             quantum=4;
           }
       }
     datum=0;
     if (quantum == 4)
       {
         if (group == 0x0002)
           datum=(int) ReadBlobLSBLong(image);
         else
           datum=(int) ReadBlobLong(image);
       }
     else
       if (quantum == 2)
         {
           if (group == 0x0002)
             datum=(int) ReadBlobLSBShort(image);
           else
             datum=(int) ReadBlobShort(image);
         }
     quantum=0;
     length=1;
     if (datum != 0)
       {
         if ((strcmp(implicit_vr,""SS"") == 0) ||
             (strcmp(implicit_vr,""US"") == 0))
           quantum=2;
         else
           if ((strcmp(implicit_vr,""UL"") == 0) ||
               (strcmp(implicit_vr,""SL"") == 0) ||
               (strcmp(implicit_vr,""FL"") == 0))
             quantum=4;
           else
             if (strcmp(implicit_vr,""FD"") != 0)
               quantum=1;
             else
               quantum=8;
         if (datum != ~0)
           length=(size_t) datum/quantum;
         else
           {
              
             quantum=0;
             length=0;
           }
       }
     if (image_info->verbose != MagickFalse)
       {
          
         if (use_explicit == MagickFalse)
           explicit_vr[0]='\0';
         for (i=0; dicom_info[i].description != (char *) NULL; i++)
           if ((group == dicom_info[i].group) &&
               (element == dicom_info[i].element))
             break;
         (void) FormatLocaleFile(stdout,""0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)"",
           (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,
           (unsigned long) group,(unsigned long) element);
         if (dicom_info[i].description != (char *) NULL)
           (void) FormatLocaleFile(stdout,"" %s"",dicom_info[i].description);
         (void) FormatLocaleFile(stdout,"": "");
       }
     if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))
       {
         if (image_info->verbose != MagickFalse)
           (void) FormatLocaleFile(stdout,""\n"");
         break;
       }
      
     data=(unsigned char *) NULL;
     if ((length == 1) && (quantum == 1))
       datum=(int) ReadBlobByte(image);
     else
       if ((length == 1) && (quantum == 2))
         {
           if (group == 0x0002)
             datum=(int) ReadBlobLSBShort(image);
           else
             datum=(int) ReadBlobShort(image);
         }
       else
         if ((length == 1) && (quantum == 4))
           {
             if (group == 0x0002)
               datum=(int) ReadBlobLSBLong(image);
             else
               datum=(int) ReadBlobLong(image);
           }
         else
           if ((quantum != 0) && (length != 0))
             {
               if (~length >= 1)
                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*
                   sizeof(*data));
               if (data == (unsigned char *) NULL)
                 ThrowReaderException(ResourceLimitError,
                   ""MemoryAllocationFailed"");
               count=ReadBlob(image,(size_t) quantum*length,data);
               if (count != (ssize_t) (quantum*length))
                 {
                   if (image_info->verbose != MagickFalse)
                     (void) FormatLocaleFile(stdout,""count=%d quantum=%d ""
                       ""length=%d group=%d\n"",(int) count,(int) quantum,(int)
                       length,(int) group);
                    ThrowReaderException(CorruptImageError,
                      ""InsufficientImageDataInFile"");
                 }
               data[length*quantum]='\0';
             }
           else
             if ((unsigned int) datum == 0xFFFFFFFFU)
               {
                 sequence=MagickTrue;
                 continue;
               }
     if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)
       {
         if (data != (unsigned char *) NULL)
           data=(unsigned char *) RelinquishMagickMemory(data);
         sequence=MagickFalse;
         continue;
       }
     if (sequence != MagickFalse)
       {
         if (data != (unsigned char *) NULL)
           data=(unsigned char *) RelinquishMagickMemory(data);
         continue;
       }
     switch (group)
     {
       case 0x0002:
       {
         switch (element)
         {
           case 0x0010:
           {
             char
               transfer_syntax[MaxTextExtent];
 
              
             if ((datum == 0) && (explicit_retry == MagickFalse))
               {
                 explicit_retry=MagickTrue;
                 (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);
                 group=0;
                 element=0;
                 if (image_info->verbose != MagickFalse)
                   (void) FormatLocaleFile(stdout,
                     ""Corrupted image - trying explicit format\n"");
                 break;
               }
             *transfer_syntax='\0';
             if (data != (unsigned char *) NULL)
               (void) CopyMagickString(transfer_syntax,(char *) data,
                 MaxTextExtent);
             if (image_info->verbose != MagickFalse)
               (void) FormatLocaleFile(stdout,""transfer_syntax=%s\n"",
                 (const char *) transfer_syntax);
             if (strncmp(transfer_syntax,""1.2.840.10008.1.2"",17) == 0)
               {
                 int
                   subtype,
                   type;
 
                 type=0;
                 subtype=0;
                 (void) sscanf(transfer_syntax+17,"".%d.%d"",&type,&subtype);
                 switch (type)
                 {
                   case 1:
                   {
                     image->endian=LSBEndian;
                     break;
                   }
                   case 2:
                   {
                     image->endian=MSBEndian;
                     break;
                   }
                   case 4:
                   {
                     if ((subtype >= 80) && (subtype <= 81))
                       image->compression=JPEGCompression;
                     else
                       if ((subtype >= 90) && (subtype <= 93))
                         image->compression=JPEG2000Compression;
                       else
                         image->compression=JPEGCompression;
                     break;
                   }
                   case 5:
                   {
                     image->compression=RLECompression;
                     break;
                   }
                 }
               }
             break;
           }
           default:
             break;
         }
         break;
       }
       case 0x0028:
       {
         switch (element)
         {
           case 0x0002:
           {
              
             samples_per_pixel=(size_t) datum;
             break;
           }
           case 0x0004:
           {
              
             for (i=0; i < (ssize_t) MagickMin(length,MaxTextExtent-1); i++)
               photometric[i]=(char) data[i];
             photometric[i]='\0';
             polarity=LocaleCompare(photometric,""MONOCHROME1 "") == 0 ?
               MagickTrue : MagickFalse;
             break;
           }
           case 0x0006:
           {
              
             if (datum == 1)
               image->interlace=PlaneInterlace;
             break;
           }
           case 0x0008:
           {
              
             number_scenes=StringToUnsignedLong((char *) data);
             break;
           }
           case 0x0010:
           {
              
             height=(size_t) datum;
             break;
           }
           case 0x0011:
           {
              
             width=(size_t) datum;
             break;
           }
           case 0x0100:
           {
              
             bits_allocated=(size_t) datum;
             bytes_per_pixel=1;
             if (datum > 8)
               bytes_per_pixel=2;
             depth=bits_allocated;
             if (depth > 32)
               ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
             max_value=(1UL << bits_allocated)-1;
             break;
           }
           case 0x0101:
           {
              
             significant_bits=(size_t) datum;
             bytes_per_pixel=1;
             if (significant_bits > 8)
               bytes_per_pixel=2;
             depth=significant_bits;
             if (depth > 32)
               ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
             max_value=(1UL << significant_bits)-1;
             mask=(size_t) GetQuantumRange(significant_bits);
             break;
           }
           case 0x0102:
           {
              
             break;
           }
           case 0x0103:
           {
              
             signed_data=(size_t) datum;
             break;
           }
           case 0x1050:
           {
              
             if (data != (unsigned char *) NULL)
               window_center=(ssize_t) StringToLong((char *) data);
             break;
           }
           case 0x1051:
           {
              
             if (data != (unsigned char *) NULL)
               window_width=StringToUnsignedLong((char *) data);
             break;
           }
           case 0x1200:
           case 0x3006:
           {
              
             if (data == (unsigned char *) NULL)
               break;
             colors=(size_t) (length/bytes_per_pixel);
             datum=(int) colors;
             graymap=(int *) AcquireQuantumMemory((size_t) colors,
               sizeof(*graymap));
             if (graymap == (int *) NULL)
               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
             for (i=0; i < (ssize_t) colors; i++)
               if (bytes_per_pixel == 1)
                 graymap[i]=(int) data[i];
               else
                 graymap[i]=(int) ((short *) data)[i];
             break;
           }
           case 0x1201:
           {
             unsigned short
               index;
 
              
             if (data == (unsigned char *) NULL)
               break;
             colors=(size_t) (length/2);
             datum=(int) colors;
             redmap=(int *) AcquireQuantumMemory((size_t) colors,
               sizeof(*redmap));
             if (redmap == (int *) NULL)
               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
             p=data;
             for (i=0; i < (ssize_t) colors; i++)
             {
               if (image->endian == MSBEndian)
                 index=(unsigned short) ((*p << 8) | *(p+1));
               else
                 index=(unsigned short) (*p | (*(p+1) << 8));
               redmap[i]=(int) index;
               p+=2;
             }
             break;
           }
           case 0x1202:
           {
             unsigned short
               index;
 
              
             if (data == (unsigned char *) NULL)
               break;
             colors=(size_t) (length/2);
             datum=(int) colors;
             greenmap=(int *) AcquireQuantumMemory((size_t) colors,
               sizeof(*greenmap));
             if (greenmap == (int *) NULL)
               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
             p=data;
             for (i=0; i < (ssize_t) colors; i++)
             {
               if (image->endian == MSBEndian)
                 index=(unsigned short) ((*p << 8) | *(p+1));
               else
                 index=(unsigned short) (*p | (*(p+1) << 8));
               greenmap[i]=(int) index;
               p+=2;
             }
             break;
           }
           case 0x1203:
           {
             unsigned short
               index;
 
              
             if (data == (unsigned char *) NULL)
               break;
             colors=(size_t) (length/2);
             datum=(int) colors;
             bluemap=(int *) AcquireQuantumMemory((size_t) colors,
               sizeof(*bluemap));
             if (bluemap == (int *) NULL)
               ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
             p=data;
             for (i=0; i < (ssize_t) colors; i++)
             {
               if (image->endian == MSBEndian)
                 index=(unsigned short) ((*p << 8) | *(p+1));
               else
                 index=(unsigned short) (*p | (*(p+1) << 8));
               bluemap[i]=(int) index;
               p+=2;
             }
             break;
           }
           default:
             break;
         }
         break;
       }
       case 0x2050:
       {
         switch (element)
         {
           case 0x0020:
           {
             if ((data != (unsigned char *) NULL) &&
                 (strncmp((char*) data,""INVERSE"", 7) == 0))
               polarity=MagickTrue;
             break;
           }
           default:
             break;
         }
         break;
       }
       default:
         break;
     }
     if (data != (unsigned char *) NULL)
       {
         char
           *attribute;
 
         for (i=0; dicom_info[i].description != (char *) NULL; i++)
           if ((group == dicom_info[i].group) &&
               (element == dicom_info[i].element))
             break;
         if (dicom_info[i].description != (char *) NULL)
           {
             attribute=AcquireString(""dcm:"");
             (void) ConcatenateString(&attribute,dicom_info[i].description);
             for (i=0; i < (ssize_t) MagickMax(length,4); i++)
               if (isprint((int) data[i]) == MagickFalse)
                 break;
             if ((i == (ssize_t) length) || (length > 4))
               {
                 (void) SubstituteString(&attribute,"" "","""");
                 (void) SetImageProperty(image,attribute,(char *) data);
               }
             attribute=DestroyString(attribute);
           }
       }
     if (image_info->verbose != MagickFalse)
       {
         if (data == (unsigned char *) NULL)
           (void) FormatLocaleFile(stdout,""%d\n"",datum);
         else
           {
              
             for (i=0; i < (ssize_t) MagickMax(length,4); i++)
               if (isprint((int) data[i]) == MagickFalse)
                 break;
             if ((i != (ssize_t) length) && (length <= 4))
               {
                 ssize_t
                   j;
 
                 datum=0;
                 for (j=(ssize_t) length-1; j >= 0; j--)
                   datum=(256*datum+data[j]);
                 (void) FormatLocaleFile(stdout,""%d"",datum);
               }
             else
               for (i=0; i < (ssize_t) length; i++)
                 if (isprint((int) data[i]) != MagickFalse)
                   (void) FormatLocaleFile(stdout,""%c"",data[i]);
                 else
                   (void) FormatLocaleFile(stdout,""%c"",'.');
             (void) FormatLocaleFile(stdout,""\n"");
           }
       }
     if (data != (unsigned char *) NULL)
       data=(unsigned char *) RelinquishMagickMemory(data);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
   }
   if ((width == 0) || (height == 0))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   image->columns=(size_t) width;
   image->rows=(size_t) height;
   if (signed_data == 0xffff)
     signed_data=(size_t) (significant_bits == 16 ? 1 : 0);
   if ((image->compression == JPEGCompression) ||
       (image->compression == JPEG2000Compression))
     {
       Image
         *images;
 
       ImageInfo
         *read_info;
 
       int
         c;
 
       size_t
         length;
 
       unsigned int
         tag;
 
        
       for (i=0; i < (ssize_t) stream_info->remaining; i++)
         (void) ReadBlobByte(image);
       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);
       (void) tag;
       length=(size_t) ReadBlobLSBLong(image);
       stream_info->offset_count=length >> 2;
       if (stream_info->offset_count != 0)
         {
           MagickOffsetType
             offset;
 
           stream_info->offsets=(ssize_t *) AcquireQuantumMemory(
             stream_info->offset_count,sizeof(*stream_info->offsets));
           if (stream_info->offsets == (ssize_t *) NULL)
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           for (i=0; i < (ssize_t) stream_info->offset_count; i++)
             stream_info->offsets[i]=(ssize_t) ((int) ReadBlobLSBLong(image));
           offset=TellBlob(image);
           for (i=0; i < (ssize_t) stream_info->offset_count; i++)
             stream_info->offsets[i]+=offset;
         }
        
       read_info=CloneImageInfo(image_info);
       SetImageInfoBlob(read_info,(void *) NULL,0);
       images=NewImageList();
       for (scene=0; scene < (ssize_t) number_scenes; scene++)
       {
         char
           filename[MaxTextExtent];
 
         const char
           *property;
 
         FILE
           *file;
 
         Image
           *jpeg_image;
 
         int
           unique_file;
 
         unsigned int
           tag;
 
         tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);
         length=(size_t) ReadBlobLSBLong(image);
         if (tag == 0xFFFEE0DD)
           break;  
         if (tag != 0xFFFEE000)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         file=(FILE *) NULL;
         unique_file=AcquireUniqueFileResource(filename);
         if (unique_file != -1)
           file=fdopen(unique_file,""wb"");
         if (file == (FILE *) NULL)
           {
             (void) RelinquishUniqueFileResource(filename);
             ThrowFileException(exception,FileOpenError,
               ""UnableToCreateTemporaryFile"",filename);
             break;
           }
         for ( ; length != 0; length--)
         {
           c=ReadBlobByte(image);
           if (c == EOF)
             {
               ThrowFileException(exception,CorruptImageError,
                 ""UnexpectedEndOfFile"",image->filename);
               break;
             }
           (void) fputc(c,file);
         }
         (void) fclose(file);
         (void) FormatLocaleString(read_info->filename,MaxTextExtent,""jpeg:%s"",
           filename);
         if (image->compression == JPEG2000Compression)
           (void) FormatLocaleString(read_info->filename,MaxTextExtent,""j2k:%s"",
             filename);
         jpeg_image=ReadImage(read_info,exception);
         if (jpeg_image != (Image *) NULL)
           {
             ResetImagePropertyIterator(image);
             property=GetNextImageProperty(image);
             while (property != (const char *) NULL)
             {
               (void) SetImageProperty(jpeg_image,property,
                 GetImageProperty(image,property));
               property=GetNextImageProperty(image);
             }
             AppendImageToList(&images,jpeg_image);
           }
         (void) RelinquishUniqueFileResource(filename);
       }
       read_info=DestroyImageInfo(read_info);
       image=DestroyImage(image);
       return(GetFirstImageInList(images));
     }
   if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))
     {
       QuantumAny
         range;
 
       size_t
         length;
 
        
       length=(size_t) (GetQuantumRange(depth)+1);
       scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));
       if (scale == (Quantum *) NULL)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       range=GetQuantumRange(depth);
       for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)
         scale[i]=ScaleAnyToQuantum((size_t) i,range);
     }
   if (image->compression == RLECompression)
     {
       size_t
         length;
 
       unsigned int
         tag;
 
        
       for (i=0; i < (ssize_t) stream_info->remaining; i++)
         (void) ReadBlobByte(image);
       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);
       (void) tag;
       length=(size_t) ReadBlobLSBLong(image);
       stream_info->offset_count=length >> 2;
       if (stream_info->offset_count != 0)
         {
           MagickOffsetType
             offset;
 
           stream_info->offsets=(ssize_t *) AcquireQuantumMemory(
             stream_info->offset_count,sizeof(*stream_info->offsets));
           if (stream_info->offsets == (ssize_t *) NULL)
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           for (i=0; i < (ssize_t) stream_info->offset_count; i++)
             stream_info->offsets[i]=(ssize_t) ((int) ReadBlobLSBLong(image));
           offset=TellBlob(image);
           for (i=0; i < (ssize_t) stream_info->offset_count; i++)
             stream_info->offsets[i]+=offset;
         }
     }
   for (scene=0; scene < (ssize_t) number_scenes; scene++)
   {
     if (image_info->ping != MagickFalse)
       break;
      image->columns=(size_t) width;
      image->rows=(size_t) height;
      image->depth=depth;
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
         InheritException(exception,&image->exception);
         break;
       }
      image->colorspace=RGBColorspace;
      if ((image->colormap == (PixelPacket *) NULL) && (samples_per_pixel == 1))
        {
         size_t
           one;
 
         one=1;
         if (colors == 0)
           colors=one << depth;
         if (AcquireImageColormap(image,one << depth) == MagickFalse)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         if (redmap != (int *) NULL)
           for (i=0; i < (ssize_t) colors; i++)
           {
             index=redmap[i];
             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))
               index=(int) scale[index];
             image->colormap[i].red=(Quantum) index;
           }
         if (greenmap != (int *) NULL)
           for (i=0; i < (ssize_t) colors; i++)
           {
             index=greenmap[i];
             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))
               index=(int) scale[index];
             image->colormap[i].green=(Quantum) index;
           }
         if (bluemap != (int *) NULL)
           for (i=0; i < (ssize_t) colors; i++)
           {
             index=bluemap[i];
             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))
               index=(int) scale[index];
             image->colormap[i].blue=(Quantum) index;
           }
         if (graymap != (int *) NULL)
           for (i=0; i < (ssize_t) colors; i++)
           {
             index=graymap[i];
             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))
               index=(int) scale[index];
             image->colormap[i].red=(Quantum) index;
             image->colormap[i].green=(Quantum) index;
             image->colormap[i].blue=(Quantum) index;
           }
       }
     if (image->compression == RLECompression)
       {
         unsigned int
           tag;
 
          
         for (i=0; i < (ssize_t) stream_info->remaining; i++)
           (void) ReadBlobByte(image);
         tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);
         stream_info->remaining=(size_t) ReadBlobLSBLong(image);
         if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||
             (EOFBlob(image) != MagickFalse))
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         stream_info->count=0;
         stream_info->segment_count=ReadBlobLSBLong(image);
         if (stream_info->segment_count > 1)
           {
             bytes_per_pixel=1;
             depth=8;
           }
         for (i=0; i < 15; i++)
           stream_info->segments[i]=(ssize_t) ((int) ReadBlobLSBLong(image));
         stream_info->remaining-=64;
       }
     if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))
       {
          
         for (i=0; i < (ssize_t) samples_per_pixel; i++)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (PixelPacket *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               switch ((int) i)
               {
                 case 0:
                 {
                   SetPixelRed(q,ScaleCharToQuantum((unsigned char)
                     ReadDCMByte(stream_info,image)));
                   break;
                 }
                 case 1:
                 {
                   SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
                     ReadDCMByte(stream_info,image)));
                   break;
                 }
                 case 2:
                 {
                   SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
                     ReadDCMByte(stream_info,image)));
                   break;
                 }
                 case 3:
                 {
                   SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)
                     ReadDCMByte(stream_info,image)));
                   break;
                 }
                 default:
                   break;
               }
               q++;
             }
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                   image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
         }
       }
     else
       {
         const char
           *option;
 
         int
           byte;
 
         LongPixelPacket
           pixel;
 
          
         byte=0;
         i=0;
         if ((window_center != 0) && (window_width == 0))
           window_width=(size_t) window_center;
         option=GetImageOption(image_info,""dcm:display-range"");
         if (option != (const char *) NULL)
           {
             if (LocaleCompare(option,""reset"") == 0)
               window_width=0;
           }
         (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           indexes=GetAuthenticIndexQueue(image);
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             if (samples_per_pixel == 1)
               {
                 int
                   pixel_value;
 
                 if (bytes_per_pixel == 1)
                   pixel_value=polarity != MagickFalse ? ((int) max_value-
                     ReadDCMByte(stream_info,image)) :
                     ReadDCMByte(stream_info,image);
                 else
                   if ((bits_allocated != 12) || (significant_bits != 12))
                     pixel_value=(int) (polarity != MagickFalse ? (max_value-
                       ReadDCMShort(stream_info,image)) :
                       ReadDCMShort(stream_info,image));
                   else
                     {
                       if ((i & 0x01) != 0)
                         pixel_value=(ReadDCMByte(stream_info,image) << 8) |
                           byte;
                       else
                         {
                           pixel_value=(int) ReadDCMShort(stream_info,image);
                           byte=(int) (pixel_value & 0x0f);
                           pixel_value>>=4;
                         }
                       i++;
                     }
                 index=pixel_value;
                 if (window_width == 0)
                   {
                     if (signed_data == 1)
                       index=pixel_value-32767;
                   }
                 else
                   {
                     ssize_t
                       window_max,
                       window_min;
 
                     window_min=(ssize_t) ceil((double) window_center-
                       (window_width-1.0)/2.0-0.5);
                     window_max=(ssize_t) floor((double) window_center+
                       (window_width-1.0)/2.0+0.5);
                     if ((ssize_t) pixel_value <= window_min)
                       index=0;
                     else
                       if ((ssize_t) pixel_value > window_max)
                         index=(int) max_value;
                       else
                         index=(int) (max_value*(((pixel_value-window_center-
                           0.5)/(window_width-1))+0.5));
                   }
                 index&=mask;
                 index=(int) ConstrainColormapIndex(image,(size_t) index);
                 SetPixelIndex(indexes+x,index);
                 pixel.red=1U*image->colormap[index].red;
                 pixel.green=1U*image->colormap[index].green;
                 pixel.blue=1U*image->colormap[index].blue;
               }
             else
               {
                 if (bytes_per_pixel == 1)
                   {
                     pixel.red=(unsigned int) ReadDCMByte(stream_info,image);
                     pixel.green=(unsigned int) ReadDCMByte(stream_info,image);
                     pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);
                   }
                 else
                   {
                     pixel.red=ReadDCMShort(stream_info,image);
                     pixel.green=ReadDCMShort(stream_info,image);
                     pixel.blue=ReadDCMShort(stream_info,image);
                   }
                 pixel.red&=mask;
                 pixel.green&=mask;
                 pixel.blue&=mask;
                 if (scale != (Quantum *) NULL)
                   {
                     pixel.red=scale[pixel.red];
                     pixel.green=scale[pixel.green];
                     pixel.blue=scale[pixel.blue];
                   }
               }
             SetPixelRed(q,pixel.red);
             SetPixelGreen(q,pixel.green);
             SetPixelBlue(q,pixel.blue);
             q++;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         if (stream_info->segment_count > 1)
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (PixelPacket *) NULL)
               break;
             indexes=GetAuthenticIndexQueue(image);
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (samples_per_pixel == 1)
                 {
                   int
                     pixel_value;
 
                   if (bytes_per_pixel == 1)
                     pixel_value=polarity != MagickFalse ? ((int) max_value-
                       ReadDCMByte(stream_info,image)) :
                       ReadDCMByte(stream_info,image);
                   else
                     if ((bits_allocated != 12) || (significant_bits != 12))
                       {
                         pixel_value=(int) (polarity != MagickFalse ? (max_value-
                           ReadDCMShort(stream_info,image)) :
                           ReadDCMShort(stream_info,image));
                         if (signed_data == 1)
                           pixel_value=((signed short) pixel_value);
                       }
                     else
                       {
                         if ((i & 0x01) != 0)
                           pixel_value=(ReadDCMByte(stream_info,image) << 8) |
                             byte;
                         else
                           {
                             pixel_value=(int) ReadDCMShort(stream_info,image);
                             byte=(int) (pixel_value & 0x0f);
                             pixel_value>>=4;
                           }
                         i++;
                       }
                   index=pixel_value;
                   if (window_width == 0)
                     {
                       if (signed_data == 1)
                         index=pixel_value-32767;
                     }
                   else
                     {
                       ssize_t
                         window_max,
                         window_min;
 
                       window_min=(ssize_t) ceil((double) window_center-
                         (window_width-1.0)/2.0-0.5);
                       window_max=(ssize_t) floor((double) window_center+
                         (window_width-1.0)/2.0+0.5);
                       if ((ssize_t) pixel_value <= window_min)
                         index=0;
                       else
                         if ((ssize_t) pixel_value > window_max)
                           index=(int) max_value;
                         else
                           index=(int) (max_value*(((pixel_value-window_center-
                             0.5)/(window_width-1))+0.5));
                     }
                   index&=mask;
                   index=(int) ConstrainColormapIndex(image,(size_t) index);
                   SetPixelIndex(indexes+x,(((size_t) GetPixelIndex(indexes+x)) |
                     (((size_t) index) << 8)));
                   pixel.red=1U*image->colormap[index].red;
                   pixel.green=1U*image->colormap[index].green;
                   pixel.blue=1U*image->colormap[index].blue;
                 }
               else
                 {
                   if (bytes_per_pixel == 1)
                     {
                       pixel.red=(unsigned int) ReadDCMByte(stream_info,image);
                       pixel.green=(unsigned int) ReadDCMByte(stream_info,image);
                       pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);
                     }
                   else
                     {
                       pixel.red=ReadDCMShort(stream_info,image);
                       pixel.green=ReadDCMShort(stream_info,image);
                       pixel.blue=ReadDCMShort(stream_info,image);
                     }
                   pixel.red&=mask;
                   pixel.green&=mask;
                   pixel.blue&=mask;
                   if (scale != (Quantum *) NULL)
                     {
                       pixel.red=scale[pixel.red];
                       pixel.green=scale[pixel.green];
                       pixel.blue=scale[pixel.blue];
                     }
                 }
               SetPixelRed(q,(((size_t) GetPixelRed(q)) |
                 (((size_t) pixel.red) << 8)));
               SetPixelGreen(q,(((size_t) GetPixelGreen(q)) |
                 (((size_t) pixel.green) << 8)));
               SetPixelBlue(q,(((size_t) GetPixelBlue(q)) |
                 (((size_t) pixel.blue) << 8)));
               q++;
             }
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                   image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
       }
     if (IsGrayImage(image,exception) != MagickFalse)
       (void) SetImageColorspace(image,GRAYColorspace);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     if (scene < (ssize_t) (number_scenes-1))
       {
          
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   }
    
   if (stream_info->offsets != (ssize_t *) NULL)
     stream_info->offsets=(ssize_t *)
       RelinquishMagickMemory(stream_info->offsets);
   stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);
   if (scale != (Quantum *) NULL)
     scale=(Quantum *) RelinquishMagickMemory(scale);
   if (graymap != (int *) NULL)
     graymap=(int *) RelinquishMagickMemory(graymap);
   if (bluemap != (int *) NULL)
     bluemap=(int *) RelinquishMagickMemory(bluemap);
   if (greenmap != (int *) NULL)
     greenmap=(int *) RelinquishMagickMemory(greenmap);
   if (redmap != (int *) NULL)
     redmap=(int *) RelinquishMagickMemory(redmap);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[848, 849, 850, 851, 852, 853]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
207779,"  static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)
  {
    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));
     UINT16 buflen = (UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR));
     if (buflen < len) {
       android_errorWriteWithInfoLog(0x534e4554, ""28672558"", -1, NULL, 0);
       return NULL;
     }
     BT_HDR* p_buf = GKI_getbuf(buflen);
  
      if (p_buf) {
          UINT8* pbuf_data;
 
         p_buf->len = len;
         p_buf->offset = BTA_HH_MIN_OFFSET;
 
         pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset;
         memcpy(pbuf_data, data, len);
  }
  return p_buf;
 }","[4, 5, 6, 7, 8, 9, 3]","Buffer overflow in the create_pbuf function in btif/src/btif_hh.c in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows remote attackers to gain privileges via a crafted pairing operation, aka internal bug 27930580."
206637," void WebContentsImpl::CreateNewWindow(
     RenderFrameHost* opener,
     int32_t render_view_route_id,
     int32_t main_frame_route_id,
     int32_t main_frame_widget_route_id,
     const mojom::CreateNewWindowParams& params,
     SessionStorageNamespace* session_storage_namespace) {
   DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),
             (main_frame_route_id == MSG_ROUTING_NONE));
   DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),
             (main_frame_widget_route_id == MSG_ROUTING_NONE));
   DCHECK(opener);
 
   int render_process_id = opener->GetProcess()->GetID();
   SiteInstance* source_site_instance = opener->GetSiteInstance();
 
   DCHECK(!RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id));
 
   bool is_guest = BrowserPluginGuest::IsGuest(this);
 
   DCHECK(!params.opener_suppressed || render_view_route_id == MSG_ROUTING_NONE);
 
   scoped_refptr<SiteInstance> site_instance =
       params.opener_suppressed && !is_guest
           ? SiteInstance::CreateForURL(GetBrowserContext(), params.target_url)
           : source_site_instance;
 
   const std::string& partition_id =
       GetContentClient()->browser()->
           GetStoragePartitionIdForSite(GetBrowserContext(),
                                        site_instance->GetSiteURL());
   StoragePartition* partition = BrowserContext::GetStoragePartition(
       GetBrowserContext(), site_instance.get());
   DOMStorageContextWrapper* dom_storage_context =
       static_cast<DOMStorageContextWrapper*>(partition->GetDOMStorageContext());
   SessionStorageNamespaceImpl* session_storage_namespace_impl =
       static_cast<SessionStorageNamespaceImpl*>(session_storage_namespace);
   CHECK(session_storage_namespace_impl->IsFromContext(dom_storage_context));
 
   if (delegate_ &&
       !delegate_->ShouldCreateWebContents(
           this, opener, source_site_instance, render_view_route_id,
           main_frame_route_id, main_frame_widget_route_id,
           params.window_container_type, opener->GetLastCommittedURL(),
           params.frame_name, params.target_url, partition_id,
           session_storage_namespace)) {
     RenderFrameHostImpl* rfh =
         RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id);
     if (rfh) {
       DCHECK(rfh->IsRenderFrameLive());
       rfh->Init();
     }
     return;
   }
 
   CreateParams create_params(GetBrowserContext(), site_instance.get());
   create_params.routing_id = render_view_route_id;
   create_params.main_frame_routing_id = main_frame_route_id;
   create_params.main_frame_widget_routing_id = main_frame_widget_route_id;
   create_params.main_frame_name = params.frame_name;
   create_params.opener_render_process_id = render_process_id;
   create_params.opener_render_frame_id = opener->GetRoutingID();
   create_params.opener_suppressed = params.opener_suppressed;
   if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB)
     create_params.initially_hidden = true;
   create_params.renderer_initiated_creation =
       main_frame_route_id != MSG_ROUTING_NONE;
 
   std::unique_ptr<WebContents> new_contents;
   if (!is_guest) {
     create_params.context = view_->GetNativeView();
     create_params.initial_size = GetContainerBounds().size();
     new_contents = WebContents::Create(create_params);
   }  else {
     new_contents = base::WrapUnique(
         GetBrowserPluginGuest()->CreateNewGuestWindow(create_params));
   }
   WebContentsImpl* raw_new_contents =
       static_cast<WebContentsImpl*>(new_contents.get());
   raw_new_contents->GetController().SetSessionStorageNamespace(
       partition_id, session_storage_namespace);
 
   if (!params.frame_name.empty())
     raw_new_contents->GetRenderManager()->CreateProxiesForNewNamedFrame();
 
   if (!params.opener_suppressed) {
     if (!is_guest) {
       WebContentsView* new_view = raw_new_contents->view_.get();
 
       new_view->CreateViewForWidget(
           new_contents->GetRenderViewHost()->GetWidget(), false);
     }
     DCHECK_NE(MSG_ROUTING_NONE, main_frame_widget_route_id);
     pending_contents_[std::make_pair(render_process_id,
                                      main_frame_widget_route_id)] =
         std::move(new_contents);
     AddDestructionObserver(raw_new_contents);
   }
 
   if (delegate_) {
     delegate_->WebContentsCreated(this, render_process_id,
                                   opener->GetRoutingID(), params.frame_name,
                                   params.target_url, raw_new_contents);
   }
 
   if (opener) {
     for (auto& observer : observers_) {
       observer.DidOpenRequestedURL(raw_new_contents, opener, params.target_url,
                                    params.referrer, params.disposition,
                                    ui::PAGE_TRANSITION_LINK,
                                    false,   
                                    true);   
     }
   }
  
  if (IsFullscreenForCurrentTab())
    ExitFullscreen(true);
   ForSecurityDropFullscreen();
  
    if (params.opener_suppressed) {
     bool was_blocked = false;
 
     base::WeakPtr<WebContentsImpl> weak_new_contents =
         raw_new_contents->weak_factory_.GetWeakPtr();
     if (delegate_) {
       gfx::Rect initial_rect;
 
       delegate_->AddNewContents(this, std::move(new_contents),
                                 params.disposition, initial_rect,
                                 params.mimic_user_gesture, &was_blocked);
       if (!weak_new_contents)
         return;   
     }
 
     if (!was_blocked) {
       OpenURLParams open_params(params.target_url, params.referrer,
                                 WindowOpenDisposition::CURRENT_TAB,
                                 ui::PAGE_TRANSITION_LINK,
                                 true  );
       open_params.user_gesture = params.mimic_user_gesture;
 
       if (delegate_ && !is_guest &&
           !delegate_->ShouldResumeRequestsForCreatedWindow()) {
         DCHECK(weak_new_contents);
         weak_new_contents->delayed_open_url_params_.reset(
             new OpenURLParams(open_params));
       } else {
         weak_new_contents->OpenURL(open_params);
       }
     }
   }
 }","[118, 116, 117]",Incorrect dialog placement in WebContents in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to obscure the full screen warning via a crafted HTML page.
208038,"  static void copyMono24(
          short *dst,
        const int *const *src,
         const int * src[FLACParser::kMaxChannels],
          unsigned nSamples,
          unsigned  ) {
      for (unsigned i = 0; i < nSamples; ++i) {
  *dst++ = src[0][i] >> 8;
  }
 }","[4, 3]","A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788."
202350," SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)
 {
 	struct k_itimer *timr;
 	int overrun;
 	unsigned long flags;
 
 	timr = lock_timer(timer_id, &flags);
  	if (!timr)
  		return -EINVAL;
  
	overrun = timr->it_overrun_last;
 	overrun = timer_overrun_to_int(timr, 0);
  	unlock_timer(timr, flags);
  
  	return overrun;
 }","[12, 11]","An issue was discovered in the Linux kernel through 4.17.3. An Integer Overflow in kernel/time/posix-timers.c in the POSIX timer code is caused by the way the overrun accounting works. Depending on interval and expiry time values, the overrun can be larger than INT_MAX, but the accounting is int based. This basically makes the accounting values, which are visible to user space via timer_getoverrun(2) and siginfo::si_overrun, random. For example, a local user can cause a denial of service (signed integer overflow) via crafted mmap, futex, timer_create, and timer_settime system calls."
207001," download::DownloadInterruptReason DownloadManagerImpl::BeginDownloadRequest(
     std::unique_ptr<net::URLRequest> url_request,
     ResourceContext* resource_context,
     download::DownloadUrlParameters* params) {
   if (ResourceDispatcherHostImpl::Get()->is_shutdown())
     return download::DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN;
 
   ResourceDispatcherHostImpl::Get()->InitializeURLRequest(
       url_request.get(),
       Referrer(params->referrer(),
                Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
                     params->referrer_policy())),
        true,   
        params->render_process_host_id(), params->render_view_host_routing_id(),
      params->render_frame_host_routing_id(), PREVIEWS_OFF, resource_context);
       params->render_frame_host_routing_id(), params->frame_tree_node_id(),
       PREVIEWS_OFF, resource_context);
  
   url_request->set_first_party_url_policy(
       net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);
 
   const GURL& url = url_request->original_url();
 
   const net::URLRequestContext* request_context = url_request->context();
   if (!request_context->job_factory()->IsHandledProtocol(url.scheme())) {
     DVLOG(1) << ""Download request for unsupported protocol: ""
              << url.possibly_invalid_spec();
     return download::DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST;
   }
 
   std::unique_ptr<ResourceHandler> handler(
       DownloadResourceHandler::CreateForNewRequest(
           url_request.get(), params->request_origin(),
           params->download_source(), params->follow_cross_origin_redirects()));
 
   ResourceDispatcherHostImpl::Get()->BeginURLRequest(
       std::move(url_request), std::move(handler), true,   
       params->content_initiated(), params->do_not_prompt_for_login(),
       resource_context);
   return download::DOWNLOAD_INTERRUPT_REASON_NONE;
 }","[16, 17, 15]",Inappropriate implementation in Blink in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to bypass same origin policy via a crafted HTML page.
201939," static Image *ReadTIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   const char
     *option;
 
   float
     *chromaticity,
     x_position,
     y_position,
     x_resolution,
     y_resolution;
 
   Image
     *image;
 
   int
     tiff_status;
 
   MagickBooleanType
     status;
 
   MagickSizeType
     number_pixels;
 
   QuantumInfo
     *quantum_info;
 
   QuantumType
     quantum_type;
 
   register ssize_t
     i;
 
   size_t
     pad;
 
   ssize_t
     y;
 
   TIFF
     *tiff;
 
   TIFFMethodType
     method;
 
   uint16
     compress_tag,
     bits_per_sample,
     endian,
     extra_samples,
     interlace,
     max_sample_value,
     min_sample_value,
     orientation,
     pages,
     photometric,
     *sample_info,
     sample_format,
     samples_per_pixel,
     units,
     value;
 
   uint32
     height,
     rows_per_strip,
     width;
 
   unsigned char
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   (void) SetMagickThreadValue(tiff_exception,exception);
   tiff=TIFFClientOpen(image->filename,""rb"",(thandle_t) image,TIFFReadBlob,
     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,
     TIFFUnmapBlob);
   if (tiff == (TIFF *) NULL)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   if (image_info->number_scenes != 0)
     {
        
       if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))
         {
           for (i=0; i < (ssize_t) image_info->scene; i++)
           {
             status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;
             if (status == MagickFalse)
               {
                 TIFFClose(tiff);
                 image=DestroyImageList(image);
                 return((Image *) NULL);
               }
             AcquireNextImage(image_info,image,exception);
             if (GetNextImageInList(image) == (Image *) NULL)
               {
                 TIFFClose(tiff);
                 image=DestroyImageList(image);
                 return((Image *) NULL);
               }
             image=SyncNextImageInList(image);
           }
       }
   }
   do
   {
 DisableMSCWarning(4127)
     if (0 && (image_info->verbose != MagickFalse))
       TIFFPrintDirectory(tiff,stdout,MagickFalse);
 RestoreMSCWarning
     if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||
         (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))
       {
         TIFFClose(tiff);
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       }
     if (sample_format == SAMPLEFORMAT_IEEEFP)
       (void) SetImageProperty(image,""quantum:format"",""floating-point"",
         exception);
     switch (photometric)
     {
       case PHOTOMETRIC_MINISBLACK:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""min-is-black"",
           exception);
         break;
       }
       case PHOTOMETRIC_MINISWHITE:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""min-is-white"",
           exception);
         break;
       }
       case PHOTOMETRIC_PALETTE:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""palette"",exception);
         break;
       }
       case PHOTOMETRIC_RGB:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""RGB"",exception);
         break;
       }
       case PHOTOMETRIC_CIELAB:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""CIELAB"",exception);
         break;
       }
       case PHOTOMETRIC_LOGL:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""CIE Log2(L)"",
           exception);
         break;
       }
       case PHOTOMETRIC_LOGLUV:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""LOGLUV"",exception);
         break;
       }
 #if defined(PHOTOMETRIC_MASK)
       case PHOTOMETRIC_MASK:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""MASK"",exception);
         break;
       }
 #endif
       case PHOTOMETRIC_SEPARATED:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""separated"",exception);
         break;
       }
       case PHOTOMETRIC_YCBCR:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""YCBCR"",exception);
         break;
       }
       default:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""unknown"",exception);
         break;
       }
     }
     if (image->debug != MagickFalse)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %ux%u"",
           (unsigned int) width,(unsigned int) height);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Interlace: %u"",
           interlace);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Bits per sample: %u"",bits_per_sample);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Min sample value: %u"",min_sample_value);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Max sample value: %u"",max_sample_value);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Photometric ""
           ""interpretation: %s"",GetImageProperty(image,""tiff:photometric"",
           exception));
       }
     image->columns=(size_t) width;
     image->rows=(size_t) height;
     image->depth=(size_t) bits_per_sample;
     if (image->debug != MagickFalse)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Image depth: %.20g"",
         (double) image->depth);
     image->endian=MSBEndian;
     if (endian == FILLORDER_LSB2MSB)
       image->endian=LSBEndian;
 #if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)
     if (TIFFIsBigEndian(tiff) == 0)
       {
         (void) SetImageProperty(image,""tiff:endian"",""lsb"",exception);
         image->endian=LSBEndian;
       }
     else
       {
         (void) SetImageProperty(image,""tiff:endian"",""msb"",exception);
         image->endian=MSBEndian;
       }
 #endif
     if ((photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       SetImageColorspace(image,GRAYColorspace,exception);
     if (photometric == PHOTOMETRIC_SEPARATED)
       SetImageColorspace(image,CMYKColorspace,exception);
     if (photometric == PHOTOMETRIC_CIELAB)
       SetImageColorspace(image,LabColorspace,exception);
     TIFFGetProfiles(tiff,image,image_info->ping,exception);
     TIFFGetProperties(tiff,image,exception);
     option=GetImageOption(image_info,""tiff:exif-properties"");
     if (IsStringFalse(option) == MagickFalse)  
       TIFFGetEXIFProperties(tiff,image,exception);
     (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,
       &samples_per_pixel);
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))
       {
         image->resolution.x=x_resolution;
         image->resolution.y=y_resolution;
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)
       {
         if (units == RESUNIT_INCH)
           image->units=PixelsPerInchResolution;
         if (units == RESUNIT_CENTIMETER)
           image->units=PixelsPerCentimeterResolution;
       }
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))
       {
         image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);
         image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)
       image->orientation=(OrientationType) orientation;
     if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)
       {
         if (chromaticity != (float *) NULL)
           {
             image->chromaticity.white_point.x=chromaticity[0];
             image->chromaticity.white_point.y=chromaticity[1];
           }
       }
     if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)
       {
         if (chromaticity != (float *) NULL)
           {
             image->chromaticity.red_primary.x=chromaticity[0];
             image->chromaticity.red_primary.y=chromaticity[1];
             image->chromaticity.green_primary.x=chromaticity[2];
             image->chromaticity.green_primary.y=chromaticity[3];
             image->chromaticity.blue_primary.x=chromaticity[4];
             image->chromaticity.blue_primary.y=chromaticity[5];
           }
       }
 #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)
     if ((compress_tag != COMPRESSION_NONE) &&
         (TIFFIsCODECConfigured(compress_tag) == 0))
       {
         TIFFClose(tiff);
         ThrowReaderException(CoderError,""CompressNotSupported"");
       }
 #endif
     switch (compress_tag)
     {
       case COMPRESSION_NONE: image->compression=NoCompression; break;
       case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;
       case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;
       case COMPRESSION_JPEG:
       {
          image->compression=JPEGCompression;
 #if defined(JPEG_SUPPORT)
          {
            char
              sampling_factor[MagickPathExtent];
 
            int
              tiff_status;
 
            uint16
              horizontal,
              vertical;
 
            tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_YCBCRSUBSAMPLING,
              &horizontal,&vertical);
            if (tiff_status == 1)
              {
                (void) FormatLocaleString(sampling_factor,MagickPathExtent,
                  ""%dx%d"",horizontal,vertical);
                (void) SetImageProperty(image,""jpeg:sampling-factor"",
                  sampling_factor,exception);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""Sampling Factors: %s"",sampling_factor);
              }
          }
 #endif
         break;
       }
       case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;
 #if defined(COMPRESSION_LZMA)
       case COMPRESSION_LZMA: image->compression=LZMACompression; break;
 #endif
       case COMPRESSION_LZW: image->compression=LZWCompression; break;
       case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;
        case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;
        default: image->compression=RLECompression; break;
      }
     
    quantum_info=AcquireQuantumInfo(image_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      {
        TIFFClose(tiff);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if (sample_format == SAMPLEFORMAT_UINT)
      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
    if (sample_format == SAMPLEFORMAT_INT)
      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
    if (sample_format == SAMPLEFORMAT_IEEEFP)
      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
    if (status == MagickFalse)
      {
        TIFFClose(tiff);
        quantum_info=DestroyQuantumInfo(quantum_info);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    status=MagickTrue;
    switch (photometric)
    {
      case PHOTOMETRIC_MINISBLACK:
      {
        quantum_info->min_is_white=MagickFalse;
        break;
      }
      case PHOTOMETRIC_MINISWHITE:
      {
        quantum_info->min_is_white=MagickTrue;
        break;
      }
      default:
        break;
    }
    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
      &sample_info);
    if (tiff_status == 1)
      {
        (void) SetImageProperty(image,""tiff:alpha"",""unspecified"",exception);
        if (extra_samples == 0)
          {
            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
              image->alpha_trait=BlendPixelTrait;
          }
        else
          for (i=0; i < extra_samples; i++)
          {
            image->alpha_trait=BlendPixelTrait;
            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
              {
                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
                (void) SetImageProperty(image,""tiff:alpha"",""associated"",
                  exception);
              }
            else
              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
                (void) SetImageProperty(image,""tiff:alpha"",""unassociated"",
                  exception);
          }
      }
     quantum_info=(QuantumInfo *) NULL;
      if ((photometric == PHOTOMETRIC_PALETTE) &&
          (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))
        {
         size_t
           colors;
 
         colors=(size_t) GetQuantumRange(bits_per_sample)+1;
         if (AcquireImageColormap(image,colors,exception) == MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
       }
     value=(unsigned short) image->scene;
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)
       image->scene=value;
     if (image->storage_class == PseudoClass)
       {
         int
           tiff_status;
 
         size_t
           range;
 
         uint16
           *blue_colormap,
           *green_colormap,
           *red_colormap;
 
          
         tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,
           &green_colormap,&blue_colormap);
         if (tiff_status == 1)
           {
             if ((red_colormap != (uint16 *) NULL) &&
                 (green_colormap != (uint16 *) NULL) &&
                 (blue_colormap != (uint16 *) NULL))
               {
                 range=255;   
                 for (i=0; i < (ssize_t) image->colors; i++)
                   if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||
                       (blue_colormap[i] >= 256))
                     {
                       range=65535;
                       break;
                     }
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   image->colormap[i].red=ClampToQuantum(((double)
                     QuantumRange*red_colormap[i])/range);
                   image->colormap[i].green=ClampToQuantum(((double)
                     QuantumRange*green_colormap[i])/range);
                   image->colormap[i].blue=ClampToQuantum(((double)
                     QuantumRange*blue_colormap[i])/range);
                 }
               }
           }
         if (image->alpha_trait == UndefinedPixelTrait)
           image->depth=GetImageDepth(image,exception);
       }
     if (image_info->ping != MagickFalse)
        {
          if (image_info->number_scenes != 0)
            if (image->scene >= (image_info->scene+image_info->number_scenes-1))
            {
              quantum_info=DestroyQuantumInfo(quantum_info);
              break;
            }
             break;
          goto next_tiff_frame;
        }
      status=SetImageExtent(image,image->columns,image->rows,exception);
      if (status == MagickFalse)
        return(DestroyImageList(image));
      
     quantum_info=AcquireQuantumInfo(image_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       {
         TIFFClose(tiff);
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     if (sample_format == SAMPLEFORMAT_UINT)
       status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
     if (sample_format == SAMPLEFORMAT_INT)
       status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
     if (sample_format == SAMPLEFORMAT_IEEEFP)
       status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
     if (status == MagickFalse)
       {
         TIFFClose(tiff);
         quantum_info=DestroyQuantumInfo(quantum_info);
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     status=MagickTrue;
     switch (photometric)
     {
       case PHOTOMETRIC_MINISBLACK:
       {
         quantum_info->min_is_white=MagickFalse;
         break;
       }
       case PHOTOMETRIC_MINISWHITE:
       {
         quantum_info->min_is_white=MagickTrue;
         break;
       }
       default:
         break;
     }
     tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
       &sample_info);
     if (tiff_status == 1)
       {
         (void) SetImageProperty(image,""tiff:alpha"",""unspecified"",exception);
         if (extra_samples == 0)
           {
             if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
               image->alpha_trait=BlendPixelTrait;
           }
         else
           for (i=0; i < extra_samples; i++)
           {
             image->alpha_trait=BlendPixelTrait;
             if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
               {
                 SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
                 (void) SetImageProperty(image,""tiff:alpha"",""associated"",
                   exception);
               }
             else
               if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
                 (void) SetImageProperty(image,""tiff:alpha"",""unassociated"",
                   exception);
           }
       }
      method=ReadGenericMethod;
      if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
        {
         char
           value[MagickPathExtent];
 
         method=ReadStripMethod;
         (void) FormatLocaleString(value,MagickPathExtent,""%u"",
           (unsigned int) rows_per_strip);
         (void) SetImageProperty(image,""tiff:rows-per-strip"",value,exception);
       }
     if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))
       method=ReadRGBAMethod;
     if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))
       method=ReadCMYKAMethod;
     if ((photometric != PHOTOMETRIC_RGB) &&
         (photometric != PHOTOMETRIC_CIELAB) &&
         (photometric != PHOTOMETRIC_SEPARATED))
       method=ReadGenericMethod;
     if (image->storage_class == PseudoClass)
       method=ReadSingleSampleMethod;
     if ((photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       method=ReadSingleSampleMethod;
     if ((photometric != PHOTOMETRIC_SEPARATED) &&
         (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))
       method=ReadGenericMethod;
     if (image->compression == JPEGCompression)
       method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,
         samples_per_pixel);
     if (compress_tag == COMPRESSION_JBIG)
       method=ReadStripMethod;
     if (TIFFIsTiled(tiff) != MagickFalse)
       method=ReadTileMethod;
     quantum_info->endian=LSBEndian;
     quantum_type=RGBQuantum;
     pixels=(unsigned char *) GetQuantumPixels(quantum_info);
     switch (method)
     {
       case ReadSingleSampleMethod:
       {
          
         quantum_type=IndexQuantum;
         pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);
         if (image->alpha_trait != UndefinedPixelTrait)
           {
             if (image->storage_class != PseudoClass)
               {
                 quantum_type=samples_per_pixel == 1 ? AlphaQuantum :
                   GrayAlphaQuantum;
                 pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);
               }
             else
               {
                 quantum_type=IndexAlphaQuantum;
                 pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);
               }
           }
         else
           if (image->storage_class != PseudoClass)
             {
               quantum_type=GrayQuantum;
               pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);
             }
         status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(
           bits_per_sample)/log(2))));
         if (status == MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixels=(unsigned char *) GetQuantumPixels(quantum_info);
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           int
             status;
 
           register Quantum
             *magick_restrict q;
 
           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);
           if (status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadRGBAMethod:
       {
          
         pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
         quantum_type=RGBQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           {
             quantum_type=RGBAQuantum;
             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
           }
         if (image->colorspace == CMYKColorspace)
           {
             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
             quantum_type=CMYKQuantum;
             if (image->alpha_trait != UndefinedPixelTrait)
               {
                 quantum_type=CMYKAQuantum;
                 pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
               }
           }
         status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
         if (status == MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixels=(unsigned char *) GetQuantumPixels(quantum_info);
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           int
             status;
 
           register Quantum
             *magick_restrict q;
 
           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);
           if (status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadCMYKAMethod:
       {
          
         for (i=0; i < (ssize_t) samples_per_pixel; i++)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             int
               status;
 
             status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)
               pixels);
             if (status == -1)
               break;
             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             if (image->colorspace != CMYKColorspace)
               switch (i)
               {
                 case 0: quantum_type=RedQuantum; break;
                 case 1: quantum_type=GreenQuantum; break;
                 case 2: quantum_type=BlueQuantum; break;
                 case 3: quantum_type=AlphaQuantum; break;
                 default: quantum_type=UndefinedQuantum; break;
               }
             else
               switch (i)
               {
                 case 0: quantum_type=CyanQuantum; break;
                 case 1: quantum_type=MagentaQuantum; break;
                 case 2: quantum_type=YellowQuantum; break;
                 case 3: quantum_type=BlackQuantum; break;
                 case 4: quantum_type=AlphaQuantum; break;
                 default: quantum_type=UndefinedQuantum; break;
               }
             (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
               quantum_type,pixels,exception);
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
           }
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadYCCKMethod:
       {
         pixels=(unsigned char *) GetQuantumPixels(quantum_info);
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           int
             status;
 
           register Quantum
             *magick_restrict q;
 
           register ssize_t
             x;
 
           unsigned char
             *p;
 
           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);
           if (status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           p=pixels;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+
               (1.402*(double) *(p+2))-179.456)),q);
             SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-
               (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
               135.45984)),q);
             SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+
               (1.772*(double) *(p+1))-226.816)),q);
             SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
             q+=GetPixelChannels(image);
             p+=4;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadStripMethod:
       {
         register uint32
           *p;
 
          
         i=0;
         p=(uint32 *) NULL;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register ssize_t
             x;
 
           register Quantum
             *magick_restrict q;
 
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           if (i == 0)
             {
               if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)
                 break;
               i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)
                 image->rows-y);
             }
           i--;
           p=((uint32 *) pixels)+image->columns*i;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(image,ScaleCharToQuantum((unsigned char)
               (TIFFGetR(*p))),q);
             SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
               (TIFFGetG(*p))),q);
             SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
               (TIFFGetB(*p))),q);
             if (image->alpha_trait != UndefinedPixelTrait)
               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                 (TIFFGetA(*p))),q);
             p++;
             q+=GetPixelChannels(image);
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadTileMethod:
       {
         register uint32
           *p;
 
         uint32
           *tile_pixels,
           columns,
           rows;
 
          
         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
           {
             TIFFClose(tiff);
             ThrowReaderException(CoderError,""ImageIsNotTiled"");
           }
         (void) SetImageStorageClass(image,DirectClass,exception);
         number_pixels=(MagickSizeType) columns*rows;
         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*
           sizeof(*tile_pixels));
         if (tile_pixels == (uint32 *) NULL)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         for (y=0; y < (ssize_t) image->rows; y+=rows)
         {
           register ssize_t
             x;
 
           register Quantum
             *magick_restrict q,
             *magick_restrict tile;
 
           size_t
             columns_remaining,
             rows_remaining;
 
           rows_remaining=image->rows-y;
           if ((ssize_t) (y+rows) < (ssize_t) image->rows)
             rows_remaining=rows;
           tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,
             exception);
           if (tile == (Quantum *) NULL)
             break;
           for (x=0; x < (ssize_t) image->columns; x+=columns)
           {
             size_t
               column,
               row;
 
             if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)
               break;
             columns_remaining=image->columns-x;
             if ((ssize_t) (x+columns) < (ssize_t) image->columns)
               columns_remaining=columns;
             p=tile_pixels+(rows-rows_remaining)*columns;
             q=tile+GetPixelChannels(image)*(image->columns*(rows_remaining-1)+
               x);
             for (row=rows_remaining; row > 0; row--)
             {
               if (image->alpha_trait != UndefinedPixelTrait)
                 for (column=columns_remaining; column > 0; column--)
                 {
                   SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                     TIFFGetR(*p)),q);
                   SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                     TIFFGetG(*p)),q);
                   SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                     TIFFGetB(*p)),q);
                   SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                     TIFFGetA(*p)),q);
                   p++;
                   q+=GetPixelChannels(image);
                 }
               else
                 for (column=columns_remaining; column > 0; column--)
                 {
                   SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                     TIFFGetR(*p)),q);
                   SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                     TIFFGetG(*p)),q);
                   SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                     TIFFGetB(*p)),q);
                   p++;
                   q+=GetPixelChannels(image);
                 }
               p+=columns-columns_remaining;
               q-=GetPixelChannels(image)*(image->columns+columns_remaining);
             }
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);
         break;
       }
       case ReadGenericMethod:
       default:
       {
         MemoryInfo
           *pixel_info;
 
         register uint32
           *p;
 
         uint32
           *pixels;
 
          
         number_pixels=(MagickSizeType) image->columns*image->rows;
         if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixel_info=AcquireVirtualMemory(image->columns,image->rows*
           sizeof(uint32));
         if (pixel_info == (MemoryInfo *) NULL)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
         (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)
           image->rows,(uint32 *) pixels,0);
          
         p=pixels+number_pixels-1;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register ssize_t
             x;
 
           register Quantum
             *magick_restrict q;
 
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           q+=GetPixelChannels(image)*(image->columns-1);
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(image,ScaleCharToQuantum((unsigned char)
               TIFFGetR(*p)),q);
             SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
               TIFFGetG(*p)),q);
             SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
               TIFFGetB(*p)),q);
             if (image->alpha_trait != UndefinedPixelTrait)
               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                 TIFFGetA(*p)),q);
             p--;
             q-=GetPixelChannels(image);
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         pixel_info=RelinquishVirtualMemory(pixel_info);
         break;
       }
      }
      SetQuantumImageType(image,quantum_type);
    next_tiff_frame:
    quantum_info=DestroyQuantumInfo(quantum_info);
     if (quantum_info != (QuantumInfo *) NULL)
       quantum_info=DestroyQuantumInfo(quantum_info);
      if (photometric == PHOTOMETRIC_CIELAB)
        DecodeLabImage(image,exception);
      if ((photometric == PHOTOMETRIC_LOGL) ||
         (photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       {
         image->type=GrayscaleType;
         if (bits_per_sample == 1)
           image->type=BilevelType;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;
     if (status != MagickFalse)
       {
          
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,image->scene-1,
           image->scene);
         if (status == MagickFalse)
           break;
       }
   } while (status != MagickFalse);
   TIFFClose(tiff);
   TIFFReadPhotoshopLayers(image,image_info,exception);
   if (image_info->number_scenes != 0)
     {
       if (image_info->scene >= GetImageListLength(image))
         {
            
           image=DestroyImageList(image);
           return((Image *)NULL);
         }
     }
   return(GetFirstImageInList(image));
 }","[413, 482, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 1045, 1046, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 478, 479, 480, 481, 1044]","The AcquireQuantumPixels function in MagickCore/quantum.c in ImageMagick before 7.0.3-1 allows remote attackers to have unspecified impact via a crafted image file, which triggers a memory allocation failure."
203105," int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,
  		const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)
   	{
  	ECDSA_SIG *s;
 	const unsigned char *p = sigbuf;
 	unsigned char *der = NULL;
 	int derlen = -1;
  	int ret=-1;
  
  	s = ECDSA_SIG_new();
  	if (s == NULL) return(ret);
	if (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;
 	if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;
 	 
 	derlen = i2d_ECDSA_SIG(s, &der);
 	if (derlen != sig_len || memcmp(sigbuf, der, derlen))
 		goto err;
  	ret=ECDSA_do_verify(dgst, dgst_len, s, eckey);
  err:
 	if (derlen > 0)
 		{
 		OPENSSL_cleanse(der, derlen);
 		OPENSSL_free(der);
 		}
  	ECDSA_SIG_free(s);
  	return(ret);
  	}","[5, 6, 7, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 12]","OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c."
205620," void AppCacheUpdateJob::OnDestructionImminent(AppCacheHost* host) {
    PendingMasters::iterator found =
        pending_master_entries_.find(host->pending_master_entry_url());
  DCHECK(found != pending_master_entries_.end());
   CHECK(found != pending_master_entries_.end());
    PendingHosts& hosts = found->second;
    PendingHosts::iterator it = std::find(hosts.begin(), hosts.end(), host);
  DCHECK(it != hosts.end());
   CHECK(it != hosts.end());
    hosts.erase(it);
  }","[5, 9, 4, 8]",Use-after-free vulnerability in the AppCache implementation in Google Chrome before 47.0.2526.73 allows remote attackers with renderer access to cause a denial of service or possibly have unspecified other impact by leveraging incorrect AppCacheUpdateJob behavior associated with duplicate cache selection.
108,"SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)
{
unsigned len;
int i;

if (!access_ok(VERIFY_WRITE, name, namelen))
return -EFAULT;

len = namelen;
if (namelen > 32)
len = 32;

down_read(&uts_sem);
for (i = 0; i < len; ++i) {
__put_user(utsname()->domainname[i], name + i);
if (utsname()->domainname[i] == '\0')
break;
}
up_read(&uts_sem);

return 0;
}",[10],Integer signedness error in the osf_getdomainname function in arch/alpha/kernel/osf_sys.c in the Linux kernel before 2.6.39.4 on the Alpha platform allows local users to obtain sensitive information from kernel memory via a crafted call.
205659,"   WebsiteSettings* website_settings() {
      if (!website_settings_.get()) {
        website_settings_.reset(new WebsiteSettings(
            mock_ui(), profile(), tab_specific_content_settings(),
          infobar_service(), url(), ssl(), cert_store()));
           web_contents(), url(), ssl(), cert_store()));
      }
      return website_settings_.get();
    }","[6, 5]","Use-after-free vulnerability in the Infobars implementation in Google Chrome before 47.0.2526.73 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted web site, related to browser/ui/views/website_settings/website_settings_popup_view.cc."
199432," xfs_da3_fixhashpath(
 	struct xfs_da_state	*state,
 	struct xfs_da_state_path *path)
 {
 	struct xfs_da_state_blk	*blk;
 	struct xfs_da_intnode	*node;
 	struct xfs_da_node_entry *btree;
 	xfs_dahash_t		lasthash=0;
 	int			level;
 	int			count;
 	struct xfs_inode	*dp = state->args->dp;
 
 	trace_xfs_da_fixhashpath(state->args);
 
 	level = path->active-1;
 	blk = &path->blk[ level ];
 	switch (blk->magic) {
 	case XFS_ATTR_LEAF_MAGIC:
 		lasthash = xfs_attr_leaf_lasthash(blk->bp, &count);
 		if (count == 0)
 			return;
 		break;
 	case XFS_DIR2_LEAFN_MAGIC:
 		lasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);
 		if (count == 0)
 			return;
 		break;
 	case XFS_DA_NODE_MAGIC:
 		lasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);
 		if (count == 0)
 			return;
 		break;
 	}
 	for (blk--, level--; level >= 0; blk--, level--) {
 		struct xfs_da3_icnode_hdr nodehdr;
 
  		node = blk->bp->b_addr;
  		dp->d_ops->node_hdr_from_disk(&nodehdr, node);
  		btree = dp->d_ops->node_tree_p(node);
		if (be32_to_cpu(btree->hashval) == lasthash)
 		if (be32_to_cpu(btree[blk->index].hashval) == lasthash)
  			break;
  		blk->hashval = lasthash;
  		btree[blk->index].hashval = cpu_to_be32(lasthash);
 		xfs_trans_log_buf(state->args->trans, blk->bp,
 				  XFS_DA_LOGRANGE(node, &btree[blk->index],
 						  sizeof(*btree)));
 
 		lasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);
 	}
 }","[41, 40]","The xfs_da3_fixhashpath function in fs/xfs/xfs_da_btree.c in the xfs implementation in the Linux kernel before 3.14.2 does not properly compare btree hash values, which allows local users to cause a denial of service (filesystem corruption, and OOPS or panic) via operations on directories that have hash collisions, as demonstrated by rmdir operations."
6112,"static int normal_ecc_mulmod(mp_int* k, ecc_point *G, ecc_point *R,
mp_int* a, mp_int* modulus, int map,
void* heap)
#else
int wc_ecc_mulmod_ex(mp_int* k, ecc_point *G, ecc_point *R,
mp_int* a, mp_int* modulus, int map,
void* heap)
#endif
{
#ifndef WOLFSSL_SP_MATH
#ifndef ECC_TIMING_RESISTANT

#define WINSIZE  4
#define M_POINTS 8
int           first = 1, bitbuf = 0, bitcpy = 0, j;
#else
#define M_POINTS 4
#endif

ecc_point     *tG, *M[M_POINTS];
int           i, err;
#ifdef WOLFSSL_SMALL_STACK
mp_int*       mu = NULL;
#ifdef WOLFSSL_SMALL_STACK_CACHE
ecc_key       key;
#endif
#else
mp_int        mu[1];
#endif
mp_digit      mp;
mp_digit      buf;
int           bitcnt = 0, mode = 0, digidx = 0;

if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
return ECC_BAD_ARG_E;
}


tG = NULL;
XMEMSET(M, 0, sizeof(M));
#ifdef WOLFSSL_SMALL_STACK
mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
if (mu == NULL)
return MEMORY_E;
#endif
#ifdef WOLFSSL_SMALL_STACK_CACHE
key.t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
key.t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
#ifdef ALT_ECC_SIZE
key.x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
key.y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
key.z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);
#endif
if (key.t1 == NULL || key.t2 == NULL
#ifdef ALT_ECC_SIZE
|| key.x == NULL || key.y == NULL || key.z == NULL
#endif
) {
#ifdef ALT_ECC_SIZE
XFREE(key.z, heap, DYNAMIC_TYPE_ECC);
XFREE(key.y, heap, DYNAMIC_TYPE_ECC);
XFREE(key.x, heap, DYNAMIC_TYPE_ECC);
#endif
XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);
XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);
XFREE(mu, heap, DYNAMIC_TYPE_ECC);
return MEMORY_E;
}
#endif /* WOLFSSL_SMALL_STACK_CACHE */


if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
#ifdef WOLFSSL_SMALL_STACK_CACHE
#ifdef ALT_ECC_SIZE
XFREE(key.z, heap, DYNAMIC_TYPE_ECC);
XFREE(key.y, heap, DYNAMIC_TYPE_ECC);
XFREE(key.x, heap, DYNAMIC_TYPE_ECC);
#endif
XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);
XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#ifdef WOLFSSL_SMALL_STACK
XFREE(mu, heap, DYNAMIC_TYPE_ECC);
#endif
return err;
}

if ((err = mp_init(mu)) != MP_OKAY) {
#ifdef WOLFSSL_SMALL_STACK_CACHE
#ifdef ALT_ECC_SIZE
XFREE(key.z, heap, DYNAMIC_TYPE_ECC);
XFREE(key.y, heap, DYNAMIC_TYPE_ECC);
XFREE(key.x, heap, DYNAMIC_TYPE_ECC);
#endif
XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);
XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#ifdef WOLFSSL_SMALL_STACK
XFREE(mu, heap, DYNAMIC_TYPE_ECC);
#endif
return err;
}
if ((err = mp_montgomery_calc_normalization(mu, modulus)) != MP_OKAY) {
mp_clear(mu);
#ifdef WOLFSSL_SMALL_STACK_CACHE
#ifdef ALT_ECC_SIZE
XFREE(key.z, heap, DYNAMIC_TYPE_ECC);
XFREE(key.y, heap, DYNAMIC_TYPE_ECC);
XFREE(key.x, heap, DYNAMIC_TYPE_ECC);
#endif
XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);
XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#ifdef WOLFSSL_SMALL_STACK
XFREE(mu, heap, DYNAMIC_TYPE_ECC);
#endif
return err;
}


for (i = 0; i < M_POINTS; i++) {
M[i] = wc_ecc_new_point_h(heap);
if (M[i] == NULL) {
mp_clear(mu);
err = MEMORY_E; goto exit;
}
#ifdef WOLFSSL_SMALL_STACK_CACHE
M[i]->key = &key;
#endif
}


tG = wc_ecc_new_point_h(heap);
if (tG == NULL)
err = MEMORY_E;


if (err == MP_OKAY) {
if (mp_cmp_d(mu, 1) == MP_EQ) {
err = mp_copy(G->x, tG->x);
if (err == MP_OKAY)
err = mp_copy(G->y, tG->y);
if (err == MP_OKAY)
err = mp_copy(G->z, tG->z);
} else {
err = mp_mulmod(G->x, mu, modulus, tG->x);
if (err == MP_OKAY)
err = mp_mulmod(G->y, mu, modulus, tG->y);
if (err == MP_OKAY)
err = mp_mulmod(G->z, mu, modulus, tG->z);
}
}


mp_clear(mu);

#ifdef WOLFSSL_SMALL_STACK_CACHE
R->key = &key;
#endif
#ifndef ECC_TIMING_RESISTANT



if (err == MP_OKAY)
err = ecc_projective_dbl_point(tG, M[0], a, modulus, mp);
if (err == MP_OKAY)
err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);
if (err == MP_OKAY)
err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);


if (err == MP_OKAY)
for (j = 9; j < 16; j++) {
err = ecc_projective_add_point(M[j-9], tG, M[j-M_POINTS], a, modulus,
mp);
if (err != MP_OKAY) break;
}


if (err == MP_OKAY) {
mode   = 0;
bitcnt = 1;
buf    = 0;
digidx = get_digit_count(k) - 1;
bitcpy = bitbuf = 0;
first  = 1;


for (;;) {

if (--bitcnt == 0) {
if (digidx == -1) {
break;
}
buf    = get_digit(k, digidx);
bitcnt = (int) DIGIT_BIT;
--digidx;
}


i = (int)(buf >> (DIGIT_BIT - 1)) & 1;
buf <<= 1;


if (mode == 0 && i == 0)
continue;


if (mode == 1 && i == 0) {
err = ecc_projective_dbl_point(R, R, a, modulus, mp);
if (err != MP_OKAY) break;
continue;
}


bitbuf |= (i << (WINSIZE - ++bitcpy));
mode = 2;

if (bitcpy == WINSIZE) {

if (first == 1) {

err = mp_copy(M[bitbuf-M_POINTS]->x, R->x);
if (err != MP_OKAY) break;

err = mp_copy(M[bitbuf-M_POINTS]->y, R->y);
if (err != MP_OKAY) break;

err = mp_copy(M[bitbuf-M_POINTS]->z, R->z);
first = 0;
} else {



for (j = 0; j < WINSIZE; j++) {
err = ecc_projective_dbl_point(R, R, a, modulus, mp);
if (err != MP_OKAY) break;
}
if (err != MP_OKAY) break;


err = ecc_projective_add_point(R, M[bitbuf-M_POINTS], R, a,
modulus, mp);
}
if (err != MP_OKAY) break;

bitcpy = bitbuf = 0;
mode = 1;
}
}
}


if (err == MP_OKAY) {
if (mode == 2 && bitcpy > 0) {

for (j = 0; j < bitcpy; j++) {

if (first == 0) {
err = ecc_projective_dbl_point(R, R, a, modulus, mp);
if (err != MP_OKAY) break;
}

bitbuf <<= 1;
if ((bitbuf & (1 << WINSIZE)) != 0) {
if (first == 1) {

err = mp_copy(tG->x, R->x);
if (err != MP_OKAY) break;

err = mp_copy(tG->y, R->y);
if (err != MP_OKAY) break;

err = mp_copy(tG->z, R->z);
if (err != MP_OKAY) break;
first = 0;
} else {

err = ecc_projective_add_point(R, tG, R, a, modulus, mp);
if (err != MP_OKAY) break;
}
}
}
}
}

#undef WINSIZE

#else /* ECC_TIMING_RESISTANT */



if (err == MP_OKAY)
err = mp_copy(tG->x, M[0]->x);
if (err == MP_OKAY)
err = mp_copy(tG->y, M[0]->y);
if (err == MP_OKAY)
err = mp_copy(tG->z, M[0]->z);


if (err == MP_OKAY)
err = ecc_projective_dbl_point(tG, M[1], a, modulus, mp);


mode   = 0;
bitcnt = 1;
buf    = 0;
digidx = get_digit_count(modulus) - 1;

digidx += (modulus->dp[digidx] >> (DIGIT_BIT-1));


if (err == MP_OKAY) {
for (;;) {

if (--bitcnt == 0) {
if (digidx == -1) {
break;
}
buf = get_digit(k, digidx);
bitcnt = (int)DIGIT_BIT;
--digidx;
}


i = (buf >> (DIGIT_BIT - 1)) & 1;
buf <<= 1;

if (mode == 0) {
mode = i;

if (err == MP_OKAY)
err = ecc_projective_add_point(M[1], M[2], M[2], a, modulus,
mp);
#ifdef WC_NO_CACHE_RESISTANT
if (err == MP_OKAY)
err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);
#else



if (err == MP_OKAY)
err = mp_copy((mp_int*)
( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->x & wc_off_on_addr[i])),
M[2]->x);
if (err == MP_OKAY)
err = mp_copy((mp_int*)
( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->y & wc_off_on_addr[i])),
M[2]->y);
if (err == MP_OKAY)
err = mp_copy((mp_int*)
( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->z & wc_off_on_addr[i])),
M[2]->z);
if (err == MP_OKAY)
err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);

if (err == MP_OKAY)
err = mp_copy(M[2]->x,
(mp_int*)
( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );
if (err == MP_OKAY)
err = mp_copy(M[2]->y,
(mp_int*)
( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );
if (err == MP_OKAY)
err = mp_copy(M[2]->z,
(mp_int*)
( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );
#endif
if (err == MP_OKAY)
continue;
}

if (err == MP_OKAY)
err = ecc_projective_add_point(M[0], M[1], M[i^1], a, modulus,
mp);
#ifdef WC_NO_CACHE_RESISTANT
if (err == MP_OKAY)
err = ecc_projective_dbl_point(M[i], M[i], a, modulus, mp);
#else



if (err == MP_OKAY)
err = mp_copy((mp_int*)
( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->x & wc_off_on_addr[i])),
M[2]->x);
if (err == MP_OKAY)
err = mp_copy((mp_int*)
( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->y & wc_off_on_addr[i])),
M[2]->y);
if (err == MP_OKAY)
err = mp_copy((mp_int*)
( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->z & wc_off_on_addr[i])),
M[2]->z);
if (err == MP_OKAY)
err = ecc_projective_dbl_point(M[2], M[2], a, modulus, mp);

if (err == MP_OKAY)
err = mp_copy(M[2]->x,
(mp_int*)
( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );
if (err == MP_OKAY)
err = mp_copy(M[2]->y,
(mp_int*)
( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );
if (err == MP_OKAY)
err = mp_copy(M[2]->z,
(mp_int*)
( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +
((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );
if (err != MP_OKAY)
break;
#endif /* WC_NO_CACHE_RESISTANT */
}
}


if (err == MP_OKAY)
err = mp_copy(M[0]->x, R->x);
if (err == MP_OKAY)
err = mp_copy(M[0]->y, R->y);
if (err == MP_OKAY)
err = mp_copy(M[0]->z, R->z);

#endif /* ECC_TIMING_RESISTANT */


if (err == MP_OKAY && map)
err = ecc_map(R, modulus, mp);

exit:


wc_ecc_del_point_h(tG, heap);
for (i = 0; i < M_POINTS; i++) {
wc_ecc_del_point_h(M[i], heap);
}
#ifdef WOLFSSL_SMALL_STACK_CACHE
R->key = NULL;
#ifdef ALT_ECC_SIZE
XFREE(key.z, heap, DYNAMIC_TYPE_ECC);
XFREE(key.y, heap, DYNAMIC_TYPE_ECC);
XFREE(key.x, heap, DYNAMIC_TYPE_ECC);
#endif
XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);
XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);
#endif /* WOLFSSL_SMALL_STACK_CACHE */
#ifdef WOLFSSL_SMALL_STACK
XFREE(mu, heap, DYNAMIC_TYPE_ECC);
#endif

return err;
#else
if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
return ECC_BAD_ARG_E;
}

(void)a;

return sp_ecc_mulmod_256(k, G, R, map, heap);
#endif
}","[329, 330, 335, 338, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 377, 380, 381, 382, 383, 385, 386, 392, 393, 397, 398, 402, 403, 406, 409, 411, 412, 414, 416, 417, 419, 421, 422, 425]","In wolfSSL before 4.3.0, wc_ecc_mulmod_ex does not properly resist side-channel attacks."
8675,"sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,
unsigned char **out, size_t *out_len,
int verify_pin)
{
struct sc_context *ctx = p15card->card->ctx;
struct sc_card *card = p15card->card;
struct sc_file *file = NULL;
struct sc_path path;
size_t sz;
int rv;

LOG_FUNC_CALLED(ctx);
if (!in_path || !out || !out_len)
LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file"");

sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin);

*out = NULL;
*out_len = 0;

sc_format_path(in_path, &path);
rv = sc_select_file(card, &path, &file);
if (rv != SC_SUCCESS) {
sc_file_free(file);
LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read"");
}

if (file->ef_structure == SC_FILE_EF_TRANSPARENT)
sz = file->size;
else
sz = (file->record_length + 2) * file->record_count;

*out = calloc(sz, 1);
if (*out == NULL) {
sc_file_free(file);
LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file"");
}

if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {
rv = sc_read_binary(card, 0, *out, sz, 0);
}
else {
size_t rec;
size_t offs = 0;
size_t rec_len = file->record_length;

for (rec = 1; ; rec++)   {
if (rec > file->record_count) {
rv = 0;
break;
}
rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);
if (rv == SC_ERROR_RECORD_NOT_FOUND)   {
rv = 0;
break;
}
else if (rv < 0)   {
break;
}

rec_len = rv;

*(*out + offs) = 'R';
*(*out + offs + 1) = rv;

offs += rv + 2;
}

sz = offs;
}

sc_log(ctx, ""read oberthur file result %i"", rv);
if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {
struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;
const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);
int ii;

if (acl == NULL) {
sc_file_free(file);
free(*out);
*out = NULL;
LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);
}

rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);
if (rv != SC_SUCCESS) {
sc_file_free(file);
free(*out);
*out = NULL;
LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error"");
}

for (ii=0; ii<rv; ii++)   {
struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;
sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"",
auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);
if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {
pin_obj = objs[ii];
break;
}
}

if (!pin_obj || !pin_obj->content.value)    {
rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;
}
else    {
rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);
if (!rv)
rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);
}
}

sc_file_free(file);

if (rv < 0)   {
free(*out);
*out = NULL;
*out_len = 0;
}

*out_len = sz;

LOG_FUNC_RETURN(ctx, rv);
}","[76, 85, 86, 90, 93, 96]",A heap use after free issue was found in Opensc before version 0.22.0 in sc_file_valid.
199169," static int filter_frame(AVFilterLink *inlink, AVFrame *in)
 {
     AVFilterContext *ctx = inlink->dst;
     BoxBlurContext *s = ctx->priv;
     AVFilterLink *outlink = inlink->dst->outputs[0];
     AVFrame *out;
     int plane;
     int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);
     int w[4] = { inlink->w, cw, cw, inlink->w };
     int h[4] = { in->height, ch, ch, in->height };
 
     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
     if (!out) {
         av_frame_free(&in);
         return AVERROR(ENOMEM);
      }
      av_frame_copy_props(out, in);
  
    for (plane = 0; in->data[plane] && plane < 4; plane++)
     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
          hblur(out->data[plane], out->linesize[plane],
                in ->data[plane], in ->linesize[plane],
                w[plane], h[plane], s->radius[plane], s->power[plane],
                s->temp);
  
    for (plane = 0; in->data[plane] && plane < 4; plane++)
     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
          vblur(out->data[plane], out->linesize[plane],
                out->data[plane], out->linesize[plane],
                w[plane], h[plane], s->radius[plane], s->power[plane],
               s->temp);
 
     av_frame_free(&in);
 
     return ff_filter_frame(outlink, out);
 }","[20, 27, 19, 26]","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write."
201838," PHP_FUNCTION(unserialize)
 {
 	char *buf = NULL;
 	size_t buf_len;
  	const unsigned char *p;
  	php_unserialize_data_t var_hash;
  	zval *options = NULL, *classes = NULL;
 	zval *retval;
  	HashTable *class_hash = NULL;
  
  	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
 		RETURN_FALSE;
 	}
 
 	if (buf_len == 0) {
 		RETURN_FALSE;
 	}
 
 	p = (const unsigned char*) buf;
 	PHP_VAR_UNSERIALIZE_INIT(var_hash);
 	if(options != NULL) {
 		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
 		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
 			ALLOC_HASHTABLE(class_hash);
 			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
 		}
 		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
 			zval *entry;
 			zend_string *lcname;
 
 			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
 				convert_to_string_ex(entry);
 				lcname = zend_string_tolower(Z_STR_P(entry));
 				zend_hash_add_empty_element(class_hash, lcname);
 		        zend_string_release(lcname);
 			} ZEND_HASH_FOREACH_END();
  		}
  	}
  
	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
 	retval = var_tmp_var(&var_hash);
 	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
  		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
  		if (class_hash) {
  			zend_hash_destroy(class_hash);
  			FREE_HASHTABLE(class_hash);
  		}
		zval_ptr_dtor(return_value);
  		if (!EG(exception)) {
  			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
  				(zend_long)((char*)p - buf), buf_len);
  		}
  		RETURN_FALSE;
  	}
	 
	var_push_dtor(&var_hash, return_value);
 
 	ZVAL_COPY(return_value, retval);
  
  	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
  	if (class_hash) {
 		zend_hash_destroy(class_hash);
 		FREE_HASHTABLE(class_hash);
 	}
 }","[8, 41, 42, 57, 58, 40, 48, 55, 56]",The unserialize implementation in ext/standard/var.c in PHP 7.x before 7.0.14 allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted serialized data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6834.
205625,"    static bool IsManualFallbackForFillingEnabled() {
      return base::FeatureList::IsEnabled(
               password_manager::features::kEnableManualFallbacksFilling) &&
                password_manager::features::kManualFallbacksFilling) &&
             !IsPreLollipopAndroid();
    }","[4, 3]",The provisional-load commit implementation in WebKit/Source/bindings/core/v8/WindowProxy.cpp in Google Chrome before 47.0.2526.73 allows remote attackers to bypass the Same Origin Policy by leveraging a delay in window proxy clearing.
199980," int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 {
 	int retval;
 	int remount_ro;
 
 	if (sb->s_writers.frozen != SB_UNFROZEN)
 		return -EBUSY;
 
 #ifdef CONFIG_BLOCK
 	if (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))
 		return -EACCES;
 #endif
 
 	if (flags & MS_RDONLY)
 		acct_auto_close(sb);
 	shrink_dcache_sb(sb);
 	sync_filesystem(sb);
 
 	remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);
 
 	 
  	if (remount_ro) {
  		if (force) {
			mark_files_ro(sb);
 			sb->s_readonly_remount = 1;
 			smp_wmb();
  		} else {
  			retval = sb_prepare_remount_readonly(sb);
  			if (retval)
 				return retval;
 		}
 	}
 
 	if (sb->s_op->remount_fs) {
 		retval = sb->s_op->remount_fs(sb, &flags, data);
 		if (retval) {
 			if (!force)
 				goto cancel_readonly;
 			 
 			WARN(1, ""forced remount of a %s fs returned %i\n"",
 			     sb->s_type->name, retval);
 		}
 	}
 	sb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);
 	 
 	smp_wmb();
 	sb->s_readonly_remount = 0;
 
 	 
 	if (remount_ro && sb->s_bdev)
 		invalidate_bdev(sb->s_bdev);
 	return 0;
 
 cancel_readonly:
 	sb->s_readonly_remount = 0;
 	return retval;
 }","[25, 26, 24]","The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations."
9934,"void Compute(OpKernelContext* ctx) override {
const Tensor* seq_len_max_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""seq_len_max"", &seq_len_max_tensor));

const Tensor* x;
OP_REQUIRES_OK(ctx, ctx->input(""x"", &x));
OP_REQUIRES(ctx, x->dims() == 3, errors::InvalidArgument(""x must be 3D""));
const int64_t timelen = x->dim_size(0);
const int64_t batch_size = x->dim_size(1);
const int64_t input_size = x->dim_size(2);

const Tensor* cs_prev_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""cs_prev"", &cs_prev_tensor));

const Tensor* h_prev_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""h_prev"", &h_prev_tensor));

const Tensor* w_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""w"", &w_tensor));
const int64_t cell_size = w_tensor->dim_size(1) / 4;
OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),
errors::InvalidArgument(
""w matrix rows don't match: "", input_size + cell_size,
"" vs. "", w_tensor->dim_size(0)));

const Tensor* wci_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""wci"", &wci_tensor));

const Tensor* wcf_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""wcf"", &wcf_tensor));

const Tensor* wco_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""wco"", &wco_tensor));

const Tensor* b_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""b"", &b_tensor));
OP_REQUIRES(
ctx, cell_size == b_tensor->dim_size(0) / 4,
errors::InvalidArgument(""w and b cell_size don't match: "", cell_size,
"" vs. "", b_tensor->dim_size(0)));

const Tensor* i_out = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""i"", &i_out));

const Tensor* cs_out = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""cs"", &cs_out));

const Tensor* f_out = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""f"", &f_out));

const Tensor* o_out = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""o"", &o_out));

const Tensor* ci_out = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""ci"", &ci_out));

const Tensor* co_out = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""co"", &co_out));

const Tensor* h_out = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""h"", &h_out));

const Tensor* cs_grad = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""cs_grad"", &cs_grad));

const Tensor* h_grad = nullptr;
OP_REQUIRES_OK(ctx, ctx->input(""h_grad"", &h_grad));

TensorShape batch_input_shape({timelen, batch_size, input_size});
Tensor* x_grad;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(""x_grad"", batch_input_shape, &x_grad));

Tensor* cs_prev_grad_tensor = nullptr;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(""cs_prev_grad"", cs_prev_tensor->shape(),
&cs_prev_grad_tensor));

Tensor* h_prev_grad_tensor = nullptr;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(""h_prev_grad"", h_prev_tensor->shape(),
&h_prev_grad_tensor));

Tensor* w_grad_tensor = nullptr;
OP_REQUIRES_OK(
ctx, ctx->allocate_output(""w_grad"", w_tensor->shape(), &w_grad_tensor));

Tensor* wci_grad_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(""wci_grad"", wci_tensor->shape(),
&wci_grad_tensor));

Tensor* wcf_grad_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(""wcf_grad"", wcf_tensor->shape(),
&wcf_grad_tensor));

Tensor* wco_grad_tensor = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(""wco_grad"", wco_tensor->shape(),
&wco_grad_tensor));

Tensor* b_grad_tensor = nullptr;
OP_REQUIRES_OK(
ctx, ctx->allocate_output(""b_grad"", b_tensor->shape(), &b_grad_tensor));

TensorShape batch_cell_shape({batch_size, cell_size});

Tensor xh_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(
DataTypeToEnum<T>::v(),
TensorShape({batch_size, input_size + cell_size}),
&xh_tensor));

Tensor xh_grad_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
xh_tensor.shape(), &xh_grad_tensor));

Tensor do_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
batch_cell_shape, &do_tensor));

Tensor dcs_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
batch_cell_shape, &dcs_tensor));

Tensor dci_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
batch_cell_shape, &dci_tensor));

Tensor df_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
batch_cell_shape, &df_tensor));

Tensor di_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
batch_cell_shape, &di_tensor));

Tensor dgates_tensor;
OP_REQUIRES_OK(ctx,
ctx->allocate_temp(DataTypeToEnum<T>::v(),
TensorShape({batch_size, cell_size * 4}),
&dgates_tensor));

Tensor cs_grad_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
batch_cell_shape, &cs_grad_tensor));

Tensor h_grad_tensor;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),
batch_cell_shape, &h_grad_tensor));

const Device& device = ctx->eigen_device<Device>();

functor::TensorZero<Device, T>()(device, cs_grad_tensor.flat<T>());
functor::TensorZero<Device, T>()(device, cs_prev_grad_tensor->flat<T>());
functor::TensorZero<Device, T>()(device, h_grad_tensor.flat<T>());
functor::TensorZero<Device, T>()(device, h_prev_grad_tensor->flat<T>());
functor::TensorZero<Device, T>()(device, w_grad_tensor->flat<T>());
functor::TensorZero<Device, T>()(device, wci_grad_tensor->flat<T>());
functor::TensorZero<Device, T>()(device, wcf_grad_tensor->flat<T>());
functor::TensorZero<Device, T>()(device, wco_grad_tensor->flat<T>());
functor::TensorZero<Device, T>()(device, b_grad_tensor->flat<T>());

const int64_t seq_len_max = seq_len_max_tensor->scalar<int64_t>()();
SliceHelper<Device, T> slicer(ctx);
for (int64_t t = seq_len_max - 1; t >= 0; --t) {
const Tensor& x_tensor = slicer.InputSlice(*x, t, ""x"");
const Tensor& cs_prev_tensor2 =
t == 0 ? *cs_prev_tensor
: slicer.InputSlice(*cs_out, t - 1, ""cs_prev"");
const Tensor& h_prev_tensor2 =
t == 0 ? *h_prev_tensor : slicer.InputSlice(*h_out, t - 1, ""h_prev"");
const Tensor& i_tensor = slicer.InputSlice(*i_out, t, ""i_out"");
const Tensor& cs_tensor = slicer.InputSlice(*cs_out, t, ""cs_out"");
const Tensor& f_tensor = slicer.InputSlice(*f_out, t, ""f_out"");
const Tensor& o_tensor = slicer.InputSlice(*o_out, t, ""o_out"");
const Tensor& ci_tensor = slicer.InputSlice(*ci_out, t, ""ci_out"");
const Tensor& co_tensor = slicer.InputSlice(*co_out, t, ""co_out"");


const Tensor& const_cs_prev_grad_tensor = *cs_prev_grad_tensor;
const Tensor const_cs_grad_slice =
slicer.InputSlice(*cs_grad, t, ""cs_grad"");
functor::TensorAdd<Device, T>()(
device, const_cs_prev_grad_tensor.flat<T>(),
const_cs_grad_slice.flat<T>(), cs_grad_tensor.flat<T>());


const Tensor& const_h_prev_grad_tensor = *h_prev_grad_tensor;
const Tensor const_h_grad_slice = slicer.InputSlice(*h_grad, t, ""h_grad"");
functor::TensorAdd<Device, T>()(
device, const_h_prev_grad_tensor.flat<T>(),
const_h_grad_slice.flat<T>(), h_grad_tensor.flat<T>());

const Tensor& const_cs_grad_tensor = cs_grad_tensor;
const Tensor& const_h_grad_tensor = h_grad_tensor;

Tensor x_grad_tensor = slicer.OutputSlice(x_grad, t, ""x_grad"");
functor::BlockLSTMBprop<Device, T, USE_CUBLAS, gate_layout>(
batch_size, input_size, cell_size)(
ctx, device, use_peephole_, x_tensor.matrix<T>(),
cs_prev_tensor2.matrix<T>(), h_prev_tensor2.matrix<T>(),
w_tensor->matrix<T>(), wci_tensor->vec<T>(), wcf_tensor->vec<T>(),
wco_tensor->vec<T>(), b_tensor->vec<T>(), xh_tensor.matrix<T>(),
i_tensor.matrix<T>(), cs_tensor.matrix<T>(), f_tensor.matrix<T>(),
o_tensor.matrix<T>(), ci_tensor.matrix<T>(), co_tensor.matrix<T>(),
const_cs_grad_tensor.matrix<T>(), const_h_grad_tensor.matrix<T>(),
do_tensor.matrix<T>(), dcs_tensor.matrix<T>(), dci_tensor.matrix<T>(),
df_tensor.matrix<T>(), di_tensor.matrix<T>(),
dgates_tensor.matrix<T>(), cs_prev_grad_tensor->matrix<T>(),
h_prev_grad_tensor->matrix<T>(), xh_grad_tensor.matrix<T>(),
x_grad_tensor.matrix<T>(), w_grad_tensor->matrix<T>(),
wci_grad_tensor->vec<T>(), wcf_grad_tensor->vec<T>(),
wco_grad_tensor->vec<T>(), b_grad_tensor->vec<T>());
slicer.FinishTimeStep();
}

if (seq_len_max < timelen) {
Tensor x_grad_tensor = x_grad->Slice(seq_len_max, timelen);
functor::TensorUnalignedZero<Device, T>()(
device, x_grad_tensor.unaligned_flat<T>());
}
}","[7, 15, 18, 20, 29, 32, 35, 37]","TensorFlow is an open source platform for machine learning. The implementation of `BlockLSTMGradV2` does not fully validate its inputs. This results in a a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 2a458fc4866505be27c62f81474ecb2b870498fa. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
205776," void MediaControlTimelineElement::defaultEventHandler(Event* event) {
   if (event->isMouseEvent() &&
       toMouseEvent(event)->button() !=
           static_cast<short>(WebPointerProperties::Button::Left))
     return;
 
   if (!isConnected() || !document().isActive())
     return;
 
   if (event->type() == EventTypeNames::mousedown) {
     Platform::current()->recordAction(
         UserMetricsAction(""Media.Controls.ScrubbingBegin""));
     mediaControls().beginScrubbing();
   }
 
   if (event->type() == EventTypeNames::mouseup) {
     Platform::current()->recordAction(
         UserMetricsAction(""Media.Controls.ScrubbingEnd""));
     mediaControls().endScrubbing();
   }
  
    MediaControlInputElement::defaultEventHandler(event);
  
  if (event->type() == EventTypeNames::mouseover ||
      event->type() == EventTypeNames::mouseout ||
      event->type() == EventTypeNames::mousemove)
   if (event->type() != EventTypeNames::input)
      return;
  
    double time = value().toDouble();
  if (event->type() == EventTypeNames::input) {
    if (mediaElement().seekable()->contain(time))
      mediaElement().setCurrentTime(time);
  }
 
    
    
   if (mediaElement().seekable()->contain(time))
     mediaElement().setCurrentTime(time);
  
    LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject()));
    if (!slider.isNull() && slider.inDragMode())
     mediaControls().updateCurrentTimeDisplay();
 }","[27, 35, 36, 37, 38, 39, 24, 25, 26, 31, 32, 33, 34]","PDFium, as used in Google Chrome before 44.0.2403.89, does not properly handle certain out-of-memory conditions, which allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a crafted PDF document that triggers a large memory allocation."
200017," void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime;
 	unsigned long flags;
 
 	if (PCM_RUNTIME_CHECK(substream))
 		return;
 	runtime = substream->runtime;
 
 	snd_pcm_stream_lock_irqsave(substream, flags);
 	if (!snd_pcm_running(substream) ||
 	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
 		goto _end;
 
 #ifdef CONFIG_SND_PCM_TIMER
 	if (substream->timer_running)
  		snd_timer_interrupt(substream->timer, 1);
  #endif
   _end:
	snd_pcm_stream_unlock_irqrestore(substream, flags);
  	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
  }","[22, 20]",Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command.
200734,"  void pin_remove(struct fs_pin *pin)
  {
  	spin_lock(&pin_lock);
	hlist_del(&pin->m_list);
	hlist_del(&pin->s_list);
 	hlist_del_init(&pin->m_list);
 	hlist_del_init(&pin->s_list);
  	spin_unlock(&pin_lock);
  	spin_lock_irq(&pin->wait.lock);
  	pin->done = 1;
 	wake_up_locked(&pin->wait);
 	spin_unlock_irq(&pin->wait.lock);
 }","[6, 7, 4, 5]","The fs_pin implementation in the Linux kernel before 4.0.5 does not ensure the internal consistency of a certain list data structure, which allows local users to cause a denial of service (system crash) by leveraging user-namespace root access for an MNT_DETACH umount2 system call, related to fs/fs_pin.c and include/linux/fs_pin.h."
200546," get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,
 		      const char *hookname, const char **chainname,
 		      const char **comment, unsigned int *rulenum)
 {
 	const struct xt_standard_target *t = (void *)ip6t_get_target_c(s);
 
 	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
 		 
 		*chainname = t->target.data;
 		(*rulenum) = 0;
  	} else if (s == e) {
  		(*rulenum)++;
  
		if (s->target_offset == sizeof(struct ip6t_entry) &&
 		if (unconditional(s) &&
  		    strcmp(t->target.u.kernel.target->name,
  			   XT_STANDARD_TARGET) == 0 &&
		    t->verdict < 0 &&
		    unconditional(&s->ipv6)) {
 		    t->verdict < 0) {
  			 
  			*comment = *chainname == hookname
  				? comments[NF_IP6_TRACE_COMMENT_POLICY]
 				: comments[NF_IP6_TRACE_COMMENT_RETURN];
 		}
 		return 1;
 	} else
 		(*rulenum)++;
 
 	return 0;
 }","[15, 20, 14, 18, 19]","The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call."
204759," static v8::Handle<v8::Value> postMessageCallback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestActiveDOMObject.postMessage"");
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestActiveDOMObject* imp = V8TestActiveDOMObject::toNative(args.Holder());
      STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, message, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
      imp->postMessage(message);
     return v8::Handle<v8::Value>();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
197922,"  void add_param_to_argv(char *parsestart, int line)
  {
	int quote_open = 0, escaped = 0, param_len = 0;
	char param_buffer[1024], *curchar;
 	int quote_open = 0, escaped = 0;
 	struct xt_param_buf param = {};
 	char *curchar;
  
  	 
 			param_buffer[param_len++] = *curchar;
 
 			if (param_len >= sizeof(param_buffer))
 				xtables_error(PARAMETER_PROBLEM,
  		case ' ':
  		case '\t':
  		case '\n':
			if (!param_len) {
 			if (!param.len) {
  				 
  				continue;
  			}
  			break;
  		default:
  			 
			param_buffer[param_len++] = *curchar;
			if (param_len >= sizeof(param_buffer))
				xtables_error(PARAMETER_PROBLEM,
					      ""Parameter too long!"");
 			add_param(&param, curchar);
  			continue;
  		}
  
		param_buffer[param_len] = '\0';
 		param.buffer[param.len] = '\0';
  
  		 
		if ((param_buffer[0] == '-' &&
		     param_buffer[1] != '-' &&
		     strchr(param_buffer, 't')) ||
		    (!strncmp(param_buffer, ""--t"", 3) &&
		     !strncmp(param_buffer, ""--table"", strlen(param_buffer)))) {
 		if ((param.buffer[0] == '-' &&
 		     param.buffer[1] != '-' &&
 		     strchr(param.buffer, 't')) ||
 		    (!strncmp(param.buffer, ""--t"", 3) &&
 		     !strncmp(param.buffer, ""--table"", strlen(param.buffer)))) {
  			xtables_error(PARAMETER_PROBLEM,
  				      ""The -t option (seen in line %u) cannot be used in %s.\n"",
  				      line, xt_params->program_name);
  		}
  
		add_argv(param_buffer, 0);
		param_len = 0;
 		add_argv(param.buffer, 0);
 		param.len = 0;
  	}","[5, 6, 7, 18, 29, 34, 42, 43, 44, 45, 46, 54, 55, 3, 4, 17, 25, 26, 27, 28, 33, 37, 38, 39, 40, 41, 52, 53]",A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.
201650,"  int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
  {
	return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,
 	return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
 	  jpc_tsfb_synthesize2(tsfb,
  	  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
  	  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
  	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;
 }","[4, 5, 3]",The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.
2755,"static int php_mb_parse_encoding_list(const char *value, int value_length,
mbfl_encoding ***return_list,
int *return_size, int persistent) {
int n, l, size, bauto, ret = 1;
char *p, *p1, *p2, *endp, *tmpstr;
mbfl_encoding *encoding;
mbfl_no_encoding *src;
mbfl_encoding **entry, **list;

list = nullptr;
if (value == nullptr || value_length <= 0) {
if (return_list) {
*return_list = nullptr;
}
if (return_size) {
*return_size = 0;
}
return 0;
} else {
mbfl_no_encoding *identify_list;
int identify_list_size;

identify_list = MBSTRG(default_detect_order_list);
identify_list_size = MBSTRG(default_detect_order_list_size);


if (value[0]=='""' && value[value_length-1]=='""' && value_length>2) {
tmpstr = (char *)strndup(value+1, value_length-2);
value_length -= 2;
}
else
tmpstr = (char *)strndup(value, value_length);
if (tmpstr == nullptr) {
return 0;
}

endp = tmpstr + value_length;
n = 1;
p1 = tmpstr;
while ((p2 = (char*)string_memnstr(p1, "","", 1, endp)) != nullptr) {
p1 = p2 + 1;
n++;
}
size = n + identify_list_size;

list = (mbfl_encoding **)calloc(size, sizeof(mbfl_encoding*));
if (list != nullptr) {
entry = list;
n = 0;
bauto = 0;
p1 = tmpstr;
do {
p2 = p = (char*)string_memnstr(p1, "","", 1, endp);
if (p == nullptr) {
p = endp;
}
*p = '\0';

while (p1 < p && (*p1 == ' ' || *p1 == '\t')) {
p1++;
}
p--;
while (p > p1 && (*p == ' ' || *p == '\t')) {
*p = '\0';
p--;
}

if (strcasecmp(p1, ""auto"") == 0) {
if (!bauto) {
bauto = 1;
l = identify_list_size;
src = identify_list;
for (int i = 0; i < l; i++) {
*entry++ = (mbfl_encoding*) mbfl_no2encoding(*src++);
n++;
}
}
} else {
encoding = (mbfl_encoding*) mbfl_name2encoding(p1);
if (encoding != nullptr) {
*entry++ = encoding;
n++;
} else {
ret = 0;
}
}
p1 = p2 + 1;
} while (n < size && p2 != nullptr);
if (n > 0) {
if (return_list) {
*return_list = list;
} else {
free(list);
}
} else {
free(list);
if (return_list) {
*return_list = nullptr;
}
ret = 0;
}
if (return_size) {
*return_size = n;
}
} else {
if (return_list) {
*return_list = nullptr;
}
if (return_size) {
*return_size = 0;
}
ret = 0;
}
free(tmpstr);
}

return ret;
}","[28, 31, 31, 32, 114]","Out-of-bounds write in the (1) mb_detect_encoding, (2) mb_send_mail, and (3) mb_detect_order functions in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors."
202039," int exfat_mount(struct exfat* ef, const char* spec, const char* options)
 {
 	int rc;
 	enum exfat_mode mode;
 
 	exfat_tzset();
 	memset(ef, 0, sizeof(struct exfat));
 
 	parse_options(ef, options);
 
 	if (match_option(options, ""ro""))
 		mode = EXFAT_MODE_RO;
 	else if (match_option(options, ""ro_fallback""))
 		mode = EXFAT_MODE_ANY;
 	else
 		mode = EXFAT_MODE_RW;
 	ef->dev = exfat_open(spec, mode);
 	if (ef->dev == NULL)
 		return -EIO;
 	if (exfat_get_mode(ef->dev) == EXFAT_MODE_RO)
 	{
 		if (mode == EXFAT_MODE_ANY)
 			ef->ro = -1;
 		else
 			ef->ro = 1;
 	}
 
 	ef->sb = malloc(sizeof(struct exfat_super_block));
 	if (ef->sb == NULL)
 	{
 		exfat_close(ef->dev);
 		exfat_error(""failed to allocate memory for the super block"");
 		return -ENOMEM;
 	}
 	memset(ef->sb, 0, sizeof(struct exfat_super_block));
 
 	if (exfat_pread(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)
 	{
 		exfat_close(ef->dev);
 		free(ef->sb);
 		exfat_error(""failed to read boot sector"");
 		return -EIO;
 	}
 	if (memcmp(ef->sb->oem_name, ""EXFAT   "", 8) != 0)
 	{
 		exfat_close(ef->dev);
 		free(ef->sb);
  		exfat_error(""exFAT file system is not found"");
  		return -EIO;
  	}
 	 
 	if (ef->sb->sector_bits < 9)
 	{
 		exfat_close(ef->dev);
 		exfat_error(""too small sector size: 2^%hhd"", ef->sb->sector_bits);
 		free(ef->sb);
 		return -EIO;
 	}
 	 
 	if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)
 	{
 		exfat_close(ef->dev);
 		exfat_error(""too big cluster size: 2^(%hhd+%hhd)"",
 				ef->sb->sector_bits, ef->sb->spc_bits);
 		free(ef->sb);
 		return -EIO;
 	}
  	ef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));
  	if (ef->zero_cluster == NULL)
  	{
 		exfat_close(ef->dev);
 		free(ef->sb);
 		exfat_error(""failed to allocate zero sector"");
 		return -ENOMEM;
 	}
 	 
 	if (!verify_vbr_checksum(ef->dev, ef->zero_cluster, SECTOR_SIZE(*ef->sb)))
 	{
 		free(ef->zero_cluster);
 		exfat_close(ef->dev);
 		free(ef->sb);
 		return -EIO;
 	}
 	memset(ef->zero_cluster, 0, CLUSTER_SIZE(*ef->sb));
 	if (ef->sb->version.major != 1 || ef->sb->version.minor != 0)
 	{
 		free(ef->zero_cluster);
 		exfat_close(ef->dev);
 		exfat_error(""unsupported exFAT version: %hhu.%hhu"",
 				ef->sb->version.major, ef->sb->version.minor);
 		free(ef->sb);
 		return -EIO;
 	}
 	if (ef->sb->fat_count != 1)
 	{
 		free(ef->zero_cluster);
 		exfat_close(ef->dev);
 		exfat_error(""unsupported FAT count: %hhu"", ef->sb->fat_count);
  		free(ef->sb);
  		return -EIO;
  	}
	 
	if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)
	{
		free(ef->zero_cluster);
		exfat_close(ef->dev);
		exfat_error(""too big cluster size: 2^%d"",
				(int) ef->sb->sector_bits + (int) ef->sb->spc_bits);
		free(ef->sb);
		return -EIO;
	}
  	if (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >
  			exfat_get_size(ef->dev))
  	{
 		 
 		exfat_warn(""file system is larger than underlying device: ""
 				""%""PRIu64"" > %""PRIu64,
 				le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb),
 				exfat_get_size(ef->dev));
 	}
 
 	ef->root = malloc(sizeof(struct exfat_node));
 	if (ef->root == NULL)
 	{
 		free(ef->zero_cluster);
 		exfat_close(ef->dev);
 		free(ef->sb);
 		exfat_error(""failed to allocate root node"");
 		return -ENOMEM;
 	}
 	memset(ef->root, 0, sizeof(struct exfat_node));
 	ef->root->flags = EXFAT_ATTRIB_DIR;
 	ef->root->start_cluster = le32_to_cpu(ef->sb->rootdir_cluster);
 	ef->root->fptr_cluster = ef->root->start_cluster;
 	ef->root->name[0] = cpu_to_le16('\0');
 	ef->root->size = rootdir_size(ef);
 	if (ef->root->size == 0)
 	{
 		free(ef->root);
 		free(ef->zero_cluster);
 		exfat_close(ef->dev);
 		free(ef->sb);
 		return -EIO;
 	}
 	 
 	ef->root->mtime = 0;
 	ef->root->atime = 0;
 	 
 	exfat_get_node(ef->root);
 
 	rc = exfat_cache_directory(ef, ef->root);
 	if (rc != 0)
 		goto error;
 	if (ef->upcase == NULL)
 	{
 		exfat_error(""upcase table is not found"");
 		goto error;
 	}
 	if (ef->cmap.chunk == NULL)
 	{
 		exfat_error(""clusters bitmap is not found"");
 		goto error;
 	}
 
 	if (prepare_super_block(ef) != 0)
 		goto error;
 
 	return 0;
 
 error:
 	exfat_put_node(ef, ef->root);
 	exfat_reset_cache(ef);
 	free(ef->root);
 	free(ef->zero_cluster);
 	exfat_close(ef->dev);
 	free(ef->sb);
 	return -EIO;
 }","[51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]",Heap-based buffer overflow in the verify_vbr_checksum function in exfatfsck in exfat-utils before 1.2.1 allows remote attackers to cause a denial of service (infinite loop) or possibly execute arbitrary code via a crafted filesystem.
208496," int main(int argc, char **argv) {
  int frame_cnt = 0;
  FILE *outfile = NULL;
  vpx_codec_ctx_t codec;
  VpxVideoReader *reader = NULL;
  const VpxVideoInfo *info = NULL;
  const VpxInterface *decoder = NULL;
 
   exec_name = argv[0];
 
  if (argc != 3)
     die(""Invalid number of arguments."");
 
   reader = vpx_video_reader_open(argv[1]);
  if (!reader)
     die(""Failed to open %s for reading."", argv[1]);
 
  if (!(outfile = fopen(argv[2], ""wb"")))
     die(""Failed to open %s for writing."", argv[2]);
 
   info = vpx_video_reader_get_info(reader);
 
   decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);
 
    if (!decoder)
      die(""Unknown input codec."");
  
  printf(""Using %s\n"", vpx_codec_iface_name(decoder->interface()));
   printf(""Using %s\n"", vpx_codec_iface_name(decoder->codec_interface()));
  
  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
   if (vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL, 0))
      die_codec(&codec, ""Failed to initialize decoder"");
  
    while (vpx_video_reader_read_frame(reader)) {
  vpx_codec_iter_t iter = NULL;
  vpx_image_t *img = NULL;
  size_t frame_size = 0;
  const unsigned char *frame = vpx_video_reader_get_frame(reader,
  &frame_size);
  if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))
       die_codec(&codec, ""Failed to decode frame"");
 
  while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {
  unsigned char digest[16];
 
       get_image_md5(img, digest);
       print_md5(outfile, digest);
       fprintf(outfile, ""  img-%dx%d-%04d.i420\n"",
               img->d_w, img->d_h, ++frame_cnt);
  }
  }
 
   printf(""Processed %d frames.\n"", frame_cnt);
  if (vpx_codec_destroy(&codec))
     die_codec(&codec, ""Failed to destroy codec."");
 
   vpx_video_reader_close(reader);
 
   fclose(outfile);
  return EXIT_SUCCESS;
 }","[29, 32, 28, 31]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
7880,"void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,
const Tensor& in, Tensor* out) {

const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);
auto device = ctx->eigen_device<CPUDevice>();
auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();
const auto input_dims = input.dimensions();


Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;
input_slice_sizes[0] = input_dims[0];
TensorShape temp_shape{input_dims[0]};
for (int i = 1; i <= FFTRank; ++i) {
input_slice_sizes[i] = fft_shape[i - 1];
temp_shape.AddDim(fft_shape[i - 1]);
}

auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();
const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;


Tensor temp;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),
temp_shape, &temp));
auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();
full_fft.device(device) =
input.slice(zero_start_indices, input_slice_sizes)
.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);


output.device(device) =
full_fft.slice(zero_start_indices, output.dimensions());
}",[18],"TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
9153,"R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
ut64 offset = 6;
RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
if (attr) {
attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;
attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);
offset += 2;
attr->size = offset;
}

return attr;
}",[6],"Out-of-bounds Read in r_bin_java_constant_value_attr_new function in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end 2f the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. More details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html)."
4143,"static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)
{
struct snd_msnd *chip = dev_id;
void *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;





while (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {
u16 wTmp;

snd_msnd_eval_dsp_msg(chip,
readw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));

wTmp = readw(chip->DSPQ + JQS_wHead) + 1;
if (wTmp > readw(chip->DSPQ + JQS_wSize))
writew(0, chip->DSPQ + JQS_wHead);
else
writew(wTmp, chip->DSPQ + JQS_wHead);
}

inb(chip->io + HP_RXL);
return IRQ_HANDLED;
}","[10, 10, 11, 13, 14, 16, 17, 18, 19, 20, 23]","The snd_msnd_interrupt function in sound/isa/msnd/msnd_pinnacle.c in the Linux kernel through 4.11.7 allows local users to cause a denial of service (over-boundary access) or possibly have unspecified other impact by changing the value of a message queue head pointer between two kernel reads of that value, aka a ""double fetch"" vulnerability."
202652," static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
 {
     cJSON *current_element = NULL;
 
     if ((object == NULL) || (name == NULL))
     {
         return NULL;
     }
 
      current_element = object->child;
      if (case_sensitive)
      {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
          {
              current_element = current_element->next;
          }
     }
     else
     {
         while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
         {
             current_element = current_element->next;
          }
      }
  
     if ((current_element == NULL) || (current_element->string == NULL)) {
         return NULL;
     }
 
      return current_element;
  }","[14, 27, 28, 29, 30, 13]","DaveGamble/cJSON cJSON 1.7.8 is affected by: Improper Check for Unusual or Exceptional Conditions. The impact is: Null dereference, so attack can cause denial of service. The component is: cJSON_GetObjectItemCaseSensitive() function. The attack vector is: crafted json file. The fixed version is: 1.7.9 and later."
198098," static void usb_xhci_exit(PCIDevice *dev)
 {
     int i;
     XHCIState *xhci = XHCI(dev);
 
     trace_usb_xhci_exit();
 
     for (i = 0; i < xhci->numslots; i++) {
         xhci_disable_slot(xhci, i + 1);
     }
 
     if (xhci->mfwrap_timer) {
         timer_del(xhci->mfwrap_timer);
         timer_free(xhci->mfwrap_timer);
         xhci->mfwrap_timer = NULL;
     }
 
     memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);
     memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);
     memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);
     memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);
 
     for (i = 0; i < xhci->numports; i++) {
         XHCIPort *port = &xhci->ports[i];
         memory_region_del_subregion(&xhci->mem, &port->mem);
     }
 
       
      if (dev->msix_table && dev->msix_pba
          && dev->msix_entry_used) {
        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);
        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);
         msix_uninit(dev, &xhci->mem, &xhci->mem);
      }
  
      usb_bus_release(&xhci->bus);
     usb_bus_release(&xhci->bus);
 }","[33, 31, 32]","Memory leak in the usb_xhci_exit function in hw/usb/hcd-xhci.c in QEMU (aka Quick Emulator), when the xhci uses msix, allows local guest OS administrators to cause a denial of service (memory consumption and possibly QEMU process crash) by repeatedly unplugging a USB device."
8602,"void Compute(OpKernelContext* context) override {
const Tensor& start_in = context->input(0);
const Tensor& limit_in = context->input(1);
const Tensor& delta_in = context->input(2);

OP_REQUIRES(context,
TensorShapeUtils::IsScalar(start_in.shape()) ||
(TensorShapeUtils::IsVector(start_in.shape()) &&
start_in.shape().dim_size(0) == 1),
errors::InvalidArgument(""start must be a scalar, not shape "",
start_in.shape().DebugString()));
OP_REQUIRES(context,
TensorShapeUtils::IsScalar(limit_in.shape()) ||
(TensorShapeUtils::IsVector(limit_in.shape()) &&
limit_in.shape().dim_size(0) == 1),
errors::InvalidArgument(""limit must be a scalar, not shape "",
limit_in.shape().DebugString()));
OP_REQUIRES(context,
TensorShapeUtils::IsScalar(delta_in.shape()) ||
(TensorShapeUtils::IsVector(delta_in.shape()) &&
delta_in.shape().dim_size(0) == 1),
errors::InvalidArgument(""delta must be a scalar, not shape "",
delta_in.shape().DebugString()));
const T start = start_in.scalar<T>()();
const T limit = limit_in.scalar<T>()();
const T delta = delta_in.scalar<T>()();
OP_REQUIRES(context, delta != 0,
errors::InvalidArgument(""Requires delta != 0: "", delta));
if (delta > 0) {
OP_REQUIRES(
context, start <= limit,
errors::InvalidArgument(
""Requires start <= limit when delta > 0: "", start, ""/"", limit));
} else {
OP_REQUIRES(
context, start >= limit,
errors::InvalidArgument(
""Requires start >= limit when delta < 0: "", start, ""/"", limit));
}
int64_t size = (std::is_integral<T>::value
? ((std::abs(limit - start) + std::abs(delta) - 1) /
std::abs(delta))
: std::ceil(std::abs((limit - start) / delta)));
Tensor* out = nullptr;
OP_REQUIRES_OK(context,
context->allocate_output(0, TensorShape({size}), &out));
auto flat = out->flat<T>();
T val = start;
for (int64_t i = 0; i < size; ++i) {
flat(i) = T(val);
val += delta;
}
}","[40, 41, 42, 43]","TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."
204778," static v8::Handle<v8::Value> methodReturningSequenceCallback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestObj.methodReturningSequence"");
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestObj* imp = V8TestObj::toNative(args.Holder());
      EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
      return v8Array(imp->methodReturningSequence(intArg), args.GetIsolate());
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
200861," static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
 	const char *section_name = """";
 	const char *link_section_name = """";
 	char *end = NULL;
 	Elf_(Shdr) *link_shdr = NULL;
 	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
 	Sdb *sdb;
 	int cnt, i;
 	if (shdr->sh_link > bin->ehdr.e_shnum) {
  		return false;
  	}
  	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1) {
 	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
  		return false;
  	}
  	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
 	if (!defs) {
 		return false;
 	}
 	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
 		section_name = &bin->shstrtab[shdr->sh_name];
 	}
 	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
 		link_section_name = &bin->shstrtab[link_shdr->sh_name];
 	}
 	if (!defs) {
 		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
 		return NULL;
 	}
 	sdb = sdb_new0 ();
 	end = (char *)defs + shdr->sh_size;
 	sdb_set (sdb, ""section_name"", section_name, 0);
 	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
 	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
 	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
 	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
 		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
 		Elf_(Verdaux) aux = {0};
 		int j = 0;
 		int isum = 0;
 
 		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
 		verdef->vd_version = READ16 (dfs, j)
 		verdef->vd_flags = READ16 (dfs, j)
 		verdef->vd_ndx = READ16 (dfs, j)
 		verdef->vd_cnt = READ16 (dfs, j)
 		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
 		if (vdaux < 1) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
 		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 
 		j = 0;
 		aux.vda_name = READ32 (vstart, j)
 		aux.vda_next = READ32 (vstart, j)
 
 		isum = i + verdef->vd_aux;
 		if (aux.vda_name > bin->dynstr_size) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 
 		sdb_num_set (sdb_verdef, ""idx"", i, 0);
 		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
 		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
 		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
 		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
 		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);
 
 		for (j = 1; j < verdef->vd_cnt; ++j) {
 			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
 			if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;
 			}
 			k = 0;
 			aux.vda_name = READ32 (vstart, k)
 			aux.vda_next = READ32 (vstart, k)
 			if (aux.vda_name > bin->dynstr_size) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;
 			}
 			sdb_num_set (sdb_parent, ""idx"", isum, 0);
 			sdb_num_set (sdb_parent, ""parent"", j, 0);
 			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
 			snprintf (key, sizeof (key), ""parent%d"", j - 1);
 			sdb_ns_set (sdb_verdef, key, sdb_parent);
 		}
 
 		snprintf (key, sizeof (key), ""verdef%d"", cnt);
 		sdb_ns_set (sdb, key, sdb_verdef);
 		if (!verdef->vd_next) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		if ((st32)verdef->vd_next < 1) {
 			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
 			break;
 		}
 		i += verdef->vd_next;
 	}
 	free (defs);
 	return sdb;
 out_error:
 	free (defs);
 	sdb_free (sdb);
 	return NULL;
 }","[14, 13]","In radare 2.0.1, a memory corruption vulnerability exists in store_versioninfo_gnu_verdef() and store_versioninfo_gnu_verneed() in libr/bin/format/elf/elf.c, as demonstrated by an invalid free. This error is due to improper sh_size validation when allocating memory."
206514," void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {
   DCHECK(submission->method() == FormSubmission::PostMethod ||
          submission->method() == FormSubmission::GetMethod);
   DCHECK(submission->data());
   DCHECK(submission->form());
   if (submission->action().isEmpty())
     return;
   if (document().isSandboxed(SandboxForms)) {
     document().addConsoleMessage(ConsoleMessage::create(
         SecurityMessageSource, ErrorMessageLevel,
         ""Blocked form submission to '"" + submission->action().elidedString() +
             ""' because the form's frame is sandboxed and the 'allow-forms' ""
             ""permission is not set.""));
      return;
    }
  
   if (!document().contentSecurityPolicy()->allowFormAction(
           submission->action())) {
     return;
   }
 
    if (protocolIsJavaScript(submission->action())) {
    if (!document().contentSecurityPolicy()->allowFormAction(
            submission->action()))
      return;
      document().frame()->script().executeScriptIfJavaScriptURL(
          submission->action(), this);
      return;
   }
 
   Frame* targetFrame = document().frame()->findFrameForNavigation(
       submission->target(), *document().frame());
   if (!targetFrame) {
     if (!LocalDOMWindow::allowPopUp(*document().frame()) &&
         !UserGestureIndicator::utilizeUserGesture())
       return;
     targetFrame = document().frame();
   } else {
     submission->clearTarget();
   }
   if (!targetFrame->host())
     return;
 
   UseCounter::count(document(), UseCounter::FormsSubmitted);
   if (MixedContentChecker::isMixedFormAction(document().frame(),
                                              submission->action()))
     UseCounter::count(document().frame(),
                       UseCounter::MixedContentFormsSubmitted);
 
   if (targetFrame->isLocalFrame()) {
     toLocalFrame(targetFrame)
         ->navigationScheduler()
         .scheduleFormSubmission(&document(), submission);
   } else {
     FrameLoadRequest frameLoadRequest =
         submission->createFrameLoadRequest(&document());
     toRemoteFrame(targetFrame)->navigate(frameLoadRequest);
   }
 }","[17, 18, 19, 20, 21, 23, 24, 25]","Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly handled form actions, which allowed a remote attacker to bypass Content Security Policy via a crafted HTML page."
203761," void FFmpegVideoDecodeEngine::Initialize(
     MessageLoop* message_loop,
     VideoDecodeEngine::EventHandler* event_handler,
     VideoDecodeContext* context,
     const VideoDecoderConfig& config) {
   static const int kDecodeThreads = 2;
   static const int kMaxDecodeThreads = 16;
 
   codec_context_ = avcodec_alloc_context();
 
   codec_context_->pix_fmt = PIX_FMT_YUV420P;
   codec_context_->codec_type = AVMEDIA_TYPE_VIDEO;
   codec_context_->codec_id = VideoCodecToCodecID(config.codec());
   codec_context_->coded_width = config.width();
   codec_context_->coded_height = config.height();
 
   frame_rate_numerator_ = config.frame_rate_numerator();
   frame_rate_denominator_ = config.frame_rate_denominator();
  
    if (config.extra_data() != NULL) {
      codec_context_->extradata_size = config.extra_data_size();
    codec_context_->extradata =
        reinterpret_cast<uint8_t*>(av_malloc(config.extra_data_size()));
     codec_context_->extradata = reinterpret_cast<uint8_t*>(
         av_malloc(config.extra_data_size() + FF_INPUT_BUFFER_PADDING_SIZE));
      memcpy(codec_context_->extradata, config.extra_data(),
             config.extra_data_size());
     memset(codec_context_->extradata + config.extra_data_size(), '\0',
            FF_INPUT_BUFFER_PADDING_SIZE);
    }
  
   codec_context_->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;
   codec_context_->error_recognition = FF_ER_CAREFUL;
 
   AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
 
   int decode_threads = (codec_context_->codec_id == CODEC_ID_THEORA) ?
       1 : kDecodeThreads;
 
   const CommandLine* cmd_line = CommandLine::ForCurrentProcess();
   std::string threads(cmd_line->GetSwitchValueASCII(switches::kVideoThreads));
   if ((!threads.empty() &&
       !base::StringToInt(threads, &decode_threads)) ||
       decode_threads < 0 || decode_threads > kMaxDecodeThreads) {
     decode_threads = kDecodeThreads;
   }
 
   av_frame_.reset(avcodec_alloc_frame());
   VideoCodecInfo info;
   info.success = false;
   info.provides_buffers = true;
   info.stream_info.surface_type = VideoFrame::TYPE_SYSTEM_MEMORY;
   info.stream_info.surface_format = GetSurfaceFormat();
   info.stream_info.surface_width = config.surface_width();
   info.stream_info.surface_height = config.surface_height();
 
   bool buffer_allocated = true;
   frame_queue_available_.clear();
 
   for (size_t i = 0; i < Limits::kMaxVideoFrames; ++i) {
     scoped_refptr<VideoFrame> video_frame;
     VideoFrame::CreateFrame(VideoFrame::YV12,
                             config.width(),
                             config.height(),
                             kNoTimestamp,
                             kNoTimestamp,
                             &video_frame);
     if (!video_frame.get()) {
       buffer_allocated = false;
       break;
     }
     frame_queue_available_.push_back(video_frame);
   }
 
   if (codec &&
       avcodec_thread_init(codec_context_, decode_threads) >= 0 &&
       avcodec_open(codec_context_, codec) >= 0 &&
       av_frame_.get() &&
       buffer_allocated) {
     info.success = true;
   }
   event_handler_ = event_handler;
   event_handler_->OnInitializeComplete(info);
 }","[24, 25, 28, 29, 22, 23]","Google Chrome before 14.0.835.163 does not properly handle media buffers, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
6454,"TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {
TFLITE_DCHECK(node->user_data != nullptr);

OpData* data = static_cast<OpData*>(node->user_data);

const TfLiteTensor* input = GetInput(context, node, kInputTensor);
data->input_zero_point = input->params.zero_point;
return CalculateArithmeticOpData(context, node, data);
}",[7],"In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code."
200255," static void spl_filesystem_object_free_storage(void *object TSRMLS_DC)  
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)object;
 
  	if (intern->oth_handler && intern->oth_handler->dtor) {
  		intern->oth_handler->dtor(intern TSRMLS_CC);
  	}
 
  	zend_object_std_dtor(&intern->std TSRMLS_CC);
 
  	if (intern->_path) {
  		efree(intern->_path);
  	}
 	if (intern->file_name) {
 		efree(intern->file_name);
 	}
 	switch(intern->type) {
 	case SPL_FS_INFO:
 		break;
 	case SPL_FS_DIR:
 		if (intern->u.dir.dirp) {
 			php_stream_close(intern->u.dir.dirp);
 			intern->u.dir.dirp = NULL;
  		}
  		if (intern->u.dir.sub_path) {
  			efree(intern->u.dir.sub_path);
		}		
 		}
  		break;
  	case SPL_FS_FILE:
  		if (intern->u.file.stream) {
 			if (intern->u.file.zcontext) {
  
 			}
 			if (!intern->u.file.stream->is_persistent) {
 				php_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);
 			} else {
 				php_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);
 			}
 			if (intern->u.file.open_mode) {
 				efree(intern->u.file.open_mode);
 			}
 			if (intern->orig_path) {
 				efree(intern->orig_path);
 			}
 		}
 		spl_filesystem_file_free_line(intern TSRMLS_CC);
 		break;
 	}
 
 	{
 		zend_object_iterator *iterator;
 		iterator = (zend_object_iterator*)
 				spl_filesystem_object_to_iterator(intern);
 		if (iterator->data != NULL) {
 			iterator->data = NULL;
 			iterator->funcs->dtor(iterator TSRMLS_CC);
 		}
 	}
 	efree(object);
  }  ","[8, 10, 28, 27]","Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096."
199401," cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)
 cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)
  {
	struct list_head *tmp;
  	struct cifsSesInfo *ses;
  
  	write_lock(&cifs_tcp_ses_lock);
	list_for_each(tmp, &server->smb_ses_list) {
		ses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);
		if (strncmp(ses->userName, username, MAX_USERNAME_SIZE))
			continue;
 	list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
 		switch (server->secType) {
 		case Kerberos:
 			if (vol->linux_uid != ses->linux_uid)
 				continue;
 			break;
 		default:
 			 
 			if (strncmp(ses->userName, vol->username,
 				    MAX_USERNAME_SIZE))
 				continue;
 			if (strlen(vol->username) != 0 &&
 			    strncmp(ses->password, vol->password,
 				    MAX_PASSWORD_SIZE))
 				continue;
 		}
  		++ses->ses_count;
  		write_unlock(&cifs_tcp_ses_lock);
  		return ses;
 	}
 	write_unlock(&cifs_tcp_ses_lock);
 	return NULL;
 }","[2, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 4, 8, 9, 10, 11]","The cifs_find_smb_ses function in fs/cifs/connect.c in the Linux kernel before 2.6.36 does not properly determine the associations between users and sessions, which allows local users to bypass CIFS share authentication by leveraging a mount of a share by a different user."
200955," int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                      mbedtls_x509_crt *trust_ca,
                      mbedtls_x509_crl *ca_crl,
                      const mbedtls_x509_crt_profile *profile,
                      const char *cn, uint32_t *flags,
                      int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                      void *p_vrfy )
 {
     size_t cn_len;
     int ret;
     int pathlen = 0, selfsigned = 0;
     mbedtls_x509_crt *parent;
     mbedtls_x509_name *name;
      mbedtls_x509_sequence *cur = NULL;
      mbedtls_pk_type_t pk_type;
  
    if( profile == NULL )
        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
      *flags = 0;
  
     if( profile == NULL )
     {
         ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
         goto exit;
     }
 
      if( cn != NULL )
      {
          name = &crt->subject;
         cn_len = strlen( cn );
 
         if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
         {
             cur = &crt->subject_alt_names;
 
             while( cur != NULL )
             {
                 if( cur->buf.len == cn_len &&
                     x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                     break;
 
                 if( cur->buf.len > 2 &&
                     memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                     x509_check_wildcard( cn, &cur->buf ) == 0 )
                 {
                     break;
                 }
 
                 cur = cur->next;
             }
 
             if( cur == NULL )
                 *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
         }
         else
         {
             while( name != NULL )
             {
                 if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                 {
                     if( name->val.len == cn_len &&
                         x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                         break;
 
                     if( name->val.len > 2 &&
                         memcmp( name->val.p, ""*."", 2 ) == 0 &&
                         x509_check_wildcard( cn, &name->val ) == 0 )
                         break;
                 }
 
                 name = name->next;
             }
 
             if( name == NULL )
                 *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
         }
     }
 
      
     pk_type = mbedtls_pk_get_type( &crt->pk );
 
     if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
         *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
 
     if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
         *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 
      
     for( parent = trust_ca; parent != NULL; parent = parent->next )
     {
         if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
             break;
     }
 
     if( parent != NULL )
     {
          ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                     pathlen, selfsigned, flags, f_vrfy, p_vrfy );
          if( ret != 0 )
            return( ret );
             goto exit;
      }
      else
      {
          
         for( parent = crt->next; parent != NULL; parent = parent->next )
             if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                 break;
 
          
         if( parent != NULL )
         {
              ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                           pathlen, selfsigned, flags, f_vrfy, p_vrfy );
              if( ret != 0 )
                return( ret );
                 goto exit;
          }
          else
          {
              ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );
              if( ret != 0 )
                return( ret );
                 goto exit;
          }
      }
  
 exit:
     if( ret != 0 )
     {
         *flags = (uint32_t) -1;
         return( ret );
     }
 
      if( *flags != 0 )
          return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
  
     return( 0 );
 }","[21, 22, 23, 24, 25, 26, 101, 117, 125, 129, 130, 131, 132, 133, 134, 135, 17, 18, 100, 116, 124]","ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected."
203103," int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
 		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
 	{
 	EVP_MD_CTX ctx;
 	unsigned char *buf_in=NULL;
 	int ret= -1,inl;
 
 	int mdnid, pknid;
 
 	if (!pkey)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
  		return -1;
  		}
  
 	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
 		{
 		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
 		return -1;
 		}
 
  	EVP_MD_CTX_init(&ctx);
  
  	 
 	if (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
 		goto err;
 		}
 	if (mdnid == NID_undef)
 		{
 		if (!pkey->ameth || !pkey->ameth->item_verify)
 			{
 			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
 			goto err;
 			}
 		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
 							signature, pkey);
 		 
 		if (ret != 2)
 			goto err;
 		ret = -1;
 		}
 	else
 		{
 		const EVP_MD *type;
 		type=EVP_get_digestbynid(mdnid);
 		if (type == NULL)
 			{
 			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
 			goto err;
 			}
 
 		 
 		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
 			{
 			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
 			goto err;
 			}
 
 		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
 			{
 			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
 			ret=0;
 			goto err;
 			}
 
 		}
 
 	inl = ASN1_item_i2d(asn, &buf_in, it);
 	
 	if (buf_in == NULL)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
 		goto err;
 		}
 
 	ret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);
 
 	OPENSSL_cleanse(buf_in,(unsigned int)inl);
 	OPENSSL_free(buf_in);
 
 	if (!ret)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
 		goto err;
 		}
 	ret = -1;
 
 	if (EVP_DigestVerifyFinal(&ctx,signature->data,
 			(size_t)signature->length) <= 0)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
 		ret=0;
 		goto err;
 		}
 	 
 	 
 	ret=1;
 err:
 	EVP_MD_CTX_cleanup(&ctx);
 	return(ret);
 	}","[16, 17, 18, 19, 20, 21]","OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c."
199142," static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)
 {
  	struct sem_array *sma;
  	struct sem_undo_list *ulp;
  	struct sem_undo *un, *new;
	int nsems;
	int error;
 	int nsems, error;
  
  	error = get_undo_list(&ulp);
  	if (error)
 		return ERR_PTR(error);
 
 	rcu_read_lock();
 	spin_lock(&ulp->lock);
 	un = lookup_undo(ulp, semid);
 	spin_unlock(&ulp->lock);
 	if (likely(un!=NULL))
 		goto out;
 
 	 
 	 
 	sma = sem_obtain_object_check(ns, semid);
 	if (IS_ERR(sma)) {
 		rcu_read_unlock();
 		return ERR_CAST(sma);
  	}
  
  	nsems = sma->sem_nsems;
	ipc_rcu_getref(sma);
 	if (!ipc_rcu_getref(sma)) {
 		rcu_read_unlock();
 		un = ERR_PTR(-EIDRM);
 		goto out;
 	}
  	rcu_read_unlock();
  
  	 
 	new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);
 	if (!new) {
 		sem_putref(sma);
 		return ERR_PTR(-ENOMEM);
 	}
 
  	 
  	sem_lock_and_putref(sma);
  	if (sma->sem_perm.deleted) {
		sem_unlock(sma);
 		sem_unlock(sma, -1);
  		kfree(new);
  		un = ERR_PTR(-EIDRM);
  		goto out;
 	}
 	spin_lock(&ulp->lock);
 
 	 
 	un = lookup_undo(ulp, semid);
 	if (un) {
 		kfree(new);
 		goto success;
 	}
 	 
 	new->semadj = (short *) &new[1];
 	new->ulp = ulp;
 	new->semid = semid;
 	assert_spin_locked(&ulp->lock);
 	list_add_rcu(&new->list_proc, &ulp->list_proc);
 	assert_spin_locked(&sma->sem_perm.lock);
 	list_add(&new->list_id, &sma->list_id);
 	un = new;
 
  success:
  	spin_unlock(&ulp->lock);
  	rcu_read_lock();
	sem_unlock(sma);
 	sem_unlock(sma, -1);
  out:
  	return un;
  }","[8, 31, 32, 33, 34, 35, 49, 76, 6, 7, 30, 48, 75]","The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application."
203885," void HttpBridge::MakeAsynchronousPost() {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
   base::AutoLock lock(fetch_state_lock_);
   DCHECK(!fetch_state_.request_completed);
    if (fetch_state_.aborted)
      return;
  
  fetch_state_.url_poster = new URLFetcher(url_for_request_,
                                           URLFetcher::POST, this);
   fetch_state_.url_poster = URLFetcher::Create(0, url_for_request_,
                                                URLFetcher::POST, this);
    fetch_state_.url_poster->set_request_context(context_getter_for_request_);
    fetch_state_.url_poster->set_upload_data(content_type_, request_content_);
    fetch_state_.url_poster->set_extra_request_headers(extra_headers_);
   fetch_state_.url_poster->set_load_flags(net::LOAD_DO_NOT_SEND_COOKIES);
   fetch_state_.url_poster->Start();
 }","[10, 11, 8, 9]",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to media selectors.
205970," TracingControllerImpl::TracingControllerImpl()
     : delegate_(GetContentClient()->browser()->GetTracingDelegate()),
       weak_ptr_factory_(this) {
   DCHECK(!g_tracing_controller);
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   base::FileTracing::SetProvider(new FileTracingProviderImpl);
   AddAgents();
    base::trace_event::TraceLog::GetInstance()->AddAsyncEnabledStateObserver(
        weak_ptr_factory_.GetWeakPtr());
    g_tracing_controller = this;
 
    
    
   ConnectToServiceIfNeeded();
  }","[11, 12, 13, 14]","The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site."
203700," void PrintWebViewHelper::OnPrintForPrintPreview(
     const DictionaryValue& job_settings) {
   DCHECK(is_preview_);
   if (print_web_view_)
     return;
 
   if (!render_view()->webview())
     return;
   WebFrame* main_frame = render_view()->webview()->mainFrame();
   if (!main_frame)
     return;
 
   WebDocument document = main_frame->document();
   WebElement pdf_element = document.getElementById(""pdf-viewer"");
   if (pdf_element.isNull()) {
     NOTREACHED();
      return;
    }
  
  WebFrame* pdf_frame = pdf_element.document().frame();
  scoped_ptr<PrepareFrameAndViewForPrint> prepare;
  if (!InitPrintSettingsAndPrepareFrame(pdf_frame, &pdf_element, &prepare)) {
    LOG(ERROR) << ""Failed to initialize print page settings"";
    return;
  }
    if (!UpdatePrintSettings(job_settings, false)) {
      LOG(ERROR) << ""UpdatePrintSettings failed"";
      DidFinishPrinting(FAIL_PRINT);
      return;
    }
  
   WebFrame* pdf_frame = pdf_element.document().frame();
   scoped_ptr<PrepareFrameAndViewForPrint> prepare;
   prepare.reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,
                                                 pdf_frame, &pdf_element));
   UpdatePrintableSizeInPrintParameters(pdf_frame, &pdf_element, prepare.get(),
                                        &print_pages_params_->params);
 
    if (!RenderPagesForPrint(pdf_frame, &pdf_element, prepare.get())) {
      LOG(ERROR) << ""RenderPagesForPrint failed"";
     DidFinishPrinting(FAIL_PRINT);
   }
 }","[32, 33, 34, 35, 36, 37, 38, 20, 21, 22, 23, 24, 25]",Use-after-free vulnerability in Google Chrome before 15.0.874.120 allows user-assisted remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to editing.
204892," void FolderHeaderView::ContentsChanged(views::Textfield* sender,
                                        const base::string16& new_contents) {
    if (!folder_item_)
      return;
  
   folder_name_view_->Update();
    folder_item_->RemoveObserver(this);
  std::string name = base::UTF16ToUTF8(folder_name_view_->text());
  delegate_->SetItemName(folder_item_, name);
    
   std::string name = base::UTF16ToUTF8(
       folder_name_view_->text().substr(0, kMaxFolderNameChars));
   if (name != folder_item_->name())
     delegate_->SetItemName(folder_item_, name);
    folder_item_->AddObserver(this);
  
    Layout();
 }","[6, 10, 11, 12, 13, 14, 8, 9]","Use-after-free vulnerability in the HTMLMediaElement::didMoveToNewDocument function in core/html/HTMLMediaElement.cpp in Blink, as used in Google Chrome before 29.0.1547.57, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving moving a (1) AUDIO or (2) VIDEO element between documents."
202148," int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
 		const URI_TYPE(QueryList) * queryList,
 		int maxChars, int * charsWritten, int * charsRequired,
 		UriBool spaceToPlus, UriBool normalizeBreaks) {
 	UriBool firstItem = URI_TRUE;
 	int ampersandLen = 0;   
 	URI_CHAR * write = dest;
 
 	 
 	if (dest == NULL) {
 		*charsRequired = 0;
 	} else {
 		maxChars--;
 	}
 			
 	while (queryList != NULL) {
 		const URI_CHAR * const key = queryList->key;
 		const URI_CHAR * const value = queryList->value;
 		const int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);
 		const int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);
 		const int keyRequiredChars = worstCase * keyLen;
 		const int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);
 		const int valueRequiredChars = worstCase * valueLen;
 
 		if (dest == NULL) {
 			if (firstItem == URI_TRUE) {
 				ampersandLen = 1;
 				firstItem = URI_FALSE;
 			}
 
 			(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)
 						? 0
 						: 1 + valueRequiredChars);
 		} else {
 			URI_CHAR * afterKey;
 
 			if ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {
 				return URI_ERROR_OUTPUT_TOO_LARGE;
 			}
  
  			 
  			if (firstItem == URI_TRUE) {
 				ampersandLen = 1;
  				firstItem = URI_FALSE;
  			} else {
  				write[0] = _UT('&');
 				write++;
 			}
 			afterKey = URI_FUNC(EscapeEx)(key, key + keyLen,
 					write, spaceToPlus, normalizeBreaks);
 			write += (afterKey - write);
 
 			if (value != NULL) {
 				URI_CHAR * afterValue;
 
 				if ((write - dest) + 1 + valueRequiredChars > maxChars) {
 					return URI_ERROR_OUTPUT_TOO_LARGE;
 				}
 
 				 
 				write[0] = _UT('=');
 				write++;
 				afterValue = URI_FUNC(EscapeEx)(value, value + valueLen,
 						write, spaceToPlus, normalizeBreaks);
 				write += (afterValue - write);
 			}
 		}
 
 		queryList = queryList->next;
 	}
 
 	if (dest != NULL) {
 		write[0] = _UT('\0');
 		if (charsWritten != NULL) {
 			*charsWritten = (int)(write - dest) + 1;  
 		}
 	}
 
 	return URI_SUCCESS;
 }",[43],An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an out-of-bounds write via a uriComposeQuery* or uriComposeQueryEx* function because the '&' character is mishandled in certain contexts.
201561," static int klsi_105_get_line_state(struct usb_serial_port *port,
 				   unsigned long *line_state_p)
 {
 	int rc;
 	u8 *status_buf;
 	__u16 status;
 
 	dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n"");
 
 	status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);
 	if (!status_buf)
 		return -ENOMEM;
 
 	status_buf[0] = 0xff;
 	status_buf[1] = 0xff;
 	rc = usb_control_msg(port->serial->dev,
 			     usb_rcvctrlpipe(port->serial->dev, 0),
 			     KL5KUSB105A_SIO_POLL,
 			     USB_TYPE_VENDOR | USB_DIR_IN,
 			     0,  
 			     0,  
  			     status_buf, KLSI_STATUSBUF_LEN,
  			     10000
  			     );
	if (rc < 0)
		dev_err(&port->dev, ""Reading line status failed (error = %d)\n"",
			rc);
	else {
 	if (rc != KLSI_STATUSBUF_LEN) {
 		dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
 		if (rc >= 0)
 			rc = -EIO;
 	} else {
  		status = get_unaligned_le16(status_buf);
  
  		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",
 			 status_buf[0], status_buf[1]);
 
 		*line_state_p = klsi_105_status2linestate(status);
 	}
 
 	kfree(status_buf);
 	return rc;
 }","[29, 30, 31, 32, 33, 25, 26, 27, 28]","The klsi_105_get_line_state function in drivers/usb/serial/kl5kusb105.c in the Linux kernel before 4.9.5 places uninitialized heap-memory contents into a log entry upon a failure to read the line status, which allows local users to obtain sensitive information by reading the log."
5375,"static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,
oidc_session_t *session, const char *client_id,
const char *check_session_iframe) {

oidc_debug(r, ""enter"");

const char *java_script =
""    <script type=\""text/javascript\"">\n""
""      var targetOrigin  = '%s';\n""
""      var message = '%s' + ' ' + '%s';\n""
""	   var timerID;\n""
""\n""
""      function checkSession() {\n""
""        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\n""
""        var win = window.parent.document.getElementById('%s').contentWindow;\n""
""        win.postMessage( message, targetOrigin);\n""
""      }\n""
""\n""
""      function setTimer() {\n""
""        checkSession();\n""
""        timerID = setInterval('checkSession()', %s);\n""
""      }\n""
""\n""
""      function receiveMessage(e) {\n""
""        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\n""
""        if (e.origin !== targetOrigin ) {\n""
""          console.debug('receiveMessage: cross-site scripting attack?');\n""
""          return;\n""
""        }\n""
""        if (e.data != 'unchanged') {\n""
""          clearInterval(timerID);\n""
""          if (e.data == 'changed') {\n""
""		     window.location.href = '%s?session=check';\n""
""          } else {\n""
""		     window.location.href = '%s?session=logout';\n""
""          }\n""
""        }\n""
""      }\n""
""\n""
""      window.addEventListener('message', receiveMessage, false);\n""
""\n""
""    </script>\n"";


char *origin = apr_pstrdup(r->pool, check_session_iframe);
apr_uri_t uri;
apr_uri_parse(r->pool, check_session_iframe, &uri);
char *p = strstr(origin, uri.path);
*p = '\0';


const char *op_iframe_id = ""openidc-op"";


const char *session_state = oidc_session_get_session_state(r, session);
if (session_state == NULL) {
oidc_warn(r,
""no session_state found in the session; the OP does probably not support session management!?"");
return DONE;
}

char *s_poll_interval = NULL;
oidc_util_get_request_parameter(r, ""poll"", &s_poll_interval);
if (s_poll_interval == NULL)
s_poll_interval = ""3000"";

const char *redirect_uri = oidc_get_redirect_uri(r, c);
java_script = apr_psprintf(r->pool, java_script, origin, client_id,
session_state, op_iframe_id, s_poll_interval, redirect_uri,
redirect_uri);

return oidc_util_html_send(r, NULL, java_script, ""setTimer"", NULL, DONE);
}","[21, 64, 65, 69]","ZmartZone IAM mod_auth_openidc 2.3.10.1 and earlier is affected by: Cross Site Scripting (XSS). The impact is: Redirecting the user to a phishing page or interacting with the application on behalf of the user. The component is: File: src/mod_auth_openidc.c, Line: 3109. The fixed version is: 2.3.10.2."
203165," ext4_xattr_create_cache(char *name)
 struct mb2_cache *
 ext4_xattr_create_cache(void)
  {
	return mb_cache_create(name, HASH_BUCKET_BITS);
 	return mb2_cache_create(HASH_BUCKET_BITS);
  }","[2, 3, 6, 5]","The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba."
6130,"yyparse (void *scanner, struct yang_parameter *param)
{

int yychar;
char *s = NULL, *tmp_s = NULL, *ext_name = NULL;
struct lys_module *trg = NULL;
struct lys_node *tpdf_parent = NULL, *data_node = NULL;
struct lys_ext_instance_complex *ext_instance = NULL;
int is_ext_instance;
void *actual = NULL;
enum yytokentype backup_type, actual_type = MODULE_KEYWORD;
int64_t cnt_val = 0;
int is_value = 0;
void *yang_type = NULL;





YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);


static YYLTYPE yyloc_default
# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
= { 1, 1, 1, 1 }
# endif
;
YYLTYPE yylloc = yyloc_default;


int yynerrs;

int yystate;

int yyerrstatus;










yytype_int16 yyssa[YYINITDEPTH];
yytype_int16 *yyss;
yytype_int16 *yyssp;


YYSTYPE yyvsa[YYINITDEPTH];
YYSTYPE *yyvs;
YYSTYPE *yyvsp;


YYLTYPE yylsa[YYINITDEPTH];
YYLTYPE *yyls;
YYLTYPE *yylsp;


YYLTYPE yyerror_range[3];

YYSIZE_T yystacksize;

int yyn;
int yyresult;

int yytoken = 0;


YYSTYPE yyval;
YYLTYPE yyloc;

#if YYERROR_VERBOSE

char yymsgbuf[128];
char *yymsg = yymsgbuf;
YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))



int yylen = 0;

yyssp = yyss = yyssa;
yyvsp = yyvs = yyvsa;
yylsp = yyls = yylsa;
yystacksize = YYINITDEPTH;

YYDPRINTF ((stderr, ""Starting parse\n""));

yystate = 0;
yyerrstatus = 0;
yynerrs = 0;
yychar = YYEMPTY;



{ yylloc.last_column = 0;
if (param->flags & EXT_INSTANCE_SUBSTMT) {
is_ext_instance = 1;
ext_instance = (struct lys_ext_instance_complex *)param->actual_node;
ext_name = (char *)param->data_node;
} else {
is_ext_instance = 0;
}
yylloc.last_line = is_ext_instance;
param->value = &s;
param->data_node = (void **)&data_node;
param->actual_node = &actual;
backup_type = NODE;
trg = (param->submodule) ? (struct lys_module *)param->submodule : param->module;
}


yylsp[0] = yylloc;
goto yysetstate;




yynewstate:


yyssp++;

yysetstate:
*yyssp = (yytype_int16) yystate;

if (yyss + yystacksize - 1 <= yyssp)
{

YYSIZE_T yysize = (YYSIZE_T) (yyssp - yyss + 1);

#ifdef yyoverflow
{



YYSTYPE *yyvs1 = yyvs;
yytype_int16 *yyss1 = yyss;
YYLTYPE *yyls1 = yyls;





yyoverflow (YY_(""memory exhausted""),
&yyss1, yysize * sizeof (*yyssp),
&yyvs1, yysize * sizeof (*yyvsp),
&yyls1, yysize * sizeof (*yylsp),
&yystacksize);
yyss = yyss1;
yyvs = yyvs1;
yyls = yyls1;
}
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
goto yyexhaustedlab;
# else

if (YYMAXDEPTH <= yystacksize)
goto yyexhaustedlab;
yystacksize *= 2;
if (YYMAXDEPTH < yystacksize)
yystacksize = YYMAXDEPTH;

{
yytype_int16 *yyss1 = yyss;
union yyalloc *yyptr =
(union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
if (! yyptr)
goto yyexhaustedlab;
YYSTACK_RELOCATE (yyss_alloc, yyss);
YYSTACK_RELOCATE (yyvs_alloc, yyvs);
YYSTACK_RELOCATE (yyls_alloc, yyls);
#  undef YYSTACK_RELOCATE
if (yyss1 != yyssa)
YYSTACK_FREE (yyss1);
}
# endif
#endif /* no yyoverflow */

yyssp = yyss + yysize - 1;
yyvsp = yyvs + yysize - 1;
yylsp = yyls + yysize - 1;

YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
(unsigned long) yystacksize));

if (yyss + yystacksize - 1 <= yyssp)
YYABORT;
}

YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

if (yystate == YYFINAL)
YYACCEPT;

goto yybackup;




yybackup:





yyn = yypact[yystate];
if (yypact_value_is_default (yyn))
goto yydefault;




if (yychar == YYEMPTY)
{
YYDPRINTF ((stderr, ""Reading a token: ""));
yychar = yylex (&yylval, &yylloc, scanner);
}

if (yychar <= YYEOF)
{
yychar = yytoken = YYEOF;
YYDPRINTF ((stderr, ""Now at end of input.\n""));
}
else
{
yytoken = YYTRANSLATE (yychar);
YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
}



yyn += yytoken;
if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
goto yydefault;
yyn = yytable[yyn];
if (yyn <= 0)
{
if (yytable_value_is_error (yyn))
goto yyerrlab;
yyn = -yyn;
goto yyreduce;
}



if (yyerrstatus)
yyerrstatus--;


YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);


yychar = YYEMPTY;

yystate = yyn;
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
*++yyvsp = yylval;
YY_IGNORE_MAYBE_UNINITIALIZED_END
*++yylsp = yylloc;
goto yynewstate;





yydefault:
yyn = yydefact[yystate];
if (yyn == 0)
goto yyerrlab;
goto yyreduce;





yyreduce:

yylen = yyr2[yyn];









yyval = yyvsp[1-yylen];


YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
yyerror_range[1] = yyloc;
YY_REDUCE_PRINT (yyn);
switch (yyn)
{
case 5:

{ if (yyget_text(scanner)[0] == '""') {
char *tmp;

s = malloc(yyget_leng(scanner) - 1 + 7 * yylval.i);
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, yyget_leng(scanner) - 2, 0, yylloc.first_column))) {
YYABORT;
}
s = tmp;
} else {
s = calloc(1, yyget_leng(scanner) - 1);
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
memcpy(s, yyget_text(scanner) + 1, yyget_leng(scanner) - 2);
}
(yyval.p_str) = &s;
}

break;

case 8:

{ if (yyget_leng(scanner) > 2) {
int length_s = strlen(s), length_tmp = yyget_leng(scanner);
char *tmp;

tmp = realloc(s, length_s + length_tmp - 1);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
s = tmp;
if (yyget_text(scanner)[0] == '""') {
if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, length_tmp - 2, length_s, yylloc.first_column))) {
YYABORT;
}
s = tmp;
} else {
memcpy(s + length_s, yyget_text(scanner) + 1, length_tmp - 2);
s[length_s + length_tmp - 2] = '\0';
}
}
}

break;

case 10:

{ if (param->submodule) {
free(s);
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""module"");
YYABORT;
}
trg = param->module;
yang_read_common(trg,s,MODULE_KEYWORD);
s = NULL;
actual_type = MODULE_KEYWORD;
}

break;

case 12:

{ if (!param->module->ns) {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""namespace"", ""module"");
YYABORT;
}
if (!param->module->prefix) {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""prefix"", ""module"");
YYABORT;
}
}

break;

case 13:

{ (yyval.i) = 0; }

break;

case 14:

{ if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {
YYABORT;
}
(yyval.i) = 1;
s = NULL;
}

break;

case 15:

{ if (yang_read_common(param->module, s, NAMESPACE_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 16:

{ if (yang_read_prefix(trg, NULL, s)) {
YYABORT;
}
s = NULL;
}

break;

case 17:

{ if (!param->submodule) {
free(s);
LOGVAL(trg->ctx, LYE_SUBMODULE, LY_VLOG_NONE, NULL);
YYABORT;
}
trg = (struct lys_module *)param->submodule;
yang_read_common(trg,s,MODULE_KEYWORD);
s = NULL;
actual_type = SUBMODULE_KEYWORD;
}

break;

case 19:

{ if (!param->submodule->prefix) {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""belongs-to"", ""submodule"");
YYABORT;
}
if (!(yyvsp[0].i)) {

if (param->module->version > 1) {
LOGVAL(trg->ctx, LYE_INVER, LY_VLOG_NONE, NULL);
YYABORT;
}
}
}

break;

case 20:

{ (yyval.i) = 0; }

break;

case 21:

{ if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {
YYABORT;
}
(yyval.i) = 1;
s = NULL;
}

break;

case 23:

{ backup_type = actual_type;
actual_type = YANG_VERSION_KEYWORD;
}

break;

case 25:

{ backup_type = actual_type;
actual_type = NAMESPACE_KEYWORD;
}

break;

case 30:

{ actual_type = (yyvsp[-4].token);
backup_type = NODE;
actual = NULL;
}

break;

case 31:

{ YANG_ADDELEM(trg->imp, trg->imp_size, ""imports"");

((struct lys_import *)actual)->module = (struct lys_module *)s;
s = NULL;
(yyval.token) = actual_type;
actual_type = IMPORT_KEYWORD;
}

break;

case 32:

{ (yyval.i) = 0; }

break;

case 33:

{ if (yang_read_prefix(trg, actual, s)) {
YYABORT;
}
s = NULL;
}

break;

case 34:

{ if (trg->version != 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""description"");
free(s);
YYABORT;
}
if (yang_read_description(trg, actual, s, ""import"", IMPORT_KEYWORD)) {
YYABORT;
}
s = NULL;
(yyval.i) = (yyvsp[-1].i);
}

break;

case 35:

{ if (trg->version != 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""reference"");
free(s);
YYABORT;
}
if (yang_read_reference(trg, actual, s, ""import"", IMPORT_KEYWORD)) {
YYABORT;
}
s = NULL;
(yyval.i) = (yyvsp[-1].i);
}

break;

case 36:

{ if ((yyvsp[-1].i)) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""revision-date"", ""import"");
free(s);
YYABORT;
}
memcpy(((struct lys_import *)actual)->rev, s, LY_REV_SIZE-1);
free(s);
s = NULL;
(yyval.i) = 1;
}

break;

case 37:

{ YANG_ADDELEM(trg->inc, trg->inc_size, ""includes"");

((struct lys_include *)actual)->submodule = (struct lys_submodule *)s;
s = NULL;
(yyval.token) = actual_type;
actual_type = INCLUDE_KEYWORD;
}

break;

case 38:

{ actual_type = (yyvsp[-1].token);
backup_type = NODE;
actual = NULL;
}

break;

case 41:

{ (yyval.i) = 0; }

break;

case 42:

{ if (trg->version != 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""description"");
free(s);
YYABORT;
}
if (yang_read_description(trg, actual, s, ""include"", INCLUDE_KEYWORD)) {
YYABORT;
}
s = NULL;
(yyval.i) = (yyvsp[-1].i);
}

break;

case 43:

{ if (trg->version != 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""reference"");
free(s);
YYABORT;
}
if (yang_read_reference(trg, actual, s, ""include"", INCLUDE_KEYWORD)) {
YYABORT;
}
s = NULL;
(yyval.i) = (yyvsp[-1].i);
}

break;

case 44:

{ if ((yyvsp[-1].i)) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""revision-date"", ""include"");
free(s);
YYABORT;
}
memcpy(((struct lys_include *)actual)->rev, s, LY_REV_SIZE-1);
free(s);
s = NULL;
(yyval.i) = 1;
}

break;

case 45:

{ backup_type = actual_type;
actual_type = REVISION_DATE_KEYWORD;
}

break;

case 47:

{ (yyval.token) = actual_type;
if (is_ext_instance) {
if (yang_read_extcomplex_str(trg, ext_instance, ""belongs-to"", ext_name, &s,
0, LY_STMT_BELONGSTO)) {
YYABORT;
}
} else {
if (param->submodule->prefix) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""belongs-to"", ""submodule"");
free(s);
YYABORT;
}
if (!ly_strequal(s, param->submodule->belongsto->name, 0)) {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""belongs-to"");
free(s);
YYABORT;
}
free(s);
}
s = NULL;
actual_type = BELONGS_TO_KEYWORD;
}

break;

case 48:

{ if (is_ext_instance) {
if (yang_read_extcomplex_str(trg, ext_instance, ""prefix"", ""belongs-to"", &s,
LY_STMT_BELONGSTO, LY_STMT_PREFIX)) {
YYABORT;
}
} else {
if (yang_read_prefix(trg, NULL, s)) {
YYABORT;
}
}
s = NULL;
actual_type = (yyvsp[-4].token);
}

break;

case 49:

{ backup_type = actual_type;
actual_type = PREFIX_KEYWORD;
}

break;

case 52:

{ if (yang_read_common(trg, s, ORGANIZATION_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 53:

{ if (yang_read_common(trg, s, CONTACT_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 54:

{ if (yang_read_description(trg, NULL, s, NULL, MODULE_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 55:

{ if (yang_read_reference(trg, NULL, s, NULL, MODULE_KEYWORD)) {
YYABORT;
}
s=NULL;
}

break;

case 56:

{ backup_type = actual_type;
actual_type = ORGANIZATION_KEYWORD;
}

break;

case 58:

{ backup_type = actual_type;
actual_type = CONTACT_KEYWORD;
}

break;

case 60:

{ backup_type = actual_type;
actual_type = DESCRIPTION_KEYWORD;
}

break;

case 62:

{ backup_type = actual_type;
actual_type = REFERENCE_KEYWORD;
}

break;

case 64:

{ if (trg->rev_size) {
struct lys_revision *tmp;

tmp = realloc(trg->rev, trg->rev_size * sizeof *trg->rev);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
trg->rev = tmp;
}
}

break;

case 65:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!is_ext_instance) {
YANG_ADDELEM(trg->rev, trg->rev_size, ""revisions"");
}
memcpy(((struct lys_revision *)actual)->date, s, LY_REV_SIZE);
free(s);
s = NULL;
actual_type = REVISION_KEYWORD;
}

break;

case 67:

{ int i;


for (i = 0; i < (trg->rev_size - 1); i++) {
if (!strcmp(trg->rev[i].date, trg->rev[trg->rev_size - 1].date)) {
LOGWRN(trg->ctx, ""Module's revisions are not unique (%s)."",
trg->rev[trg->rev_size - 1].date);
break;
}
}
}

break;

case 68:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 72:

{ if (yang_read_description(trg, actual, s, ""revision"",REVISION_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 73:

{ if (yang_read_reference(trg, actual, s, ""revision"", REVISION_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 74:

{ s = strdup(yyget_text(scanner));
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
if (lyp_check_date(trg->ctx, s)) {
free(s);
YYABORT;
}
}

break;

case 76:

{ if (lyp_check_date(trg->ctx, s)) {
free(s);
YYABORT;
}
}

break;

case 77:

{ void *tmp;

if (trg->tpdf_size) {
tmp = realloc(trg->tpdf, trg->tpdf_size * sizeof *trg->tpdf);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
trg->tpdf = tmp;
}

if (trg->features_size) {
tmp = realloc(trg->features, trg->features_size * sizeof *trg->features);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
trg->features = tmp;
}

if (trg->ident_size) {
tmp = realloc(trg->ident, trg->ident_size * sizeof *trg->ident);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
trg->ident = tmp;
}

if (trg->augment_size) {
tmp = realloc(trg->augment, trg->augment_size * sizeof *trg->augment);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
trg->augment = tmp;
}

if (trg->extensions_size) {
tmp = realloc(trg->extensions, trg->extensions_size * sizeof *trg->extensions);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
trg->extensions = tmp;
}
}

break;

case 78:

{
if (!param->submodule) {
switch (lyp_ctx_check_module(trg)) {
case -1:
YYABORT;
case 0:
break;
case 1:

param->flags |= YANG_EXIST_MODULE;
YYABORT;
}
}
param->flags &= (~YANG_REMOVE_IMPORT);
if (yang_check_imports(trg, param->unres)) {
YYABORT;
}
actual = NULL;
}

break;

case 79:

{ actual = NULL; }

break;

case 90:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
YANG_ADDELEM(trg->extensions, trg->extensions_size, ""extensions"");
trg->extensions_size--;
((struct lys_ext *)actual)->name = lydict_insert_zc(param->module->ctx, s);
((struct lys_ext *)actual)->module = trg;
if (lyp_check_identifier(trg->ctx, ((struct lys_ext *)actual)->name, LY_IDENT_EXTENSION, trg, NULL)) {
trg->extensions_size++;
YYABORT;
}
trg->extensions_size++;
s = NULL;
actual_type = EXTENSION_KEYWORD;
}

break;

case 91:

{ struct lys_ext *ext = actual;
ext->plugin = ext_get_plugin(ext->name, ext->module->name, ext->module->rev ? ext->module->rev[0].date : NULL);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 96:

{ if (((struct lys_ext *)actual)->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""status"", ""extension"");
YYABORT;
}
((struct lys_ext *)actual)->flags |= (yyvsp[0].i);
}

break;

case 97:

{ if (yang_read_description(trg, actual, s, ""extension"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 98:

{ if (yang_read_reference(trg, actual, s, ""extension"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 99:

{ (yyval.token) = actual_type;
if (is_ext_instance) {
if (yang_read_extcomplex_str(trg, ext_instance, ""argument"", ext_name, &s,
0, LY_STMT_ARGUMENT)) {
YYABORT;
}
} else {
if (((struct lys_ext *)actual)->argument) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""argument"", ""extension"");
free(s);
YYABORT;
}
((struct lys_ext *)actual)->argument = lydict_insert_zc(param->module->ctx, s);
}
s = NULL;
actual_type = ARGUMENT_KEYWORD;
}

break;

case 100:

{ actual_type = (yyvsp[-1].token); }

break;

case 103:

{ (yyval.uint) = (yyvsp[0].uint);
backup_type = actual_type;
actual_type = YIN_ELEMENT_KEYWORD;
}

break;

case 105:

{ if (is_ext_instance) {
int c;
const char ***p;
uint8_t *val;
struct lyext_substmt *info;

c = 0;
p = lys_ext_complex_get_substmt(LY_STMT_ARGUMENT, ext_instance, &info);
if (info->cardinality >= LY_STMT_CARD_SOME) {

for (c = 0; p[0][c + 1]; c++);
val = (uint8_t *)p[1];
} else {
val = (uint8_t *)(p + 1);
}
val[c] = ((yyvsp[-1].uint) == LYS_YINELEM) ? 1 : 2;
} else {
((struct lys_ext *)actual)->flags |= (yyvsp[-1].uint);
}
}

break;

case 106:

{ (yyval.uint) = LYS_YINELEM; }

break;

case 107:

{ (yyval.uint) = 0; }

break;

case 108:

{ if (!strcmp(s, ""true"")) {
(yyval.uint) = LYS_YINELEM;
} else if (!strcmp(s, ""false"")) {
(yyval.uint) = 0;
} else {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);
free(s);
YYABORT;
}
free(s);
s = NULL;
}

break;

case 109:

{ (yyval.i) = (yyvsp[0].i);
backup_type = actual_type;
actual_type = STATUS_KEYWORD;
}

break;

case 110:

{ (yyval.i) = (yyvsp[-1].i); }

break;

case 111:

{ (yyval.i) = LYS_STATUS_CURR; }

break;

case 112:

{ (yyval.i) = LYS_STATUS_OBSLT; }

break;

case 113:

{ (yyval.i) = LYS_STATUS_DEPRC; }

break;

case 114:

{ if (!strcmp(s, ""current"")) {
(yyval.i) = LYS_STATUS_CURR;
} else if (!strcmp(s, ""obsolete"")) {
(yyval.i) = LYS_STATUS_OBSLT;
} else if (!strcmp(s, ""deprecated"")) {
(yyval.i) = LYS_STATUS_DEPRC;
} else {
LOGVAL(trg->ctx,LYE_INSTMT, LY_VLOG_NONE, NULL, s);
free(s);
YYABORT;
}
free(s);
s = NULL;
}

break;

case 115:

{
if (lyp_check_identifier(trg->ctx, s, LY_IDENT_FEATURE, trg, NULL)) {
free(s);
YYABORT;
}
(yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
YANG_ADDELEM(trg->features, trg->features_size, ""features"");
((struct lys_feature *)actual)->name = lydict_insert_zc(trg->ctx, s);
((struct lys_feature *)actual)->module = trg;
s = NULL;
actual_type = FEATURE_KEYWORD;
}

break;

case 116:

{ actual = (yyvsp[-1].backup_token).actual;
actual_type = (yyvsp[-1].backup_token).token;
}

break;

case 118:

{ struct lys_iffeature *tmp;

if (((struct lys_feature *)actual)->iffeature_size) {
tmp = realloc(((struct lys_feature *)actual)->iffeature,
((struct lys_feature *)actual)->iffeature_size * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct lys_feature *)actual)->iffeature = tmp;
}
}

break;

case 121:

{ if (((struct lys_feature *)actual)->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""status"", ""feature"");
YYABORT;
}
((struct lys_feature *)actual)->flags |= (yyvsp[0].i);
}

break;

case 122:

{ if (yang_read_description(trg, actual, s, ""feature"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 123:

{ if (yang_read_reference(trg, actual, s, ""feature"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 124:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
switch (actual_type) {
case FEATURE_KEYWORD:
YANG_ADDELEM(((struct lys_feature *)actual)->iffeature,
((struct lys_feature *)actual)->iffeature_size, ""if-features"");
break;
case IDENTITY_KEYWORD:
if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""if-feature"", ""identity"");
free(s);
YYABORT;
}
YANG_ADDELEM(((struct lys_ident *)actual)->iffeature,
((struct lys_ident *)actual)->iffeature_size, ""if-features"");
break;
case ENUM_KEYWORD:
if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""if-feature"");
free(s);
YYABORT;
}
YANG_ADDELEM(((struct lys_type_enum *)actual)->iffeature,
((struct lys_type_enum *)actual)->iffeature_size, ""if-features"");
break;
case BIT_KEYWORD:
if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""if-feature"", ""bit"");
free(s);
YYABORT;
}
YANG_ADDELEM(((struct lys_type_bit *)actual)->iffeature,
((struct lys_type_bit *)actual)->iffeature_size, ""if-features"");
break;
case REFINE_KEYWORD:
if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""if-feature"");
free(s);
YYABORT;
}
YANG_ADDELEM(((struct lys_refine *)actual)->iffeature,
((struct lys_refine *)actual)->iffeature_size, ""if-features"");
break;
case EXTENSION_INSTANCE:

break;
default:

YANG_ADDELEM(((struct lys_node *)actual)->iffeature,
((struct lys_node *)actual)->iffeature_size, ""if-features"");
break;
}
((struct lys_iffeature *)actual)->features = (struct lys_feature **)s;
s = NULL;
actual_type = IF_FEATURE_KEYWORD;
}

break;

case 125:

{ actual = (yyvsp[-1].backup_token).actual;
actual_type = (yyvsp[-1].backup_token).token;
}

break;

case 128:

{ const char *tmp;

tmp = lydict_insert_zc(trg->ctx, s);
s = NULL;
if (dup_identities_check(tmp, trg)) {
lydict_remove(trg->ctx, tmp);
YYABORT;
}
(yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
YANG_ADDELEM(trg->ident, trg->ident_size, ""identities"");
((struct lys_ident *)actual)->name = tmp;
((struct lys_ident *)actual)->module = trg;
actual_type = IDENTITY_KEYWORD;
}

break;

case 129:

{ actual = (yyvsp[-1].backup_token).actual;
actual_type = (yyvsp[-1].backup_token).token;
}

break;

case 131:

{ void *tmp;

if (((struct lys_ident *)actual)->base_size) {
tmp = realloc(((struct lys_ident *)actual)->base,
((struct lys_ident *)actual)->base_size * sizeof *((struct lys_ident *)actual)->base);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct lys_ident *)actual)->base = tmp;
}

if (((struct lys_ident *)actual)->iffeature_size) {
tmp = realloc(((struct lys_ident *)actual)->iffeature,
((struct lys_ident *)actual)->iffeature_size * sizeof *((struct lys_ident *)actual)->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct lys_ident *)actual)->iffeature = tmp;
}
}

break;

case 133:

{ void *identity;

if ((trg->version < 2) && ((struct lys_ident *)actual)->base_size) {
free(s);
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""base"", ""identity"");
YYABORT;
}
identity = actual;
YANG_ADDELEM(((struct lys_ident *)actual)->base,
((struct lys_ident *)actual)->base_size, ""bases"");
*((struct lys_ident **)actual) = (struct lys_ident *)s;
s = NULL;
actual = identity;
}

break;

case 135:

{ if (((struct lys_ident *)actual)->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""status"", ""identity"");
YYABORT;
}
((struct lys_ident *)actual)->flags |= (yyvsp[0].i);
}

break;

case 136:

{ if (yang_read_description(trg, actual, s, ""identity"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 137:

{ if (yang_read_reference(trg, actual, s, ""identity"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 138:

{ backup_type = actual_type;
actual_type = BASE_KEYWORD;
}

break;

case 140:

{ tpdf_parent = (actual_type == EXTENSION_INSTANCE) ? ext_instance : actual;
(yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (lyp_check_identifier(trg->ctx, s, LY_IDENT_TYPE, trg, tpdf_parent)) {
free(s);
YYABORT;
}
switch (actual_type) {
case MODULE_KEYWORD:
case SUBMODULE_KEYWORD:
YANG_ADDELEM(trg->tpdf, trg->tpdf_size, ""typedefs"");
break;
case GROUPING_KEYWORD:
YANG_ADDELEM(((struct lys_node_grp *)tpdf_parent)->tpdf,
((struct lys_node_grp *)tpdf_parent)->tpdf_size, ""typedefs"");
break;
case CONTAINER_KEYWORD:
YANG_ADDELEM(((struct lys_node_container *)tpdf_parent)->tpdf,
((struct lys_node_container *)tpdf_parent)->tpdf_size, ""typedefs"");
break;
case LIST_KEYWORD:
YANG_ADDELEM(((struct lys_node_list *)tpdf_parent)->tpdf,
((struct lys_node_list *)tpdf_parent)->tpdf_size, ""typedefs"");
break;
case RPC_KEYWORD:
case ACTION_KEYWORD:
YANG_ADDELEM(((struct lys_node_rpc_action *)tpdf_parent)->tpdf,
((struct lys_node_rpc_action *)tpdf_parent)->tpdf_size, ""typedefs"");
break;
case INPUT_KEYWORD:
case OUTPUT_KEYWORD:
YANG_ADDELEM(((struct lys_node_inout *)tpdf_parent)->tpdf,
((struct lys_node_inout *)tpdf_parent)->tpdf_size, ""typedefs"");
break;
case NOTIFICATION_KEYWORD:
YANG_ADDELEM(((struct lys_node_notif *)tpdf_parent)->tpdf,
((struct lys_node_notif *)tpdf_parent)->tpdf_size, ""typedefs"");
break;
case EXTENSION_INSTANCE:

break;
default:

LOGINT(trg->ctx);
free(s);
YYABORT;
}
((struct lys_tpdf *)actual)->name = lydict_insert_zc(param->module->ctx, s);
((struct lys_tpdf *)actual)->module = trg;
s = NULL;
actual_type = TYPEDEF_KEYWORD;
}

break;

case 141:

{ if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""type"", ""typedef"");
YYABORT;
}
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
}

break;

case 142:

{ (yyval.nodes).node.ptr_tpdf = actual;
(yyval.nodes).node.flag = 0;
}

break;

case 143:

{ (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;
(yyval.nodes) = (yyvsp[-2].nodes);
}

break;

case 144:

{ if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 145:

{ if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 146:

{ if ((yyvsp[-1].nodes).node.ptr_tpdf->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""status"", ""typedef"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_tpdf->flags |= (yyvsp[0].i);
}

break;

case 147:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, ""typedef"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 148:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, ""typedef"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 149:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 150:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_type(trg->ctx, actual, s, actual_type))) {
YYABORT;
}
s = NULL;
actual_type = TYPE_KEYWORD;
}

break;

case 153:

{ if (((struct yang_type *)actual)->base == LY_TYPE_STRING &&
((struct yang_type *)actual)->type->info.str.pat_count) {
void *tmp;

tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns,
((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct yang_type *)actual)->type->info.str.patterns = tmp;

#ifdef LY_ENABLED_CACHE
if (!(trg->ctx->models.flags & LY_CTX_TRUSTED) && ((struct yang_type *)actual)->type->info.str.patterns_pcre) {
tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns_pcre,
2 * ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns_pcre);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct yang_type *)actual)->type->info.str.patterns_pcre = tmp;
}
#endif
}
if (((struct yang_type *)actual)->base == LY_TYPE_UNION) {
struct lys_type *tmp;

tmp = realloc(((struct yang_type *)actual)->type->info.uni.types,
((struct yang_type *)actual)->type->info.uni.count * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct yang_type *)actual)->type->info.uni.types = tmp;
}
if (((struct yang_type *)actual)->base == LY_TYPE_IDENT) {
struct lys_ident **tmp;

tmp = realloc(((struct yang_type *)actual)->type->info.ident.ref,
((struct yang_type *)actual)->type->info.ident.count* sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct yang_type *)actual)->type->info.ident.ref = tmp;
}
}

break;

case 157:

{ if (yang_read_require_instance(trg->ctx, actual, (yyvsp[0].i))) {
YYABORT;
}
}

break;

case 158:

{
if (yang_read_leafref_path(trg, actual, s)) {
YYABORT;
}
s = NULL;
}

break;

case 159:

{
if (((struct yang_type *)actual)->base && ((struct yang_type *)actual)->base != LY_TYPE_IDENT) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""base"");
return EXIT_FAILURE;
}
((struct yang_type *)actual)->base = LY_TYPE_IDENT;
yang_type = actual;
YANG_ADDELEM(((struct yang_type *)actual)->type->info.ident.ref,
((struct yang_type *)actual)->type->info.ident.count, ""identity refs"");
*((struct lys_ident **)actual) = (struct lys_ident *)s;
actual = yang_type;
s = NULL;
}

break;

case 162:

{ if (yang_read_fraction(trg->ctx, actual, (yyvsp[0].uint))) {
YYABORT;
}
}

break;

case 165:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 166:

{ struct yang_type *stype = (struct yang_type *)actual;

(yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (stype->base != 0 && stype->base != LY_TYPE_UNION) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Unexpected type statement."");
YYABORT;
}
stype->base = LY_TYPE_UNION;
if (strcmp(stype->name, ""union"")) {

LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, ""type"", ""derived type"");
YYABORT;
}
YANG_ADDELEM(stype->type->info.uni.types, stype->type->info.uni.count, ""union types"")
actual_type = UNION_KEYWORD;
}

break;

case 167:

{ (yyval.uint) = (yyvsp[0].uint);
backup_type = actual_type;
actual_type = FRACTION_DIGITS_KEYWORD;
}

break;

case 168:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 169:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 170:

{ char *endptr = NULL;
unsigned long val;
errno = 0;

val = strtoul(s, &endptr, 10);
if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""fraction-digits"");
free(s);
s = NULL;
YYABORT;
}
(yyval.uint) = (uint32_t) val;
free(s);
s =NULL;
}

break;

case 171:

{ actual = (yyvsp[-1].backup_token).actual;
actual_type = (yyvsp[-1].backup_token).token;
}

break;

case 172:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_length(trg->ctx, actual, s, is_ext_instance))) {
YYABORT;
}
actual_type = LENGTH_KEYWORD;
s = NULL;
}

break;

case 175:

{ switch (actual_type) {
case MUST_KEYWORD:
(yyval.str) = ""must"";
break;
case LENGTH_KEYWORD:
(yyval.str) = ""length"";
break;
case RANGE_KEYWORD:
(yyval.str) = ""range"";
break;
default:
LOGINT(trg->ctx);
YYABORT;
break;
}
}

break;

case 176:

{ if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_MESSAGE_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 177:

{ if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_APP_TAG_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 178:

{ if (yang_read_description(trg, actual, s, (yyvsp[-1].str), NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 179:

{ if (yang_read_reference(trg, actual, s, (yyvsp[-1].str), NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 180:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
}

break;

case 181:

{struct lys_restr *pattern = actual;
actual = NULL;
#ifdef LY_ENABLED_CACHE
if ((yyvsp[-2].backup_token).token != EXTENSION_INSTANCE &&
!(data_node && data_node->nodetype != LYS_GROUPING && lys_ingrouping(data_node))) {
unsigned int c = 2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1);
YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, ""patterns"");
++c;
YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, ""patterns"");
actual = &(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1)];
}
#endif
if (yang_read_pattern(trg->ctx, pattern, actual, (yyvsp[-1].str), (yyvsp[0].ch))) {
YYABORT;
}
actual_type = (yyvsp[-2].backup_token).token;
actual = (yyvsp[-2].backup_token).actual;
}

break;

case 182:

{ if (actual_type != EXTENSION_INSTANCE) {
if (((struct yang_type *)actual)->base != 0 && ((struct yang_type *)actual)->base != LY_TYPE_STRING) {
free(s);
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Unexpected pattern statement."");
YYABORT;
}
((struct yang_type *)actual)->base = LY_TYPE_STRING;
YANG_ADDELEM(((struct yang_type *)actual)->type->info.str.patterns,
((struct yang_type *)actual)->type->info.str.pat_count, ""patterns"");
}
(yyval.str) = s;
s = NULL;
actual_type = PATTERN_KEYWORD;
}

break;

case 183:

{ (yyval.ch) = 0x06; }

break;

case 184:

{ (yyval.ch) = (yyvsp[-1].ch); }

break;

case 185:

{ (yyval.ch) = 0x06;           }

break;

case 186:

{ if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, ""modifier"");
YYABORT;
}
if ((yyvsp[-1].ch) != 0x06) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""modifier"", ""pattern"");
YYABORT;
}
(yyval.ch) = (yyvsp[0].ch);
}

break;

case 187:

{ if (yang_read_message(trg, actual, s, ""pattern"", ERROR_MESSAGE_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 188:

{ if (yang_read_message(trg, actual, s, ""pattern"", ERROR_APP_TAG_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 189:

{ if (yang_read_description(trg, actual, s, ""pattern"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 190:

{ if (yang_read_reference(trg, actual, s, ""pattern"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 191:

{ backup_type = actual_type;
actual_type = MODIFIER_KEYWORD;
}

break;

case 192:

{ if (!strcmp(s, ""invert-match"")) {
(yyval.ch) = 0x15;
free(s);
s = NULL;
} else {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);
free(s);
YYABORT;
}
}

break;

case 193:

{ struct lys_type_enum * tmp;

cnt_val = 0;
tmp = realloc(((struct yang_type *)actual)->type->info.enums.enm,
((struct yang_type *)actual)->type->info.enums.count * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct yang_type *)actual)->type->info.enums.enm = tmp;
}

break;

case 196:

{ if (yang_check_enum(trg->ctx, yang_type, actual, &cnt_val, is_value)) {
YYABORT;
}
actual = (yyvsp[-1].backup_token).actual;
actual_type = (yyvsp[-1].backup_token).token;
}

break;

case 197:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = yang_type = actual;
YANG_ADDELEM(((struct yang_type *)actual)->type->info.enums.enm, ((struct yang_type *)actual)->type->info.enums.count, ""enums"");
if (yang_read_enum(trg->ctx, yang_type, actual, s)) {
YYABORT;
}
s = NULL;
is_value = 0;
actual_type = ENUM_KEYWORD;
}

break;

case 199:

{ if (((struct lys_type_enum *)actual)->iffeature_size) {
struct lys_iffeature *tmp;

tmp = realloc(((struct lys_type_enum *)actual)->iffeature,
((struct lys_type_enum *)actual)->iffeature_size * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct lys_type_enum *)actual)->iffeature = tmp;
}
}

break;

case 202:

{ if (is_value) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""value"", ""enum"");
YYABORT;
}
((struct lys_type_enum *)actual)->value = (yyvsp[0].i);


if ((yyvsp[0].i) >= cnt_val) {
cnt_val = (yyvsp[0].i) + 1;
}
is_value = 1;
}

break;

case 203:

{ if (((struct lys_type_enum *)actual)->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""status"", ""enum"");
YYABORT;
}
((struct lys_type_enum *)actual)->flags |= (yyvsp[0].i);
}

break;

case 204:

{ if (yang_read_description(trg, actual, s, ""enum"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 205:

{ if (yang_read_reference(trg, actual, s, ""enum"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 206:

{ (yyval.i) = (yyvsp[0].i);
backup_type = actual_type;
actual_type = VALUE_KEYWORD;
}

break;

case 207:

{ (yyval.i) = (yyvsp[-1].i); }

break;

case 208:

{ (yyval.i) = (yyvsp[-1].i); }

break;

case 209:

{
int64_t val;
char *endptr;

val = strtoll(s, &endptr, 10);
if (val < INT32_MIN || val > INT32_MAX || *endptr) {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""value"");
free(s);
YYABORT;
}
free(s);
s = NULL;
(yyval.i) = (int32_t) val;
}

break;

case 210:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 213:

{ backup_type = actual_type;
actual_type = PATH_KEYWORD;
}

break;

case 215:

{ (yyval.i) = (yyvsp[0].i);
backup_type = actual_type;
actual_type = REQUIRE_INSTANCE_KEYWORD;
}

break;

case 216:

{ (yyval.i) = (yyvsp[-1].i); }

break;

case 217:

{ (yyval.i) = 1; }

break;

case 218:

{ (yyval.i) = -1; }

break;

case 219:

{ if (!strcmp(s,""true"")) {
(yyval.i) = 1;
} else if (!strcmp(s,""false"")) {
(yyval.i) = -1;
} else {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""require-instance"");
free(s);
YYABORT;
}
free(s);
s = NULL;
}

break;

case 220:

{ struct lys_type_bit * tmp;

cnt_val = 0;
tmp = realloc(((struct yang_type *)actual)->type->info.bits.bit,
((struct yang_type *)actual)->type->info.bits.count * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct yang_type *)actual)->type->info.bits.bit = tmp;
}

break;

case 223:

{ if (yang_check_bit(trg->ctx, yang_type, actual, &cnt_val, is_value)) {
YYABORT;
}
actual = (yyvsp[-2].backup_token).actual;
actual_type = (yyvsp[-2].backup_token).token;
}

break;

case 224:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = yang_type = actual;
YANG_ADDELEM(((struct yang_type *)actual)->type->info.bits.bit,
((struct yang_type *)actual)->type->info.bits.count, ""bits"");
if (yang_read_bit(trg->ctx, yang_type, actual, s)) {
YYABORT;
}
s = NULL;
is_value = 0;
actual_type = BIT_KEYWORD;
}

break;

case 226:

{ if (((struct lys_type_bit *)actual)->iffeature_size) {
struct lys_iffeature *tmp;

tmp = realloc(((struct lys_type_bit *)actual)->iffeature,
((struct lys_type_bit *)actual)->iffeature_size * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct lys_type_bit *)actual)->iffeature = tmp;
}
}

break;

case 229:

{ if (is_value) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""position"", ""bit"");
YYABORT;
}
((struct lys_type_bit *)actual)->pos = (yyvsp[0].uint);


if ((yyvsp[0].uint) >= cnt_val) {
cnt_val = (yyvsp[0].uint) + 1;
}
is_value = 1;
}

break;

case 230:

{ if (((struct lys_type_bit *)actual)->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""status"", ""bit"");
YYABORT;
}
((struct lys_type_bit *)actual)->flags |= (yyvsp[0].i);
}

break;

case 231:

{ if (yang_read_description(trg, actual, s, ""bit"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 232:

{ if (yang_read_reference(trg, actual, s, ""bit"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 233:

{ (yyval.uint) = (yyvsp[0].uint);
backup_type = actual_type;
actual_type = POSITION_KEYWORD;
}

break;

case 234:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 235:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 236:

{
unsigned long val;
char *endptr = NULL;
errno = 0;

val = strtoul(s, &endptr, 10);
if (s[0] == '-' || *endptr || errno || val > UINT32_MAX) {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""position"");
free(s);
YYABORT;
}
free(s);
s = NULL;
(yyval.uint) = (uint32_t) val;
}

break;

case 237:

{ backup_type = actual_type;
actual_type = ERROR_MESSAGE_KEYWORD;
}

break;

case 239:

{ backup_type = actual_type;
actual_type = ERROR_APP_TAG_KEYWORD;
}

break;

case 241:

{ backup_type = actual_type;
actual_type = UNITS_KEYWORD;
}

break;

case 243:

{ backup_type = actual_type;
actual_type = DEFAULT_KEYWORD;
}

break;

case 245:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_GROUPING, sizeof(struct lys_node_grp)))) {
YYABORT;
}
s = NULL;
data_node = actual;
actual_type = GROUPING_KEYWORD;
}

break;

case 246:

{ LOGDBG(LY_LDGYANG, ""finished parsing grouping statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 249:

{ (yyval.nodes).grouping = actual; }

break;

case 250:

{ if ((yyvsp[-1].nodes).grouping->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).grouping, ""status"", ""grouping"");
YYABORT;
}
(yyvsp[-1].nodes).grouping->flags |= (yyvsp[0].i);
}

break;

case 251:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).grouping, s, ""grouping"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 252:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).grouping, s, ""grouping"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 257:

{ if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).grouping, ""notification"");
YYABORT;
}
}

break;

case 266:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CONTAINER, sizeof(struct lys_node_container)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = CONTAINER_KEYWORD;
}

break;

case 267:

{ LOGDBG(LY_LDGYANG, ""finished parsing container statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 269:

{ void *tmp;

if ((yyvsp[-1].nodes).container->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).container->iffeature, (yyvsp[-1].nodes).container->iffeature_size * sizeof *(yyvsp[-1].nodes).container->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).container->iffeature = tmp;
}

if ((yyvsp[-1].nodes).container->must_size) {
tmp = realloc((yyvsp[-1].nodes).container->must, (yyvsp[-1].nodes).container->must_size * sizeof *(yyvsp[-1].nodes).container->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).container->must = tmp;
}
}

break;

case 270:

{ (yyval.nodes).container = actual; }

break;

case 274:

{ if (yang_read_presence(trg, (yyvsp[-1].nodes).container, s)) {
YYABORT;
}
s = NULL;
}

break;

case 275:

{ if ((yyvsp[-1].nodes).container->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, ""config"", ""container"");
YYABORT;
}
(yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);
}

break;

case 276:

{ if ((yyvsp[-1].nodes).container->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, ""status"", ""container"");
YYABORT;
}
(yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);
}

break;

case 277:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).container, s, ""container"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 278:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).container, s, ""container"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 281:

{ if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).container, ""notification"");
YYABORT;
}
}

break;

case 284:

{ void *tmp;

if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, ""type"", ""leaf"");
YYABORT;
}
if ((yyvsp[-1].nodes).node.ptr_leaf->dflt && ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_TRUE)) {

LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, ""mandatory"", ""leaf"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, ""The \""mandatory\"" statement is forbidden on leaf with \""default\""."");
YYABORT;
}

if ((yyvsp[-1].nodes).node.ptr_leaf->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->iffeature, (yyvsp[-1].nodes).node.ptr_leaf->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaf->iffeature = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_leaf->must_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->must, (yyvsp[-1].nodes).node.ptr_leaf->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaf->must = tmp;
}

LOGDBG(LY_LDGYANG, ""finished parsing leaf statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
data_node = (yyvsp[-4].backup_token).actual;
}

break;

case 285:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAF, sizeof(struct lys_node_leaf)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = LEAF_KEYWORD;
}

break;

case 286:

{ (yyval.nodes).node.ptr_leaf = actual;
(yyval.nodes).node.flag = 0;
}

break;

case 289:

{ (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;
(yyval.nodes) = (yyvsp[-2].nodes);
}

break;

case 290:

{ if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 292:

{ if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 293:

{ if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, ""config"", ""leaf"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);
}

break;

case 294:

{ if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, ""mandatory"", ""leaf"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);
}

break;

case 295:

{ if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, ""status"", ""leaf"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);
}

break;

case 296:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, ""leaf"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 297:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, ""leaf"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 298:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAFLIST, sizeof(struct lys_node_leaflist)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = LEAF_LIST_KEYWORD;
}

break;

case 299:

{ void *tmp;

if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_R) {



(yyvsp[-1].nodes).node.ptr_leaflist->flags &= 0x7F;
}
if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""type"", ""leaf-list"");
YYABORT;
}
if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size && (yyvsp[-1].nodes).node.ptr_leaflist->min) {
LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""min-elements"", ""leaf-list"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist,
""The \""min-elements\"" statement with non-zero value is forbidden on leaf-lists with the \""default\"" statement."");
YYABORT;
}

if ((yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->iffeature, (yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaflist->iffeature = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_leaflist->must_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->must, (yyvsp[-1].nodes).node.ptr_leaflist->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaflist->must = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->dflt, (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->dflt);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaflist->dflt = tmp;
}

LOGDBG(LY_LDGYANG, ""finished parsing leaf-list statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
data_node = (yyvsp[-4].backup_token).actual;
}

break;

case 300:

{ (yyval.nodes).node.ptr_leaflist = actual;
(yyval.nodes).node.flag = 0;
}

break;

case 303:

{ (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;
(yyval.nodes) = (yyvsp[-2].nodes);
}

break;

case 304:

{ if (trg->version < 2) {
free(s);
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""default"");
YYABORT;
}
YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_leaflist->dflt,
(yyvsp[-1].nodes).node.ptr_leaflist->dflt_size, ""defaults"");
(*(const char **)actual) = lydict_insert_zc(param->module->ctx, s);
s = NULL;
actual = (yyvsp[-1].nodes).node.ptr_leaflist;
}

break;

case 305:

{ if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, LEAF_LIST_KEYWORD)) {
YYABORT;
}
s = NULL;
}

break;

case 307:

{ if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""config"", ""leaf-list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);
}

break;

case 308:

{ if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""min-elements"", ""leaf-list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaflist->min = (yyvsp[0].uint);
(yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;
(yyval.nodes) = (yyvsp[-1].nodes);
if ((yyvsp[-1].nodes).node.ptr_leaflist->max && ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max)) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""Invalid value \""%d\"" of \""%s\""."", (yyvsp[0].uint), ""min-elements"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""\""min-elements\"" is bigger than \""max-elements\""."");
YYABORT;
}
}

break;

case 309:

{ if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""max-elements"", ""leaf-list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaflist->max = (yyvsp[0].uint);
(yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;
(yyval.nodes) = (yyvsp[-1].nodes);
if ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""Invalid value \""%d\"" of \""%s\""."", (yyvsp[0].uint), ""max-elements"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""\""max-elements\"" is smaller than \""min-elements\""."");
YYABORT;
}
}

break;

case 310:

{ if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""ordered by"", ""leaf-list"");
YYABORT;
}
if ((yyvsp[0].i) & LYS_USERORDERED) {
(yyvsp[-1].nodes).node.ptr_leaflist->flags |= LYS_USERORDERED;
}
(yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 311:

{ if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, ""status"", ""leaf-list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);
}

break;

case 312:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, ""leaf-list"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 313:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, ""leaf-list"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 314:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LIST, sizeof(struct lys_node_list)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = LIST_KEYWORD;
}

break;

case 315:

{ void *tmp;

if ((yyvsp[-1].nodes).node.ptr_list->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_list->iffeature, (yyvsp[-1].nodes).node.ptr_list->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->iffeature = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_list->must_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_list->must, (yyvsp[-1].nodes).node.ptr_list->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->must = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_list->tpdf_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_list->tpdf, (yyvsp[-1].nodes).node.ptr_list->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->tpdf);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->tpdf = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_list->unique_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->unique);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->unique = tmp;
}

LOGDBG(LY_LDGYANG, ""finished parsing list statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
data_node = (yyvsp[-4].backup_token).actual;
}

break;

case 316:

{ (yyval.nodes).node.ptr_list = actual;
(yyval.nodes).node.flag = 0;
}

break;

case 320:

{ if ((yyvsp[-1].nodes).node.ptr_list->keys) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""key"", ""list"");
free(s);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->keys = (struct lys_node_leaf **)s;
(yyval.nodes) = (yyvsp[-1].nodes);
s = NULL;
}

break;

case 321:

{ YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size, ""uniques"");
((struct lys_unique *)actual)->expr = (const char **)s;
(yyval.nodes) = (yyvsp[-1].nodes);
s = NULL;
actual = (yyvsp[-1].nodes).node.ptr_list;
}

break;

case 322:

{ if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""config"", ""list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);
}

break;

case 323:

{ if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""min-elements"", ""list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->min = (yyvsp[0].uint);
(yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;
(yyval.nodes) = (yyvsp[-1].nodes);
if ((yyvsp[-1].nodes).node.ptr_list->max && ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max)) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""Invalid value \""%d\"" of \""%s\""."", (yyvsp[0].uint), ""min-elements"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""\""min-elements\"" is bigger than \""max-elements\""."");
YYABORT;
}
}

break;

case 324:

{ if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""max-elements"", ""list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->max = (yyvsp[0].uint);
(yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;
(yyval.nodes) = (yyvsp[-1].nodes);
if ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""Invalid value \""%d\"" of \""%s\""."", (yyvsp[0].uint), ""min-elements"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""\""max-elements\"" is smaller than \""min-elements\""."");
YYABORT;
}
}

break;

case 325:

{ if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""ordered by"", ""list"");
YYABORT;
}
if ((yyvsp[0].i) & LYS_USERORDERED) {
(yyvsp[-1].nodes).node.ptr_list->flags |= LYS_USERORDERED;
}
(yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 326:

{ if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, ""status"", ""list"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);
}

break;

case 327:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_list, s, ""list"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 328:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_list, s, ""list"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 332:

{ if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_list, ""notification"");
YYABORT;
}
}

break;

case 334:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CHOICE, sizeof(struct lys_node_choice)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = CHOICE_KEYWORD;
}

break;

case 335:

{ LOGDBG(LY_LDGYANG, ""finished parsing choice statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 337:

{ struct lys_iffeature *tmp;

if (((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_TRUE) && (yyvsp[-1].nodes).node.ptr_choice->dflt) {
LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, ""default"", ""choice"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, ""The \""default\"" statement is forbidden on choices with \""mandatory\""."");
YYABORT;
}

if ((yyvsp[-1].nodes).node.ptr_choice->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_choice->iffeature, (yyvsp[-1].nodes).node.ptr_choice->iffeature_size * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_choice->iffeature = tmp;
}
}

break;

case 338:

{ (yyval.nodes).node.ptr_choice = actual;
(yyval.nodes).node.flag = 0;
}

break;

case 341:

{ if ((yyvsp[-1].nodes).node.flag & LYS_CHOICE_DEFAULT) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, ""default"", ""choice"");
free(s);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_choice->dflt = (struct lys_node *) s;
s = NULL;
(yyval.nodes) = (yyvsp[-1].nodes);
(yyval.nodes).node.flag |= LYS_CHOICE_DEFAULT;
}

break;

case 342:

{ if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, ""config"", ""choice"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 343:

{ if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, ""mandatory"", ""choice"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 344:

{ if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, ""status"", ""choice"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 345:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_choice, s, ""choice"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 346:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_choice, s, ""choice"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 356:

{ if (trg->version < 2 ) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, ""choice"");
YYABORT;
}
}

break;

case 357:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CASE, sizeof(struct lys_node_case)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = CASE_KEYWORD;
}

break;

case 358:

{ LOGDBG(LY_LDGYANG, ""finished parsing case statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 360:

{ struct lys_iffeature *tmp;

if ((yyvsp[-1].nodes).cs->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).cs->iffeature, (yyvsp[-1].nodes).cs->iffeature_size * sizeof *tmp);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).cs->iffeature = tmp;
}
}

break;

case 361:

{ (yyval.nodes).cs = actual; }

break;

case 364:

{ if ((yyvsp[-1].nodes).cs->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).cs, ""status"", ""case"");
YYABORT;
}
(yyvsp[-1].nodes).cs->flags |= (yyvsp[0].i);
}

break;

case 365:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).cs, s, ""case"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 366:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).cs, s, ""case"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 368:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYXML, sizeof(struct lys_node_anydata)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = ANYXML_KEYWORD;
}

break;

case 369:

{ LOGDBG(LY_LDGYANG, ""finished parsing anyxml statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 370:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYDATA, sizeof(struct lys_node_anydata)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = ANYDATA_KEYWORD;
}

break;

case 371:

{ LOGDBG(LY_LDGYANG, ""finished parsing anydata statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 373:

{ void *tmp;

if ((yyvsp[-1].nodes).node.ptr_anydata->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->iffeature, (yyvsp[-1].nodes).node.ptr_anydata->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_anydata->iffeature = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_anydata->must_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->must, (yyvsp[-1].nodes).node.ptr_anydata->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_anydata->must = tmp;
}
}

break;

case 374:

{ (yyval.nodes).node.ptr_anydata = actual;
(yyval.nodes).node.flag = actual_type;
}

break;

case 378:

{ if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, ""config"",
((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? ""anyxml"" : ""anydata"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);
}

break;

case 379:

{ if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_MAND_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, ""mandatory"",
((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? ""anyxml"" : ""anydata"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);
}

break;

case 380:

{ if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, ""status"",
((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? ""anyxml"" : ""anydata"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);
}

break;

case 381:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? ""anyxml"" : ""anydata"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 382:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? ""anyxml"" : ""anydata"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 383:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_USES, sizeof(struct lys_node_uses)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = USES_KEYWORD;
}

break;

case 384:

{ LOGDBG(LY_LDGYANG, ""finished parsing uses statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 386:

{ void *tmp;

if ((yyvsp[-1].nodes).uses->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).uses->iffeature, (yyvsp[-1].nodes).uses->iffeature_size * sizeof *(yyvsp[-1].nodes).uses->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).uses->iffeature = tmp;
}

if ((yyvsp[-1].nodes).uses->refine_size) {
tmp = realloc((yyvsp[-1].nodes).uses->refine, (yyvsp[-1].nodes).uses->refine_size * sizeof *(yyvsp[-1].nodes).uses->refine);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).uses->refine = tmp;
}

if ((yyvsp[-1].nodes).uses->augment_size) {
tmp = realloc((yyvsp[-1].nodes).uses->augment, (yyvsp[-1].nodes).uses->augment_size * sizeof *(yyvsp[-1].nodes).uses->augment);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).uses->augment = tmp;
}
}

break;

case 387:

{ (yyval.nodes).uses = actual; }

break;

case 390:

{ if ((yyvsp[-1].nodes).uses->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).uses, ""status"", ""uses"");
YYABORT;
}
(yyvsp[-1].nodes).uses->flags |= (yyvsp[0].i);
}

break;

case 391:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).uses, s, ""uses"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 392:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).uses, s, ""uses"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 397:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
YANG_ADDELEM(((struct lys_node_uses *)actual)->refine,
((struct lys_node_uses *)actual)->refine_size, ""refines"");
((struct lys_refine *)actual)->target_name = transform_schema2json(trg, s);
free(s);
s = NULL;
if (!((struct lys_refine *)actual)->target_name) {
YYABORT;
}
actual_type = REFINE_KEYWORD;
}

break;

case 398:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 400:

{ void *tmp;

if ((yyvsp[-1].nodes).refine->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).refine->iffeature, (yyvsp[-1].nodes).refine->iffeature_size * sizeof *(yyvsp[-1].nodes).refine->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).refine->iffeature = tmp;
}

if ((yyvsp[-1].nodes).refine->must_size) {
tmp = realloc((yyvsp[-1].nodes).refine->must, (yyvsp[-1].nodes).refine->must_size * sizeof *(yyvsp[-1].nodes).refine->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).refine->must = tmp;
}

if ((yyvsp[-1].nodes).refine->dflt_size) {
tmp = realloc((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size * sizeof *(yyvsp[-1].nodes).refine->dflt);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).refine->dflt = tmp;
}
}

break;

case 401:

{ (yyval.nodes).refine = actual;
actual_type = REFINE_KEYWORD;
}

break;

case 402:

{ actual = (yyvsp[-2].nodes).refine;
actual_type = REFINE_KEYWORD;
if ((yyvsp[-2].nodes).refine->target_type) {
if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML)) {
(yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML);
} else {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""must"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
(yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML;
}
}

break;

case 403:

{

if ((yyvsp[-2].nodes).refine->target_type) {
if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA)) {
(yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA);
} else {
free(s);
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""if-feature"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
(yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA;
}
}

break;

case 404:

{ if ((yyvsp[-1].nodes).refine->target_type) {
if ((yyvsp[-1].nodes).refine->target_type & LYS_CONTAINER) {
if ((yyvsp[-1].nodes).refine->mod.presence) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""presence"", ""refine"");
free(s);
YYABORT;
}
(yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;
(yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);
} else {
free(s);
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""presence"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
(yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;
(yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);
}
s = NULL;
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 405:

{ int i;

if ((yyvsp[-1].nodes).refine->dflt_size) {
if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""default"", ""refine"");
YYABORT;
}
if ((yyvsp[-1].nodes).refine->target_type & LYS_LEAFLIST) {
(yyvsp[-1].nodes).refine->target_type = LYS_LEAFLIST;
} else {
free(s);
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""default"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
if ((yyvsp[-1].nodes).refine->target_type) {
if (trg->version < 2 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE))) {
(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE);
} if (trg->version > 1 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {

(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE);
} else {
free(s);
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""default"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
if (trg->version < 2) {
(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE;
} else {

(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE;
}
}
}

for (i = 0; i < (yyvsp[-1].nodes).refine->dflt_size; ++i) {
if (ly_strequal((yyvsp[-1].nodes).refine->dflt[i], s, 0)) {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""default"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Duplicated default value \""%s\""."", s);
YYABORT;
}
}
YANG_ADDELEM((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size, ""defaults"");
*((const char **)actual) = lydict_insert_zc(trg->ctx, s);
actual = (yyvsp[-1].nodes).refine;
s = NULL;
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 406:

{ if ((yyvsp[-1].nodes).refine->target_type) {
if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST)) {
(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST);
if ((yyvsp[-1].nodes).refine->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""config"", ""refine"");
YYABORT;
}
(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
} else {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""config"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST;
(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
}
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 407:

{ if ((yyvsp[-1].nodes).refine->target_type) {
if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_ANYXML)) {
(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_ANYXML);
if ((yyvsp[-1].nodes).refine->flags & LYS_MAND_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""mandatory"", ""refine"");
YYABORT;
}
(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
} else {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""mandatory"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_ANYXML;
(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);
}
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 408:

{ if ((yyvsp[-1].nodes).refine->target_type) {
if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {
(yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);
if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MINSET) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""min-elements"", ""refine"");
YYABORT;
}
(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;
(yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);
} else {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""min-elements"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
(yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;
(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;
(yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);
}
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 409:

{ if ((yyvsp[-1].nodes).refine->target_type) {
if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {
(yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);
if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MAXSET) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""max-elements"", ""refine"");
YYABORT;
}
(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;
(yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);
} else {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""max-elements"", ""refine"");
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid refine target nodetype for the substatements."");
YYABORT;
}
} else {
(yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;
(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;
(yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);
}
(yyval.nodes) = (yyvsp[-1].nodes);
}

break;

case 410:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).refine, s, ""refine"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 411:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).refine, s, ""refine"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 414:

{ void *parent;

(yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
parent = actual;
YANG_ADDELEM(((struct lys_node_uses *)actual)->augment,
((struct lys_node_uses *)actual)->augment_size, ""augments"");
if (yang_read_augment(trg, parent, actual, s)) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = AUGMENT_KEYWORD;
}

break;

case 415:

{ LOGDBG(LY_LDGYANG, ""finished parsing augment statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
data_node = (yyvsp[-4].backup_token).actual;
}

break;

case 418:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
YANG_ADDELEM(trg->augment, trg->augment_size, ""augments"");
if (yang_read_augment(trg, NULL, actual, s)) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = AUGMENT_KEYWORD;
}

break;

case 419:

{ LOGDBG(LY_LDGYANG, ""finished parsing augment statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
data_node = (yyvsp[-4].backup_token).actual;
}

break;

case 420:

{ (yyval.nodes).augment = actual; }

break;

case 423:

{ if ((yyvsp[-1].nodes).augment->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).augment, ""status"", ""augment"");
YYABORT;
}
(yyvsp[-1].nodes).augment->flags |= (yyvsp[0].i);
}

break;

case 424:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).augment, s, ""augment"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 425:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).augment, s, ""augment"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 428:

{ if (trg->version < 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).augment, ""notification"");
YYABORT;
}
}

break;

case 430:

{ if (param->module->version != 2) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, ""action"");
free(s);
YYABORT;
}
(yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ACTION, sizeof(struct lys_node_rpc_action)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = ACTION_KEYWORD;
}

break;

case 431:

{ LOGDBG(LY_LDGYANG, ""finished parsing action statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 432:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, NULL, param->node, s, LYS_RPC, sizeof(struct lys_node_rpc_action)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = RPC_KEYWORD;
}

break;

case 433:

{ LOGDBG(LY_LDGYANG, ""finished parsing rpc statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 435:

{ void *tmp;

if ((yyvsp[-1].nodes).node.ptr_rpc->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->iffeature, (yyvsp[-1].nodes).node.ptr_rpc->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_rpc->iffeature = tmp;
}

if ((yyvsp[-1].nodes).node.ptr_rpc->tpdf_size) {
tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->tpdf, (yyvsp[-1].nodes).node.ptr_rpc->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->tpdf);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_rpc->tpdf = tmp;
}
}

break;

case 436:

{ (yyval.nodes).node.ptr_rpc = actual;
(yyval.nodes).node.flag = 0;
}

break;

case 438:

{ if ((yyvsp[-1].nodes).node.ptr_rpc->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_rpc, ""status"", ""rpc"");
YYABORT;
}
(yyvsp[-1].nodes).node.ptr_rpc->flags |= (yyvsp[0].i);
}

break;

case 439:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, ""rpc"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 440:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, ""rpc"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 443:

{ if ((yyvsp[-2].nodes).node.flag & LYS_RPC_INPUT) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, ""input"", ""rpc"");
YYABORT;
}
(yyvsp[-2].nodes).node.flag |= LYS_RPC_INPUT;
(yyval.nodes) = (yyvsp[-2].nodes);
}

break;

case 444:

{ if ((yyvsp[-2].nodes).node.flag & LYS_RPC_OUTPUT) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, ""output"", ""rpc"");
YYABORT;
}
(yyvsp[-2].nodes).node.flag |= LYS_RPC_OUTPUT;
(yyval.nodes) = (yyvsp[-2].nodes);
}

break;

case 445:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
s = strdup(""input"");
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_INPUT, sizeof(struct lys_node_inout)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = INPUT_KEYWORD;
}

break;

case 446:

{ void *tmp;
struct lys_node_inout *input = actual;

if (input->must_size) {
tmp = realloc(input->must, input->must_size * sizeof *input->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
input->must = tmp;
}

if (input->tpdf_size) {
tmp = realloc(input->tpdf, input->tpdf_size * sizeof *input->tpdf);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
input->tpdf = tmp;
}

LOGDBG(LY_LDGYANG, ""finished parsing input statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
data_node = (yyvsp[-4].backup_token).actual;
}

break;

case 452:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
s = strdup(""output"");
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_OUTPUT, sizeof(struct lys_node_inout)))) {
YYABORT;
}
data_node = actual;
s = NULL;
actual_type = OUTPUT_KEYWORD;
}

break;

case 453:

{ void *tmp;
struct lys_node_inout *output = actual;

if (output->must_size) {
tmp = realloc(output->must, output->must_size * sizeof *output->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
output->must = tmp;
}

if (output->tpdf_size) {
tmp = realloc(output->tpdf, output->tpdf_size * sizeof *output->tpdf);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
output->tpdf = tmp;
}

LOGDBG(LY_LDGYANG, ""finished parsing output statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
data_node = (yyvsp[-4].backup_token).actual;
}

break;

case 454:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_NOTIF, sizeof(struct lys_node_notif)))) {
YYABORT;
}
data_node = actual;
actual_type = NOTIFICATION_KEYWORD;
}

break;

case 455:

{ LOGDBG(LY_LDGYANG, ""finished parsing notification statement \""%s\"""", data_node->name);
actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
data_node = (yyvsp[-1].backup_token).actual;
}

break;

case 457:

{ void *tmp;

if ((yyvsp[-1].nodes).notif->must_size) {
tmp = realloc((yyvsp[-1].nodes).notif->must, (yyvsp[-1].nodes).notif->must_size * sizeof *(yyvsp[-1].nodes).notif->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).notif->must = tmp;
}

if ((yyvsp[-1].nodes).notif->iffeature_size) {
tmp = realloc((yyvsp[-1].nodes).notif->iffeature, (yyvsp[-1].nodes).notif->iffeature_size * sizeof *(yyvsp[-1].nodes).notif->iffeature);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).notif->iffeature = tmp;
}

if ((yyvsp[-1].nodes).notif->tpdf_size) {
tmp = realloc((yyvsp[-1].nodes).notif->tpdf, (yyvsp[-1].nodes).notif->tpdf_size * sizeof *(yyvsp[-1].nodes).notif->tpdf);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].nodes).notif->tpdf = tmp;
}
}

break;

case 458:

{ (yyval.nodes).notif = actual; }

break;

case 461:

{ if ((yyvsp[-1].nodes).notif->flags & LYS_STATUS_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).notif, ""status"", ""notification"");
YYABORT;
}
(yyvsp[-1].nodes).notif->flags |= (yyvsp[0].i);
}

break;

case 462:

{ if (yang_read_description(trg, (yyvsp[-1].nodes).notif, s, ""notification"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 463:

{ if (yang_read_reference(trg, (yyvsp[-1].nodes).notif, s, ""notification"", NODE_PRINT)) {
YYABORT;
}
s = NULL;
}

break;

case 467:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
YANG_ADDELEM(trg->deviation, trg->deviation_size, ""deviations"");
((struct lys_deviation *)actual)->target_name = transform_schema2json(trg, s);
free(s);
if (!((struct lys_deviation *)actual)->target_name) {
YYABORT;
}
s = NULL;
actual_type = DEVIATION_KEYWORD;
}

break;

case 468:

{ void *tmp;

if ((yyvsp[-1].dev)->deviate_size) {
tmp = realloc((yyvsp[-1].dev)->deviate, (yyvsp[-1].dev)->deviate_size * sizeof *(yyvsp[-1].dev)->deviate);
if (!tmp) {
LOGINT(trg->ctx);
YYABORT;
}
(yyvsp[-1].dev)->deviate = tmp;
} else {
LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ""deviate"", ""deviation"");
YYABORT;
}
actual_type = (yyvsp[-4].backup_token).token;
actual = (yyvsp[-4].backup_token).actual;
}

break;

case 469:

{ (yyval.dev) = actual; }

break;

case 470:

{ if (yang_read_description(trg, (yyvsp[-1].dev), s, ""deviation"", NODE)) {
YYABORT;
}
s = NULL;
(yyval.dev) = (yyvsp[-1].dev);
}

break;

case 471:

{ if (yang_read_reference(trg, (yyvsp[-1].dev), s, ""deviation"", NODE)) {
YYABORT;
}
s = NULL;
(yyval.dev) = (yyvsp[-1].dev);
}

break;

case 477:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_deviate_unsupported(trg->ctx, actual))) {
YYABORT;
}
actual_type = NOT_SUPPORTED_KEYWORD;
}

break;

case 478:

{ actual_type = (yyvsp[-2].backup_token).token;
actual = (yyvsp[-2].backup_token).actual;
}

break;

case 484:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_ADD))) {
YYABORT;
}
actual_type = ADD_KEYWORD;
}

break;

case 485:

{ actual_type = (yyvsp[-2].backup_token).token;
actual = (yyvsp[-2].backup_token).actual;
}

break;

case 487:

{ void *tmp;

if ((yyvsp[-1].deviate)->must_size) {
tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].deviate)->must = tmp;
}

if ((yyvsp[-1].deviate)->unique_size) {
tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].deviate)->unique = tmp;
}

if ((yyvsp[-1].deviate)->dflt_size) {
tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].deviate)->dflt = tmp;
}
}

break;

case 488:

{ (yyval.deviate) = actual; }

break;

case 489:

{ if (yang_read_units(trg, actual, s, ADD_KEYWORD)) {
YYABORT;
}
s = NULL;
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 491:

{ YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, ""uniques"");
((struct lys_unique *)actual)->expr = (const char **)s;
s = NULL;
actual = (yyvsp[-1].deviate);
(yyval.deviate)= (yyvsp[-1].deviate);
}

break;

case 492:

{ YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, ""defaults"");
*((const char **)actual) = lydict_insert_zc(trg->ctx, s);
s = NULL;
actual = (yyvsp[-1].deviate);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 493:

{ if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""config"", ""deviate"");
YYABORT;
}
(yyvsp[-1].deviate)->flags = (yyvsp[0].i);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 494:

{ if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""mandatory"", ""deviate"");
YYABORT;
}
(yyvsp[-1].deviate)->flags = (yyvsp[0].i);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 495:

{ if ((yyvsp[-1].deviate)->min_set) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""min-elements"", ""deviation"");
YYABORT;
}
(yyvsp[-1].deviate)->min = (yyvsp[0].uint);
(yyvsp[-1].deviate)->min_set = 1;
(yyval.deviate) =  (yyvsp[-1].deviate);
}

break;

case 496:

{ if ((yyvsp[-1].deviate)->max_set) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""max-elements"", ""deviation"");
YYABORT;
}
(yyvsp[-1].deviate)->max = (yyvsp[0].uint);
(yyvsp[-1].deviate)->max_set = 1;
(yyval.deviate) =  (yyvsp[-1].deviate);
}

break;

case 497:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_DEL))) {
YYABORT;
}
actual_type = DELETE_KEYWORD;
}

break;

case 498:

{ actual_type = (yyvsp[-2].backup_token).token;
actual = (yyvsp[-2].backup_token).actual;
}

break;

case 500:

{ void *tmp;

if ((yyvsp[-1].deviate)->must_size) {
tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].deviate)->must = tmp;
}

if ((yyvsp[-1].deviate)->unique_size) {
tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].deviate)->unique = tmp;
}

if ((yyvsp[-1].deviate)->dflt_size) {
tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].deviate)->dflt = tmp;
}
}

break;

case 501:

{ (yyval.deviate) = actual; }

break;

case 502:

{ if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {
YYABORT;
}
s = NULL;
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 504:

{ YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, ""uniques"");
((struct lys_unique *)actual)->expr = (const char **)s;
s = NULL;
actual = (yyvsp[-1].deviate);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 505:

{ YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, ""defaults"");
*((const char **)actual) = lydict_insert_zc(trg->ctx, s);
s = NULL;
actual = (yyvsp[-1].deviate);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 506:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_RPL))) {
YYABORT;
}
actual_type = REPLACE_KEYWORD;
}

break;

case 507:

{ actual_type = (yyvsp[-2].backup_token).token;
actual = (yyvsp[-2].backup_token).actual;
}

break;

case 509:

{ void *tmp;

if ((yyvsp[-1].deviate)->dflt_size) {
tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);
if (!tmp) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyvsp[-1].deviate)->dflt = tmp;
}
}

break;

case 510:

{ (yyval.deviate) = actual; }

break;

case 512:

{ if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {
YYABORT;
}
s = NULL;
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 513:

{ YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, ""defaults"");
*((const char **)actual) = lydict_insert_zc(trg->ctx, s);
s = NULL;
actual = (yyvsp[-1].deviate);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 514:

{ if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""config"", ""deviate"");
YYABORT;
}
(yyvsp[-1].deviate)->flags = (yyvsp[0].i);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 515:

{ if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""mandatory"", ""deviate"");
YYABORT;
}
(yyvsp[-1].deviate)->flags = (yyvsp[0].i);
(yyval.deviate) = (yyvsp[-1].deviate);
}

break;

case 516:

{ if ((yyvsp[-1].deviate)->min_set) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""min-elements"", ""deviation"");
YYABORT;
}
(yyvsp[-1].deviate)->min = (yyvsp[0].uint);
(yyvsp[-1].deviate)->min_set = 1;
(yyval.deviate) =  (yyvsp[-1].deviate);
}

break;

case 517:

{ if ((yyvsp[-1].deviate)->max_set) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""max-elements"", ""deviation"");
YYABORT;
}
(yyvsp[-1].deviate)->max = (yyvsp[0].uint);
(yyvsp[-1].deviate)->max_set = 1;
(yyval.deviate) =  (yyvsp[-1].deviate);
}

break;

case 518:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_when(trg, actual, actual_type, s))) {
YYABORT;
}
s = NULL;
actual_type = WHEN_KEYWORD;
}

break;

case 519:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 523:

{ if (yang_read_description(trg, actual, s, ""when"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 524:

{ if (yang_read_reference(trg, actual, s, ""when"", NODE)) {
YYABORT;
}
s = NULL;
}

break;

case 525:

{ (yyval.i) = (yyvsp[0].i);
backup_type = actual_type;
actual_type = CONFIG_KEYWORD;
}

break;

case 526:

{ (yyval.i) = (yyvsp[-1].i); }

break;

case 527:

{ (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET; }

break;

case 528:

{ (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET; }

break;

case 529:

{ if (!strcmp(s, ""true"")) {
(yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET;
} else if (!strcmp(s, ""false"")) {
(yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET;
} else {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""config"");
free(s);
YYABORT;
}
free(s);
s = NULL;
}

break;

case 530:

{ (yyval.i) = (yyvsp[0].i);
backup_type = actual_type;
actual_type = MANDATORY_KEYWORD;
}

break;

case 531:

{ (yyval.i) = (yyvsp[-1].i); }

break;

case 532:

{ (yyval.i) = LYS_MAND_TRUE; }

break;

case 533:

{ (yyval.i) = LYS_MAND_FALSE; }

break;

case 534:

{ if (!strcmp(s, ""true"")) {
(yyval.i) = LYS_MAND_TRUE;
} else if (!strcmp(s, ""false"")) {
(yyval.i) = LYS_MAND_FALSE;
} else {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""mandatory"");
free(s);
YYABORT;
}
free(s);
s = NULL;
}

break;

case 535:

{ backup_type = actual_type;
actual_type = PRESENCE_KEYWORD;
}

break;

case 537:

{ (yyval.uint) = (yyvsp[0].uint);
backup_type = actual_type;
actual_type = MIN_ELEMENTS_KEYWORD;
}

break;

case 538:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 539:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 540:

{ if (strlen(s) == 1 && s[0] == '0') {
(yyval.uint) = 0;
} else {

uint64_t val;
char *endptr = NULL;
errno = 0;

val = strtoul(s, &endptr, 10);
if (*endptr || s[0] == '-' || errno || val > UINT32_MAX) {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""min-elements"");
free(s);
YYABORT;
}
(yyval.uint) = (uint32_t) val;
}
free(s);
s = NULL;
}

break;

case 541:

{ (yyval.uint) = (yyvsp[0].uint);
backup_type = actual_type;
actual_type = MAX_ELEMENTS_KEYWORD;
}

break;

case 542:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 543:

{ (yyval.uint) = 0; }

break;

case 544:

{ (yyval.uint) = (yyvsp[-1].uint); }

break;

case 545:

{ if (!strcmp(s, ""unbounded"")) {
(yyval.uint) = 0;
} else {

uint64_t val;
char *endptr = NULL;
errno = 0;

val = strtoul(s, &endptr, 10);
if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {
LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, ""max-elements"");
free(s);
YYABORT;
}
(yyval.uint) = (uint32_t) val;
}
free(s);
s = NULL;
}

break;

case 546:

{ (yyval.i) = (yyvsp[0].i);
backup_type = actual_type;
actual_type = ORDERED_BY_KEYWORD;
}

break;

case 547:

{ (yyval.i) = (yyvsp[-1].i); }

break;

case 548:

{ (yyval.i) = LYS_USERORDERED; }

break;

case 549:

{ (yyval.i) = LYS_SYSTEMORDERED; }

break;

case 550:

{ if (!strcmp(s, ""user"")) {
(yyval.i) = LYS_USERORDERED;
} else if (!strcmp(s, ""system"")) {
(yyval.i) = LYS_SYSTEMORDERED;
} else {
free(s);
YYABORT;
}
free(s);
s=NULL;
}

break;

case 551:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
switch (actual_type) {
case CONTAINER_KEYWORD:
YANG_ADDELEM(((struct lys_node_container *)actual)->must,
((struct lys_node_container *)actual)->must_size, ""musts"");
break;
case ANYDATA_KEYWORD:
case ANYXML_KEYWORD:
YANG_ADDELEM(((struct lys_node_anydata *)actual)->must,
((struct lys_node_anydata *)actual)->must_size, ""musts"");
break;
case LEAF_KEYWORD:
YANG_ADDELEM(((struct lys_node_leaf *)actual)->must,
((struct lys_node_leaf *)actual)->must_size, ""musts"");
break;
case LEAF_LIST_KEYWORD:
YANG_ADDELEM(((struct lys_node_leaflist *)actual)->must,
((struct lys_node_leaflist *)actual)->must_size, ""musts"");
break;
case LIST_KEYWORD:
YANG_ADDELEM(((struct lys_node_list *)actual)->must,
((struct lys_node_list *)actual)->must_size, ""musts"");
break;
case REFINE_KEYWORD:
YANG_ADDELEM(((struct lys_refine *)actual)->must,
((struct lys_refine *)actual)->must_size, ""musts"");
break;
case ADD_KEYWORD:
case DELETE_KEYWORD:
YANG_ADDELEM(((struct lys_deviate *)actual)->must,
((struct lys_deviate *)actual)->must_size, ""musts"");
break;
case NOTIFICATION_KEYWORD:
if (trg->version < 2) {
free(s);
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, ""must"");
YYABORT;
}
YANG_ADDELEM(((struct lys_node_notif *)actual)->must,
((struct lys_node_notif *)actual)->must_size, ""musts"");
break;
case INPUT_KEYWORD:
case OUTPUT_KEYWORD:
if (trg->version < 2) {
free(s);
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, ""must"");
YYABORT;
}
YANG_ADDELEM(((struct lys_node_inout *)actual)->must,
((struct lys_node_inout *)actual)->must_size, ""musts"");
break;
case EXTENSION_INSTANCE:

break;
default:
free(s);
LOGINT(trg->ctx);
YYABORT;
}
((struct lys_restr *)actual)->expr = transform_schema2json(trg, s);
free(s);
if (!((struct lys_restr *)actual)->expr) {
YYABORT;
}
s = NULL;
actual_type = MUST_KEYWORD;
}

break;

case 552:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 555:

{ backup_type = actual_type;
actual_type = UNIQUE_KEYWORD;
}

break;

case 559:

{ backup_type = actual_type;
actual_type = KEY_KEYWORD;
}

break;

case 561:

{ s = strdup(yyget_text(scanner));
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
}

break;

case 564:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_range(trg->ctx, actual, s, is_ext_instance))) {
YYABORT;
}
actual_type = RANGE_KEYWORD;
s = NULL;
}

break;

case 565:

{ if (s) {
s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 2);
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
strcat(s,""/"");
strcat(s, yyget_text(scanner));
} else {
s = malloc(yyget_leng(scanner) + 2);
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
s[0]='/';
memcpy(s + 1, yyget_text(scanner), yyget_leng(scanner) + 1);
}
}

break;

case 569:

{ if (s) {
s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 1);
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
strcat(s, yyget_text(scanner));
} else {
s = strdup(yyget_text(scanner));
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
}
}

break;

case 571:

{ tmp_s = yyget_text(scanner); }

break;

case 572:

{ s = strdup(tmp_s);
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
s[strlen(s) - 1] = '\0';
}

break;

case 573:

{ tmp_s = yyget_text(scanner); }

break;

case 574:

{ s = strdup(tmp_s);
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
s[strlen(s) - 1] = '\0';
}

break;

case 598:

{
unsigned long val;

val = strtoul(yyget_text(scanner), NULL, 10);
if (val > UINT32_MAX) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Converted number is very long."");
YYABORT;
}
(yyval.uint) = (uint32_t) val;
}

break;

case 599:

{ (yyval.uint) = 0; }

break;

case 600:

{ (yyval.uint) = (yyvsp[0].uint); }

break;

case 601:

{ (yyval.i) = 0; }

break;

case 602:

{
int64_t val;

val = strtoll(yyget_text(scanner), NULL, 10);
if (val < INT32_MIN || val > INT32_MAX) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,
""The number is not in the correct range (INT32_MIN..INT32_MAX): \""%d\"""",val);
YYABORT;
}
(yyval.i) = (int32_t) val;
}

break;

case 608:

{ if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {
free(s);
YYABORT;
}
}

break;

case 613:

{ char *tmp;

if ((tmp = strchr(s, ':'))) {
*tmp = '\0';

if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {
free(s);
YYABORT;
}

if (lyp_check_identifier(trg->ctx, tmp + 1, LY_IDENT_SIMPLE, trg, NULL)) {
free(s);
YYABORT;
}
*tmp = ':';
} else {

if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {
free(s);
YYABORT;
}
}
}

break;

case 614:

{ s = (yyvsp[-1].str); }

break;

case 615:

{ s = (yyvsp[-3].str); }

break;

case 616:

{ actual_type = backup_type;
backup_type = NODE;
(yyval.str) = s;
s = NULL;
}

break;

case 617:

{ actual_type = backup_type;
backup_type = NODE;
}

break;

case 618:

{ (yyval.str) = s;
s = NULL;
}

break;

case 622:

{ actual_type = (yyvsp[-1].backup_token).token;
actual = (yyvsp[-1].backup_token).actual;
}

break;

case 623:

{ (yyval.backup_token).token = actual_type;
(yyval.backup_token).actual = actual;
if (!(actual = yang_read_ext(trg, (actual) ? actual : trg, (yyvsp[-1].str), s,
actual_type, backup_type, is_ext_instance))) {
YYABORT;
}
s = NULL;
actual_type = EXTENSION_INSTANCE;
}

break;

case 624:

{ (yyval.str) = s; s = NULL; }

break;

case 639:

{  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;
int32_t length = 0, old_length = 0;
char *tmp_value;

if (!substmt) {
substmt = calloc(1, sizeof *substmt);
if (!substmt) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct lys_ext_instance *)actual)->parent = substmt;
}
length = strlen((yyvsp[-2].str));
old_length = (substmt->ext_substmt) ? strlen(substmt->ext_substmt) + 2 : 2;
tmp_value = realloc(substmt->ext_substmt, old_length + length + 1);
if (!tmp_value) {
LOGMEM(trg->ctx);
YYABORT;
}
substmt->ext_substmt = tmp_value;
tmp_value += old_length - 2;
memcpy(tmp_value, (yyvsp[-2].str), length);
tmp_value[length] = ' ';
tmp_value[length + 1] = '\0';
tmp_value[length + 2] = '\0';
}

break;

case 640:

{  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;
int32_t length;
char *tmp_value, **array;
int i = 0;

if (!substmt) {
substmt = calloc(1, sizeof *substmt);
if (!substmt) {
LOGMEM(trg->ctx);
YYABORT;
}
((struct lys_ext_instance *)actual)->parent = substmt;
}
length = strlen((yyvsp[-2].str));
if (!substmt->ext_modules) {
array = malloc(2 * sizeof *substmt->ext_modules);
} else {
for (i = 0; substmt->ext_modules[i]; ++i);
array = realloc(substmt->ext_modules, (i + 2) * sizeof *substmt->ext_modules);
}
if (!array) {
LOGMEM(trg->ctx);
YYABORT;
}
substmt->ext_modules = array;
array[i + 1] = NULL;
tmp_value = malloc(length + 2);
if (!tmp_value) {
LOGMEM(trg->ctx);
YYABORT;
}
array[i] = tmp_value;
memcpy(tmp_value, (yyvsp[-2].str), length);
tmp_value[length] = '\0';
tmp_value[length + 1] = '\0';
}

break;

case 643:

{ (yyval.str) = yyget_text(scanner); }

break;

case 644:

{ (yyval.str) = yyget_text(scanner); }

break;

case 656:

{ s = strdup(yyget_text(scanner));
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
}

break;

case 749:

{ s = strdup(yyget_text(scanner));
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
}

break;

case 750:

{ s = strdup(yyget_text(scanner));
if (!s) {
LOGMEM(trg->ctx);
YYABORT;
}
}

break;

case 751:

{ struct lys_type **type;

type = (struct lys_type **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""type"", LY_STMT_TYPE);
if (!type) {
YYABORT;
}

(*type) = calloc(1, sizeof **type);
if (!*type) {
LOGMEM(trg->ctx);
YYABORT;
}


(*type)->parent = (struct lys_tpdf *)ext_instance;
(yyval.v) = actual = *type;
is_ext_instance = 0;
}

break;

case 752:

{ struct lys_tpdf **tpdf;

tpdf = (struct lys_tpdf **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""typedef"", LY_STMT_TYPEDEF);
if (!tpdf) {
YYABORT;
}

(*tpdf) = calloc(1, sizeof **tpdf);
if (!*tpdf) {
LOGMEM(trg->ctx);
YYABORT;
}

(yyval.v) = actual = *tpdf;
is_ext_instance = 0;
}

break;

case 753:

{ struct lys_iffeature **iffeature;

iffeature = (struct lys_iffeature **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""if-feature"", LY_STMT_IFFEATURE);
if (!iffeature) {
YYABORT;
}

(*iffeature) = calloc(1, sizeof **iffeature);
if (!*iffeature) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyval.v) = actual = *iffeature;
}

break;

case 754:

{ struct lys_restr **restr;
LY_STMT stmt;

s = yyget_text(scanner);
if (!strcmp(s, ""must"")) {
stmt = LY_STMT_MUST;
} else if (!strcmp(s, ""pattern"")) {
stmt = LY_STMT_PATTERN;
} else if (!strcmp(s, ""range"")) {
stmt = LY_STMT_RANGE;
} else {
stmt = LY_STMT_LENGTH;
}
restr = (struct lys_restr **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, s, stmt);
if (!restr) {
YYABORT;
}

(*restr) = calloc(1, sizeof(struct lys_restr));
if (!*restr) {
LOGMEM(trg->ctx);
YYABORT;
}
(yyval.v) = actual = *restr;
s = NULL;
}

break;

case 755:

{ actual = yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, ""when"", LY_STMT_WHEN);
if (!actual) {
YYABORT;
}
(yyval.v) = actual;
}

break;

case 756:

{ struct lys_revision **rev;
int i;

rev = (struct lys_revision **)yang_getplace_for_extcomplex_struct(ext_instance, &i, ext_name,
""revision"", LY_STMT_REVISION);
if (!rev) {
YYABORT;
}
rev[i] = calloc(1, sizeof **rev);
if (!rev[i]) {
LOGMEM(trg->ctx);
YYABORT;
}
actual = rev[i];
(yyval.revisions).revision = rev;
(yyval.revisions).index = i;
}

break;

case 757:

{ LY_STMT stmt;

s = yyget_text(scanner);
if (!strcmp(s, ""action"")) {
stmt = LY_STMT_ACTION;
} else if (!strcmp(s, ""anydata"")) {
stmt = LY_STMT_ANYDATA;
} else if (!strcmp(s, ""anyxml"")) {
stmt = LY_STMT_ANYXML;
} else if (!strcmp(s, ""case"")) {
stmt = LY_STMT_CASE;
} else if (!strcmp(s, ""choice"")) {
stmt = LY_STMT_CHOICE;
} else if (!strcmp(s, ""container"")) {
stmt = LY_STMT_CONTAINER;
} else if (!strcmp(s, ""grouping"")) {
stmt = LY_STMT_GROUPING;
} else if (!strcmp(s, ""input"")) {
stmt = LY_STMT_INPUT;
} else if (!strcmp(s, ""leaf"")) {
stmt = LY_STMT_LEAF;
} else if (!strcmp(s, ""leaf-list"")) {
stmt = LY_STMT_LEAFLIST;
} else if (!strcmp(s, ""list"")) {
stmt = LY_STMT_LIST;
} else if (!strcmp(s, ""notification"")) {
stmt = LY_STMT_NOTIFICATION;
} else if (!strcmp(s, ""output"")) {
stmt = LY_STMT_OUTPUT;
} else {
stmt = LY_STMT_USES;
}
if (yang_extcomplex_node(ext_instance, ext_name, s, *param->node, stmt)) {
YYABORT;
}
actual = NULL;
s = NULL;
is_ext_instance = 0;
}

break;

case 758:

{ LOGERR(trg->ctx, ly_errno, ""Extension's substatement \""%s\"" not supported."", yyget_text(scanner)); }

break;

case 790:

{ actual_type = EXTENSION_INSTANCE;
actual = ext_instance;
if (!is_ext_instance) {
LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));
YYABORT;
}
(yyval.i) = 0;
}

break;

case 792:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""prefix"", ext_name, &s,
0, LY_STMT_PREFIX)) {
YYABORT;
}
}

break;

case 793:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""description"", ext_name, &s,
0, LY_STMT_DESCRIPTION)) {
YYABORT;
}
}

break;

case 794:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""reference"", ext_name, &s,
0, LY_STMT_REFERENCE)) {
YYABORT;
}
}

break;

case 795:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""units"", ext_name, &s,
0, LY_STMT_UNITS)) {
YYABORT;
}
}

break;

case 796:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""base"", ext_name, &s,
0, LY_STMT_BASE)) {
YYABORT;
}
}

break;

case 797:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""contact"", ext_name, &s,
0, LY_STMT_CONTACT)) {
YYABORT;
}
}

break;

case 798:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""default"", ext_name, &s,
0, LY_STMT_DEFAULT)) {
YYABORT;
}
}

break;

case 799:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""error-message"", ext_name, &s,
0, LY_STMT_ERRMSG)) {
YYABORT;
}
}

break;

case 800:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""error-app-tag"", ext_name, &s,
0, LY_STMT_ERRTAG)) {
YYABORT;
}
}

break;

case 801:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""key"", ext_name, &s,
0, LY_STMT_KEY)) {
YYABORT;
}
}

break;

case 802:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""namespace"", ext_name, &s,
0, LY_STMT_NAMESPACE)) {
YYABORT;
}
}

break;

case 803:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""organization"", ext_name, &s,
0, LY_STMT_ORGANIZATION)) {
YYABORT;
}
}

break;

case 804:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""path"", ext_name, &s,
0, LY_STMT_PATH)) {
YYABORT;
}
}

break;

case 805:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""presence"", ext_name, &s,
0, LY_STMT_PRESENCE)) {
YYABORT;
}
}

break;

case 806:

{ if (yang_read_extcomplex_str(trg, ext_instance, ""revision-date"", ext_name, &s,
0, LY_STMT_REVISIONDATE)) {
YYABORT;
}
}

break;

case 807:

{ struct lys_type *type = (yyvsp[-2].v);

if (yang_fill_type(trg, type, (struct yang_type *)type->der, ext_instance, param->unres)) {
yang_type_free(trg->ctx, type);
YYABORT;
}
if (unres_schema_add_node(trg, param->unres, type, UNRES_TYPE_DER_EXT, NULL) == -1) {
yang_type_free(trg->ctx, type);
YYABORT;
}
actual = ext_instance;
is_ext_instance = 1;
}

break;

case 808:

{ struct lys_tpdf *tpdf = (yyvsp[-2].v);

if (yang_fill_type(trg, &tpdf->type, (struct yang_type *)tpdf->type.der, tpdf, param->unres)) {
yang_type_free(trg->ctx, &tpdf->type);
}
if (yang_check_ext_instance(trg, &tpdf->ext, tpdf->ext_size, tpdf, param->unres)) {
YYABORT;
}
if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DER_TPDF, (struct lys_node *)ext_instance) == -1) {
yang_type_free(trg->ctx, &tpdf->type);
YYABORT;
}

if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&tpdf->dflt)) == -1)  {
YYABORT;
}
actual = ext_instance;
is_ext_instance = 1;
}

break;

case 809:

{ if (yang_fill_extcomplex_flags(ext_instance, ext_name, ""status"", LY_STMT_STATUS,
(yyvsp[0].i), LYS_STATUS_MASK)) {
YYABORT;
}
}

break;

case 810:

{ if (yang_fill_extcomplex_flags(ext_instance, ext_name, ""config"", LY_STMT_CONFIG,
(yyvsp[0].i), LYS_CONFIG_MASK)) {
YYABORT;
}
}

break;

case 811:

{ if (yang_fill_extcomplex_flags(ext_instance, ext_name, ""mandatory"", LY_STMT_MANDATORY,
(yyvsp[0].i), LYS_MAND_MASK)) {
YYABORT;
}
}

break;

case 812:

{ if ((yyvsp[-1].i) & LYS_ORDERED_MASK) {
LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, ""ordered by"", ext_name);
YYABORT;
}
if ((yyvsp[0].i) & LYS_USERORDERED) {
if (yang_fill_extcomplex_flags(ext_instance, ext_name, ""ordered-by"", LY_STMT_ORDEREDBY,
(yyvsp[0].i), LYS_USERORDERED)) {
YYABORT;
}
}
(yyvsp[-1].i) |= (yyvsp[0].i);
(yyval.i) = (yyvsp[-1].i);
}

break;

case 813:

{ if (yang_fill_extcomplex_uint8(ext_instance, ext_name, ""require-instance"",
LY_STMT_REQINSTANCE, (yyvsp[0].i))) {
YYABORT;
}
}

break;

case 814:

{ if (yang_fill_extcomplex_uint8(ext_instance, ext_name, ""modifier"", LY_STMT_MODIFIER, 0)) {
YYABORT;
}
}

break;

case 815:

{
if ((yyvsp[0].uint) < 1 || (yyvsp[0].uint) > 18) {
LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, ""Invalid value \""%d\"" of \""%s\""."", (yyvsp[0].uint), ""fraction-digits"");
YYABORT;
}
if (yang_fill_extcomplex_uint8(ext_instance, ext_name, ""fraction-digits"", LY_STMT_DIGITS, (yyvsp[0].uint))) {
YYABORT;
}
}

break;

case 816:

{ uint32_t **val;

val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""min-elements"", LY_STMT_MIN);
if (!val) {
YYABORT;
}

*val = malloc(sizeof(uint32_t));
if (!*val) {
LOGMEM(trg->ctx);
YYABORT;
}
**val = (yyvsp[0].uint);
}

break;

case 817:

{ uint32_t **val;

val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""max-elements"", LY_STMT_MAX);
if (!val) {
YYABORT;
}

*val = malloc(sizeof(uint32_t));
if (!*val) {
LOGMEM(trg->ctx);
YYABORT;
}
**val = (yyvsp[0].uint);
}

break;

case 818:

{ uint32_t **val;

val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""position"", LY_STMT_POSITION);
if (!val) {
YYABORT;
}

*val = malloc(sizeof(uint32_t));
if (!*val) {
LOGMEM(trg->ctx);
YYABORT;
}
**val = (yyvsp[0].uint);
}

break;

case 819:

{ int32_t **val;

val = (int32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""value"", LY_STMT_VALUE);
if (!val) {
YYABORT;
}

*val = malloc(sizeof(int32_t));
if (!*val) {
LOGMEM(trg->ctx);
YYABORT;
}
**val = (yyvsp[0].i);
}

break;

case 820:

{ struct lys_unique **unique;
int rc;

unique = (struct lys_unique **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,
""unique"", LY_STMT_UNIQUE);
if (!unique) {
YYABORT;
}
*unique = calloc(1, sizeof(struct lys_unique));
if (!*unique) {
LOGMEM(trg->ctx);
YYABORT;
}
rc = yang_fill_unique(trg, (struct lys_node_list *)ext_instance, *unique, s, param->unres);
free(s);
s = NULL;
if (rc) {
YYABORT;
}
}

break;

case 821:

{ struct lys_iffeature *iffeature;

iffeature = (yyvsp[-2].v);
s = (char *)iffeature->features;
iffeature->features = NULL;
if (yang_fill_iffeature(trg, iffeature, ext_instance, s, param->unres, 0)) {
YYABORT;
}
if (yang_check_ext_instance(trg, &iffeature->ext, iffeature->ext_size, iffeature, param->unres)) {
YYABORT;
}
s = NULL;
actual = ext_instance;
}

break;

case 823:

{ if (yang_check_ext_instance(trg, &((struct lys_restr *)(yyvsp[-2].v))->ext, ((struct lys_restr *)(yyvsp[-2].v))->ext_size, (yyvsp[-2].v), param->unres)) {
YYABORT;
}
actual = ext_instance;
}

break;

case 824:

{ if (yang_check_ext_instance(trg, &(*(struct lys_when **)(yyvsp[-2].v))->ext, (*(struct lys_when **)(yyvsp[-2].v))->ext_size,
*(struct lys_when **)(yyvsp[-2].v), param->unres)) {
YYABORT;
}
actual = ext_instance;
}

break;

case 825:

{ int i;

for (i = 0; i < (yyvsp[-2].revisions).index; ++i) {
if (!strcmp((yyvsp[-2].revisions).revision[i]->date, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->date)) {
LOGWRN(trg->ctx, ""Module's revisions are not unique (%s)."", (yyvsp[-2].revisions).revision[i]->date);
break;
}
}
if (yang_check_ext_instance(trg, &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext_size,
&(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index], param->unres)) {
YYABORT;
}
actual = ext_instance;
}

break;

case 826:

{ actual = ext_instance;
is_ext_instance = 1;
}

break;



default: break;
}











YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

YYPOPSTACK (yylen);
yylen = 0;
YY_STACK_PRINT (yyss, yyssp);

*++yyvsp = yyval;
*++yylsp = yyloc;




{
const int yylhs = yyr1[yyn] - YYNTOKENS;
const int yyi = yypgoto[yylhs] + *yyssp;
yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
? yytable[yyi]
: yydefgoto[yylhs]);
}

goto yynewstate;





yyerrlab:


yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);


if (!yyerrstatus)
{
++yynerrs;
#if ! YYERROR_VERBOSE
yyerror (&yylloc, scanner, param, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
{
char const *yymsgp = YY_(""syntax error"");
int yysyntax_error_status;
yysyntax_error_status = YYSYNTAX_ERROR;
if (yysyntax_error_status == 0)
yymsgp = yymsg;
else if (yysyntax_error_status == 1)
{
if (yymsg != yymsgbuf)
YYSTACK_FREE (yymsg);
yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
if (!yymsg)
{
yymsg = yymsgbuf;
yymsg_alloc = sizeof yymsgbuf;
yysyntax_error_status = 2;
}
else
{
yysyntax_error_status = YYSYNTAX_ERROR;
yymsgp = yymsg;
}
}
yyerror (&yylloc, scanner, param, yymsgp);
if (yysyntax_error_status == 2)
goto yyexhaustedlab;
}
# undef YYSYNTAX_ERROR
#endif
}

yyerror_range[1] = yylloc;

if (yyerrstatus == 3)
{



if (yychar <= YYEOF)
{

if (yychar == YYEOF)
YYABORT;
}
else
{
yydestruct (""Error: discarding"",
yytoken, &yylval, &yylloc, scanner, param);
yychar = YYEMPTY;
}
}



goto yyerrlab1;





yyerrorlab:




if (              0)
goto yyerrorlab;



YYPOPSTACK (yylen);
yylen = 0;
YY_STACK_PRINT (yyss, yyssp);
yystate = *yyssp;
goto yyerrlab1;





yyerrlab1:
yyerrstatus = 3;

for (;;)
{
yyn = yypact[yystate];
if (!yypact_value_is_default (yyn))
{
yyn += YYTERROR;
if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
{
yyn = yytable[yyn];
if (0 < yyn)
break;
}
}


if (yyssp == yyss)
YYABORT;

yyerror_range[1] = *yylsp;
yydestruct (""Error: popping"",
yystos[yystate], yyvsp, yylsp, scanner, param);
YYPOPSTACK (1);
yystate = *yyssp;
YY_STACK_PRINT (yyss, yyssp);
}

YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
*++yyvsp = yylval;
YY_IGNORE_MAYBE_UNINITIALIZED_END

yyerror_range[2] = yylloc;


YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
*++yylsp = yyloc;


YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

yystate = yyn;
goto yynewstate;





yyacceptlab:
yyresult = 0;
goto yyreturn;




yyabortlab:
yyresult = 1;
goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE



yyexhaustedlab:
yyerror (&yylloc, scanner, param, YY_(""memory exhausted""));
yyresult = 2;

#endif

yyreturn:
if (yychar != YYEMPTY)
{


yytoken = YYTRANSLATE (yychar);
yydestruct (""Cleanup: discarding lookahead"",
yytoken, &yylval, &yylloc, scanner, param);
}


YYPOPSTACK (yylen);
YY_STACK_PRINT (yyss, yyssp);
while (yyssp != yyss)
{
yydestruct (""Cleanup: popping"",
yystos[*yyssp], yyvsp, yylsp, scanner, param);
YYPOPSTACK (1);
}
#ifndef yyoverflow
if (yyss != yyssa)
YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
if (yymsg != yymsgbuf)
YYSTACK_FREE (yymsg);
#endif
return yyresult;
}",[4203],"A double-free is present in libyang before v1.0-r3 in the function yyparse() when a type statement in used in a notification statement. Applications that use libyang to parse untrusted input yang files may be vulnerable to this flaw, which would cause a crash or potentially code execution."
4676,"Perl_my_setenv(pTHX_ const char *nam, const char *val)
{
dVAR;
char *envstr;
const int nlen = strlen(nam);
int vlen;

if (!val) {
val = """";
}
vlen = strlen(val);
Newx(envstr, nlen+vlen+2, char);
my_setenv_format(envstr, nam, nlen, val, vlen);
(void)PerlEnv_putenv(envstr);
Safefree(envstr);
}","[5, 6, 12]",Perl before 5.26.3 and 5.28.x before 5.28.1 has a buffer overflow via a crafted regular expression that triggers invalid write operations.
4171,"int main (int argc, char **argv) {
int c;
bool lock_memory = false;
bool do_daemonize = false;
bool preallocate = false;
int maxcore = 0;
char *username = NULL;
char *pid_file = NULL;
struct passwd *pw;
struct rlimit rlim;
char *buf;
char unit = '\0';
int size_max = 0;
int retval = EXIT_SUCCESS;

static int *l_socket = NULL;


static int *u_socket = NULL;
bool protocol_specified = false;
bool tcp_specified = false;
bool udp_specified = false;
bool start_lru_maintainer = true;
bool start_lru_crawler = true;
bool start_assoc_maint = true;
enum hashfunc_type hash_type = MURMUR3_HASH;
uint32_t tocrawl;
uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];
bool use_slab_sizes = false;
char *slab_sizes_unparsed = NULL;
bool slab_chunk_size_changed = false;
#ifdef EXTSTORE
void *storage = NULL;
char *storage_file = NULL;
struct extstore_conf ext_cf;
#endif
char *subopts, *subopts_orig;
char *subopts_value;
enum {
MAXCONNS_FAST = 0,
HASHPOWER_INIT,
NO_HASHEXPAND,
SLAB_REASSIGN,
SLAB_AUTOMOVE,
SLAB_AUTOMOVE_RATIO,
SLAB_AUTOMOVE_WINDOW,
TAIL_REPAIR_TIME,
HASH_ALGORITHM,
LRU_CRAWLER,
LRU_CRAWLER_SLEEP,
LRU_CRAWLER_TOCRAWL,
LRU_MAINTAINER,
HOT_LRU_PCT,
WARM_LRU_PCT,
HOT_MAX_FACTOR,
WARM_MAX_FACTOR,
TEMPORARY_TTL,
IDLE_TIMEOUT,
WATCHER_LOGBUF_SIZE,
WORKER_LOGBUF_SIZE,
SLAB_SIZES,
SLAB_CHUNK_MAX,
TRACK_SIZES,
NO_INLINE_ASCII_RESP,
MODERN,
NO_MODERN,
NO_CHUNKED_ITEMS,
NO_SLAB_REASSIGN,
NO_SLAB_AUTOMOVE,
NO_MAXCONNS_FAST,
INLINE_ASCII_RESP,
NO_LRU_CRAWLER,
NO_LRU_MAINTAINER,
NO_DROP_PRIVILEGES,
#ifdef MEMCACHED_DEBUG
RELAXED_PRIVILEGES,
#endif
#ifdef EXTSTORE
EXT_PAGE_SIZE,
EXT_PAGE_COUNT,
EXT_WBUF_SIZE,
EXT_THREADS,
EXT_IO_DEPTH,
EXT_PATH,
EXT_ITEM_SIZE,
EXT_ITEM_AGE,
EXT_LOW_TTL,
EXT_RECACHE_RATE,
EXT_COMPACT_UNDER,
EXT_DROP_UNDER,
EXT_MAX_FRAG,
EXT_DROP_UNREAD,
SLAB_AUTOMOVE_FREERATIO,
#endif
};
char *const subopts_tokens[] = {
[MAXCONNS_FAST] = ""maxconns_fast"",
[HASHPOWER_INIT] = ""hashpower"",
[NO_HASHEXPAND] = ""no_hashexpand"",
[SLAB_REASSIGN] = ""slab_reassign"",
[SLAB_AUTOMOVE] = ""slab_automove"",
[SLAB_AUTOMOVE_RATIO] = ""slab_automove_ratio"",
[SLAB_AUTOMOVE_WINDOW] = ""slab_automove_window"",
[TAIL_REPAIR_TIME] = ""tail_repair_time"",
[HASH_ALGORITHM] = ""hash_algorithm"",
[LRU_CRAWLER] = ""lru_crawler"",
[LRU_CRAWLER_SLEEP] = ""lru_crawler_sleep"",
[LRU_CRAWLER_TOCRAWL] = ""lru_crawler_tocrawl"",
[LRU_MAINTAINER] = ""lru_maintainer"",
[HOT_LRU_PCT] = ""hot_lru_pct"",
[WARM_LRU_PCT] = ""warm_lru_pct"",
[HOT_MAX_FACTOR] = ""hot_max_factor"",
[WARM_MAX_FACTOR] = ""warm_max_factor"",
[TEMPORARY_TTL] = ""temporary_ttl"",
[IDLE_TIMEOUT] = ""idle_timeout"",
[WATCHER_LOGBUF_SIZE] = ""watcher_logbuf_size"",
[WORKER_LOGBUF_SIZE] = ""worker_logbuf_size"",
[SLAB_SIZES] = ""slab_sizes"",
[SLAB_CHUNK_MAX] = ""slab_chunk_max"",
[TRACK_SIZES] = ""track_sizes"",
[NO_INLINE_ASCII_RESP] = ""no_inline_ascii_resp"",
[MODERN] = ""modern"",
[NO_MODERN] = ""no_modern"",
[NO_CHUNKED_ITEMS] = ""no_chunked_items"",
[NO_SLAB_REASSIGN] = ""no_slab_reassign"",
[NO_SLAB_AUTOMOVE] = ""no_slab_automove"",
[NO_MAXCONNS_FAST] = ""no_maxconns_fast"",
[INLINE_ASCII_RESP] = ""inline_ascii_resp"",
[NO_LRU_CRAWLER] = ""no_lru_crawler"",
[NO_LRU_MAINTAINER] = ""no_lru_maintainer"",
[NO_DROP_PRIVILEGES] = ""no_drop_privileges"",
#ifdef MEMCACHED_DEBUG
[RELAXED_PRIVILEGES] = ""relaxed_privileges"",
#endif
#ifdef EXTSTORE
[EXT_PAGE_SIZE] = ""ext_page_size"",
[EXT_PAGE_COUNT] = ""ext_page_count"",
[EXT_WBUF_SIZE] = ""ext_wbuf_size"",
[EXT_THREADS] = ""ext_threads"",
[EXT_IO_DEPTH] = ""ext_io_depth"",
[EXT_PATH] = ""ext_path"",
[EXT_ITEM_SIZE] = ""ext_item_size"",
[EXT_ITEM_AGE] = ""ext_item_age"",
[EXT_LOW_TTL] = ""ext_low_ttl"",
[EXT_RECACHE_RATE] = ""ext_recache_rate"",
[EXT_COMPACT_UNDER] = ""ext_compact_under"",
[EXT_DROP_UNDER] = ""ext_drop_under"",
[EXT_MAX_FRAG] = ""ext_max_frag"",
[EXT_DROP_UNREAD] = ""ext_drop_unread"",
[SLAB_AUTOMOVE_FREERATIO] = ""slab_automove_freeratio"",
#endif
NULL
};

if (!sanitycheck()) {
return EX_OSERR;
}


signal(SIGINT, sig_handler);
signal(SIGTERM, sig_handler);


settings_init();
#ifdef EXTSTORE
settings.ext_item_size = 512;
settings.ext_item_age = UINT_MAX;
settings.ext_low_ttl = 0;
settings.ext_recache_rate = 2000;
settings.ext_max_frag = 0.8;
settings.ext_drop_unread = false;
settings.ext_wbuf_size = 1024 * 1024 * 4;
settings.ext_compact_under = 0;
settings.ext_drop_under = 0;
settings.slab_automove_freeratio = 0.01;
ext_cf.page_size = 1024 * 1024 * 64;
ext_cf.page_count = 64;
ext_cf.wbuf_size = settings.ext_wbuf_size;
ext_cf.io_threadcount = 1;
ext_cf.io_depth = 1;
ext_cf.page_buckets = 4;
ext_cf.wbuf_count = ext_cf.page_buckets;
#endif


init_lru_maintainer();


setbuf(stderr, NULL);

char *shortopts =
""a:""
""A""
""p:""
""s:""
""U:""
""m:""
""M""
""c:""
""k""
""hiV""
""r""
""v""
""d""
""l:""
""u:""
""P:""
""f:""
""n:""
""t:""
""D:""
""L""
""R:""
""C""
""b:""
""B:""
""I:""
""S""
""F""
""X""
""o:""
;


#ifdef HAVE_GETOPT_LONG
const struct option longopts[] = {
{""unix-mask"", required_argument, 0, 'a'},
{""enable-shutdown"", no_argument, 0, 'A'},
{""port"", required_argument, 0, 'p'},
{""unix-socket"", required_argument, 0, 's'},
{""udp-port"", required_argument, 0, 'U'},
{""memory-limit"", required_argument, 0, 'm'},
{""disable-evictions"", no_argument, 0, 'M'},
{""conn-limit"", required_argument, 0, 'c'},
{""lock-memory"", no_argument, 0, 'k'},
{""help"", no_argument, 0, 'h'},
{""license"", no_argument, 0, 'i'},
{""version"", no_argument, 0, 'V'},
{""enable-coredumps"", no_argument, 0, 'r'},
{""verbose"", optional_argument, 0, 'v'},
{""daemon"", no_argument, 0, 'd'},
{""listen"", required_argument, 0, 'l'},
{""user"", required_argument, 0, 'u'},
{""pidfile"", required_argument, 0, 'P'},
{""slab-growth-factor"", required_argument, 0, 'f'},
{""slab-min-size"", required_argument, 0, 'n'},
{""threads"", required_argument, 0, 't'},
{""enable-largepages"", no_argument, 0, 'L'},
{""max-reqs-per-event"", required_argument, 0, 'R'},
{""disable-cas"", no_argument, 0, 'C'},
{""listen-backlog"", required_argument, 0, 'b'},
{""protocol"", required_argument, 0, 'B'},
{""max-item-size"", required_argument, 0, 'I'},
{""enable-sasl"", no_argument, 0, 'S'},
{""disable-flush-all"", no_argument, 0, 'F'},
{""disable-dumping"", no_argument, 0, 'X'},
{""extended"", required_argument, 0, 'o'},
{0, 0, 0, 0}
};
int optindex;
while (-1 != (c = getopt_long(argc, argv, shortopts,
longopts, &optindex))) {
#else
while (-1 != (c = getopt(argc, argv, shortopts))) {
#endif
switch (c) {
case 'A':

settings.shutdown_command = true;
break;

case 'a':

settings.access= strtol(optarg,NULL,8);
break;

case 'U':
settings.udpport = atoi(optarg);
udp_specified = true;
break;
case 'p':
settings.port = atoi(optarg);
tcp_specified = true;
break;
case 's':
settings.socketpath = optarg;
break;
case 'm':
settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;
break;
case 'M':
settings.evict_to_free = 0;
break;
case 'c':
settings.maxconns = atoi(optarg);
if (settings.maxconns <= 0) {
fprintf(stderr, ""Maximum connections must be greater than 0\n"");
return 1;
}
break;
case 'h':
usage();
exit(EXIT_SUCCESS);
case 'i':
usage_license();
exit(EXIT_SUCCESS);
case 'V':
printf(PACKAGE "" "" VERSION ""\n"");
exit(EXIT_SUCCESS);
case 'k':
lock_memory = true;
break;
case 'v':
settings.verbose++;
break;
case 'l':
if (settings.inter != NULL) {
if (strstr(settings.inter, optarg) != NULL) {
break;
}
size_t len = strlen(settings.inter) + strlen(optarg) + 2;
char *p = malloc(len);
if (p == NULL) {
fprintf(stderr, ""Failed to allocate memory\n"");
return 1;
}
snprintf(p, len, ""%s,%s"", settings.inter, optarg);
free(settings.inter);
settings.inter = p;
} else {
settings.inter= strdup(optarg);
}
break;
case 'd':
do_daemonize = true;
break;
case 'r':
maxcore = 1;
break;
case 'R':
settings.reqs_per_event = atoi(optarg);
if (settings.reqs_per_event == 0) {
fprintf(stderr, ""Number of requests per event must be greater than 0\n"");
return 1;
}
break;
case 'u':
username = optarg;
break;
case 'P':
pid_file = optarg;
break;
case 'f':
settings.factor = atof(optarg);
if (settings.factor <= 1.0) {
fprintf(stderr, ""Factor must be greater than 1\n"");
return 1;
}
break;
case 'n':
settings.chunk_size = atoi(optarg);
if (settings.chunk_size == 0) {
fprintf(stderr, ""Chunk size must be greater than 0\n"");
return 1;
}
break;
case 't':
settings.num_threads = atoi(optarg);
if (settings.num_threads <= 0) {
fprintf(stderr, ""Number of threads must be greater than 0\n"");
return 1;
}




if (settings.num_threads > 64) {
fprintf(stderr, ""WARNING: Setting a high number of worker""
""threads is not recommended.\n""
"" Set this value to the number of cores in""
"" your machine or less.\n"");
}
break;
case 'D':
if (! optarg || ! optarg[0]) {
fprintf(stderr, ""No delimiter specified\n"");
return 1;
}
settings.prefix_delimiter = optarg[0];
settings.detail_enabled = 1;
break;
case 'L' :
if (enable_large_pages() == 0) {
preallocate = true;
} else {
fprintf(stderr, ""Cannot enable large pages on this system\n""
""(There is no Linux support as of this version)\n"");
return 1;
}
break;
case 'C' :
settings.use_cas = false;
break;
case 'b' :
settings.backlog = atoi(optarg);
break;
case 'B':
protocol_specified = true;
if (strcmp(optarg, ""auto"") == 0) {
settings.binding_protocol = negotiating_prot;
} else if (strcmp(optarg, ""binary"") == 0) {
settings.binding_protocol = binary_prot;
} else if (strcmp(optarg, ""ascii"") == 0) {
settings.binding_protocol = ascii_prot;
} else {
fprintf(stderr, ""Invalid value for binding protocol: %s\n""
"" -- should be one of auto, binary, or ascii\n"", optarg);
exit(EX_USAGE);
}
break;
case 'I':
buf = strdup(optarg);
unit = buf[strlen(buf)-1];
if (unit == 'k' || unit == 'm' ||
unit == 'K' || unit == 'M') {
buf[strlen(buf)-1] = '\0';
size_max = atoi(buf);
if (unit == 'k' || unit == 'K')
size_max *= 1024;
if (unit == 'm' || unit == 'M')
size_max *= 1024 * 1024;
settings.item_size_max = size_max;
} else {
settings.item_size_max = atoi(buf);
}
free(buf);
break;
case 'S':
#ifndef ENABLE_SASL
fprintf(stderr, ""This server is not built with SASL support.\n"");
exit(EX_USAGE);
#endif
settings.sasl = true;
break;
case 'F' :
settings.flush_enabled = false;
break;
case 'X' :
settings.dump_enabled = false;
break;
case 'o':
subopts_orig = subopts = strdup(optarg);

while (*subopts != '\0') {

switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
case MAXCONNS_FAST:
settings.maxconns_fast = true;
break;
case HASHPOWER_INIT:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing numeric argument for hashpower\n"");
return 1;
}
settings.hashpower_init = atoi(subopts_value);
if (settings.hashpower_init < 12) {
fprintf(stderr, ""Initial hashtable multiplier of %d is too low\n"",
settings.hashpower_init);
return 1;
} else if (settings.hashpower_init > 32) {
fprintf(stderr, ""Initial hashtable multiplier of %d is too high\n""
""Choose a value based on \""STAT hash_power_level\"" from a running instance\n"",
settings.hashpower_init);
return 1;
}
break;
case NO_HASHEXPAND:
start_assoc_maint = false;
break;
case SLAB_REASSIGN:
settings.slab_reassign = true;
break;
case SLAB_AUTOMOVE:
if (subopts_value == NULL) {
settings.slab_automove = 1;
break;
}
settings.slab_automove = atoi(subopts_value);
if (settings.slab_automove < 0 || settings.slab_automove > 2) {
fprintf(stderr, ""slab_automove must be between 0 and 2\n"");
return 1;
}
break;
case SLAB_AUTOMOVE_RATIO:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing slab_automove_ratio argument\n"");
return 1;
}
settings.slab_automove_ratio = atof(subopts_value);
if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {
fprintf(stderr, ""slab_automove_ratio must be > 0 and < 1\n"");
return 1;
}
break;
case SLAB_AUTOMOVE_WINDOW:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing slab_automove_window argument\n"");
return 1;
}
settings.slab_automove_window = atoi(subopts_value);
if (settings.slab_automove_window < 3) {
fprintf(stderr, ""slab_automove_window must be > 2\n"");
return 1;
}
break;
case TAIL_REPAIR_TIME:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing numeric argument for tail_repair_time\n"");
return 1;
}
settings.tail_repair_time = atoi(subopts_value);
if (settings.tail_repair_time < 10) {
fprintf(stderr, ""Cannot set tail_repair_time to less than 10 seconds\n"");
return 1;
}
break;
case HASH_ALGORITHM:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing hash_algorithm argument\n"");
return 1;
};
if (strcmp(subopts_value, ""jenkins"") == 0) {
hash_type = JENKINS_HASH;
} else if (strcmp(subopts_value, ""murmur3"") == 0) {
hash_type = MURMUR3_HASH;
} else {
fprintf(stderr, ""Unknown hash_algorithm option (jenkins, murmur3)\n"");
return 1;
}
break;
case LRU_CRAWLER:
start_lru_crawler = true;
break;
case LRU_CRAWLER_SLEEP:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing lru_crawler_sleep value\n"");
return 1;
}
settings.lru_crawler_sleep = atoi(subopts_value);
if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {
fprintf(stderr, ""LRU crawler sleep must be between 0 and 1 second\n"");
return 1;
}
break;
case LRU_CRAWLER_TOCRAWL:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing lru_crawler_tocrawl value\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &tocrawl)) {
fprintf(stderr, ""lru_crawler_tocrawl takes a numeric 32bit value\n"");
return 1;
}
settings.lru_crawler_tocrawl = tocrawl;
break;
case LRU_MAINTAINER:
start_lru_maintainer = true;
settings.lru_segmented = true;
break;
case HOT_LRU_PCT:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing hot_lru_pct argument\n"");
return 1;
}
settings.hot_lru_pct = atoi(subopts_value);
if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {
fprintf(stderr, ""hot_lru_pct must be > 1 and < 80\n"");
return 1;
}
break;
case WARM_LRU_PCT:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing warm_lru_pct argument\n"");
return 1;
}
settings.warm_lru_pct = atoi(subopts_value);
if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {
fprintf(stderr, ""warm_lru_pct must be > 1 and < 80\n"");
return 1;
}
break;
case HOT_MAX_FACTOR:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing hot_max_factor argument\n"");
return 1;
}
settings.hot_max_factor = atof(subopts_value);
if (settings.hot_max_factor <= 0) {
fprintf(stderr, ""hot_max_factor must be > 0\n"");
return 1;
}
break;
case WARM_MAX_FACTOR:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing warm_max_factor argument\n"");
return 1;
}
settings.warm_max_factor = atof(subopts_value);
if (settings.warm_max_factor <= 0) {
fprintf(stderr, ""warm_max_factor must be > 0\n"");
return 1;
}
break;
case TEMPORARY_TTL:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing temporary_ttl argument\n"");
return 1;
}
settings.temp_lru = true;
settings.temporary_ttl = atoi(subopts_value);
break;
case IDLE_TIMEOUT:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing numeric argument for idle_timeout\n"");
return 1;
}
settings.idle_timeout = atoi(subopts_value);
break;
case WATCHER_LOGBUF_SIZE:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing watcher_logbuf_size argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {
fprintf(stderr, ""could not parse argument to watcher_logbuf_size\n"");
return 1;
}
settings.logger_watcher_buf_size *= 1024;
break;
case WORKER_LOGBUF_SIZE:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing worker_logbuf_size argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {
fprintf(stderr, ""could not parse argument to worker_logbuf_size\n"");
return 1;
}
settings.logger_buf_size *= 1024;
case SLAB_SIZES:
slab_sizes_unparsed = subopts_value;
break;
case SLAB_CHUNK_MAX:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing slab_chunk_max argument\n"");
}
if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {
fprintf(stderr, ""could not parse argument to slab_chunk_max\n"");
}
slab_chunk_size_changed = true;
break;
case TRACK_SIZES:
item_stats_sizes_init();
break;
case NO_INLINE_ASCII_RESP:
settings.inline_ascii_response = false;
break;
case INLINE_ASCII_RESP:
settings.inline_ascii_response = true;
break;
case NO_CHUNKED_ITEMS:
settings.slab_chunk_size_max = settings.slab_page_size;
break;
case NO_SLAB_REASSIGN:
settings.slab_reassign = false;
break;
case NO_SLAB_AUTOMOVE:
settings.slab_automove = 0;
break;
case NO_MAXCONNS_FAST:
settings.maxconns_fast = false;
break;
case NO_LRU_CRAWLER:
settings.lru_crawler = false;
start_lru_crawler = false;
break;
case NO_LRU_MAINTAINER:
start_lru_maintainer = false;
settings.lru_segmented = false;
break;
#ifdef EXTSTORE
case EXT_PAGE_SIZE:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_page_size argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {
fprintf(stderr, ""could not parse argument to ext_page_size\n"");
return 1;
}
ext_cf.page_size *= 1024 * 1024;
break;
case EXT_PAGE_COUNT:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_page_count argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &ext_cf.page_count)) {
fprintf(stderr, ""could not parse argument to ext_page_count\n"");
return 1;
}
break;
case EXT_WBUF_SIZE:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_wbuf_size argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {
fprintf(stderr, ""could not parse argument to ext_wbuf_size\n"");
return 1;
}
ext_cf.wbuf_size *= 1024 * 1024;
settings.ext_wbuf_size = ext_cf.wbuf_size;
break;
case EXT_THREADS:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_threads argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {
fprintf(stderr, ""could not parse argument to ext_threads\n"");
return 1;
}
break;
case EXT_IO_DEPTH:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_io_depth argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {
fprintf(stderr, ""could not parse argument to ext_io_depth\n"");
return 1;
}
break;
case EXT_ITEM_SIZE:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_item_size argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {
fprintf(stderr, ""could not parse argument to ext_item_size\n"");
return 1;
}
break;
case EXT_ITEM_AGE:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_item_age argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {
fprintf(stderr, ""could not parse argument to ext_item_age\n"");
return 1;
}
break;
case EXT_LOW_TTL:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_low_ttl argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {
fprintf(stderr, ""could not parse argument to ext_low_ttl\n"");
return 1;
}
break;
case EXT_RECACHE_RATE:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_recache_rate argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {
fprintf(stderr, ""could not parse argument to ext_recache_rate\n"");
return 1;
}
break;
case EXT_COMPACT_UNDER:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_compact_under argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {
fprintf(stderr, ""could not parse argument to ext_compact_under\n"");
return 1;
}
break;
case EXT_DROP_UNDER:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_drop_under argument\n"");
return 1;
}
if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {
fprintf(stderr, ""could not parse argument to ext_drop_under\n"");
return 1;
}
break;
case EXT_MAX_FRAG:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing ext_max_frag argument\n"");
return 1;
}
if (!safe_strtod(subopts_value, &settings.ext_max_frag)) {
fprintf(stderr, ""could not parse argument to ext_max_frag\n"");
return 1;
}
break;
case SLAB_AUTOMOVE_FREERATIO:
if (subopts_value == NULL) {
fprintf(stderr, ""Missing slab_automove_freeratio argument\n"");
return 1;
}
if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {
fprintf(stderr, ""could not parse argument to slab_automove_freeratio\n"");
return 1;
}
break;
case EXT_DROP_UNREAD:
settings.ext_drop_unread = true;
break;
case EXT_PATH:
storage_file = strdup(subopts_value);
break;
#endif
case MODERN:

break;
case NO_MODERN:
if (!slab_chunk_size_changed) {
settings.slab_chunk_size_max = settings.slab_page_size;
}
settings.slab_reassign = false;
settings.slab_automove = 0;
settings.maxconns_fast = false;
settings.inline_ascii_response = true;
settings.lru_segmented = false;
hash_type = JENKINS_HASH;
start_lru_crawler = false;
start_lru_maintainer = false;
break;
case NO_DROP_PRIVILEGES:
settings.drop_privileges = false;
break;
#ifdef MEMCACHED_DEBUG
case RELAXED_PRIVILEGES:
settings.relaxed_privileges = true;
break;
#endif
default:
printf(""Illegal suboption \""%s\""\n"", subopts_value);
return 1;
}

}
free(subopts_orig);
break;
default:
fprintf(stderr, ""Illegal argument \""%c\""\n"", c);
return 1;
}
}

if (settings.item_size_max < 1024) {
fprintf(stderr, ""Item max size cannot be less than 1024 bytes.\n"");
exit(EX_USAGE);
}
if (settings.item_size_max > (settings.maxbytes / 2)) {
fprintf(stderr, ""Cannot set item size limit higher than 1/2 of memory max.\n"");
exit(EX_USAGE);
}
if (settings.item_size_max > (1024 * 1024 * 1024)) {
fprintf(stderr, ""Cannot set item size limit higher than a gigabyte.\n"");
exit(EX_USAGE);
}
if (settings.item_size_max > 1024 * 1024) {
if (!slab_chunk_size_changed) {

settings.slab_chunk_size_max = settings.slab_page_size / 2;
}
}

if (settings.slab_chunk_size_max > settings.item_size_max) {
fprintf(stderr, ""slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\n"",
settings.slab_chunk_size_max, settings.item_size_max);
exit(EX_USAGE);
}

if (settings.item_size_max % settings.slab_chunk_size_max != 0) {
fprintf(stderr, ""-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\n"",
settings.item_size_max, settings.slab_chunk_size_max);
exit(EX_USAGE);
}

if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {
fprintf(stderr, ""slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\n"",
settings.slab_chunk_size_max, settings.slab_page_size);
exit(EX_USAGE);
}
#ifdef EXTSTORE
if (storage_file) {
if (settings.item_size_max > ext_cf.wbuf_size) {
fprintf(stderr, ""-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\n"",
settings.item_size_max, ext_cf.wbuf_size);
exit(EX_USAGE);
}





if (settings.inline_ascii_response) {
fprintf(stderr, ""Cannot use inline_ascii_response with extstore enabled\n"");
exit(EX_USAGE);
}

if (settings.udpport) {
fprintf(stderr, ""Cannot use UDP with extstore enabled (-U 0 to disable)\n"");
exit(EX_USAGE);
}
}
#endif






if (slab_sizes_unparsed != NULL) {
if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {
use_slab_sizes = true;
} else {
exit(EX_USAGE);
}
}

if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {
fprintf(stderr, ""hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\n"");
exit(EX_USAGE);
}

if (settings.temp_lru && !start_lru_maintainer) {
fprintf(stderr, ""temporary_ttl requires lru_maintainer to be enabled\n"");
exit(EX_USAGE);
}

if (hash_init(hash_type) != 0) {
fprintf(stderr, ""Failed to initialize hash_algorithm!\n"");
exit(EX_USAGE);
}





if (settings.inter != NULL && strchr(settings.inter, ',')) {
settings.num_threads_per_udp = 1;
} else {
settings.num_threads_per_udp = settings.num_threads;
}

if (settings.sasl) {
if (!protocol_specified) {
settings.binding_protocol = binary_prot;
} else {
if (settings.binding_protocol != binary_prot) {
fprintf(stderr, ""ERROR: You cannot allow the ASCII protocol while using SASL.\n"");
exit(EX_USAGE);
}
}
}

if (tcp_specified && settings.port != 0 && !udp_specified) {
settings.udpport = settings.port;
} else if (udp_specified && settings.udpport != 0 && !tcp_specified) {
settings.port = settings.udpport;
}

if (maxcore != 0) {
struct rlimit rlim_new;




if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {

rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
(void)setrlimit(RLIMIT_CORE, &rlim_new);
}
}






if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
fprintf(stderr, ""failed to ensure corefile creation\n"");
exit(EX_OSERR);
}
}






if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
fprintf(stderr, ""failed to getrlimit number of files\n"");
exit(EX_OSERR);
} else {
rlim.rlim_cur = settings.maxconns;
rlim.rlim_max = settings.maxconns;
if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
fprintf(stderr, ""failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n"");
exit(EX_OSERR);
}
}


if (getuid() == 0 || geteuid() == 0) {
if (username == 0 || *username == '\0') {
fprintf(stderr, ""can't run as root without the -u switch\n"");
exit(EX_USAGE);
}
if ((pw = getpwnam(username)) == 0) {
fprintf(stderr, ""can't find the user %s to switch to\n"", username);
exit(EX_NOUSER);
}
if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
fprintf(stderr, ""failed to assume identity of user %s\n"", username);
exit(EX_OSERR);
}
}


if (settings.sasl) {
init_sasl();
}



if (do_daemonize) {
if (sigignore(SIGHUP) == -1) {
perror(""Failed to ignore SIGHUP"");
}
if (daemonize(maxcore, settings.verbose) == -1) {
fprintf(stderr, ""failed to daemon() in order to daemonize\n"");
exit(EXIT_FAILURE);
}
}


if (lock_memory) {
#ifdef HAVE_MLOCKALL
int res = mlockall(MCL_CURRENT | MCL_FUTURE);
if (res != 0) {
fprintf(stderr, ""warning: -k invalid, mlockall() failed: %s\n"",
strerror(errno));
}
#else
fprintf(stderr, ""warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n"");
#endif
}


#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101

struct event_config *ev_config;
ev_config = event_config_new();
event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
main_base = event_base_new_with_config(ev_config);
event_config_free(ev_config);
#else

main_base = event_init();
#endif


logger_init();
stats_init();
assoc_init(settings.hashpower_init);
conn_init();
slabs_init(settings.maxbytes, settings.factor, preallocate,
use_slab_sizes ? slab_sizes : NULL);
#ifdef EXTSTORE
if (storage_file) {
enum extstore_res eres;
if (settings.ext_compact_under == 0) {
settings.ext_compact_under = ext_cf.page_count / 4;

settings.ext_drop_under = ext_cf.page_count / 4;
}
crc32c_init();

for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {
settings.ext_free_memchunks[x] = 0;
}
storage = extstore_init(storage_file, &ext_cf, &eres);
if (storage == NULL) {
fprintf(stderr, ""Failed to initialize external storage: %s\n"",
extstore_err(eres));
if (eres == EXTSTORE_INIT_OPEN_FAIL) {
perror(""extstore open"");
}
exit(EXIT_FAILURE);
}
ext_storage = storage;

slabs_prefill_global();
}
#endif




if (sigignore(SIGPIPE) == -1) {
perror(""failed to ignore SIGPIPE; sigaction"");
exit(EX_OSERR);
}

#ifdef EXTSTORE
slabs_set_storage(storage);
memcached_thread_init(settings.num_threads, storage);
init_lru_crawler(storage);
#else
memcached_thread_init(settings.num_threads, NULL);
init_lru_crawler(NULL);
#endif

if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {
exit(EXIT_FAILURE);
}
if (start_lru_crawler && start_item_crawler_thread() != 0) {
fprintf(stderr, ""Failed to enable LRU crawler thread\n"");
exit(EXIT_FAILURE);
}
#ifdef EXTSTORE
if (storage && start_storage_compact_thread(storage) != 0) {
fprintf(stderr, ""Failed to start storage compaction thread\n"");
exit(EXIT_FAILURE);
}

if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {
#else
if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {
#endif
fprintf(stderr, ""Failed to enable LRU maintainer thread\n"");
return 1;
}

if (settings.slab_reassign &&
start_slab_maintenance_thread() == -1) {
exit(EXIT_FAILURE);
}

if (settings.idle_timeout && start_conn_timeout_thread() == -1) {
exit(EXIT_FAILURE);
}


clock_handler(0, 0, 0);


if (settings.socketpath != NULL) {
errno = 0;
if (server_socket_unix(settings.socketpath,settings.access)) {
vperror(""failed to listen on UNIX socket: %s"", settings.socketpath);
exit(EX_OSERR);
}
}


if (settings.socketpath == NULL) {
const char *portnumber_filename = getenv(""MEMCACHED_PORT_FILENAME"");
char *temp_portnumber_filename = NULL;
size_t len;
FILE *portnumber_file = NULL;

if (portnumber_filename != NULL) {
len = strlen(portnumber_filename)+4+1;
temp_portnumber_filename = malloc(len);
snprintf(temp_portnumber_filename,
len,
""%s.lck"", portnumber_filename);

portnumber_file = fopen(temp_portnumber_filename, ""a"");
if (portnumber_file == NULL) {
fprintf(stderr, ""Failed to open \""%s\"": %s\n"",
temp_portnumber_filename, strerror(errno));
}
}

errno = 0;
if (settings.port && server_sockets(settings.port, tcp_transport,
portnumber_file)) {
vperror(""failed to listen on TCP port %d"", settings.port);
exit(EX_OSERR);
}









errno = 0;
if (settings.udpport && server_sockets(settings.udpport, udp_transport,
portnumber_file)) {
vperror(""failed to listen on UDP port %d"", settings.udpport);
exit(EX_OSERR);
}

if (portnumber_file) {
fclose(portnumber_file);
rename(temp_portnumber_filename, portnumber_filename);
}
if (temp_portnumber_filename)
free(temp_portnumber_filename);
}




usleep(1000);
if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
fprintf(stderr, ""Maxconns setting is too low, use -c to increase.\n"");
exit(EXIT_FAILURE);
}

if (pid_file != NULL) {
save_pid(pid_file);
}


if (settings.drop_privileges) {
drop_privileges();
}


uriencode_init();


if (event_base_loop(main_base, 0) != 0) {
retval = EXIT_FAILURE;
}

stop_assoc_maintenance_thread();


if (do_daemonize)
remove_pidfile(pid_file);

if (settings.inter)
free(settings.inter);
if (l_socket)
free(l_socket);
if (u_socket)
free(u_socket);


event_base_free(main_base);

return retval;
}","[979, 980, 981]","Memcached version 1.5.5 contains an Insufficient Control of Network Message Volume (Network Amplification, CWE-406) vulnerability in the UDP support of the memcached server that can result in denial of service via network flood (traffic amplification of 1:50,000 has been reported by reliable sources). This attack appear to be exploitable via network connectivity to port 11211 UDP. This vulnerability appears to have been fixed in 1.5.6 due to the disabling of the UDP protocol by default."
201935," static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)
 {
 	int n;
 	uint_fast32_t v;
 	int c;
 	for (n = 4, v = 0;;) {
  		if ((c = jas_stream_getc(in)) == EOF) {
  			return -1;
  		}
		v |= (c << 24);
 		v |= (JAS_CAST(uint_fast32_t, c) << 24);
  		if (--n <= 0) {
  			break;
  		}
 		v >>= 8;
 	}
 	if (val) {
 		*val = v;
 	}
 	return 0;
 }","[11, 10]",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.
204754,"  void InputMethodBase::OnInputMethodChanged() const {
    TextInputClient* client = GetTextInputClient();
  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)
   if (!IsTextInputTypeNone())
      client->OnInputMethodChanged();
  }","[4, 3]",Use-after-free vulnerability in the Cascading Style Sheets (CSS) implementation in Google Chrome before 17.0.963.83 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the cross-fade function.
203144,"  static void __exit exit_ext2_fs(void)
  {
  	unregister_filesystem(&ext2_fs_type);
  	destroy_inodecache();
	exit_ext2_xattr();
  }",[5],"The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba."
198968," int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,
 			    struct mem_access *ma, int expected,
 			    unsigned long address)
 {
 	u_int rm;
 	int ret, index;
 
 	 
 	if (instruction_size(instruction) != 2)
 		return -EINVAL;
 
 	index = (instruction>>8)&15;	 
 	rm = regs->regs[index];
 
 	 
  	if (!expected) {
  		unaligned_fixups_notify(current, instruction, regs);
		perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,
 		perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,
  			      regs, address);
  	}
  
 	ret = -EFAULT;
 	switch (instruction&0xF000) {
 	case 0x0000:
 		if (instruction==0x000B) {
 			 
 			ret = handle_delayslot(regs, instruction, ma);
 			if (ret==0)
 				regs->pc = regs->pr;
 		}
 		else if ((instruction&0x00FF)==0x0023) {
 			 
 			ret = handle_delayslot(regs, instruction, ma);
 			if (ret==0)
 				regs->pc += rm + 4;
 		}
 		else if ((instruction&0x00FF)==0x0003) {
 			 
 			ret = handle_delayslot(regs, instruction, ma);
 			if (ret==0) {
 				regs->pr = regs->pc + 4;
 				regs->pc += rm + 4;
 			}
 		}
 		else {
 			 
 			goto simple;
 		}
 		break;
 
 	case 0x1000:  
 		goto simple;
 
 	case 0x2000:  
 		goto simple;
 
 	case 0x4000:
 		if ((instruction&0x00FF)==0x002B) {
 			 
 			ret = handle_delayslot(regs, instruction, ma);
 			if (ret==0)
 				regs->pc = rm;
 		}
 		else if ((instruction&0x00FF)==0x000B) {
 			 
 			ret = handle_delayslot(regs, instruction, ma);
 			if (ret==0) {
 				regs->pr = regs->pc + 4;
 				regs->pc = rm;
 			}
 		}
 		else {
 			 
 			goto simple;
 		}
 		break;
 
 	case 0x5000:  
 		goto simple;
 
 	case 0x6000:  
 		goto simple;
 
 	case 0x8000:  
 		switch (instruction&0x0F00) {
 		case 0x0100:  
 			goto simple;
 		case 0x0500:  
 			goto simple;
 		case 0x0B00:  
 			break;
 		case 0x0F00:  
 			ret = handle_delayslot(regs, instruction, ma);
 			if (ret==0) {
 #if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)
 				if ((regs->sr & 0x00000001) != 0)
 					regs->pc += 4;  
 				else
 #endif
 					regs->pc += SH_PC_8BIT_OFFSET(instruction);
 			}
 			break;
 		case 0x0900:  
 			break;
 		case 0x0D00:  
 			ret = handle_delayslot(regs, instruction, ma);
 			if (ret==0) {
 #if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)
 				if ((regs->sr & 0x00000001) == 0)
 					regs->pc += 4;  
 				else
 #endif
 					regs->pc += SH_PC_8BIT_OFFSET(instruction);
 			}
 			break;
 		}
 		break;
 
 	case 0xA000:  
 		ret = handle_delayslot(regs, instruction, ma);
 		if (ret==0)
 			regs->pc += SH_PC_12BIT_OFFSET(instruction);
 		break;
 
 	case 0xB000:  
 		ret = handle_delayslot(regs, instruction, ma);
 		if (ret==0) {
 			regs->pr = regs->pc + 4;
 			regs->pc += SH_PC_12BIT_OFFSET(instruction);
 		}
 		break;
 	}
 	return ret;
 
 	 
  simple:
 	ret = handle_unaligned_ins(instruction, regs, ma);
 	if (ret==0)
 		regs->pc += instruction_size(instruction);
 	return ret;
 }","[19, 18]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
202848," static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
 {
 	struct hidp_connadd_req ca;
 	struct hidp_conndel_req cd;
 	struct hidp_connlist_req cl;
 	struct hidp_conninfo ci;
 	struct socket *csock;
 	struct socket *isock;
 	int err;
 
 	BT_DBG(""cmd %x arg %p"", cmd, argp);
 
 	switch (cmd) {
 	case HIDPCONNADD:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 
 		if (copy_from_user(&ca, argp, sizeof(ca)))
 			return -EFAULT;
 
 		csock = sockfd_lookup(ca.ctrl_sock, &err);
 		if (!csock)
 			return err;
 
 		isock = sockfd_lookup(ca.intr_sock, &err);
 		if (!isock) {
  			sockfd_put(csock);
  			return err;
  		}
 		ca.name[sizeof(ca.name)-1] = 0;
  
  		err = hidp_connection_add(&ca, csock, isock);
  		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
 			err = -EFAULT;
 
 		sockfd_put(csock);
 		sockfd_put(isock);
 
 		return err;
 
 	case HIDPCONNDEL:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 
 		if (copy_from_user(&cd, argp, sizeof(cd)))
 			return -EFAULT;
 
 		return hidp_connection_del(&cd);
 
 	case HIDPGETCONNLIST:
 		if (copy_from_user(&cl, argp, sizeof(cl)))
 			return -EFAULT;
 
 		if (cl.cnum <= 0)
 			return -EINVAL;
 
 		err = hidp_get_connlist(&cl);
 		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
 			return -EFAULT;
 
 		return err;
 
 	case HIDPGETCONNINFO:
 		if (copy_from_user(&ci, argp, sizeof(ci)))
 			return -EFAULT;
 
 		err = hidp_get_conninfo(&ci);
 		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
 			return -EFAULT;
 
 		return err;
 	}
 
 	return -EINVAL;
 }",[30],"The do_hidp_sock_ioctl function in net/bluetooth/hidp/sock.c in the Linux kernel before 5.0.15 allows a local user to obtain potentially sensitive information from kernel stack memory via a HIDPCONNADD command, because a name field may not end with a '0' character."
201653," yyparse (void *yyscanner, YR_COMPILER* compiler)
 {
  
 int yychar;
 
 
  
  
 YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
 YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
      
     int yynerrs;
 
     int yystate;
      
     int yyerrstatus;
 
      
 
      
     yytype_int16 yyssa[YYINITDEPTH];
     yytype_int16 *yyss;
     yytype_int16 *yyssp;
 
      
     YYSTYPE yyvsa[YYINITDEPTH];
     YYSTYPE *yyvs;
     YYSTYPE *yyvsp;
 
     YYSIZE_T yystacksize;
 
   int yyn;
   int yyresult;
    
   int yytoken = 0;
    
   YYSTYPE yyval;
 
 #if YYERROR_VERBOSE
    
   char yymsgbuf[128];
   char *yymsg = yymsgbuf;
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
    
   int yylen = 0;
 
   yyssp = yyss = yyssa;
   yyvsp = yyvs = yyvsa;
   yystacksize = YYINITDEPTH;
 
   YYDPRINTF ((stderr, ""Starting parse\n""));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
   yychar = YYEMPTY;  
   goto yysetstate;
 
  
  yynewstate:
    
   yyssp++;
 
  yysetstate:
   *yyssp = yystate;
 
   if (yyss + yystacksize - 1 <= yyssp)
     {
        
       YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
       {
          
         YYSTYPE *yyvs1 = yyvs;
         yytype_int16 *yyss1 = yyss;
 
          
         yyoverflow (YY_(""memory exhausted""),
                     &yyss1, yysize * sizeof (*yyssp),
                     &yyvs1, yysize * sizeof (*yyvsp),
                     &yystacksize);
 
         yyss = yyss1;
         yyvs = yyvs1;
       }
 #else  
 # ifndef YYSTACK_RELOCATE
       goto yyexhaustedlab;
 # else
        
       if (YYMAXDEPTH <= yystacksize)
         goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
         yystacksize = YYMAXDEPTH;
 
       {
         yytype_int16 *yyss1 = yyss;
         union yyalloc *yyptr =
           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
         if (! yyptr)
           goto yyexhaustedlab;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
         if (yyss1 != yyssa)
           YYSTACK_FREE (yyss1);
       }
 # endif
 #endif  
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
       YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                   (unsigned long int) yystacksize));
 
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
 
   YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));
 
   if (yystate == YYFINAL)
     YYACCEPT;
 
   goto yybackup;
 
  
 yybackup:
 
    
 
    
   yyn = yypact[yystate];
   if (yypact_value_is_default (yyn))
     goto yydefault;
 
    
 
    
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, ""Reading a token: ""));
       yychar = yylex (&yylval, yyscanner, compiler);
     }
 
   if (yychar <= YYEOF)
     {
       yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, ""Now at end of input.\n""));
     }
   else
     {
       yytoken = YYTRANSLATE (yychar);
       YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
     }
 
    
   yyn += yytoken;
   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
       if (yytable_value_is_error (yyn))
         goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
 
    
   if (yyerrstatus)
     yyerrstatus--;
 
    
   YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);
 
    
   yychar = YYEMPTY;
 
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 
   goto yynewstate;
 
 
  
 yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
   goto yyreduce;
 
 
  
 yyreduce:
    
   yylen = yyr2[yyn];
 
    
   yyval = yyvsp[1-yylen];
 
 
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
         case 8:
 #line 230 ""grammar.y""  
     {
         int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
 
         yr_free((yyvsp[0].sized_string));
 
         ERROR_IF(result != ERROR_SUCCESS);
       }
 #line 1661 ""grammar.c""  
     break;
 
   case 9:
 #line 242 ""grammar.y""  
     {
         YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
             yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));
 
         ERROR_IF(rule == NULL);
 
         (yyval.rule) = rule;
       }
 #line 1674 ""grammar.c""  
     break;
 
   case 10:
 #line 251 ""grammar.y""  
     {
         YR_RULE* rule = (yyvsp[-4].rule);  
 
         rule->tags = (yyvsp[-3].c_string);
         rule->metas = (yyvsp[-1].meta);
         rule->strings = (yyvsp[0].string);
       }
 #line 1686 ""grammar.c""  
     break;
 
   case 11:
 #line 259 ""grammar.y""  
     {
         YR_RULE* rule = (yyvsp[-7].rule);  
 
         compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
             yyscanner, rule);
 
         yr_free((yyvsp[-8].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 1701 ""grammar.c""  
     break;
 
   case 12:
 #line 274 ""grammar.y""  
     {
         (yyval.meta) = NULL;
       }
 #line 1709 ""grammar.c""  
     break;
 
   case 13:
 #line 278 ""grammar.y""  
     {
 
         YR_META null_meta;
 
         memset(&null_meta, 0xFF, sizeof(YR_META));
         null_meta.type = META_TYPE_NULL;
 
         compiler->last_result = yr_arena_write_data(
             compiler->metas_arena,
             &null_meta,
             sizeof(YR_META),
             NULL);
 
         (yyval.meta) = (yyvsp[0].meta);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 1736 ""grammar.c""  
     break;
 
   case 14:
 #line 305 ""grammar.y""  
     {
         (yyval.string) = NULL;
       }
 #line 1744 ""grammar.c""  
     break;
 
   case 15:
 #line 309 ""grammar.y""  
     {
 
         YR_STRING null_string;
 
         memset(&null_string, 0xFF, sizeof(YR_STRING));
         null_string.g_flags = STRING_GFLAGS_NULL;
 
         compiler->last_result = yr_arena_write_data(
             compiler->strings_arena,
             &null_string,
             sizeof(YR_STRING),
             NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.string) = (yyvsp[0].string);
       }
 #line 1771 ""grammar.c""  
     break;
 
   case 17:
 #line 340 ""grammar.y""  
     { (yyval.integer) = 0;  }
 #line 1777 ""grammar.c""  
     break;
 
   case 18:
 #line 341 ""grammar.y""  
     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
 #line 1783 ""grammar.c""  
     break;
 
   case 19:
 #line 346 ""grammar.y""  
     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
 #line 1789 ""grammar.c""  
     break;
 
   case 20:
 #line 347 ""grammar.y""  
     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
 #line 1795 ""grammar.c""  
     break;
 
   case 21:
 #line 353 ""grammar.y""  
     {
         (yyval.c_string) = NULL;
       }
 #line 1803 ""grammar.c""  
     break;
 
   case 22:
 #line 357 ""grammar.y""  
     {
 
         compiler->last_result = yr_arena_write_string(
             yyget_extra(yyscanner)->sz_arena, """", NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.c_string) = (yyvsp[0].c_string);
       }
 #line 1821 ""grammar.c""  
     break;
 
   case 23:
 #line 375 ""grammar.y""  
     {
         char* identifier;
 
         compiler->last_result = yr_arena_write_string(
             yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.c_string) = identifier;
       }
 #line 1838 ""grammar.c""  
     break;
 
   case 24:
 #line 388 ""grammar.y""  
     {
         char* tag_name = (yyvsp[-1].c_string);
         size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
 
         while (tag_length > 0)
         {
           if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
           {
             yr_compiler_set_error_extra_info(compiler, tag_name);
             compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
             break;
           }
 
           tag_name = (char*) yr_arena_next_address(
               yyget_extra(yyscanner)->sz_arena,
               tag_name,
               tag_length + 1);
 
           tag_length = tag_name != NULL ? strlen(tag_name) : 0;
         }
 
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_arena_write_string(
               yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.c_string) = (yyvsp[-1].c_string);
       }
 #line 1874 ""grammar.c""  
     break;
 
   case 25:
 #line 424 ""grammar.y""  
     {  (yyval.meta) = (yyvsp[0].meta); }
 #line 1880 ""grammar.c""  
     break;
 
   case 26:
 #line 425 ""grammar.y""  
     {  (yyval.meta) = (yyvsp[-1].meta); }
 #line 1886 ""grammar.c""  
     break;
 
   case 27:
 #line 431 ""grammar.y""  
     {
         SIZED_STRING* sized_string = (yyvsp[0].sized_string);
 
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_STRING,
             (yyvsp[-2].c_string),
             sized_string->c_string,
             0);
 
         yr_free((yyvsp[-2].c_string));
         yr_free((yyvsp[0].sized_string));
 
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1906 ""grammar.c""  
     break;
 
   case 28:
 #line 447 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_INTEGER,
             (yyvsp[-2].c_string),
             NULL,
             (yyvsp[0].integer));
 
         yr_free((yyvsp[-2].c_string));
 
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1923 ""grammar.c""  
     break;
 
   case 29:
 #line 460 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_INTEGER,
             (yyvsp[-3].c_string),
             NULL,
             -(yyvsp[0].integer));
 
         yr_free((yyvsp[-3].c_string));
 
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1940 ""grammar.c""  
     break;
 
   case 30:
 #line 473 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_BOOLEAN,
             (yyvsp[-2].c_string),
             NULL,
             TRUE);
 
         yr_free((yyvsp[-2].c_string));
 
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1957 ""grammar.c""  
     break;
 
   case 31:
 #line 486 ""grammar.y""  
     {
         (yyval.meta) = yr_parser_reduce_meta_declaration(
             yyscanner,
             META_TYPE_BOOLEAN,
             (yyvsp[-2].c_string),
             NULL,
             FALSE);
 
         yr_free((yyvsp[-2].c_string));
 
         ERROR_IF((yyval.meta) == NULL);
       }
 #line 1974 ""grammar.c""  
     break;
 
   case 32:
 #line 502 ""grammar.y""  
     { (yyval.string) = (yyvsp[0].string); }
 #line 1980 ""grammar.c""  
     break;
 
   case 33:
 #line 503 ""grammar.y""  
     { (yyval.string) = (yyvsp[-1].string); }
 #line 1986 ""grammar.c""  
     break;
 
   case 34:
 #line 509 ""grammar.y""  
     {
         compiler->error_line = yyget_lineno(yyscanner);
       }
 #line 1994 ""grammar.c""  
     break;
 
   case 35:
 #line 513 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));
 
         yr_free((yyvsp[-4].c_string));
         yr_free((yyvsp[-1].sized_string));
 
         ERROR_IF((yyval.string) == NULL);
         compiler->error_line = 0;
       }
 #line 2009 ""grammar.c""  
     break;
 
   case 36:
 #line 524 ""grammar.y""  
     {
         compiler->error_line = yyget_lineno(yyscanner);
       }
 #line 2017 ""grammar.c""  
     break;
 
   case 37:
 #line 528 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));
 
         yr_free((yyvsp[-4].c_string));
         yr_free((yyvsp[-1].sized_string));
 
         ERROR_IF((yyval.string) == NULL);
 
         compiler->error_line = 0;
       }
 #line 2033 ""grammar.c""  
     break;
 
   case 38:
 #line 540 ""grammar.y""  
     {
         (yyval.string) = yr_parser_reduce_string_declaration(
             yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));
 
         yr_free((yyvsp[-2].c_string));
         yr_free((yyvsp[0].sized_string));
 
         ERROR_IF((yyval.string) == NULL);
       }
 #line 2047 ""grammar.c""  
     break;
 
   case 39:
 #line 553 ""grammar.y""  
     { (yyval.integer) = 0; }
 #line 2053 ""grammar.c""  
     break;
 
   case 40:
 #line 554 ""grammar.y""  
     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
 #line 2059 ""grammar.c""  
     break;
 
   case 41:
 #line 559 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_WIDE; }
 #line 2065 ""grammar.c""  
     break;
 
   case 42:
 #line 560 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_ASCII; }
 #line 2071 ""grammar.c""  
     break;
 
   case 43:
 #line 561 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
 #line 2077 ""grammar.c""  
     break;
 
   case 44:
 #line 562 ""grammar.y""  
     { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
 #line 2083 ""grammar.c""  
     break;
 
   case 45:
 #line 568 ""grammar.y""  
     {
         int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
 
         if (var_index >= 0)
         {
           compiler->last_result = yr_parser_emit_with_arg(
               yyscanner,
               OP_PUSH_M,
               LOOP_LOCAL_VARS * var_index,
               NULL,
               NULL);
 
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = UNDEFINED;
           (yyval.expression).identifier = compiler->loop_identifier[var_index];
         }
         else
         {
 
           YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
               compiler->objects_table, (yyvsp[0].c_string), NULL);
 
           if (object == NULL)
           {
             char* ns = compiler->current_namespace->name;
 
             object = (YR_OBJECT*) yr_hash_table_lookup(
                 compiler->objects_table, (yyvsp[0].c_string), ns);
           }
 
           if (object != NULL)
           {
             char* id;
 
             compiler->last_result = yr_arena_write_string(
                 compiler->sz_arena, (yyvsp[0].c_string), &id);
 
             if (compiler->last_result == ERROR_SUCCESS)
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_OBJ_LOAD,
                   id,
                   NULL,
                   NULL);
 
             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
             (yyval.expression).value.object = object;
             (yyval.expression).identifier = object->identifier;
           }
           else
           {
             YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                 compiler->rules_table,
                 (yyvsp[0].c_string),
                 compiler->current_namespace->name);
 
             if (rule != NULL)
             {
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_PUSH_RULE,
                   rule,
                   NULL,
                   NULL);
 
               (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
               (yyval.expression).value.integer = UNDEFINED;
               (yyval.expression).identifier = rule->identifier;
             }
             else
             {
               yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
               compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
             }
           }
         }
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2172 ""grammar.c""  
     break;
 
   case 46:
 #line 653 ""grammar.y""  
     {
         YR_OBJECT* field = NULL;
 
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
         {
           field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
 
           if (field != NULL)
           {
             char* ident;
 
             compiler->last_result = yr_arena_write_string(
               compiler->sz_arena, (yyvsp[0].c_string), &ident);
 
             if (compiler->last_result == ERROR_SUCCESS)
               compiler->last_result = yr_parser_emit_with_arg_reloc(
                   yyscanner,
                   OP_OBJ_FIELD,
                   ident,
                   NULL,
                   NULL);
 
             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
             (yyval.expression).value.object = field;
             (yyval.expression).identifier = field->identifier;
           }
           else
           {
             yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
             compiler->last_result = ERROR_INVALID_FIELD_NAME;
           }
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-2].expression).identifier);
 
           compiler->last_result = ERROR_NOT_A_STRUCTURE;
         }
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2222 ""grammar.c""  
     break;
 
   case 47:
 #line 699 ""grammar.y""  
     {
         YR_OBJECT_ARRAY* array;
         YR_OBJECT_DICTIONARY* dict;
 
         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
         {
           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
           {
             yr_compiler_set_error_extra_info(
                 compiler, ""array indexes must be of integer type"");
             compiler->last_result = ERROR_WRONG_TYPE;
           }
 
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_INDEX_ARRAY, NULL);
 
           array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;
 
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = array->prototype_item;
           (yyval.expression).identifier = array->identifier;
         }
         else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                  (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
         {
           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
           {
             yr_compiler_set_error_extra_info(
                 compiler, ""dictionary keys must be of string type"");
             compiler->last_result = ERROR_WRONG_TYPE;
           }
 
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_LOOKUP_DICT, NULL);
 
           dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;
 
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = dict->prototype_item;
           (yyval.expression).identifier = dict->identifier;
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-3].expression).identifier);
 
           compiler->last_result = ERROR_NOT_INDEXABLE;
         }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2283 ""grammar.c""  
     break;
 
   case 48:
 #line 757 ""grammar.y""  
     {
         YR_OBJECT_FUNCTION* function;
         char* args_fmt;
 
         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
         {
           compiler->last_result = yr_parser_check_types(
               compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));
 
           if (compiler->last_result == ERROR_SUCCESS)
             compiler->last_result = yr_arena_write_string(
               compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
 
           if (compiler->last_result == ERROR_SUCCESS)
             compiler->last_result = yr_parser_emit_with_arg_reloc(
                 yyscanner,
                 OP_CALL,
                 args_fmt,
                 NULL,
                 NULL);
 
           function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;
 
           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
           (yyval.expression).value.object = function->return_obj;
           (yyval.expression).identifier = function->identifier;
         }
         else
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-3].expression).identifier);
 
           compiler->last_result = ERROR_NOT_A_FUNCTION;
         }
 
         yr_free((yyvsp[-1].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
 #line 2328 ""grammar.c""  
     break;
 
   case 49:
 #line 801 ""grammar.y""  
     { (yyval.c_string) = yr_strdup(""""); }
 #line 2334 ""grammar.c""  
     break;
 
   case 50:
 #line 802 ""grammar.y""  
     { (yyval.c_string) = (yyvsp[0].c_string); }
 #line 2340 ""grammar.c""  
     break;
 
   case 51:
 #line 807 ""grammar.y""  
     {
         (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);
 
         switch((yyvsp[0].expression).type)
         {
           case EXPRESSION_TYPE_INTEGER:
             strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_FLOAT:
             strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_BOOLEAN:
             strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_STRING:
             strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
             break;
           case EXPRESSION_TYPE_REGEXP:
             strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
             break;
         }
 
         ERROR_IF((yyval.c_string) == NULL);
       }
 #line 2369 ""grammar.c""  
     break;
 
   case 52:
 #line 832 ""grammar.y""  
     {
         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
         {
           compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
         }
         else
         {
           switch((yyvsp[0].expression).type)
           {
             case EXPRESSION_TYPE_INTEGER:
               strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_FLOAT:
               strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_BOOLEAN:
               strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_STRING:
               strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
               break;
             case EXPRESSION_TYPE_REGEXP:
               strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
               break;
           }
         }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.c_string) = (yyvsp[-2].c_string);
       }
 #line 2405 ""grammar.c""  
     break;
 
   case 53:
 #line 868 ""grammar.y""  
     {
         SIZED_STRING* sized_string = (yyvsp[0].sized_string);
         RE* re;
         RE_ERROR error;
 
         int re_flags = 0;
 
         if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
           re_flags |= RE_FLAGS_NO_CASE;
 
         if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
           re_flags |= RE_FLAGS_DOT_ALL;
 
         compiler->last_result = yr_re_compile(
             sized_string->c_string,
             re_flags,
             compiler->re_code_arena,
             &re,
             &error);
 
         yr_free((yyvsp[0].sized_string));
 
         if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
           yr_compiler_set_error_extra_info(compiler, error.message);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_PUSH,
               re->root_node->forward_code,
               NULL,
               NULL);
 
         yr_re_destroy(re);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
       }
 #line 2451 ""grammar.c""  
     break;
 
   case 54:
 #line 914 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
         {
           if ((yyvsp[0].expression).value.sized_string != NULL)
           {
             yywarning(yyscanner,
               ""Using literal string \""%s\"" in a boolean operation."",
               (yyvsp[0].expression).value.sized_string->c_string);
           }
 
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_STR_TO_BOOL, NULL);
 
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2474 ""grammar.c""  
     break;
 
   case 55:
 #line 936 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2487 ""grammar.c""  
     break;
 
   case 56:
 #line 945 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 0, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2500 ""grammar.c""  
     break;
 
   case 57:
 #line 954 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");
 
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit(
               yyscanner,
               OP_MATCHES,
               NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2519 ""grammar.c""  
     break;
 
   case 58:
 #line 969 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");
 
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_CONTAINS, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2535 ""grammar.c""  
     break;
 
   case 59:
 #line 981 ""grammar.y""  
     {
         int result = yr_parser_reduce_string_identifier(
             yyscanner,
             (yyvsp[0].c_string),
             OP_FOUND,
             UNDEFINED);
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2553 ""grammar.c""  
     break;
 
   case 60:
 #line 995 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");
 
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
 
         yr_free((yyvsp[-2].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2570 ""grammar.c""  
     break;
 
   case 61:
 #line 1008 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
 
         yr_free((yyvsp[-2].c_string));
 
         ERROR_IF(compiler->last_result!= ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
 #line 2585 ""grammar.c""  
     break;
  
    case 62:
  #line 1019 ""grammar.y""  
     {
         compiler->loop_depth--;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
       }
 #line 2594 ""grammar.c""  
     break;
 
   case 63:
 #line 1024 ""grammar.y""  
      {
          int var_index;
  
         if (compiler->loop_depth == MAX_LOOP_NESTING)
           compiler->last_result = \
               ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         var_index = yr_parser_lookup_loop_variable(
             yyscanner, (yyvsp[-1].c_string));
 
         if (var_index >= 0)
         {
           yr_compiler_set_error_extra_info(
               compiler, (yyvsp[-1].c_string));
 
           compiler->last_result = \
               ERROR_DUPLICATED_LOOP_IDENTIFIER;
         }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 2619 ""grammar.c""  
 #line 2628 ""grammar.c""  
      break;
  
  case 63:
#line 1049 ""grammar.y""  
   case 64:
 #line 1054 ""grammar.y""  
      {
          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
          uint8_t* addr;
 
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
 
         if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset, &addr, NULL);
         }
         else  
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
 
           yr_parser_emit_with_arg(
               yyscanner, OP_POP_M, mem_offset, NULL, NULL);
         }
 
         compiler->loop_address[compiler->loop_depth] = addr;
          compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
          compiler->loop_depth++;
        }
#line 2658 ""grammar.c""  
 #line 2667 ""grammar.c""  
      break;
  
  case 64:
#line 1084 ""grammar.y""  
   case 65:
 #line 1089 ""grammar.y""  
      {
          int mem_offset;
  
         compiler->loop_depth--;
         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
 
 
         yr_parser_emit_with_arg(
             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
 
         if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
         {
           yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_JNUNDEF,
               compiler->loop_address[compiler->loop_depth],
               NULL,
               NULL);
         }
         else  
         {
           yr_parser_emit_with_arg(
               yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
 
           yr_parser_emit_with_arg(
               yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
 
           yr_parser_emit_with_arg(
               yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
 
           yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_JLE,
               compiler->loop_address[compiler->loop_depth],
               NULL,
               NULL);
 
           yr_parser_emit(yyscanner, OP_POP, NULL);
           yr_parser_emit(yyscanner, OP_POP, NULL);
         }
 
         yr_parser_emit(yyscanner, OP_POP, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
 
         yr_parser_emit(yyscanner, OP_INT_LE, NULL);
 
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         yr_free((yyvsp[-8].c_string));
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2741 ""grammar.c""  
 #line 2750 ""grammar.c""  
      break;
  
  case 65:
#line 1163 ""grammar.y""  
   case 66:
 #line 1168 ""grammar.y""  
      {
          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
          uint8_t* addr;
 
         if (compiler->loop_depth == MAX_LOOP_NESTING)
           compiler->last_result = \
             ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
 
         if (compiler->loop_for_of_mem_offset != -1)
           compiler->last_result = \
             ERROR_NESTED_FOR_OF_LOOP;
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_POP_M, mem_offset, &addr, NULL);
 
         compiler->loop_for_of_mem_offset = mem_offset;
         compiler->loop_address[compiler->loop_depth] = addr;
          compiler->loop_identifier[compiler->loop_depth] = NULL;
          compiler->loop_depth++;
        }
#line 2775 ""grammar.c""  
 #line 2784 ""grammar.c""  
      break;
  
  case 66:
#line 1193 ""grammar.y""  
   case 67:
 #line 1198 ""grammar.y""  
      {
          int mem_offset;
  
         compiler->loop_depth--;
         compiler->loop_for_of_mem_offset = -1;
 
         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
 
 
         yr_parser_emit_with_arg(
             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
 
         yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JNUNDEF,
             compiler->loop_address[compiler->loop_depth],
             NULL,
             NULL);
 
         yr_parser_emit(yyscanner, OP_POP, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
 
         yr_parser_emit_with_arg(
             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
 
         yr_parser_emit(yyscanner, OP_INT_LE, NULL);
 
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
  
        }
#line 2828 ""grammar.c""  
 #line 2837 ""grammar.c""  
      break;
  
  case 67:
#line 1242 ""grammar.y""  
   case 68:
 #line 1247 ""grammar.y""  
      {
          yr_parser_emit(yyscanner, OP_OF, NULL);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2838 ""grammar.c""  
 #line 2847 ""grammar.c""  
      break;
  
  case 68:
#line 1248 ""grammar.y""  
   case 69:
 #line 1253 ""grammar.y""  
      {
          yr_parser_emit(yyscanner, OP_NOT, NULL);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2848 ""grammar.c""  
 #line 2857 ""grammar.c""  
      break;
  
  case 69:
#line 1254 ""grammar.y""  
   case 70:
 #line 1259 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          void* jmp_destination_addr;
 
         compiler->last_result = yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JFALSE,
             0,           
             NULL,
             &jmp_destination_addr);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
 
         if (fixup == NULL)
           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         fixup->address = jmp_destination_addr;
          fixup->next = compiler->fixup_stack_head;
          compiler->fixup_stack_head = fixup;
        }
#line 2878 ""grammar.c""  
 #line 2887 ""grammar.c""  
      break;
  
  case 70:
#line 1280 ""grammar.y""  
   case 71:
 #line 1285 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          uint8_t* and_addr;
 
 
         compiler->last_result = yr_arena_reserve_memory(
             compiler->code_arena, 2);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
 
         fixup = compiler->fixup_stack_head;
 
 
         *(void**)(fixup->address) = (void*)(and_addr + 1);
 
         compiler->fixup_stack_head = fixup->next;
         yr_free(fixup);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2918 ""grammar.c""  
 #line 2927 ""grammar.c""  
      break;
  
  case 71:
#line 1316 ""grammar.y""  
   case 72:
 #line 1321 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          void* jmp_destination_addr;
 
         compiler->last_result = yr_parser_emit_with_arg_reloc(
             yyscanner,
             OP_JTRUE,
             0,          
             NULL,
             &jmp_destination_addr);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
 
         if (fixup == NULL)
           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         fixup->address = jmp_destination_addr;
          fixup->next = compiler->fixup_stack_head;
          compiler->fixup_stack_head = fixup;
        }
#line 2947 ""grammar.c""  
 #line 2956 ""grammar.c""  
      break;
  
  case 72:
#line 1341 ""grammar.y""  
   case 73:
 #line 1346 ""grammar.y""  
      {
          YR_FIXUP* fixup;
          uint8_t* or_addr;
 
 
         compiler->last_result = yr_arena_reserve_memory(
             compiler->code_arena, 2);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
 
         fixup = compiler->fixup_stack_head;
 
 
         *(void**)(fixup->address) = (void*)(or_addr + 1);
 
         compiler->fixup_stack_head = fixup->next;
         yr_free(fixup);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 2987 ""grammar.c""  
 #line 2996 ""grammar.c""  
      break;
  
  case 73:
#line 1377 ""grammar.y""  
   case 74:
 #line 1382 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3000 ""grammar.c""  
 #line 3009 ""grammar.c""  
      break;
  
  case 74:
#line 1386 ""grammar.y""  
   case 75:
 #line 1391 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3013 ""grammar.c""  
 #line 3022 ""grammar.c""  
      break;
  
  case 75:
#line 1395 ""grammar.y""  
   case 76:
 #line 1400 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3026 ""grammar.c""  
 #line 3035 ""grammar.c""  
      break;
  
  case 76:
#line 1404 ""grammar.y""  
   case 77:
 #line 1409 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3039 ""grammar.c""  
 #line 3048 ""grammar.c""  
      break;
  
  case 77:
#line 1413 ""grammar.y""  
   case 78:
 #line 1418 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3052 ""grammar.c""  
 #line 3061 ""grammar.c""  
      break;
  
  case 78:
#line 1422 ""grammar.y""  
   case 79:
 #line 1427 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
  
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        }
#line 3065 ""grammar.c""  
 #line 3074 ""grammar.c""  
      break;
  
  case 79:
#line 1431 ""grammar.y""  
   case 80:
 #line 1436 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[0].expression);
        }
#line 3073 ""grammar.c""  
 #line 3082 ""grammar.c""  
      break;
  
  case 80:
#line 1435 ""grammar.y""  
   case 81:
 #line 1440 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[-1].expression);
        }
#line 3081 ""grammar.c""  
 #line 3090 ""grammar.c""  
      break;
  
  case 81:
#line 1442 ""grammar.y""  
   case 82:
 #line 1447 ""grammar.y""  
      { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3087 ""grammar.c""  
 #line 3096 ""grammar.c""  
      break;
  
  case 82:
#line 1443 ""grammar.y""  
   case 83:
 #line 1448 ""grammar.y""  
      { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3093 ""grammar.c""  
 #line 3102 ""grammar.c""  
      break;
  
  case 83:
#line 1449 ""grammar.y""  
   case 84:
 #line 1454 ""grammar.y""  
      {
          if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for range's lower bound"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
 
         if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
         {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for range's upper bound"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3115 ""grammar.c""  
 #line 3124 ""grammar.c""  
      break;
  
  case 84:
#line 1471 ""grammar.y""  
   case 85:
 #line 1476 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for enumeration item"");
           compiler->last_result = ERROR_WRONG_TYPE;
 
         }
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3131 ""grammar.c""  
 #line 3140 ""grammar.c""  
      break;
  
  case 85:
#line 1483 ""grammar.y""  
   case 86:
 #line 1488 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
          {
           yr_compiler_set_error_extra_info(
               compiler, ""wrong type for enumeration item"");
           compiler->last_result = ERROR_WRONG_TYPE;
         }
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3146 ""grammar.c""  
 #line 3155 ""grammar.c""  
      break;
  
  case 86:
#line 1498 ""grammar.y""  
   case 87:
 #line 1503 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        }
#line 3155 ""grammar.c""  
 #line 3164 ""grammar.c""  
      break;
  
  case 88:
#line 1504 ""grammar.y""  
   case 89:
 #line 1509 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
          yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3166 ""grammar.c""  
 #line 3175 ""grammar.c""  
      break;
  
  case 91:
#line 1521 ""grammar.y""  
   case 92:
 #line 1526 ""grammar.y""  
      {
          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
          yr_free((yyvsp[0].c_string));
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3177 ""grammar.c""  
 #line 3186 ""grammar.c""  
      break;
  
  case 92:
#line 1528 ""grammar.y""  
   case 93:
 #line 1533 ""grammar.y""  
      {
          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
          yr_free((yyvsp[0].c_string));
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3188 ""grammar.c""  
 #line 3197 ""grammar.c""  
      break;
  
  case 94:
#line 1540 ""grammar.y""  
   case 95:
 #line 1545 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        }
#line 3196 ""grammar.c""  
 #line 3205 ""grammar.c""  
      break;
  
  case 95:
#line 1544 ""grammar.y""  
   case 96:
 #line 1549 ""grammar.y""  
      {
          yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        }
#line 3204 ""grammar.c""  
 #line 3213 ""grammar.c""  
      break;
  
  case 96:
#line 1552 ""grammar.y""  
   case 97:
 #line 1557 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[-1].expression);
        }
#line 3212 ""grammar.c""  
 #line 3221 ""grammar.c""  
      break;
  
  case 97:
#line 1556 ""grammar.y""  
   case 98:
 #line 1561 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_FILESIZE, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3226 ""grammar.c""  
 #line 3235 ""grammar.c""  
      break;
  
  case 98:
#line 1566 ""grammar.y""  
   case 99:
 #line 1571 ""grammar.y""  
      {
          yywarning(yyscanner,
              ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
             ""function from PE module instead."");
 
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_ENTRYPOINT, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3244 ""grammar.c""  
 #line 3253 ""grammar.c""  
      break;
  
  case 99:
#line 1580 ""grammar.y""  
   case 100:
 #line 1585 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
  
 
         compiler->last_result = yr_parser_emit(
             yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3264 ""grammar.c""  
 #line 3273 ""grammar.c""  
      break;
  
  case 100:
#line 1596 ""grammar.y""  
   case 101:
 #line 1601 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = (yyvsp[0].integer);
        }
#line 3278 ""grammar.c""  
 #line 3287 ""grammar.c""  
      break;
  
  case 101:
#line 1606 ""grammar.y""  
   case 102:
 #line 1611 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg_double(
              yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
  
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        }
#line 3291 ""grammar.c""  
 #line 3300 ""grammar.c""  
      break;
  
  case 102:
#line 1615 ""grammar.y""  
   case 103:
 #line 1620 ""grammar.y""  
      {
          SIZED_STRING* sized_string;
  
         compiler->last_result = yr_arena_write_data(
             compiler->sz_arena,
             (yyvsp[0].sized_string),
             (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
             (void**) &sized_string);
 
         yr_free((yyvsp[0].sized_string));
 
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_emit_with_arg_reloc(
               yyscanner,
               OP_PUSH,
               sized_string,
               NULL,
               NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_STRING;
          (yyval.expression).value.sized_string = sized_string;
        }
#line 3320 ""grammar.c""  
 #line 3329 ""grammar.c""  
      break;
  
  case 103:
#line 1640 ""grammar.y""  
   case 104:
 #line 1645 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3336 ""grammar.c""  
 #line 3345 ""grammar.c""  
      break;
  
  case 104:
#line 1652 ""grammar.y""  
   case 105:
 #line 1657 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
 
         yr_free((yyvsp[-3].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3352 ""grammar.c""  
 #line 3361 ""grammar.c""  
      break;
  
  case 105:
#line 1664 ""grammar.y""  
   case 106:
 #line 1669 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 1, NULL, NULL);
 
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_reduce_string_identifier(
               yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3372 ""grammar.c""  
 #line 3381 ""grammar.c""  
      break;
  
  case 106:
#line 1680 ""grammar.y""  
   case 107:
 #line 1685 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
 
         yr_free((yyvsp[-3].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3388 ""grammar.c""  
 #line 3397 ""grammar.c""  
      break;
  
  case 107:
#line 1692 ""grammar.y""  
   case 108:
 #line 1697 ""grammar.y""  
      {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner, OP_PUSH, 1, NULL, NULL);
 
         if (compiler->last_result == ERROR_SUCCESS)
           compiler->last_result = yr_parser_reduce_string_identifier(
               yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
 
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
#line 3408 ""grammar.c""  
 #line 3417 ""grammar.c""  
      break;
  
  case 108:
#line 1708 ""grammar.y""  
   case 109:
 #line 1713 ""grammar.y""  
      {
          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   
          {
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = UNDEFINED;
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)   
         {
           (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
           (yyval.expression).value.integer = UNDEFINED;
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
         {
           compiler->last_result = yr_parser_emit(
               yyscanner, OP_OBJ_VALUE, NULL);
 
           switch((yyvsp[0].expression).value.object->type)
           {
             case OBJECT_TYPE_INTEGER:
               (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
               (yyval.expression).value.integer = UNDEFINED;
               break;
             case OBJECT_TYPE_FLOAT:
               (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
               break;
             case OBJECT_TYPE_STRING:
               (yyval.expression).type = EXPRESSION_TYPE_STRING;
               (yyval.expression).value.sized_string = NULL;
               break;
             default:
               yr_compiler_set_error_extra_info_fmt(
                   compiler,
                   ""wrong usage of identifier \""%s\"""",
                   (yyvsp[0].expression).identifier);
               compiler->last_result = ERROR_WRONG_TYPE;
           }
         }
         else
         {
           assert(FALSE);
         }
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3457 ""grammar.c""  
 #line 3466 ""grammar.c""  
      break;
  
  case 109:
#line 1753 ""grammar.y""  
   case 110:
 #line 1758 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
  
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
               UNDEFINED : -((yyvsp[0].expression).value.integer);
           compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
         }
         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
         {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
           compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
         }
  
          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }
#line 3480 ""grammar.c""  
 #line 3489 ""grammar.c""  
      break;
  
  case 110:
#line 1772 ""grammar.y""  
   case 111:
 #line 1777 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3502 ""grammar.c""  
 #line 3511 ""grammar.c""  
      break;
  
  case 111:
#line 1790 ""grammar.y""  
   case 112:
 #line 1795 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3524 ""grammar.c""  
 #line 3533 ""grammar.c""  
      break;
  
  case 112:
#line 1808 ""grammar.y""  
   case 113:
 #line 1813 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3546 ""grammar.c""  
 #line 3555 ""grammar.c""  
      break;
  
  case 113:
#line 1826 ""grammar.y""  
   case 114:
 #line 1831 ""grammar.y""  
      {
          compiler->last_result = yr_parser_reduce_operation(
              yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
         {
           if ((yyvsp[0].expression).value.integer != 0)
           {
             (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
             (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
           }
           else
           {
             compiler->last_result = ERROR_DIVISION_BY_ZERO;
             ERROR_IF(compiler->last_result != ERROR_SUCCESS);
           }
         }
         else
         {
            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          }
        }
#line 3576 ""grammar.c""  
 #line 3585 ""grammar.c""  
      break;
  
  case 114:
#line 1852 ""grammar.y""  
   case 115:
 #line 1857 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");
 
         yr_parser_emit(yyscanner, OP_MOD, NULL);
 
         if ((yyvsp[0].expression).value.integer != 0)
         {
           (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         }
         else
         {
           compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
#line 3598 ""grammar.c""  
 #line 3607 ""grammar.c""  
      break;
  
  case 115:
#line 1870 ""grammar.y""  
   case 116:
 #line 1875 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
 
         yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3612 ""grammar.c""  
 #line 3621 ""grammar.c""  
      break;
  
  case 116:
#line 1880 ""grammar.y""  
   case 117:
 #line 1885 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
 
         yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3626 ""grammar.c""  
 #line 3635 ""grammar.c""  
      break;
  
  case 117:
#line 1890 ""grammar.y""  
   case 118:
 #line 1895 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");
 
         yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3640 ""grammar.c""  
 #line 3649 ""grammar.c""  
      break;
  
  case 118:
#line 1900 ""grammar.y""  
   case 119:
 #line 1905 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
  
         yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : ~((yyvsp[0].expression).value.integer);
        }
#line 3654 ""grammar.c""  
 #line 3663 ""grammar.c""  
      break;
  
  case 119:
#line 1910 ""grammar.y""  
   case 120:
 #line 1915 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
 
         yr_parser_emit(yyscanner, OP_SHL, NULL);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3668 ""grammar.c""  
 #line 3677 ""grammar.c""  
      break;
  
  case 120:
#line 1920 ""grammar.y""  
   case 121:
 #line 1925 ""grammar.y""  
      {
          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");
 
         yr_parser_emit(yyscanner, OP_SHR, NULL);
 
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        }
#line 3682 ""grammar.c""  
 #line 3691 ""grammar.c""  
      break;
  
  case 121:
#line 1930 ""grammar.y""  
   case 122:
 #line 1935 ""grammar.y""  
      {
          (yyval.expression) = (yyvsp[0].expression);
        }
#line 3690 ""grammar.c""  
 #line 3699 ""grammar.c""  
      break;
  
  
#line 3694 ""grammar.c""  
 #line 3703 ""grammar.c""  
        default: break;
      }
     
   YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
    
 
   yyn = yyr1[yyn];
 
   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
     yystate = yydefgoto[yyn - YYNTOKENS];
 
   goto yynewstate;
 
 
  
 yyerrlab:
    
   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
 
    
   if (!yyerrstatus)
     {
       ++yynerrs;
 #if ! YYERROR_VERBOSE
       yyerror (yyscanner, compiler, YY_(""syntax error""));
 #else
 # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                         yyssp, yytoken)
       {
         char const *yymsgp = YY_(""syntax error"");
         int yysyntax_error_status;
         yysyntax_error_status = YYSYNTAX_ERROR;
         if (yysyntax_error_status == 0)
           yymsgp = yymsg;
         else if (yysyntax_error_status == 1)
           {
             if (yymsg != yymsgbuf)
               YYSTACK_FREE (yymsg);
             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
             if (!yymsg)
               {
                 yymsg = yymsgbuf;
                 yymsg_alloc = sizeof yymsgbuf;
                 yysyntax_error_status = 2;
               }
             else
               {
                 yysyntax_error_status = YYSYNTAX_ERROR;
                 yymsgp = yymsg;
               }
           }
         yyerror (yyscanner, compiler, yymsgp);
         if (yysyntax_error_status == 2)
           goto yyexhaustedlab;
       }
 # undef YYSYNTAX_ERROR
 #endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
        
 
       if (yychar <= YYEOF)
         {
            
           if (yychar == YYEOF)
             YYABORT;
         }
       else
         {
           yydestruct (""Error: discarding"",
                       yytoken, &yylval, yyscanner, compiler);
           yychar = YYEMPTY;
         }
     }
 
    
   goto yyerrlab1;
 
 
  
 yyerrorlab:
 
    
   if (  0)
      goto yyerrorlab;
 
    
   YYPOPSTACK (yylen);
   yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
 
  
 yyerrlab1:
   yyerrstatus = 3;       
 
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
           yyn += YYTERROR;
           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
                 break;
             }
         }
 
        
       if (yyssp == yyss)
         YYABORT;
 
 
       yydestruct (""Error: popping"",
                   yystos[yystate], yyvsp, yyscanner, compiler);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
 
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 
 
    
   YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
 
 
  
 yyacceptlab:
   yyresult = 0;
   goto yyreturn;
 
  
 yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
 #if !defined yyoverflow || YYERROR_VERBOSE
  
 yyexhaustedlab:
   yyerror (yyscanner, compiler, YY_(""memory exhausted""));
   yyresult = 2;
    
 #endif
 
 yyreturn:
   if (yychar != YYEMPTY)
     {
        
       yytoken = YYTRANSLATE (yychar);
       yydestruct (""Cleanup: discarding lookahead"",
                   yytoken, &yylval, yyscanner, compiler);
     }
    
   YYPOPSTACK (yylen);
   YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct (""Cleanup: popping"",
                   yystos[*yyssp], yyvsp, yyscanner, compiler);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
 #if YYERROR_VERBOSE
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
  #endif
    return yyresult;
  }","[1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1175, 1180, 1181, 1211, 1216, 1217, 1278, 1283, 1284, 1314, 1319, 1320, 1357, 1362, 1363, 1370, 1375, 1376, 1383, 1388, 1389, 1415, 1420, 1421, 1448, 1453, 1454, 1480, 1485, 1486, 1513, 1518, 1519, 1529, 1534, 1535, 1545, 1550, 1551, 1561, 1566, 1567, 1577, 1582, 1583, 1593, 1598, 1599, 1609, 1614, 1615, 1620, 1625, 1626, 1631, 1636, 1637, 1640, 1645, 1646, 1649, 1654, 1655, 1674, 1679, 1680, 1693, 1698, 1699, 1711, 1716, 1717, 1722, 1727, 1728, 1736, 1741, 1742, 1750, 1755, 1756, 1764, 1769, 1770, 1775, 1780, 1781, 1786, 1791, 1792, 1797, 1802, 1803, 1814, 1819, 1820, 1835, 1840, 1841, 1855, 1860, 1861, 1872, 1877, 1878, 1888, 1893, 1894, 1920, 1925, 1926, 1939, 1944, 1945, 1958, 1963, 1964, 1981, 1986, 1987, 2000, 2005, 2006, 2023, 2028, 2029, 2075, 2080, 2081, 2101, 2106, 2107, 2126, 2131, 2132, 2151, 2156, 2157, 2176, 2181, 2182, 2209, 2214, 2215, 2234, 2239, 2240, 2251, 2256, 2257, 2268, 2273, 2274, 2285, 2290, 2291, 2302, 2307, 2308, 2319, 2324, 2325, 2336, 2341, 2342, 2347, 2352, 1174, 1178, 1179, 1210, 1214, 1215, 1277, 1281, 1282, 1313, 1317, 1318, 1356, 1360, 1361, 1369, 1373, 1374, 1382, 1386, 1387, 1414, 1418, 1419, 1447, 1451, 1452, 1479, 1483, 1484, 1512, 1516, 1517, 1528, 1532, 1533, 1544, 1548, 1549, 1560, 1564, 1565, 1576, 1580, 1581, 1592, 1596, 1597, 1608, 1612, 1613, 1619, 1623, 1624, 1630, 1634, 1635, 1639, 1643, 1644, 1648, 1652, 1653, 1673, 1677, 1678, 1692, 1696, 1697, 1710, 1714, 1715, 1721, 1725, 1726, 1735, 1739, 1740, 1749, 1753, 1754, 1763, 1767, 1768, 1774, 1778, 1779, 1785, 1789, 1790, 1796, 1800, 1801, 1813, 1817, 1818, 1834, 1838, 1839, 1854, 1858, 1859, 1871, 1875, 1876, 1887, 1891, 1892, 1919, 1923, 1924, 1938, 1942, 1943, 1957, 1961, 1962, 1980, 1984, 1985, 1999, 2003, 2004, 2022, 2026, 2027, 2074, 2078, 2079, 2100, 2104, 2105, 2125, 2129, 2130, 2150, 2154, 2155, 2175, 2179, 2180, 2208, 2212, 2213, 2233, 2237, 2238, 2250, 2254, 2255, 2267, 2271, 2272, 2284, 2288, 2289, 2301, 2305, 2306, 2318, 2322, 2323, 2335, 2339, 2340, 2346, 2351]",libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule that is mishandled in the yr_parser_lookup_loop_variable function.
207432," bool ASessionDescription::getDimensions(
  size_t index, unsigned long PT,
  int32_t *width, int32_t *height) const {
 
      *width = 0;
      *height = 0;
  
    char key[20];
    sprintf(key, ""a=framesize:%lu"", PT);
     char key[33];
     snprintf(key, sizeof(key), ""a=framesize:%lu"", PT);
     if (PT > 9999999) {
         android_errorWriteLog(0x534e4554, ""25747670"");
     }
      AString value;
      if (!findAttribute(index, key, &value)) {
          return false;
  }
 
  const char *s = value.c_str();
  char *end;
  *width = strtoul(s, &end, 10);
     CHECK_GT(end, s);
     CHECK_EQ(*end, '-');
 
     s = end + 1;
  *height = strtoul(s, &end, 10);
     CHECK_GT(end, s);
     CHECK_EQ(*end, '\0');
 
  return true;
 }","[10, 11, 12, 13, 14, 8, 9]","Multiple buffer overflows in rtsp/ASessionDescription.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 25747670."
9825,"create_worker_threads(uint n)
{
comp_thread_ctxt_t *threads;
uint    i;

threads = (comp_thread_ctxt_t *)
my_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));

for (i = 0; i < n; i++) {
comp_thread_ctxt_t *thd = threads + i;

thd->num = i + 1;
thd->started = FALSE;
thd->cancelled = FALSE;
thd->data_avail = FALSE;

thd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +
MY_QLZ_COMPRESS_OVERHEAD,
MYF(MY_FAE));


if (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||
pthread_cond_init(&thd->ctrl_cond, NULL)) {
goto err;
}


if (pthread_mutex_init(&thd->data_mutex, NULL) ||
pthread_cond_init(&thd->data_cond, NULL)) {
goto err;
}

pthread_mutex_lock(&thd->ctrl_mutex);

if (pthread_create(&thd->id, NULL, compress_worker_thread_func,
thd)) {
msg(""compress: pthread_create() failed: ""
""errno = %d"", errno);
pthread_mutex_unlock(&thd->ctrl_mutex);
goto err;
}
}


for (i = 0; i < n; i++) {
comp_thread_ctxt_t *thd = threads + i;

while (thd->started == FALSE)
pthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);
pthread_mutex_unlock(&thd->ctrl_mutex);
}

return threads;

err:
my_free(threads);
return NULL;
}",[56],"MariaDB Server before 10.7 is vulnerable to Denial of Service. In extra/mariabackup/ds_compress.cc, when an error occurs (i.e., going to the err label) while executing the method create_worker_threads, the held lock thd->ctrl_mutex is not released correctly, which allows local users to trigger a denial of service due to the deadlock."
201351," static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)
 {
 	struct svcxprt_rdma *listen_rdma;
 	struct svcxprt_rdma *newxprt = NULL;
 	struct rdma_conn_param conn_param;
 	struct rpcrdma_connect_private pmsg;
 	struct ib_qp_init_attr qp_attr;
 	struct ib_device *dev;
 	struct sockaddr *sap;
 	unsigned int i;
 	int ret = 0;
 
 	listen_rdma = container_of(xprt, struct svcxprt_rdma, sc_xprt);
 	clear_bit(XPT_CONN, &xprt->xpt_flags);
 	 
 	spin_lock_bh(&listen_rdma->sc_lock);
 	if (!list_empty(&listen_rdma->sc_accept_q)) {
 		newxprt = list_entry(listen_rdma->sc_accept_q.next,
 				     struct svcxprt_rdma, sc_accept_q);
 		list_del_init(&newxprt->sc_accept_q);
 	}
 	if (!list_empty(&listen_rdma->sc_accept_q))
 		set_bit(XPT_CONN, &listen_rdma->sc_xprt.xpt_flags);
 	spin_unlock_bh(&listen_rdma->sc_lock);
 	if (!newxprt)
 		return NULL;
 
 	dprintk(""svcrdma: newxprt from accept queue = %p, cm_id=%p\n"",
  		newxprt, newxprt->sc_cm_id);
  
  	dev = newxprt->sc_cm_id->device;
 	newxprt->sc_port_num = newxprt->sc_cm_id->port_num;
  
  	 
 	newxprt->sc_max_sge = min((size_t)dev->attrs.max_sge,
 				  (size_t)RPCSVC_MAXPAGES);
 	newxprt->sc_max_sge_rd = min_t(size_t, dev->attrs.max_sge_rd,
 				       RPCSVC_MAXPAGES);
 	newxprt->sc_max_req_size = svcrdma_max_req_size;
 	newxprt->sc_max_requests = min_t(u32, dev->attrs.max_qp_wr,
 					 svcrdma_max_requests);
 	newxprt->sc_fc_credits = cpu_to_be32(newxprt->sc_max_requests);
 	newxprt->sc_max_bc_requests = min_t(u32, dev->attrs.max_qp_wr,
  					    svcrdma_max_bc_requests);
  	newxprt->sc_rq_depth = newxprt->sc_max_requests +
  			       newxprt->sc_max_bc_requests;
	newxprt->sc_sq_depth = RPCRDMA_SQ_DEPTH_MULT * newxprt->sc_rq_depth;
 	newxprt->sc_sq_depth = newxprt->sc_rq_depth;
  	atomic_set(&newxprt->sc_sq_avail, newxprt->sc_sq_depth);
  
  	if (!svc_rdma_prealloc_ctxts(newxprt))
  		goto errout;
	if (!svc_rdma_prealloc_maps(newxprt))
		goto errout;
  
  	 
 	newxprt->sc_ord = min_t(size_t, dev->attrs.max_qp_rd_atom, newxprt->sc_ord);
 	newxprt->sc_ord = min_t(size_t,	svcrdma_ord, newxprt->sc_ord);
 
 	newxprt->sc_pd = ib_alloc_pd(dev, 0);
 	if (IS_ERR(newxprt->sc_pd)) {
 		dprintk(""svcrdma: error creating PD for connect request\n"");
 		goto errout;
 	}
 	newxprt->sc_sq_cq = ib_alloc_cq(dev, newxprt, newxprt->sc_sq_depth,
 					0, IB_POLL_WORKQUEUE);
 	if (IS_ERR(newxprt->sc_sq_cq)) {
 		dprintk(""svcrdma: error creating SQ CQ for connect request\n"");
 		goto errout;
 	}
 	newxprt->sc_rq_cq = ib_alloc_cq(dev, newxprt, newxprt->sc_rq_depth,
 					0, IB_POLL_WORKQUEUE);
 	if (IS_ERR(newxprt->sc_rq_cq)) {
 		dprintk(""svcrdma: error creating RQ CQ for connect request\n"");
 		goto errout;
 	}
 
  	memset(&qp_attr, 0, sizeof qp_attr);
  	qp_attr.event_handler = qp_event_handler;
  	qp_attr.qp_context = &newxprt->sc_xprt;
 	qp_attr.port_num = newxprt->sc_cm_id->port_num;
 	qp_attr.cap.max_rdma_ctxs = newxprt->sc_max_requests;
  	qp_attr.cap.max_send_wr = newxprt->sc_sq_depth;
  	qp_attr.cap.max_recv_wr = newxprt->sc_rq_depth;
  	qp_attr.cap.max_send_sge = newxprt->sc_max_sge;
 	qp_attr.cap.max_recv_sge = newxprt->sc_max_sge;
 	qp_attr.sq_sig_type = IB_SIGNAL_REQ_WR;
 	qp_attr.qp_type = IB_QPT_RC;
 	qp_attr.send_cq = newxprt->sc_sq_cq;
 	qp_attr.recv_cq = newxprt->sc_rq_cq;
 	dprintk(""svcrdma: newxprt->sc_cm_id=%p, newxprt->sc_pd=%p\n"",
 		newxprt->sc_cm_id, newxprt->sc_pd);
 	dprintk(""    cap.max_send_wr = %d, cap.max_recv_wr = %d\n"",
 		qp_attr.cap.max_send_wr, qp_attr.cap.max_recv_wr);
 	dprintk(""    cap.max_send_sge = %d, cap.max_recv_sge = %d\n"",
 		qp_attr.cap.max_send_sge, qp_attr.cap.max_recv_sge);
 
 	ret = rdma_create_qp(newxprt->sc_cm_id, newxprt->sc_pd, &qp_attr);
 	if (ret) {
 		dprintk(""svcrdma: failed to create QP, ret=%d\n"", ret);
 		goto errout;
 	}
 	newxprt->sc_qp = newxprt->sc_cm_id->qp;
 
 	 
 	newxprt->sc_reader = rdma_read_chunk_lcl;
 	if (dev->attrs.device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS) {
 		newxprt->sc_frmr_pg_list_len =
 			dev->attrs.max_fast_reg_page_list_len;
 		newxprt->sc_dev_caps |= SVCRDMA_DEVCAP_FAST_REG;
 		newxprt->sc_reader = rdma_read_chunk_frmr;
 	} else
 		newxprt->sc_snd_w_inv = false;
 
 	 
 	if (!rdma_protocol_iwarp(dev, newxprt->sc_cm_id->port_num) &&
 	    !rdma_ib_or_roce(dev, newxprt->sc_cm_id->port_num))
 		goto errout;
 
 	if (rdma_protocol_iwarp(dev, newxprt->sc_cm_id->port_num))
 		newxprt->sc_dev_caps |= SVCRDMA_DEVCAP_READ_W_INV;
 
 	 
 	for (i = 0; i < newxprt->sc_max_requests; i++) {
 		ret = svc_rdma_post_recv(newxprt, GFP_KERNEL);
 		if (ret) {
 			dprintk(""svcrdma: failure posting receive buffers\n"");
 			goto errout;
 		}
 	}
 
 	 
 	newxprt->sc_cm_id->event_handler = rdma_cma_handler;
 
 	 
 	pmsg.cp_magic = rpcrdma_cmp_magic;
 	pmsg.cp_version = RPCRDMA_CMP_VERSION;
 	pmsg.cp_flags = 0;
 	pmsg.cp_send_size = pmsg.cp_recv_size =
 		rpcrdma_encode_buffer_size(newxprt->sc_max_req_size);
 
 	 
 	set_bit(RDMAXPRT_CONN_PENDING, &newxprt->sc_flags);
 	memset(&conn_param, 0, sizeof conn_param);
 	conn_param.responder_resources = 0;
 	conn_param.initiator_depth = newxprt->sc_ord;
 	conn_param.private_data = &pmsg;
 	conn_param.private_data_len = sizeof(pmsg);
 	ret = rdma_accept(newxprt->sc_cm_id, &conn_param);
 	if (ret) {
 		dprintk(""svcrdma: failed to accept new connection, ret=%d\n"",
 		       ret);
 		goto errout;
 	}
 
 	dprintk(""svcrdma: new connection %p accepted:\n"", newxprt);
 	sap = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.src_addr;
 	dprintk(""    local address   : %pIS:%u\n"", sap, rpc_get_port(sap));
 	sap = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.dst_addr;
 	dprintk(""    remote address  : %pIS:%u\n"", sap, rpc_get_port(sap));
 	dprintk(""    max_sge         : %d\n"", newxprt->sc_max_sge);
 	dprintk(""    max_sge_rd      : %d\n"", newxprt->sc_max_sge_rd);
 	dprintk(""    sq_depth        : %d\n"", newxprt->sc_sq_depth);
 	dprintk(""    max_requests    : %d\n"", newxprt->sc_max_requests);
 	dprintk(""    ord             : %d\n"", newxprt->sc_ord);
 
 	return &newxprt->sc_xprt;
 
  errout:
 	dprintk(""svcrdma: failure accepting new connection rc=%d.\n"", ret);
 	 
 	svc_xprt_get(&newxprt->sc_xprt);
 	if (newxprt->sc_qp && !IS_ERR(newxprt->sc_qp))
 		ib_destroy_qp(newxprt->sc_qp);
 	rdma_destroy_id(newxprt->sc_cm_id);
 	 
 	svc_xprt_put(&newxprt->sc_xprt);
 	return NULL;
 }","[32, 48, 81, 82, 47, 53, 54]","The NFSv4 implementation in the Linux kernel through 4.11.1 allows local users to cause a denial of service (resource consumption) by leveraging improper channel callback shutdown when unmounting an NFSv4 filesystem, aka a *module reference and kernel daemon* leak."
202056," static void set_own_dir(const char *argv0) {
 	size_t l = strlen(argv0);
  	while(l && argv0[l - 1] != '/')
  		l--;
  	if(l == 0)
 #ifdef SUPER_SECURE
 		memcpy(own_dir, ""/dev/null/"", 2);
 #else
  		memcpy(own_dir, ""."", 2);
 #endif
  	else {
  		memcpy(own_dir, argv0, l - 1);
  		own_dir[l] = 0;
 	}
 }","[6, 7, 8, 10]","Untrusted search path vulnerability in ProxyChains-NG before 4.9 allows local users to gain privileges via a Trojan horse libproxychains4.so library in the current working directory, which is referenced in the LD_PRELOAD path."
205053," void GpuProcessHost::OnAcceleratedSurfaceBuffersSwapped(
     const GpuHostMsg_AcceleratedSurfaceBuffersSwapped_Params& params) {
   TRACE_EVENT0(""gpu"", ""GpuProcessHost::OnAcceleratedSurfaceBuffersSwapped"");
 
   gfx::PluginWindowHandle handle =
       GpuSurfaceTracker::Get()->GetSurfaceWindowHandle(params.surface_id);
   if (handle != gfx::kNullPluginWindow) {
     RouteOnUIThread(GpuHostMsg_AcceleratedSurfaceBuffersSwapped(params));
     return;
   }
 
    base::ScopedClosureRunner scoped_completion_runner(
        base::Bind(&AcceleratedSurfaceBuffersSwappedCompletedForGPU,
                   host_id_, params.route_id,
                 true  , false  ));
                  true  , params.surface_handle));
  
    int render_process_id = 0;
    int render_widget_id = 0;
   if (!GpuSurfaceTracker::Get()->GetRenderWidgetIDForSurface(
       params.surface_id, &render_process_id, &render_widget_id)) {
     return;
   }
   RenderWidgetHelper* helper =
       RenderWidgetHelper::FromProcessHostID(render_process_id);
   if (!helper)
     return;
 
   scoped_completion_runner.Release();
   helper->DidReceiveBackingStoreMsg(ViewHostMsg_CompositorSurfaceBuffersSwapped(
       render_widget_id,
       params.surface_id,
       params.surface_handle,
       params.route_id,
       params.size,
       host_id_));
 }","[16, 15]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
208068," WORD32 ih264d_parse_inter_slice_data_cavlc(dec_struct_t * ps_dec,
  dec_slice_params_t * ps_slice,
                                            UWORD16 u2_first_mb_in_slice)
 {
     UWORD32 uc_more_data_flag;
     WORD32 i2_cur_mb_addr;
     UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;
     UWORD32 i2_mb_skip_run;
     UWORD32 u1_read_mb_type;
 
     UWORD32 u1_mbaff;
     UWORD32 u1_num_mbs_next, u1_end_of_row;
  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
     UWORD32 u1_slice_end = 0;
     UWORD32 u1_tfr_n_mb = 0;
     UWORD32 u1_decode_nmb = 0;
 
  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
  deblk_mb_t *ps_cur_deblk_mb;
  dec_mb_info_t *ps_cur_mb_info;
  parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;
     UWORD32 u1_inter_mb_type;
     UWORD32 u1_deblk_mb_type;
     UWORD32 u1_mb_threshold;
     WORD32 ret = OK;
 
   
   
   
 
  if(ps_slice->u1_slice_type == P_SLICE)
  {
         u1_inter_mb_type = P_MB;
         u1_deblk_mb_type = D_INTER_MB;
         u1_mb_threshold = 5;
  }
  else  
  {
         u1_inter_mb_type = B_MB;
         u1_deblk_mb_type = D_B_SLICE;
         u1_mb_threshold = 23;
  }
   
   
   
     ps_dec->u1_qp = ps_slice->u1_slice_qp;
     ih264d_update_qp(ps_dec, 0);
     u1_mb_idx = ps_dec->u1_mb_idx;
     u1_num_mbs = u1_mb_idx;
 
     u1_num_mbsNby2 = 0;
     u1_mbaff = ps_slice->u1_mbaff_frame_flag;
     i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;
     i2_mb_skip_run = 0;
     uc_more_data_flag = 1;
     u1_read_mb_type = 0;
 
  while(!u1_slice_end)
  {
         UWORD8 u1_mb_type;
 
         ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
 
  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
  {
             ret = ERROR_MB_ADDRESS_T;
  break;
  }
 
 
         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
 
         ps_cur_mb_info->u1_Mux = 0;
         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;
 
         ps_cur_mb_info->u1_end_of_slice = 0;
 
   
         ps_parse_mb_data->u1_num_part = 1;
         ps_parse_mb_data->u1_isI_mb = 0;
 
  if((!i2_mb_skip_run) && (!u1_read_mb_type))
  {
 
             UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
             UWORD32 u4_word, u4_ldz;
 
   
   
   
             NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
 
             u4_ldz = CLZ(u4_word);
 
   
             u4_bitstream_offset += (u4_ldz + 1);
   
             u4_word = 0;
  if(u4_ldz)
  {
                 GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                         u4_ldz);
  }
  *pu4_bitstrm_ofst = u4_bitstream_offset;
             i2_mb_skip_run = ((1 << u4_ldz) + u4_word - 1);
             COPYTHECONTEXT(""mb_skip_run"", i2_mb_skip_run);
             uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
             u1_read_mb_type = uc_more_data_flag;
  }
 
   
   
   
   
         ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
 
   
   
   
  if(ps_dec->u4_app_disable_deblk_frm == 0)
             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                              ps_dec->u1_mb_ngbr_availablity,
                                              ps_dec->u1_cur_mb_fld_dec_flag);
 
  if(i2_mb_skip_run)
  {
   
             ps_dec->i1_prev_mb_qp_delta = 0;
             ps_dec->u1_sub_mb_num = 0;
             ps_cur_mb_info->u1_mb_type = MB_SKIP;
             ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
             ps_cur_mb_info->u1_cbp = 0;
 
  {
   
  parse_part_params_t *ps_part_info = ps_dec->ps_part;
                 ps_part_info->u1_is_direct = PART_DIRECT_16x16;
                 ps_part_info->u1_sub_mb_num = 0;
                 ps_dec->ps_part++;
  }
 
   
             ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
 
             ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
             ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 
             i2_mb_skip_run--;
  }
  else
  {
             u1_read_mb_type = 0;
   
   
   
  {
                 UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;
                 UWORD32 u4_word, u4_ldz, u4_temp;
 
 
   
   
   
                 NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);
                 u4_ldz = CLZ(u4_word);
   
                 u4_bitstream_offset += (u4_ldz + 1);
   
                 u4_word = 0;
  if(u4_ldz)
                     GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,
                             u4_ldz);
  *pu4_bitstrm_ofst = u4_bitstream_offset;
                 u4_temp = ((1 << u4_ldz) + u4_word - 1);
  if(u4_temp > (UWORD32)(25 + u1_mb_threshold))
  return ERROR_MB_TYPE;
                 u1_mb_type = u4_temp;
                 COPYTHECONTEXT(""u1_mb_type"", u1_mb_type);
  }
             ps_cur_mb_info->u1_mb_type = u1_mb_type;
 
   
   
   
  if(u1_mb_type < u1_mb_threshold)
  {
                 ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
 
                 ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,
                                           u1_num_mbsNby2);
  if(ret != OK)
  return ret;
                 ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
  }
  else
  {
   
                 ps_parse_mb_data->u1_num_part = 0;
                 ps_parse_mb_data->u1_isI_mb = 1;
 
  if((25 + u1_mb_threshold) == u1_mb_type)
  {
   
                     ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;
                     ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);
  if(ret != OK)
  return ret;
                     ps_dec->u1_qp = 0;
  }
  else
  {
                     ret = ih264d_parse_imb_cavlc(
                                     ps_dec, ps_cur_mb_info, u1_num_mbs,
  (UWORD8)(u1_mb_type - u1_mb_threshold));
  if(ret != OK)
  return ret;
  }
 
                 ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;
  }
             uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
  }
         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 
 
          if(u1_mbaff)
          {
              ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
             if(!uc_more_data_flag && !i2_mb_skip_run && (0 == (i2_cur_mb_addr & 1)))
             {
                 return ERROR_EOB_FLUSHBITS_T;
             }
          }
           
           
   
         i2_cur_mb_addr++;
 
         u1_num_mbs++;
         u1_num_mbsNby2++;
         ps_parse_mb_data++;
 
   
   
   
   
   
         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
         u1_slice_end = (!(uc_more_data_flag || i2_mb_skip_run));
         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
  || u1_slice_end;
         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 
   
 
  if(u1_decode_nmb)
  {
             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
             u1_num_mbsNby2 = 0;
 
  {
                 ps_parse_mb_data = ps_dec->ps_parse_mb_data;
                 ps_dec->ps_part = ps_dec->ps_parse_part_params;
  }
  }
 
   
  if(u1_decode_nmb)
  {
 
 
 
  if(ps_dec->u1_separate_parse)
  {
                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                 ps_dec->ps_nmb_info +=  u1_num_mbs;
  }
  else
  {
                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                             u1_num_mbs_next, u1_tfr_n_mb,
                                             u1_end_of_row);
  }
             ps_dec->u2_total_mbs_coded += u1_num_mbs;
  if(u1_tfr_n_mb)
                 u1_num_mbs = 0;
             u1_mb_idx = u1_num_mbs;
             ps_dec->u1_mb_idx = u1_num_mbs;
 
  }
  }
 
     ps_dec->u4_num_mbs_cur_nmb = 0;
     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
  - (u2_first_mb_in_slice << u1_mbaff);
 
 
  return ret;
 }","[233, 234, 235, 236]","A remote denial of service vulnerability in libavc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33933140."
9724,"TEST_F(QuantizedConv2DTest, OddPadding) {
const int stride = 2;
TF_ASSERT_OK(NodeDefBuilder(""quantized_conv_op"", ""QuantizedConv2D"")
.Input(FakeInput(DT_QUINT8))
.Input(FakeInput(DT_QUINT8))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Attr(""out_type"", DataTypeToEnum<qint32>::v())
.Attr(""strides"", {1, stride, stride, 1})
.Attr(""padding"", ""SAME"")
.Finalize(node_def()));
TF_ASSERT_OK(InitOp());

const int depth = 1;
const int image_width = 4;
const int image_height = 4;
const int image_batch_count = 1;
AddInputFromArray<quint8>(
TensorShape({image_batch_count, image_height, image_width, depth}),
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16});
const int filter_size = 3;
const int filter_count = 1;
AddInputFromArray<quint8>(
TensorShape({filter_size, filter_size, depth, filter_count}),
{1, 2, 3, 4, 5, 6, 7, 8, 9});
AddInputFromArray<float>(TensorShape({1}), {0});
AddInputFromArray<float>(TensorShape({1}), {255.0f});
AddInputFromArray<float>(TensorShape({1}), {0});
AddInputFromArray<float>(TensorShape({1}), {255.0f});

TF_ASSERT_OK(RunOpKernel());
const int expected_width = image_width / stride;
const int expected_height = (image_height * filter_count) / stride;
Tensor expected(DT_QINT32, TensorShape({image_batch_count, expected_height,
expected_width, filter_count}));
test::FillValues<qint32>(&expected, {348, 252, 274, 175});
test::ExpectTensorEqual<qint32>(expected, *GetOutput(0));
}","[28, 29, 30, 31]","TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.QuantizedConv2D` does not fully validate the input arguments. In this case, references get bound to `nullptr` for each argument that is empty. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."
202775," MagickExport Image *AdaptiveThresholdImage(const Image *image,
   const size_t width,const size_t height,const ssize_t offset,
   ExceptionInfo *exception)
 {
 #define ThresholdImageTag  ""Threshold/Image""
 
   CacheView
     *image_view,
     *threshold_view;
 
   Image
     *threshold_image;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     progress;
 
   MagickPixelPacket
     zero;
 
   MagickRealType
     number_pixels;
 
   ssize_t
     y;
 
   assert(image != (const Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
    threshold_image=CloneImage(image,0,0,MagickTrue,exception);
    if (threshold_image == (Image *) NULL)
      return((Image *) NULL);
  if (width == 0)
   if ((width == 0) || (height == 0))
      return(threshold_image);
    if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)
      {
       InheritException(exception,&threshold_image->exception);
       threshold_image=DestroyImage(threshold_image);
       return((Image *) NULL);
     }
    
   status=MagickTrue;
   progress=0;
   GetMagickPixelPacket(image,&zero);
   number_pixels=(MagickRealType) (width*height);
   image_view=AcquireVirtualCacheView(image,exception);
   threshold_view=AcquireAuthenticCacheView(threshold_image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static) shared(progress,status) \
     magick_number_threads(image,threshold_image,image->rows,1)
 #endif
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     MagickBooleanType
       sync;
 
     MagickPixelPacket
       channel_bias,
       channel_sum;
 
     register const IndexPacket
       *magick_restrict indexes;
 
     register const PixelPacket
       *magick_restrict p,
       *magick_restrict r;
 
     register IndexPacket
       *magick_restrict threshold_indexes;
 
     register PixelPacket
       *magick_restrict q;
 
     register ssize_t
       x;
 
     ssize_t
       u,
       v;
 
     if (status == MagickFalse)
       continue;
     p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)
       height/2L,image->columns+width,height,exception);
     q=GetCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,1,
       exception);
     if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))
       {
         status=MagickFalse;
         continue;
       }
     indexes=GetCacheViewVirtualIndexQueue(image_view);
     threshold_indexes=GetCacheViewAuthenticIndexQueue(threshold_view);
     channel_bias=zero;
     channel_sum=zero;
     r=p;
     for (v=0; v < (ssize_t) height; v++)
     {
       for (u=0; u < (ssize_t) width; u++)
       {
         if (u == (ssize_t) (width-1))
           {
             channel_bias.red+=r[u].red;
             channel_bias.green+=r[u].green;
             channel_bias.blue+=r[u].blue;
             channel_bias.opacity+=r[u].opacity;
             if (image->colorspace == CMYKColorspace)
               channel_bias.index=(MagickRealType)
                 GetPixelIndex(indexes+(r-p)+u);
           }
         channel_sum.red+=r[u].red;
         channel_sum.green+=r[u].green;
         channel_sum.blue+=r[u].blue;
         channel_sum.opacity+=r[u].opacity;
         if (image->colorspace == CMYKColorspace)
           channel_sum.index=(MagickRealType) GetPixelIndex(indexes+(r-p)+u);
       }
       r+=image->columns+width;
     }
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       MagickPixelPacket
         mean;
 
       mean=zero;
       r=p;
       channel_sum.red-=channel_bias.red;
       channel_sum.green-=channel_bias.green;
       channel_sum.blue-=channel_bias.blue;
       channel_sum.opacity-=channel_bias.opacity;
       channel_sum.index-=channel_bias.index;
       channel_bias=zero;
       for (v=0; v < (ssize_t) height; v++)
       {
         channel_bias.red+=r[0].red;
         channel_bias.green+=r[0].green;
         channel_bias.blue+=r[0].blue;
         channel_bias.opacity+=r[0].opacity;
         if (image->colorspace == CMYKColorspace)
           channel_bias.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+0);
         channel_sum.red+=r[width-1].red;
         channel_sum.green+=r[width-1].green;
         channel_sum.blue+=r[width-1].blue;
         channel_sum.opacity+=r[width-1].opacity;
         if (image->colorspace == CMYKColorspace)
           channel_sum.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+
             width-1);
         r+=image->columns+width;
       }
       mean.red=(MagickRealType) (channel_sum.red/number_pixels+offset);
       mean.green=(MagickRealType) (channel_sum.green/number_pixels+offset);
       mean.blue=(MagickRealType) (channel_sum.blue/number_pixels+offset);
       mean.opacity=(MagickRealType) (channel_sum.opacity/number_pixels+offset);
       if (image->colorspace == CMYKColorspace)
         mean.index=(MagickRealType) (channel_sum.index/number_pixels+offset);
       SetPixelRed(q,((MagickRealType) GetPixelRed(q) <= mean.red) ?
         0 : QuantumRange);
       SetPixelGreen(q,((MagickRealType) GetPixelGreen(q) <= mean.green) ?
         0 : QuantumRange);
       SetPixelBlue(q,((MagickRealType) GetPixelBlue(q) <= mean.blue) ?
         0 : QuantumRange);
       SetPixelOpacity(q,((MagickRealType) GetPixelOpacity(q) <= mean.opacity) ?
         0 : QuantumRange);
       if (image->colorspace == CMYKColorspace)
         SetPixelIndex(threshold_indexes+x,(((MagickRealType) GetPixelIndex(
           threshold_indexes+x) <= mean.index) ? 0 : QuantumRange));
       p++;
       q++;
     }
     sync=SyncCacheViewAuthenticPixels(threshold_view,exception);
     if (sync == MagickFalse)
       status=MagickFalse;
     if (image->progress_monitor != (MagickProgressMonitor) NULL)
       {
         MagickBooleanType
           proceed;
 
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
         #pragma omp atomic
 #endif
         progress++;
         proceed=SetImageProgress(image,ThresholdImageTag,progress,image->rows);
         if (proceed == MagickFalse)
           status=MagickFalse;
       }
   }
   threshold_view=DestroyCacheView(threshold_view);
   image_view=DestroyCacheView(image_view);
   if (status == MagickFalse)
     threshold_image=DestroyImage(threshold_image);
   return(threshold_image);
 }","[39, 38]",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/threshold.c in AdaptiveThresholdImage because a height of zero is mishandled.
207877,"  bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,
                            Entry* pEntry) {
    if (size_ <= 0)
  return false;
 
  long long pos = start;
  const long long stop = start + size_;
 
  long len;
 
  
  
  const long long seekIdId = ReadUInt(pReader, pos, len);
   const long long seekIdId = ReadID(pReader, pos, len);
   if (seekIdId < 0)
     return false;
  
    if (seekIdId != 0x13AB)   
      return false;
 
  if ((pos + len) > stop)
  return false;
 
   pos += len;  
 
  const long long seekIdSize = ReadUInt(pReader, pos, len);
 
  if (seekIdSize <= 0)
  return false;
 
  if ((pos + len) > stop)
  return false;
 
   pos += len;  
 
  if ((pos + seekIdSize) > stop)
  return false;
 
 
   pEntry->id = ReadUInt(pReader, pos, len);  
 
  if (pEntry->id <= 0)
  return false;
 
  if (len != seekIdSize)
  return false;
 
   pos += seekIdSize;  
 
  const long long seekPosId = ReadUInt(pReader, pos, len);
 
  if (seekPosId != 0x13AC)  
  return false;
 
  if ((pos + len) > stop)
  return false;
 
   pos += len;  
 
  const long long seekPosSize = ReadUInt(pReader, pos, len);
 
  if (seekPosSize <= 0)
  return false;
 
  if ((pos + len) > stop)
  return false;
 
   pos += len;  
 
  if ((pos + seekPosSize) > stop)
  return false;
 
   pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);
 
  if (pEntry->pos < 0)
  return false;
 
   pos += seekPosSize;  
 
  if (pos != stop)
  return false;
 
  
    return true;
  }","[14, 15, 16, 13]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
199013,"  int perf_output_begin(struct perf_output_handle *handle,
  		      struct perf_event *event, unsigned int size,
		      int nmi, int sample)
 		      int sample)
  {
  	struct ring_buffer *rb;
  	unsigned long tail, offset, head;
 	int have_lost;
 	struct perf_sample_data sample_data;
 	struct {
 		struct perf_event_header header;
 		u64			 id;
 		u64			 lost;
 	} lost_event;
 
 	rcu_read_lock();
 	 
 	if (event->parent)
 		event = event->parent;
 
 	rb = rcu_dereference(event->rb);
 	if (!rb)
 		goto out;
  
  	handle->rb	= rb;
  	handle->event	= event;
	handle->nmi	= nmi;
  	handle->sample	= sample;
  
  	if (!rb->nr_pages)
 		goto out;
 
 	have_lost = local_read(&rb->lost);
 	if (have_lost) {
 		lost_event.header.size = sizeof(lost_event);
 		perf_event_header__init_id(&lost_event.header, &sample_data,
 					   event);
 		size += lost_event.header.size;
 	}
 
 	perf_output_get_handle(handle);
 
 	do {
 		 
 		tail = ACCESS_ONCE(rb->user_page->data_tail);
 		smp_rmb();
 		offset = head = local_read(&rb->head);
 		head += size;
 		if (unlikely(!perf_output_space(rb, tail, offset, head)))
 			goto fail;
 	} while (local_cmpxchg(&rb->head, offset, head) != offset);
 
 	if (head - local_read(&rb->wakeup) > rb->watermark)
 		local_add(rb->watermark, &rb->wakeup);
 
 	handle->page = offset >> (PAGE_SHIFT + page_order(rb));
 	handle->page &= rb->nr_pages - 1;
 	handle->size = offset & ((PAGE_SIZE << page_order(rb)) - 1);
 	handle->addr = rb->data_pages[handle->page];
 	handle->addr += handle->size;
 	handle->size = (PAGE_SIZE << page_order(rb)) - handle->size;
 
 	if (have_lost) {
 		lost_event.header.type = PERF_RECORD_LOST;
 		lost_event.header.misc = 0;
 		lost_event.id          = event->id;
 		lost_event.lost        = local_xchg(&rb->lost, 0);
 
 		perf_output_put(handle, lost_event);
 		perf_event__output_id_sample(event, handle, &sample_data);
 	}
 
 	return 0;
 
 fail:
 	local_inc(&rb->lost);
 	perf_output_put_handle(handle);
 out:
 	rcu_read_unlock();
 
 	return -ENOSPC;
 }","[4, 3, 27]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
3780,"int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)
{
int channelCount = m_track->f.channelCount;

for (int c=0; c<channelCount; c++)
{
m_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];
if (encoded[1] & 0x80)
m_adpcmState[c].previousValue -= 0x10000;

m_adpcmState[c].index = encoded[2];

*decoded++ = m_adpcmState[c].previousValue;

encoded += 4;
}

for (int n=0; n<m_framesPerPacket - 1; n += 8)
{
for (int c=0; c<channelCount; c++)
{
int16_t *output = decoded + c;
for (int s=0; s<4; s++)
{
*output = decodeSample(m_adpcmState[c], *encoded & 0xf);
output += channelCount;
*output = decodeSample(m_adpcmState[c], *encoded >> 4);
output += channelCount;
encoded++;
}
}

decoded += channelCount * 8;
}

return m_framesPerPacket * channelCount * sizeof (int16_t);
}",[11],The decodeSample function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.
200925," untrusted_launcher_response_callback (GtkDialog                 *dialog,
                                       int                        response_id,
                                       ActivateParametersDesktop *parameters)
 {
     GdkScreen *screen;
     char *uri;
     GFile *file;
  
      switch (response_id)
      {
        case RESPONSE_RUN:
         case GTK_RESPONSE_OK:
          {
             file = nautilus_file_get_location (parameters->file);
 
              
             nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
                                         NULL,
                                         ""yes"");
 
             nautilus_file_mark_desktop_file_executable (file,
                                                         parameters->parent_window,
                                                         TRUE,
                                                         NULL, NULL);
 
              
             nautilus_file_invalidate_all_attributes (parameters->file);
 
              screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));
              uri = nautilus_file_get_uri (parameters->file);
              DEBUG (""Launching untrusted launcher %s"", uri);
              nautilus_launch_desktop_file (screen, uri, NULL,
                                            parameters->parent_window);
              g_free (uri);
        }
        break;
        case RESPONSE_MARK_TRUSTED:
        {
            file = nautilus_file_get_location (parameters->file);
            nautilus_file_mark_desktop_file_trusted (file,
                                                     parameters->parent_window,
                                                     TRUE,
                                                     NULL, NULL);
              g_object_unref (file);
          }
          break;
 
         default:
         {
              
         }
         break;
     }
 
     gtk_widget_destroy (GTK_WIDGET (dialog));
     activate_parameters_desktop_free (parameters);
 }","[12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 11, 35, 36, 37, 38, 39, 40, 41, 42, 43]","GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious *sh -c* command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field."
198971," static int misaligned_load(struct pt_regs *regs,
 			   __u32 opcode,
 			   int displacement_not_indexed,
 			   int width_shift,
 			   int do_sign_extend)
 {
 	 
 	int error;
 	int destreg;
 	__u64 address;
 
 	error = generate_and_check_address(regs, opcode,
 			displacement_not_indexed, width_shift, &address);
 	if (error < 0) {
  		return error;
  	}
  
	perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);
 	perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);
  
  	destreg = (opcode >> 4) & 0x3f;
  	if (user_mode(regs)) {
 		__u64 buffer;
 
 		if (!access_ok(VERIFY_READ, (unsigned long) address, 1UL<<width_shift)) {
 			return -1;
 		}
 
 		if (__copy_user(&buffer, (const void *)(int)address, (1 << width_shift)) > 0) {
 			return -1;  
 		}
 		switch (width_shift) {
 		case 1:
 			if (do_sign_extend) {
 				regs->regs[destreg] = (__u64)(__s64) *(__s16 *) &buffer;
 			} else {
 				regs->regs[destreg] = (__u64) *(__u16 *) &buffer;
 			}
 			break;
 		case 2:
 			regs->regs[destreg] = (__u64)(__s64) *(__s32 *) &buffer;
 			break;
 		case 3:
 			regs->regs[destreg] = buffer;
 			break;
 		default:
 			printk(""Unexpected width_shift %d in misaligned_load, PC=%08lx\n"",
 				width_shift, (unsigned long) regs->pc);
 			break;
 		}
 	} else {
 		 
 		__u64 lo, hi;
 
 		switch (width_shift) {
 		case 1:
 			misaligned_kernel_word_load(address, do_sign_extend, &regs->regs[destreg]);
 			break;
 		case 2:
 			asm (""ldlo.l %1, 0, %0"" : ""=r"" (lo) : ""r"" (address));
 			asm (""ldhi.l %1, 3, %0"" : ""=r"" (hi) : ""r"" (address));
 			regs->regs[destreg] = lo | hi;
 			break;
 		case 3:
 			asm (""ldlo.q %1, 0, %0"" : ""=r"" (lo) : ""r"" (address));
 			asm (""ldhi.q %1, 7, %0"" : ""=r"" (hi) : ""r"" (address));
 			regs->regs[destreg] = lo | hi;
 			break;
 
 		default:
 			printk(""Unexpected width_shift %d in misaligned_load, PC=%08lx\n"",
 				width_shift, (unsigned long) regs->pc);
 			break;
 		}
 	}
 
 	return 0;
 
 }","[19, 18]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
206423," GURL DevToolsWindow::GetDevToolsURL(Profile* profile,
                                     const GURL& base_url,
                                     bool shared_worker_frontend,
                                     bool v8_only_frontend,
                                     const std::string& remote_frontend,
                                     bool can_dock,
                                     const std::string& panel) {
   if (base_url.SchemeIs(""data""))
     return base_url;
 
   std::string frontend_url(
       !remote_frontend.empty() ?
           remote_frontend :
           base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());
   std::string url_string(
       frontend_url +
       ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&""));
   if (shared_worker_frontend)
     url_string += ""&isSharedWorker=true"";
   if (v8_only_frontend)
     url_string += ""&v8only=true"";
   if (remote_frontend.size()) {
     url_string += ""&remoteFrontend=true"";
   } else {
     url_string += ""&remoteBase="" + DevToolsUI::GetRemoteBaseURL().spec();
   }
   if (can_dock)
      url_string += ""&can_dock=true"";
    if (panel.size())
      url_string += ""&panel="" + panel;
  return DevToolsUI::SanitizeFrontendURL(GURL(url_string));
   return DevToolsUIBindings::SanitizeFrontendURL(GURL(url_string));
  }","[32, 31]","Google Chrome prior to 56.0.2924.76 for Windows insufficiently sanitized DevTools URLs, which allowed a remote attacker who convinced a user to install a malicious extension to read filesystem contents via a crafted HTML page."
207540," status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
  uint32_t cmdSize,
  void *pCmdData,
  uint32_t *replySize,
  void *pReplyData)
 {
  Mutex::Autolock _l(mLock);
     ALOGVV(""command(), cmdCode: %d, mEffectInterface: %p"", cmdCode, mEffectInterface);
 
  if (mState == DESTROYED || mEffectInterface == NULL) {
  return NO_INIT;
  }
 
      if (mStatus != NO_ERROR) {
          return mStatus;
      }
     if (cmdCode == EFFECT_CMD_GET_PARAM &&
             (*replySize < sizeof(effect_param_t) ||
                     ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {
         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
      status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                     cmdCode,
                                                     cmdSize,
                                                    pCmdData,
                                                    replySize,
                                                    pReplyData);
  if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {
  uint32_t size = (replySize == NULL) ? 0 : *replySize;
  for (size_t i = 1; i < mHandles.size(); i++) {
  EffectHandle *h = mHandles[i];
  if (h != NULL && !h->destroyed_l()) {
                 h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);
  }
  }
  }
  return status;
 }","[17, 18, 19, 20, 21, 22]","services/audioflinger/Effects.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 does not validate the reply size for an AudioFlinger effect command, which allows attackers to gain privileges via a crafted application, aka internal bug 29251553."
206544,"  void SupervisedUserService::InitSync(const std::string& refresh_token) {
    ProfileOAuth2TokenService* token_service =
        ProfileOAuth2TokenServiceFactory::GetForProfile(profile_);
  token_service->UpdateCredentials(supervised_users::kSupervisedUserPseudoEmail,
                                   refresh_token);
   token_service->UpdateCredentials(
       supervised_users::kSupervisedUserPseudoEmail, refresh_token,
       signin_metrics::SourceForRefreshTokenOperation::kSupervisedUser_InitSync);
  }","[6, 7, 8, 4, 5]","The JSGenericLowering class in compiler/js-generic-lowering.cc in Google V8, as used in Google Chrome before 50.0.2661.94, mishandles comparison operators, which allows remote attackers to obtain sensitive information via crafted JavaScript code."
4478,"void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,
const struct pcap_pkthdr *header, const u_char * packet)
{

if (startTime == TIME_NONE) {
startTime = header->ts;
lastPrintTime = header->ts;
}

if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {
if (verbose) {
int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;
int days  = hours/24;
int left  = hours%24;
fprintf(stderr, ""wifipcap: %2d days %2d hours, %10"" PRId64 "" pkts\n"",
days, left, packetsProcessed);
}
lastPrintTime = header->ts;
}
packetsProcessed++;


WifiPacket pkt(cbs,header_type,header,packet);


cbs->PacketBegin(pkt, packet, header->caplen, header->len);

switch(header_type) {
case DLT_PRISM_HEADER:
pkt.handle_prism(packet,header->caplen);
break;
case DLT_IEEE802_11_RADIO:
pkt.handle_radiotap(packet,header->caplen);
break;
case DLT_IEEE802_11:
pkt.handle_80211(packet,header->caplen);
break;
case DLT_EN10MB:
pkt.handle_ether(packet,header->caplen);
break;
default:
#if 0


pkt.handle_ip(packet,header->caplen);
#endif
break;
}
cbs->PacketEnd(pkt);
}",[45],"An issue was discovered in wifipcap/wifipcap.cpp in TCPFLOW through 1.5.0-alpha. There is an integer overflow in the function handle_prism during caplen processing. If the caplen is less than 144, one can cause an integer overflow in the function handle_80211, which will result in an out-of-bounds read and may allow access to sensitive memory (or a denial of service)."
201003," dhcpv4_print(netdissect_options *ndo,
              const u_char *cp, u_int length, int indent)
 {
     u_int i, t;
     const u_char *tlv, *value;
     uint8_t type, optlen;
  
      i = 0;
      while (i < length) {
         if (i + 2 > length)
             return -1;
          tlv = cp + i;
          type = (uint8_t)tlv[0];
          optlen = (uint8_t)tlv[1];
         value = tlv + 2;
 
         ND_PRINT((ndo, ""\n""));
         for (t = indent; t > 0; t--)
             ND_PRINT((ndo, ""\t""));
  
          ND_PRINT((ndo, ""%s"", tok2str(dh4opt_str, ""Unknown"", type)));
          ND_PRINT((ndo,"" (%u)"", optlen + 2 ));
         if (i + 2 + optlen > length)
             return -1;
  
          switch (type) {
          case DH4OPT_DNS_SERVERS:
         case DH4OPT_NTP_SERVERS: {
             if (optlen < 4 || optlen % 4 != 0) {
                 return -1;
             }
             for (t = 0; t < optlen; t += 4)
                 ND_PRINT((ndo, "" %s"", ipaddr_string(ndo, value + t)));
         }
             break;
         case DH4OPT_DOMAIN_SEARCH: {
             const u_char *tp = value;
             while (tp < value + optlen) {
                 ND_PRINT((ndo, "" ""));
                 if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)
                     return -1;
             }
         }
             break;
         }
 
         i += 2 + optlen;
     }
     return 0;
 }","[10, 11, 23, 24]",The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv4_print().
7929,"TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,
const TfLiteTensor* input,
const TfLiteTensor* filter,
int16* depth_multiplier) {
int num_filter_channels = SizeOfDimension(filter, 3);
int num_input_channels = SizeOfDimension(input, 3);
TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);

*depth_multiplier = num_filter_channels / num_input_channels;
return kTfLiteOk;
}",[7],"TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthwiseConv` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/depthwise_conv.cc#L287-L288). An attacker can craft a model such that `input`'s fourth dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
7619,"const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,
socklen_t size) {
if (!src || !dst) {
errno = EFAULT;
return nullptr;
}
size_t src_size = 0;
if (af == AF_INET) {
src_size = sizeof(struct in_addr);
} else if (af == AF_INET6) {
src_size = sizeof(struct in6_addr);
} else {
errno = EAFNOSUPPORT;
return nullptr;
}

MessageWriter input;
input.Push<int>(TokLinuxAfFamily(af));
input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});
input.Push(size);
MessageReader output;

const auto status = NonSystemCallDispatcher(
::asylo::host_call::kInetNtopHandler, &input, &output);
CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_ntop"", 2);

auto result = output.next();
int klinux_errno = output.next<int>();
if (result.empty()) {
errno = FromkLinuxErrorNumber(klinux_errno);
return nullptr;
}

memcpy(dst, result.data(),
std::min(static_cast<size_t>(size),
static_cast<size_t>(INET6_ADDRSTRLEN)));
return dst;
}","[34, 35, 36]",An out of bounds read on the enc_untrusted_inet_ntop function allows an attack to extend the result size that is used by memcpy() to read memory from within the enclave heap. We recommend upgrading past commit 6ff3b77ffe110a33a2f93848a6333f33616f02c4
207783," WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,
                                 WORD32 num_mb_skip,
                                 UWORD8 u1_is_idr_slice,
                                 UWORD16 u2_frame_num,
  pocstruct_t *ps_cur_poc,
                                 WORD32 prev_slice_err)
 {
     WORD32 i2_cur_mb_addr;
     UWORD32 u1_num_mbs, u1_num_mbsNby2;
     UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
     UWORD32 i2_mb_skip_run;
 
     UWORD32 u1_num_mbs_next, u1_end_of_row;
  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
     UWORD32 u1_slice_end;
     UWORD32 u1_tfr_n_mb;
     UWORD32 u1_decode_nmb;
  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
  deblk_mb_t *ps_cur_deblk_mb;
  dec_mb_info_t *ps_cur_mb_info;
  parse_pmbarams_t *ps_parse_mb_data;
     UWORD32 u1_inter_mb_type;
     UWORD32 u1_deblk_mb_type;
     UWORD16 u2_total_mbs_coded;
     UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
  parse_part_params_t *ps_part_info;
     WORD32 ret;
 
 
  if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
  {
         ih264d_err_pic_dispbuf_mgr(ps_dec);
  return 0;
  }
     ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
  if(prev_slice_err == 1)
  {
   
         ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;
 
 
  if(!ps_dec->u1_first_slice_in_stream)
  {
             ih264d_end_of_pic(ps_dec, u1_is_idr_slice,
                 ps_dec->ps_cur_slice->u2_frame_num);
             ps_dec->s_cur_pic_poc.u2_frame_num =
                 ps_dec->ps_cur_slice->u2_frame_num;
  }
 
  {
             WORD32 i, j, poc = 0;
 
             ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;
 
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
 
  if(ps_dec->ps_cur_pic != NULL)
                 poc = ps_dec->ps_cur_pic->i4_poc + 2;
 
             j = 0;
  for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
  if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
 
                         j = i;
              {
                ps_dec->ps_cur_slice->u1_bottom_field_flag = 0;
                ps_dec->ps_cur_slice->u1_field_pic_flag = 0;
                  ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
                  ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;
                  ps_dec->ps_cur_slice->u1_nal_unit_type = 1;
                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
                         ps_dec->ps_cur_slice->u2_frame_num,
  &ps_dec->ps_pps[j]);
 
  if(ret != OK)
  {
  return ret;
  }
  }
 
             ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;
 
             ps_dec->u4_output_present = 0;
 
  {
                 ih264d_get_next_display_field(ps_dec,
                                               ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
   
 
  if(0 != ps_dec->s_disp_op.u4_error_code)
  {
                     ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
  }
  else
                     ps_dec->u4_output_present = 1;
  }
 
  if(ps_dec->u1_separate_parse == 1)
  {
  if(ps_dec->u4_dec_thread_created == 0)
  {
                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,
  (void *)ih264d_decode_picture_thread,
  (void *)ps_dec);
 
                     ps_dec->u4_dec_thread_created = 1;
  }
 
  if((ps_dec->u4_num_cores == 3) &&
  ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
  && (ps_dec->u4_bs_deblk_thread_created == 0))
  {
                     ps_dec->u4_start_recon_deblk = 0;
                     ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
  (void *)ih264d_recon_deblk_thread,
  (void *)ps_dec);
                     ps_dec->u4_bs_deblk_thread_created = 1;
  }
  }
  }
  }
  else
  {
 
  dec_slice_struct_t *ps_parse_cur_slice;
         ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;
 
  if(ps_dec->u1_slice_header_done
  && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
  {
             u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;
 
  if(u1_num_mbs)
  {
                 ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
  }
  else
  {
  if(ps_dec->u1_separate_parse)
  {
                     ps_cur_mb_info = ps_dec->ps_nmb_info - 1;
  }
  else
  {
                     ps_cur_mb_info = ps_dec->ps_nmb_info
  + ps_dec->u4_num_mbs_prev_nmb - 1;
  }
  }
 
             ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
             ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;
 
             ps_dec->u1_mb_ngbr_availablity =
                     ps_cur_mb_info->u1_mb_ngbr_availablity;
 
             ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
             ps_dec->u2_cur_mb_addr--;
             ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;
 
  if(u1_num_mbs)
  {
  if (ps_dec->u1_pr_sl_type == P_SLICE
  || ps_dec->u1_pr_sl_type == B_SLICE)
  {
                     ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
                     ps_dec->ps_part = ps_dec->ps_parse_part_params;
  }
 
                 u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
                 u1_end_of_row = (!u1_num_mbs_next)
  && (!(u1_mbaff && (u1_num_mbs & 0x01)));
                 u1_slice_end = 1;
                 u1_tfr_n_mb = 1;
                 ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 
  if(ps_dec->u1_separate_parse)
  {
                     ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                     ps_dec->ps_nmb_info += u1_num_mbs;
  }
  else
  {
                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
  }
                 ps_dec->u2_total_mbs_coded += u1_num_mbs;
                 ps_dec->u1_mb_idx = 0;
                 ps_dec->u4_num_mbs_cur_nmb = 0;
  }
 
  if(ps_dec->u2_total_mbs_coded
  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
                 ps_dec->u1_pic_decode_done = 1;
  return 0;
  }
 
             ps_dec->u2_cur_slice_num++;
              ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
             ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
             ps_dec->ps_parse_cur_slice++;
 
  }
  else
  {
             ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
  + ps_dec->u2_cur_slice_num;
  }
  }
 
   
   
   
  {
         WORD32 num_entries;
         WORD32 size;
         UWORD8 *pu1_buf;
 
         num_entries = MAX_FRAMES;
  if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
  (0 == ps_dec->i4_display_delay))
  {
             num_entries = 1;
  }
         num_entries = ((2 * num_entries) + 1);
  if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)
  {
             num_entries *= 2;
  }
         size = num_entries * sizeof(void *);
         size += PAD_MAP_IDX_POC * sizeof(void *);
 
         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
         pu1_buf += size * ps_dec->u2_cur_slice_num;
         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
  }
 
     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
     ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
     ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;
 
  if(ps_dec->ps_cur_slice->u1_field_pic_flag)
         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;
 
     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
 
  if(ps_dec->u1_separate_parse)
  {
         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
  }
  else
  {
         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
  }
 
   
   
   
     u1_inter_mb_type = P_MB;
     u1_deblk_mb_type = D_INTER_MB;
 
     ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
     ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
     ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
   
   
   
     ps_dec->u1_slice_header_done = 2;
     ps_dec->u1_qp = ps_slice->u1_slice_qp;
     ih264d_update_qp(ps_dec, 0);
     u1_mb_idx = ps_dec->u1_mb_idx;
     ps_parse_mb_data = ps_dec->ps_parse_mb_data;
     u1_num_mbs = u1_mb_idx;
 
     u1_slice_end = 0;
     u1_tfr_n_mb = 0;
     u1_decode_nmb = 0;
     u1_num_mbsNby2 = 0;
     i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
     i2_mb_skip_run = num_mb_skip;
 
  while(!u1_slice_end)
  {
         UWORD8 u1_mb_type;
 
  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
  break;
 
         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
 
         ps_cur_mb_info->u1_Mux = 0;
         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;
 
         ps_cur_mb_info->u1_end_of_slice = 0;
 
   
         ps_parse_mb_data->u1_num_part = 1;
         ps_parse_mb_data->u1_isI_mb = 0;
 
   
   
   
   
  if (u1_mbaff)
             ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
  else
             ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
 
   
  if(ps_dec->u4_app_disable_deblk_frm == 0)
  {
             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                              ps_dec->u1_mb_ngbr_availablity,
                                              ps_dec->u1_cur_mb_fld_dec_flag);
  }
 
   
         ps_dec->i1_prev_mb_qp_delta = 0;
         ps_dec->u1_sub_mb_num = 0;
         ps_cur_mb_info->u1_mb_type = MB_SKIP;
         ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
         ps_cur_mb_info->u1_cbp = 0;
 
   
         ps_part_info = ps_dec->ps_part;
         ps_part_info->u1_is_direct = PART_DIRECT_16x16;
         ps_part_info->u1_sub_mb_num = 0;
         ps_dec->ps_part++;
 
   
         ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
 
         ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
         ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 
         i2_mb_skip_run--;
 
         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 
  if (u1_mbaff)
  {
             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
  }
 
   
   
   
         i2_cur_mb_addr++;
 
         u1_num_mbs++;
         u1_num_mbsNby2++;
         ps_parse_mb_data++;
 
   
   
   
   
   
         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
         u1_slice_end = !i2_mb_skip_run;
         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
  || u1_slice_end;
         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 
  if(u1_decode_nmb)
  {
             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
             u1_num_mbsNby2 = 0;
 
             ps_parse_mb_data = ps_dec->ps_parse_mb_data;
             ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
  if(ps_dec->u1_separate_parse)
  {
                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                 ps_dec->ps_nmb_info +=  u1_num_mbs;
  }
  else
  {
                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
                                             u1_tfr_n_mb, u1_end_of_row);
  }
             ps_dec->u2_total_mbs_coded += u1_num_mbs;
  if(u1_tfr_n_mb)
                 u1_num_mbs = 0;
             u1_mb_idx = u1_num_mbs;
             ps_dec->u1_mb_idx = u1_num_mbs;
  }
  }
 
     ps_dec->u4_num_mbs_cur_nmb = 0;
     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
  - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;
 
     H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", ps_dec->ps_cur_slice->u4_mbs_in_slice);
 
     ps_dec->u2_cur_slice_num++;
 
   
  if(ps_dec->u4_first_slice_in_pic != 0)
         ps_dec->ps_parse_cur_slice++;
 
     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 
  if(ps_dec->u2_total_mbs_coded
  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
         ps_dec->u1_pic_decode_done = 1;
  }
 
  return 0;
 
 }","[71, 72]","The H.264 decoder in mediaserver in Android 6.x before 2016-07-01 does not initialize certain slice data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28165661."
199189," static int udp_v6_push_pending_frames(struct sock *sk)
 {
 	struct sk_buff *skb;
  	struct udphdr *uh;
  	struct udp_sock  *up = udp_sk(sk);
  	struct inet_sock *inet = inet_sk(sk);
	struct flowi6 *fl6 = &inet->cork.fl.u.ip6;
 	struct flowi6 *fl6;
  	int err = 0;
  	int is_udplite = IS_UDPLITE(sk);
  	__wsum csum = 0;
  
 	if (up->pending == AF_INET)
 		return udp_push_pending_frames(sk);
 
 	fl6 = &inet->cork.fl.u.ip6;
 
  	 
  	if ((skb = skb_peek(&sk->sk_write_queue)) == NULL)
  		goto out;
 
 	 
 	uh = udp_hdr(skb);
 	uh->source = fl6->fl6_sport;
 	uh->dest = fl6->fl6_dport;
 	uh->len = htons(up->len);
 	uh->check = 0;
 
 	if (is_udplite)
 		csum = udplite_csum_outgoing(sk, skb);
 	else if (skb->ip_summed == CHECKSUM_PARTIAL) {  
 		udp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,
 				     up->len);
 		goto send;
 	} else
 		csum = udp_csum_outgoing(sk, skb);
 
 	 
 	uh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,
 				    up->len, fl6->flowi6_proto, csum);
 	if (uh->check == 0)
 		uh->check = CSUM_MANGLED_0;
 
 send:
 	err = ip6_push_pending_frames(sk);
 	if (err) {
 		if (err == -ENOBUFS && !inet6_sk(sk)->recverr) {
 			UDP6_INC_STATS_USER(sock_net(sk),
 					    UDP_MIB_SNDBUFERRORS, is_udplite);
 			err = 0;
 		}
 	} else
 		UDP6_INC_STATS_USER(sock_net(sk),
 				    UDP_MIB_OUTDATAGRAMS, is_udplite);
 out:
 	up->len = 0;
 	up->pending = 0;
 	return err;
 }","[8, 13, 14, 15, 16, 17, 7]","The udp_v6_push_pending_frames function in net/ipv6/udp.c in the IPv6 implementation in the Linux kernel through 3.10.3 makes an incorrect function call for pending data, which allows local users to cause a denial of service (BUG and system crash) via a crafted application that uses the UDP_CORK option in a setsockopt system call."
9099,"RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
RList *segments = bin->segments;
if (!segments) {
return NULL;
}
RList *entries = bin->entries;
if (!entries) {
return NULL;
}
RList *symbols = bin->symbols;
if (!symbols) {
return NULL;
}

ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));
if (!modref) {
return NULL;
}
r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));

RList *relocs = r_list_newf (free);
if (!relocs) {
free (modref);
return NULL;
}

RListIter *it;
RBinSection *seg;
int index = -1;
r_list_foreach (segments, it, seg) {
index++;
if (!(bin->segment_entries[index].flags & RELOCINFO)) {
continue;
}
ut32 off, start = off = seg->paddr + seg->size;
ut16 length = r_buf_read_le16_at (bin->buf, off);
if (!length) {
continue;
}
off += 2;
while (off < start + length * sizeof (NE_image_reloc_item)) {
RBinReloc *reloc = R_NEW0 (RBinReloc);
if (!reloc) {
return NULL;
}
NE_image_reloc_item rel;
r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));
reloc->paddr = seg->paddr + rel.offset;
switch (rel.type) {
case LOBYTE:
reloc->type = R_BIN_RELOC_8;
break;
case SEL_16:
case OFF_16:
reloc->type = R_BIN_RELOC_16;
break;
case POI_32:
case OFF_32:
reloc->type = R_BIN_RELOC_32;
break;
case POI_48:
reloc->type = R_BIN_RELOC_64;
break;
}

ut32 offset;
if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {
RBinImport *imp = R_NEW0 (RBinImport);
if (!imp) {
free (reloc);
break;
}
char *name;
if (rel.index > bin->ne_header->ModRefs) {
name = r_str_newf (""UnknownModule%d_%x"", rel.index, off);
} else {
offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
name = __read_nonnull_str_at (bin->buf, offset);
}
if (rel.flags & IMPORTED_ORD) {
imp->ordinal = rel.func_ord;
imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord));
} else {
offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;
char *func = __read_nonnull_str_at (bin->buf, offset);
imp->name = r_str_newf (""%s.%s"", name, func);
free (func);
}
free (name);
reloc->import = imp;
} else if (rel.flags & OSFIXUP) {

} else {
if (strstr (seg->name, ""FIXED"")) {
RBinSection *s = r_list_get_n (segments, rel.segnum - 1);
if (s) {
offset = s->paddr + rel.segoff;
} else {
offset = -1;
}
} else {
RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);
if (entry) {
offset = entry->paddr;
} else {
offset = -1;
}
}
reloc->addend = offset;
RBinSymbol *sym = NULL;
RListIter *sit;
r_list_foreach (symbols, sit, sym) {
if (sym->paddr == reloc->addend) {
reloc->symbol = sym;
break;
}
}
}

if (rel.flags & ADDITIVE) {
reloc->additive = 1;
r_list_append (relocs, reloc);
} else {
do {
r_list_append (relocs, reloc);

offset = r_buf_read_le16_at (bin->buf, reloc->paddr);
RBinReloc *tmp = reloc;
reloc = R_NEW0 (RBinReloc);
if (!reloc) {
break;
}
*reloc = *tmp;
reloc->paddr = seg->paddr + offset;
} while (offset != 0xFFFF);
free (reloc);
}

off += sizeof (NE_image_reloc_item);
}
}
free (modref);
return relocs;
}","[15, 41, 74, 77]","Improper Validation of Array Index in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html)."
202600," int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
 			    pte_t *dst_pte,
 			    struct vm_area_struct *dst_vma,
 			    unsigned long dst_addr,
  			    unsigned long src_addr,
  			    struct page **pagep)
  {
 	struct address_space *mapping;
 	pgoff_t idx;
 	unsigned long size;
  	int vm_shared = dst_vma->vm_flags & VM_SHARED;
  	struct hstate *h = hstate_vma(dst_vma);
  	pte_t _dst_pte;
 	spinlock_t *ptl;
 	int ret;
 	struct page *page;
 
 	if (!*pagep) {
 		ret = -ENOMEM;
 		page = alloc_huge_page(dst_vma, dst_addr, 0);
 		if (IS_ERR(page))
 			goto out;
 
 		ret = copy_huge_page_from_user(page,
 						(const void __user *) src_addr,
 						pages_per_huge_page(h), false);
 
 		 
 		if (unlikely(ret)) {
 			ret = -EFAULT;
 			*pagep = page;
 			 
 			goto out;
 		}
 	} else {
 		page = *pagep;
 		*pagep = NULL;
 	}
 
 	 
  	__SetPageUptodate(page);
  	set_page_huge_active(page);
  
 	mapping = dst_vma->vm_file->f_mapping;
 	idx = vma_hugecache_offset(h, dst_vma, dst_addr);
 
  	 
  	if (vm_shared) {
		struct address_space *mapping = dst_vma->vm_file->f_mapping;
		pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);
 		size = i_size_read(mapping->host) >> huge_page_shift(h);
 		ret = -EFAULT;
 		if (idx >= size)
 			goto out_release_nounlock;
  
 		 
  		ret = huge_add_to_page_cache(page, mapping, idx);
  		if (ret)
  			goto out_release_nounlock;
 	}
 
  	ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
  	spin_lock(ptl);
  
 	 
 	size = i_size_read(mapping->host) >> huge_page_shift(h);
 	ret = -EFAULT;
 	if (idx >= size)
 		goto out_release_unlock;
 
  	ret = -EEXIST;
  	if (!huge_pte_none(huge_ptep_get(dst_pte)))
  		goto out_release_unlock;
 
 	if (vm_shared) {
 		page_dup_rmap(page, true);
 	} else {
 		ClearPagePrivate(page);
 		hugepage_add_new_anon_rmap(page, dst_vma, dst_addr);
 	}
 
 	_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);
 	if (dst_vma->vm_flags & VM_WRITE)
 		_dst_pte = huge_pte_mkdirty(_dst_pte);
 	_dst_pte = pte_mkyoung(_dst_pte);
 
 	set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);
 
 	(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,
 					dst_vma->vm_flags & VM_WRITE);
 	hugetlb_count_add(pages_per_huge_page(h), dst_mm);
 
 	 
 	update_mmu_cache(dst_vma, dst_addr, dst_pte);
 
 	spin_unlock(ptl);
 	if (vm_shared)
 		unlock_page(page);
 	ret = 0;
 out:
 	return ret;
 out_release_unlock:
 	spin_unlock(ptl);
 	if (vm_shared)
 		unlock_page(page);
 out_release_nounlock:
 	put_page(page);
 	goto out;
 }","[8, 9, 10, 44, 45, 46, 51, 52, 53, 54, 56, 65, 66, 67, 68, 69, 70, 49, 50]",A flaw was found in the hugetlb_mcopy_atomic_pte function in mm/hugetlb.c in the Linux kernel before 4.13.12. A lack of size check could cause a denial of service (BUG).
9406,"void Compute(tensorflow::OpKernelContext* context) override {
for (int ngram_width : ngram_widths_) {
OP_REQUIRES(
context, ngram_width > 0,
errors::InvalidArgument(""ngram_widths must contain positive values""));
}

const tensorflow::Tensor* data;
OP_REQUIRES_OK(context, context->input(""data"", &data));
const auto& input_data = data->flat<tstring>().data();

const tensorflow::Tensor* splits;
OP_REQUIRES_OK(context, context->input(""data_splits"", &splits));
const auto& splits_vec = splits->flat<SPLITS_TYPE>();



const int input_data_size = data->flat<tstring>().size();
const int splits_vec_size = splits_vec.size();
if (splits_vec_size > 0) {
int prev_split = splits_vec(0);
OP_REQUIRES(context, prev_split == 0,
errors::InvalidArgument(""First split value must be 0, got "",
prev_split));
for (int i = 1; i < splits_vec_size; ++i) {
bool valid_splits = splits_vec(i) >= prev_split;
valid_splits = valid_splits && (splits_vec(i) <= input_data_size);
OP_REQUIRES(context, valid_splits,
errors::InvalidArgument(
""Invalid split value "", splits_vec(i), "", must be in ["",
prev_split, "", "", input_data_size, ""]""));
prev_split = splits_vec(i);
}
OP_REQUIRES(context, prev_split == input_data_size,
errors::InvalidArgument(
""Last split value must be data size. Expected "",
input_data_size, "", got "", prev_split));
}

int num_batch_items = splits_vec.size() - 1;
tensorflow::Tensor* ngrams_splits;
OP_REQUIRES_OK(
context, context->allocate_output(1, splits->shape(), &ngrams_splits));
auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();


if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {
tensorflow::Tensor* empty;
OP_REQUIRES_OK(context,
context->allocate_output(0, data->shape(), &empty));
for (int i = 0; i <= num_batch_items; ++i) {
ngrams_splits_data[i] = 0;
}
return;
}

ngrams_splits_data[0] = 0;
for (int i = 1; i <= num_batch_items; ++i) {
int length = splits_vec(i) - splits_vec(i - 1);
int num_ngrams = 0;
for (int ngram_width : ngram_widths_)
num_ngrams += get_num_ngrams(length, ngram_width);
if (preserve_short_ && length > 0 && num_ngrams == 0) {
num_ngrams = 1;
}
ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;
}

tensorflow::Tensor* ngrams;
OP_REQUIRES_OK(
context,
context->allocate_output(
0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));
auto ngrams_data = ngrams->flat<tstring>().data();

for (int i = 0; i < num_batch_items; ++i) {
auto data_start = &input_data[splits_vec(i)];
int output_start_idx = ngrams_splits_data[i];
for (int ngram_width : ngram_widths_) {
auto output_start = &ngrams_data[output_start_idx];
int length = splits_vec(i + 1) - splits_vec(i);
int num_ngrams = get_num_ngrams(length, ngram_width);
CreateNgrams(data_start, output_start, num_ngrams, ngram_width);
output_start_idx += num_ngrams;
}





if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {
int data_length = splits_vec(i + 1) - splits_vec(i);


if (data_length == 0) {
continue;
}



int ngram_width = data_length + 2 * pad_width_;
auto output_start = &ngrams_data[output_start_idx];
int num_ngrams = 1;
CreateNgrams(data_start, output_start, num_ngrams, ngram_width);
}
}
}",[101],"Tensorflow is an Open Source Machine Learning Framework. The implementation of `StringNGrams` can be used to trigger a denial of service attack by causing an out of memory condition after an integer overflow. We are missing a validation on `pad_witdh` and that result in computing a negative value for `ngram_width` which is later used to allocate parts of the output. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
205202," WebView* RenderViewImpl::createView(
     WebFrame* creator,
     const WebURLRequest& request,
     const WebWindowFeatures& features,
     const WebString& frame_name,
     WebNavigationPolicy policy) {
   if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)
     return NULL;
 
   ViewHostMsg_CreateWindow_Params params;
   params.opener_id = routing_id_;
   params.user_gesture = creator->isProcessingUserGesture();
   params.window_container_type = WindowFeaturesToContainerType(features);
   params.session_storage_namespace_id = session_storage_namespace_id_;
    params.frame_name = frame_name;
    params.opener_frame_id = creator->identifier();
    params.opener_url = creator->document().url();
  params.opener_security_origin =
      creator->document().securityOrigin().toString().utf8();
   GURL security_url(creator->document().securityOrigin().toString().utf8());
   if (!security_url.is_valid())
     security_url = GURL();
   params.opener_security_origin = security_url;
    params.opener_suppressed = creator->willSuppressOpenerInNewFrame();
    params.disposition = NavigationPolicyToDisposition(policy);
    if (!request.isNull())
     params.target_url = request.url();
 
   int32 routing_id = MSG_ROUTING_NONE;
   int32 surface_id = 0;
   int64 cloned_session_storage_namespace_id;
 
   RenderThread::Get()->Send(
       new ViewHostMsg_CreateWindow(params,
                                    &routing_id,
                                    &surface_id,
                                    &cloned_session_storage_namespace_id));
   if (routing_id == MSG_ROUTING_NONE)
     return NULL;
 
   creator->consumeUserGesture();
 
   RenderViewImpl* view = RenderViewImpl::Create(
       routing_id_,
       renderer_preferences_,
       webkit_preferences_,
       shared_popup_counter_,
       routing_id,
       surface_id,
       cloned_session_storage_namespace_id,
       frame_name,
       true,
       false,
       1,
       screen_info_,
       accessibility_mode_);
   view->opened_by_user_gesture_ = params.user_gesture;
 
   view->opener_suppressed_ = params.opener_suppressed;
 
   view->alternate_error_page_url_ = alternate_error_page_url_;
 
   return view->webview();
 }","[20, 21, 22, 23, 18, 19]","Google Chrome before 24.0.1312.56 does not validate URLs during the opening of new windows, which has unspecified impact and remote attack vectors."
200174," static int parse_packet (sockent_t *se,  
 		void *buffer, size_t buffer_size, int flags,
 		const char *username)
 {
 	int status;
 
 	value_list_t vl = VALUE_LIST_INIT;
 	notification_t n;
 
 #if HAVE_LIBGCRYPT
 	int packet_was_signed = (flags & PP_SIGNED);
         int packet_was_encrypted = (flags & PP_ENCRYPTED);
 	int printed_ignore_warning = 0;
 #endif  
 
 
 	memset (&vl, '\0', sizeof (vl));
 	memset (&n, '\0', sizeof (n));
 	status = 0;
 
 	while ((status == 0) && (0 < buffer_size)
 			&& ((unsigned int) buffer_size > sizeof (part_header_t)))
 	{
 		uint16_t pkg_length;
 		uint16_t pkg_type;
 
 		memcpy ((void *) &pkg_type,
 				(void *) buffer,
 				sizeof (pkg_type));
 		memcpy ((void *) &pkg_length,
 				(void *) (buffer + sizeof (pkg_type)),
 				sizeof (pkg_length));
 
 		pkg_length = ntohs (pkg_length);
 		pkg_type = ntohs (pkg_type);
 
 		if (pkg_length > buffer_size)
 			break;
 		 
 		if (pkg_length < (2 * sizeof (uint16_t)))
 			break;
 
 		if (pkg_type == TYPE_ENCR_AES256)
 		{
 			status = parse_part_encr_aes256 (se,
 					&buffer, &buffer_size, flags);
 			if (status != 0)
 			{
 				ERROR (""network plugin: Decrypting AES256 ""
 						""part failed ""
 						""with status %i."", status);
 				break;
 			}
 		}
 #if HAVE_LIBGCRYPT
 		else if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)
 				&& (packet_was_encrypted == 0))
 		{
 			if (printed_ignore_warning == 0)
 			{
 				INFO (""network plugin: Unencrypted packet or ""
 						""part has been ignored."");
  				printed_ignore_warning = 1;
  			}
  			buffer = ((char *) buffer) + pkg_length;
 			buffer_size -= (size_t) pkg_length;
  			continue;
  		}
  #endif  
 		else if (pkg_type == TYPE_SIGN_SHA256)
 		{
 			status = parse_part_sign_sha256 (se,
                                         &buffer, &buffer_size, flags);
 			if (status != 0)
 			{
 				ERROR (""network plugin: Verifying HMAC-SHA-256 ""
 						""signature failed ""
 						""with status %i."", status);
 				break;
 			}
 		}
 #if HAVE_LIBGCRYPT
 		else if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)
 				&& (packet_was_encrypted == 0)
 				&& (packet_was_signed == 0))
 		{
 			if (printed_ignore_warning == 0)
 			{
 				INFO (""network plugin: Unsigned packet or ""
 						""part has been ignored."");
  				printed_ignore_warning = 1;
  			}
  			buffer = ((char *) buffer) + pkg_length;
 			buffer_size -= (size_t) pkg_length;
  			continue;
  		}
  #endif  
 		else if (pkg_type == TYPE_VALUES)
 		{
 			status = parse_part_values (&buffer, &buffer_size,
 					&vl.values, &vl.values_len);
 			if (status != 0)
 				break;
 
 			network_dispatch_values (&vl, username);
 
 			sfree (vl.values);
 		}
 		else if (pkg_type == TYPE_TIME)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 			{
 				vl.time = TIME_T_TO_CDTIME_T (tmp);
 				n.time  = TIME_T_TO_CDTIME_T (tmp);
 			}
 		}
 		else if (pkg_type == TYPE_TIME_HR)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 			{
 				vl.time = (cdtime_t) tmp;
 				n.time  = (cdtime_t) tmp;
 			}
 		}
 		else if (pkg_type == TYPE_INTERVAL)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 				vl.interval = TIME_T_TO_CDTIME_T (tmp);
 		}
 		else if (pkg_type == TYPE_INTERVAL_HR)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 				vl.interval = (cdtime_t) tmp;
 		}
 		else if (pkg_type == TYPE_HOST)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.host, sizeof (vl.host));
 			if (status == 0)
 				sstrncpy (n.host, vl.host, sizeof (n.host));
 		}
 		else if (pkg_type == TYPE_PLUGIN)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.plugin, sizeof (vl.plugin));
 			if (status == 0)
 				sstrncpy (n.plugin, vl.plugin,
 						sizeof (n.plugin));
 		}
 		else if (pkg_type == TYPE_PLUGIN_INSTANCE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.plugin_instance,
 					sizeof (vl.plugin_instance));
 			if (status == 0)
 				sstrncpy (n.plugin_instance,
 						vl.plugin_instance,
 						sizeof (n.plugin_instance));
 		}
 		else if (pkg_type == TYPE_TYPE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.type, sizeof (vl.type));
 			if (status == 0)
 				sstrncpy (n.type, vl.type, sizeof (n.type));
 		}
 		else if (pkg_type == TYPE_TYPE_INSTANCE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					vl.type_instance,
 					sizeof (vl.type_instance));
 			if (status == 0)
 				sstrncpy (n.type_instance, vl.type_instance,
 						sizeof (n.type_instance));
 		}
 		else if (pkg_type == TYPE_MESSAGE)
 		{
 			status = parse_part_string (&buffer, &buffer_size,
 					n.message, sizeof (n.message));
 
 			if (status != 0)
 			{
 				 
 			}
 			else if ((n.severity != NOTIF_FAILURE)
 					&& (n.severity != NOTIF_WARNING)
 					&& (n.severity != NOTIF_OKAY))
 			{
 				INFO (""network plugin: ""
 						""Ignoring notification with ""
 						""unknown severity %i."",
 						n.severity);
 			}
 			else if (n.time <= 0)
 			{
 				INFO (""network plugin: ""
 						""Ignoring notification with ""
 						""time == 0."");
 			}
 			else if (strlen (n.message) <= 0)
 			{
 				INFO (""network plugin: ""
 						""Ignoring notification with ""
 						""an empty message."");
 			}
 			else
 			{
 				network_dispatch_notification (&n);
 			}
 		}
 		else if (pkg_type == TYPE_SEVERITY)
 		{
 			uint64_t tmp = 0;
 			status = parse_part_number (&buffer, &buffer_size,
 					&tmp);
 			if (status == 0)
 				n.severity = (int) tmp;
 		}
 		else
 		{
  			DEBUG (""network plugin: parse_packet: Unknown part""
  					"" type: 0x%04hx"", pkg_type);
  			buffer = ((char *) buffer) + pkg_length;
 			buffer_size -= (size_t) pkg_length;
  		}
  	}  
  
 	if (status == 0 && buffer_size > 0)
 		WARNING (""network plugin: parse_packet: Received truncated ""
 				""packet, try increasing `MaxPacketSize'"");
 
 	return (status);
 }  ","[66, 94, 236]",Heap-based buffer overflow in the parse_packet function in network.c in collectd before 5.4.3 and 5.x before 5.5.2 allows remote attackers to cause a denial of service (daemon crash) or possibly execute arbitrary code via a crafted network packet.
205464,"  static void locationAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
  {
      TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->location());
     RefPtr<TestNode> imp = WTF::getPtr(proxyImp->location());
      if (!imp)
          return;
      V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
     imp->setHref(cppValue);
 }","[5, 4]","Use-after-free vulnerability in the AttributeSetter function in bindings/templates/attributes.cpp in the bindings in Blink, as used in Google Chrome before 33.0.1750.152 on OS X and Linux and before 33.0.1750.154 on Windows, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving the document.location value."
199285," _xfs_buf_find(
 	struct xfs_buftarg	*btp,
 	struct xfs_buf_map	*map,
 	int			nmaps,
 	xfs_buf_flags_t		flags,
 	xfs_buf_t		*new_bp)
 {
 	size_t			numbytes;
 	struct xfs_perag	*pag;
 	struct rb_node		**rbp;
  	struct rb_node		*parent;
  	xfs_buf_t		*bp;
  	xfs_daddr_t		blkno = map[0].bm_bn;
 	xfs_daddr_t		eofs;
  	int			numblks = 0;
  	int			i;
  
 	for (i = 0; i < nmaps; i++)
 		numblks += map[i].bm_len;
 	numbytes = BBTOB(numblks);
 
 	 
  	ASSERT(!(numbytes < (1 << btp->bt_sshift)));
  	ASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));
  
 	 
 	eofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);
 	if (blkno >= eofs) {
 		 
 		xfs_alert(btp->bt_mount,
 			  ""%s: Block out of range: block 0x%llx, EOFS 0x%llx "",
 			  __func__, blkno, eofs);
 		return NULL;
 	}
 
  	 
  	pag = xfs_perag_get(btp->bt_mount,
  				xfs_daddr_to_agno(btp->bt_mount, blkno));
 
 	 
 	spin_lock(&pag->pag_buf_lock);
 	rbp = &pag->pag_buf_tree.rb_node;
 	parent = NULL;
 	bp = NULL;
 	while (*rbp) {
 		parent = *rbp;
 		bp = rb_entry(parent, struct xfs_buf, b_rbnode);
 
 		if (blkno < bp->b_bn)
 			rbp = &(*rbp)->rb_left;
 		else if (blkno > bp->b_bn)
 			rbp = &(*rbp)->rb_right;
 		else {
 			 
 			if (bp->b_length != numblks) {
 				ASSERT(bp->b_flags & XBF_STALE);
 				rbp = &(*rbp)->rb_right;
 				continue;
 			}
 			atomic_inc(&bp->b_hold);
 			goto found;
 		}
 	}
 
 	 
 	if (new_bp) {
 		rb_link_node(&new_bp->b_rbnode, parent, rbp);
 		rb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);
 		 
 		new_bp->b_pag = pag;
 		spin_unlock(&pag->pag_buf_lock);
 	} else {
 		XFS_STATS_INC(xb_miss_locked);
 		spin_unlock(&pag->pag_buf_lock);
 		xfs_perag_put(pag);
 	}
 	return new_bp;
 
 found:
 	spin_unlock(&pag->pag_buf_lock);
 	xfs_perag_put(pag);
 
 	if (!xfs_buf_trylock(bp)) {
 		if (flags & XBF_TRYLOCK) {
 			xfs_buf_rele(bp);
 			XFS_STATS_INC(xb_busy_locked);
 			return NULL;
 		}
 		xfs_buf_lock(bp);
 		XFS_STATS_INC(xb_get_locked_waited);
 	}
 
 	 
 	if (bp->b_flags & XBF_STALE) {
 		ASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);
 		ASSERT(bp->b_iodone == NULL);
 		bp->b_flags &= _XBF_KMEM | _XBF_PAGES;
 		bp->b_ops = NULL;
 	}
 
 	trace_xfs_buf_find(bp, flags, _RET_IP_);
 	XFS_STATS_INC(xb_get_locked);
 	return bp;
 }","[14, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]","The _xfs_buf_find function in fs/xfs/xfs_buf.c in the Linux kernel before 3.7.6 does not validate block numbers, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by leveraging the ability to mount an XFS filesystem containing a metadata inode with an invalid extent map."
202584," static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 {
 	struct mmu_gather tlb;
 	struct vm_area_struct *vma;
 	bool ret = true;
 
 	 
 	mutex_lock(&oom_lock);
 
 	if (!down_read_trylock(&mm->mmap_sem)) {
 		ret = false;
 		trace_skip_task_reaping(tsk->pid);
 		goto unlock_oom;
 	}
 
 	 
 	if (mm_has_notifiers(mm)) {
 		up_read(&mm->mmap_sem);
 		schedule_timeout_idle(HZ);
 		goto unlock_oom;
 	}
 
 	 
 	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
 		up_read(&mm->mmap_sem);
 		trace_skip_task_reaping(tsk->pid);
 		goto unlock_oom;
 	}
 
 	trace_start_task_reaping(tsk->pid);
 
 	 
  	set_bit(MMF_UNSTABLE, &mm->flags);
  
	tlb_gather_mmu(&tlb, mm, 0, -1);
  	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
  		if (!can_madv_dontneed_vma(vma))
  			continue;
 
 		 
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
 		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
 			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
  			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
  					 NULL);
 			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
 		}
  	}
	tlb_finish_mmu(&tlb, 0, -1);
  	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
  			task_pid_nr(tsk), tsk->comm,
  			K(get_mm_counter(mm, MM_ANONPAGES)),
 			K(get_mm_counter(mm, MM_FILEPAGES)),
 			K(get_mm_counter(mm, MM_SHMEMPAGES)));
 	up_read(&mm->mmap_sem);
 
 	trace_finish_task_reaping(tsk->pid);
 unlock_oom:
 	mutex_unlock(&oom_lock);
 	return ret;
 }","[42, 43, 46, 47, 35, 41, 49]","The __oom_reap_task_mm function in mm/oom_kill.c in the Linux kernel before 4.14.4 mishandles gather operations, which allows attackers to cause a denial of service (TLB entry leak or use-after-free) or possibly have unspecified other impact by triggering a copy_to_user call within a certain time window."
199133,"  static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
  {
	struct serial_icounter_struct icount;
 	struct serial_icounter_struct icount = {};
  	struct sb_uart_icount cnow;
  	struct sb_uart_port *port = state->port;
  
 	spin_lock_irq(&port->lock);
 	memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));
 	spin_unlock_irq(&port->lock);
 
 	icount.cts         = cnow.cts;
 	icount.dsr         = cnow.dsr;
 	icount.rng         = cnow.rng;
 	icount.dcd         = cnow.dcd;
 	icount.rx          = cnow.rx;
 	icount.tx          = cnow.tx;
 	icount.frame       = cnow.frame;
 	icount.overrun     = cnow.overrun;
 	icount.parity      = cnow.parity;
 	icount.brk         = cnow.brk;
 	icount.buf_overrun = cnow.buf_overrun;
 
 	return copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;
 }","[4, 3]","The mp_get_count function in drivers/staging/sb105x/sb_pci_mp.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a TIOCGICOUNT ioctl call."
199124," long kvm_arch_vcpu_ioctl(struct file *filp,
 			 unsigned int ioctl, unsigned long arg)
 {
 	struct kvm_vcpu *vcpu = filp->private_data;
 	void __user *argp = (void __user *)arg;
 
 	switch (ioctl) {
 	case KVM_ARM_VCPU_INIT: {
 		struct kvm_vcpu_init init;
 
 		if (copy_from_user(&init, argp, sizeof(init)))
 			return -EFAULT;
 
 		return kvm_vcpu_set_target(vcpu, &init);
 
 	}
  	case KVM_SET_ONE_REG:
  	case KVM_GET_ONE_REG: {
  		struct kvm_one_reg reg;
 
 		if (unlikely(!kvm_vcpu_initialized(vcpu)))
 			return -ENOEXEC;
 
  		if (copy_from_user(&reg, argp, sizeof(reg)))
  			return -EFAULT;
  		if (ioctl == KVM_SET_ONE_REG)
 			return kvm_arm_set_reg(vcpu, &reg);
 		else
 			return kvm_arm_get_reg(vcpu, &reg);
 	}
 	case KVM_GET_REG_LIST: {
 		struct kvm_reg_list __user *user_list = argp;
  		struct kvm_reg_list reg_list;
  		unsigned n;
  
 		if (unlikely(!kvm_vcpu_initialized(vcpu)))
 			return -ENOEXEC;
 
  		if (copy_from_user(&reg_list, user_list, sizeof(reg_list)))
  			return -EFAULT;
  		n = reg_list.n;
 		reg_list.n = kvm_arm_num_regs(vcpu);
 		if (copy_to_user(user_list, &reg_list, sizeof(reg_list)))
 			return -EFAULT;
 		if (n < reg_list.n)
 			return -E2BIG;
 		return kvm_arm_copy_reg_indices(vcpu, user_list->reg);
 	}
 	default:
 		return -EINVAL;
 	}
 }","[20, 21, 22, 23, 36, 37, 38]","arch/arm/kvm/arm.c in the Linux kernel before 3.10 on the ARM platform, when KVM is used, allows host OS users to cause a denial of service (NULL pointer dereference, OOPS, and host OS crash) or possibly have unspecified other impact by omitting vCPU initialization before a KVM_GET_REG_LIST ioctl call."
204122,"  void AutoFillQueryXmlParser::StartElement(buzz::XmlParseContext* context,
                                            const char* name,
                                            const char** attrs) {
    buzz::QName qname = context->ResolveQName(name, false);
  const std::string &element = qname.LocalPart();
   const std::string& element = qname.LocalPart();
    if (element.compare(""autofillqueryresponse"") == 0) {
      
      
      
      *upload_required_ = USE_UPLOAD_RATES;
    if (*attrs) {
     *experiment_id_ = std::string();
 
      
     while (*attrs) {
        buzz::QName attribute_qname = context->ResolveQName(attrs[0], true);
      const std::string &attribute_name = attribute_qname.LocalPart();
       const std::string& attribute_name = attribute_qname.LocalPart();
        if (attribute_name.compare(""uploadrequired"") == 0) {
          if (strcmp(attrs[1], ""true"") == 0)
            *upload_required_ = UPLOAD_REQUIRED;
          else if (strcmp(attrs[1], ""false"") == 0)
            *upload_required_ = UPLOAD_NOT_REQUIRED;
       } else if (attribute_name.compare(""experimentid"") == 0) {
         *experiment_id_ = attrs[1];
        }
 
        
       attrs += 2;
      }
    } else if (element.compare(""field"") == 0) {
      if (!attrs[0]) {
       context->RaiseError(XML_ERROR_ABORTED);
       return;
     }
 
      AutoFillFieldType field_type = UNKNOWN_TYPE;
      buzz::QName attribute_qname = context->ResolveQName(attrs[0], true);
    const std::string &attribute_name = attribute_qname.LocalPart();
     const std::string& attribute_name = attribute_qname.LocalPart();
  
      if (attribute_name.compare(""autofilltype"") == 0) {
        int value = GetIntValue(context, attrs[1]);
       field_type = static_cast<AutoFillFieldType>(value);
       if (field_type < 0 || field_type > MAX_VALID_FIELD_TYPE) {
         field_type = NO_SERVER_DATA;
       }
     }
 
     field_types_->push_back(field_type);
   }
 }","[6, 8, 9, 10, 13, 14, 15, 16, 19, 25, 26, 28, 29, 30, 41, 5, 12, 18, 40]",Use-after-free vulnerability in the frame-loader implementation in Google Chrome before 10.0.648.204 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
201503," static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)
 {
   CompressionType
      compression;
  
    const char
     *comment,
      *value;
  
    const double
     midpoint = QuantumRange/2.0;
 
   MagickBooleanType
     status;
 
   QuantumAny
     range;
 
   register const IndexPacket
     *indexes;
 
   register const PixelPacket
     *p;
 
   register ssize_t
     x;
 
   register ssize_t
     i;
 
   register unsigned char
     *q;
 
   ssize_t
     count,
     y;
 
   TGAInfo
     tga_info;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
    
   if ((image->columns > 65535L) || (image->rows > 65535L))
     ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
   (void) TransformImageColorspace(image,sRGBColorspace);
   compression=image->compression;
   if (image_info->compression != UndefinedCompression)
      compression=image_info->compression;
    range=GetQuantumRange(5UL);
    tga_info.id_length=0;
  value=GetImageProperty(image,""comment"");
  if (value != (const char *) NULL)
    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);
   comment=GetImageProperty(image,""comment"");
   if (comment != (const char *) NULL)
     tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);
    tga_info.colormap_type=0;
    tga_info.colormap_index=0;
    tga_info.colormap_length=0;
   tga_info.colormap_size=0;
   tga_info.x_origin=0;
   tga_info.y_origin=0;
   tga_info.width=(unsigned short) image->columns;
   tga_info.height=(unsigned short) image->rows;
   tga_info.bits_per_pixel=8;
   tga_info.attributes=0;
   if ((image_info->type != TrueColorType) &&
       (image_info->type != TrueColorMatteType) &&
       (image_info->type != PaletteType) &&
       (image->matte == MagickFalse) &&
       (SetImageGray(image,&image->exception) != MagickFalse))
     tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :
       TGAMonochrome;
   else
     if ((image->storage_class == DirectClass) || (image->colors > 256))
       {
          
         tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;
         if (image_info->depth == 5)
           {
             tga_info.bits_per_pixel=16;
             if (image->matte != MagickFalse)
               tga_info.attributes=1;   
           }
         else
           {
             tga_info.bits_per_pixel=24;
             if (image->matte != MagickFalse)
               {
                 tga_info.bits_per_pixel=32;
                 tga_info.attributes=8;   
               }
           }
       }
     else
       {
          
         tga_info.image_type=compression == RLECompression ? TGARLEColormap :
           TGAColormap;
         tga_info.colormap_type=1;
         tga_info.colormap_length=(unsigned short) image->colors;
         if (image_info->depth == 5)
           tga_info.colormap_size=16;
         else
           tga_info.colormap_size=24;
       }
   value=GetImageArtifact(image,""tga:image-origin"");
   if (value != (const char *) NULL)
     {
       OrientationType
         origin;
 
       origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,
         MagickFalse,value);
       if (origin == BottomRightOrientation || origin == TopRightOrientation)
         tga_info.attributes|=(1UL << 4);
       if (origin == TopLeftOrientation || origin == TopRightOrientation)
         tga_info.attributes|=(1UL << 5);
     }
    
   (void) WriteBlobByte(image,tga_info.id_length);
   (void) WriteBlobByte(image,tga_info.colormap_type);
   (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);
   (void) WriteBlobLSBShort(image,tga_info.colormap_index);
   (void) WriteBlobLSBShort(image,tga_info.colormap_length);
   (void) WriteBlobByte(image,tga_info.colormap_size);
   (void) WriteBlobLSBShort(image,tga_info.x_origin);
   (void) WriteBlobLSBShort(image,tga_info.y_origin);
   (void) WriteBlobLSBShort(image,tga_info.width);
   (void) WriteBlobLSBShort(image,tga_info.height);
    (void) WriteBlobByte(image,tga_info.bits_per_pixel);
    (void) WriteBlobByte(image,tga_info.attributes);
    if (tga_info.id_length != 0)
    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);
     (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);
    if (tga_info.colormap_type != 0)
      {
        unsigned char
         green,
         *targa_colormap;
 
        
       targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
         tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(
         *targa_colormap));
       if (targa_colormap == (unsigned char *) NULL)
         ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
       q=targa_colormap;
       for (i=0; i < (ssize_t) image->colors; i++)
       {
         if (image_info->depth == 5)
           {
             green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,
               range);
             *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,
               range)) | ((green & 0x07) << 5);
             *q++=(((image->matte != MagickFalse) && (
               (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |
               ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,
               range) << 2) | ((green & 0x18) >> 3);
           }
         else
           {
             *q++=ScaleQuantumToChar(image->colormap[i].blue);
             *q++=ScaleQuantumToChar(image->colormap[i].green);
             *q++=ScaleQuantumToChar(image->colormap[i].red);
           }
       }
       (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*
         tga_info.colormap_length),targa_colormap);
       targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);
     }
    
   for (y=(ssize_t) (image->rows-1); y >= 0; y--)
   {
     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     indexes=GetVirtualIndexQueue(image);
     if (compression == RLECompression)
       {
         x=0;
         count=0;
         while (x < (ssize_t) image->columns)
         {
           i=1;
           while ((i < 128) && (count + i < 128) &&
                  ((x + i) < (ssize_t) image->columns))
           {
             if (tga_info.image_type == TGARLEColormap)
               {
                 if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))
                   break;
               }
             else
               if (tga_info.image_type == TGARLEMonochrome)
                 {
                   if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))
                     break;
                 }
               else
                 {
                   if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||
                       (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||
                       (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))
                     break;
                   if ((image->matte != MagickFalse) &&
                       (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))
                     break;
                 }
             i++;
           }
           if (i < 3)
             {
               count+=i;
               p+=i;
               indexes+=i;
             }
           if ((i >= 3) || (count == 128) ||
               ((x + i) == (ssize_t) image->columns))
             {
               if (count > 0)
                 {
                   (void) WriteBlobByte(image,(unsigned char) (--count));
                   while (count >= 0)
                   {
                     WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),
                       p-(count+1),range,midpoint);
                     count--;
                   }
                   count=0;
                 }
             }
           if (i >= 3)
             {
               (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));
               WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);
               p+=i;
               indexes+=i;
             }
           x+=i;
         }
       }
     else
       {
         for (x=0; x < (ssize_t) image->columns; x++)
           WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);
       }
     if (image->previous == (Image *) NULL)
       {
         status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
           image->rows);
         if (status == MagickFalse)
           break;
       }
   }
   (void) CloseBlob(image);
   return(MagickTrue);
 }","[7, 63, 64, 65, 144, 60, 61, 62, 143]","An issue was discovered in ImageMagick 6.9.7. Incorrect TGA files could trigger assertion failures, thus leading to DoS."
207115,"  GLboolean WebGLRenderingContextBase::isRenderbuffer(
      WebGLRenderbuffer* renderbuffer) {
  if (!renderbuffer || isContextLost())
   if (!renderbuffer || isContextLost() ||
       !renderbuffer->Validate(ContextGroup(), this))
      return 0;
  
    if (!renderbuffer->HasEverBeenBound())
     return 0;
   if (renderbuffer->IsDeleted())
     return 0;
 
   return ContextGL()->IsRenderbuffer(renderbuffer->Object());
  }","[4, 5, 3]",Insufficient data validation in WebGL in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
201990," BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
 {
 	gdIOCtx *out = gdNewFileCtx(outFile);
  	if (out == NULL) {
  		return;
  	}
	gdImageWebpCtx(im, out, quality);
 	_gdImageWebpCtx(im, out, quality);
  	out->gd_free(out);
  }","[8, 7]",Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.
7458,"evtchn_port_t evtchn_from_irq(unsigned irq)
{
if (WARN(irq >= nr_irqs, ""Invalid irq %d!\n"", irq))
return 0;

return info_for_irq(irq)->evtchn;
}","[3, 6]","An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5."
205104,"  void GpuCommandBufferStub::OnRegisterTransferBuffer(
      base::SharedMemoryHandle transfer_buffer,
    size_t size,
     uint32 size,
      int32 id_request,
      IPC::Message* reply_message) {
    TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnRegisterTransferBuffer"");
   base::SharedMemory shared_memory(transfer_buffer, false);
 
   if (command_buffer_.get()) {
     int32 id = command_buffer_->RegisterTransferBuffer(&shared_memory,
                                                        size,
                                                        id_request);
     GpuCommandBufferMsg_RegisterTransferBuffer::WriteReplyParams(reply_message,
                                                                  id);
   } else {
     reply_message->set_reply_error();
   }
 
   Send(reply_message);
 }","[4, 3]","Multiple unspecified vulnerabilities in the IPC layer in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allow remote attackers to cause a denial of service or possibly have other impact via unknown vectors."
206301," void WebContentsImpl::SetAsFocusedWebContentsIfNecessary() {
   WebContentsImpl* old_contents = GetFocusedWebContents();
   if (old_contents == this)
     return;
 
   GetOutermostWebContents()->node_.SetFocusedWebContents(this);
 
   if (!GuestMode::IsCrossProcessFrameGuest(this) && browser_plugin_guest_)
     return;
 
   if (old_contents)
     old_contents->GetMainFrame()->GetRenderWidgetHost()->SetPageFocus(false);
 
   if (GetRenderManager()->GetProxyToOuterDelegate())
      GetRenderManager()->GetProxyToOuterDelegate()->SetFocusedFrame();
  
    if (ShowingInterstitialPage()) {
    static_cast<RenderFrameHostImpl*>(
        GetRenderManager()->interstitial_page()->GetMainFrame())
     static_cast<RenderFrameHostImpl*>(interstitial_page_->GetMainFrame())
          ->GetRenderWidgetHost()
          ->SetPageFocus(true);
    } else {
     GetMainFrame()->GetRenderWidgetHost()->SetPageFocus(true);
   }
 }","[20, 18, 19]",Inappropriate implementation in interstitials in Google Chrome prior to 60.0.3112.78 for Mac allowed a remote attacker to spoof the contents of the omnibox via a crafted HTML page.
200496," static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
 			   int addr_len)
 {
 	struct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct inet_sock *inet = inet_sk(sk);
  	struct ipv6_pinfo *np = inet6_sk(sk);
  	struct dccp_sock *dp = dccp_sk(sk);
  	struct in6_addr *saddr = NULL, *final_p, final;
 	struct ipv6_txoptions *opt;
  	struct flowi6 fl6;
  	struct dst_entry *dst;
  	int addr_type;
 	int err;
 
 	dp->dccps_role = DCCP_ROLE_CLIENT;
 
 	if (addr_len < SIN6_LEN_RFC2133)
 		return -EINVAL;
 
 	if (usin->sin6_family != AF_INET6)
 		return -EAFNOSUPPORT;
 
 	memset(&fl6, 0, sizeof(fl6));
 
 	if (np->sndflow) {
 		fl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;
 		IP6_ECN_flow_init(fl6.flowlabel);
 		if (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {
 			struct ip6_flowlabel *flowlabel;
 			flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
 			if (flowlabel == NULL)
 				return -EINVAL;
 			fl6_sock_release(flowlabel);
 		}
 	}
 	 
 	if (ipv6_addr_any(&usin->sin6_addr))
 		usin->sin6_addr.s6_addr[15] = 1;
 
 	addr_type = ipv6_addr_type(&usin->sin6_addr);
 
 	if (addr_type & IPV6_ADDR_MULTICAST)
 		return -ENETUNREACH;
 
 	if (addr_type & IPV6_ADDR_LINKLOCAL) {
 		if (addr_len >= sizeof(struct sockaddr_in6) &&
 		    usin->sin6_scope_id) {
 			 
 			if (sk->sk_bound_dev_if &&
 			    sk->sk_bound_dev_if != usin->sin6_scope_id)
 				return -EINVAL;
 
 			sk->sk_bound_dev_if = usin->sin6_scope_id;
 		}
 
 		 
 		if (!sk->sk_bound_dev_if)
 			return -EINVAL;
 	}
 
 	sk->sk_v6_daddr = usin->sin6_addr;
 	np->flow_label = fl6.flowlabel;
 
 	 
 	if (addr_type == IPV6_ADDR_MAPPED) {
 		u32 exthdrlen = icsk->icsk_ext_hdr_len;
 		struct sockaddr_in sin;
 
 		SOCK_DEBUG(sk, ""connect: ipv4 mapped\n"");
 
 		if (__ipv6_only_sock(sk))
 			return -ENETUNREACH;
 
 		sin.sin_family = AF_INET;
 		sin.sin_port = usin->sin6_port;
 		sin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];
 
 		icsk->icsk_af_ops = &dccp_ipv6_mapped;
 		sk->sk_backlog_rcv = dccp_v4_do_rcv;
 
 		err = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));
 		if (err) {
 			icsk->icsk_ext_hdr_len = exthdrlen;
 			icsk->icsk_af_ops = &dccp_ipv6_af_ops;
 			sk->sk_backlog_rcv = dccp_v6_do_rcv;
 			goto failure;
 		}
 		np->saddr = sk->sk_v6_rcv_saddr;
 		return err;
 	}
 
 	if (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))
 		saddr = &sk->sk_v6_rcv_saddr;
 
 	fl6.flowi6_proto = IPPROTO_DCCP;
 	fl6.daddr = sk->sk_v6_daddr;
 	fl6.saddr = saddr ? *saddr : np->saddr;
 	fl6.flowi6_oif = sk->sk_bound_dev_if;
 	fl6.fl6_dport = usin->sin6_port;
  	fl6.fl6_sport = inet->inet_sport;
  	security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
  
	final_p = fl6_update_dst(&fl6, np->opt, &final);
 	opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));
 	final_p = fl6_update_dst(&fl6, opt, &final);
  
  	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
  	if (IS_ERR(dst)) {
 		err = PTR_ERR(dst);
 		goto failure;
 	}
 
 	if (saddr == NULL) {
 		saddr = &fl6.saddr;
 		sk->sk_v6_rcv_saddr = *saddr;
 	}
 
 	 
 	np->saddr = *saddr;
 	inet->inet_rcv_saddr = LOOPBACK4_IPV6;
 
  	__ip6_dst_store(sk, dst, NULL, NULL);
  
  	icsk->icsk_ext_hdr_len = 0;
	if (np->opt != NULL)
		icsk->icsk_ext_hdr_len = (np->opt->opt_flen +
					  np->opt->opt_nflen);
 	if (opt)
 		icsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;
  
  	inet->inet_dport = usin->sin6_port;
  
 	dccp_set_state(sk, DCCP_REQUESTING);
 	err = inet6_hash_connect(&dccp_death_row, sk);
 	if (err)
 		goto late_failure;
 
 	dp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,
 						      sk->sk_v6_daddr.s6_addr32,
 						      inet->inet_sport,
 						      inet->inet_dport);
 	err = dccp_connect(sk);
 	if (err)
 		goto late_failure;
 
 	return 0;
 
 late_failure:
 	dccp_set_state(sk, DCCP_CLOSED);
 	__sk_dst_reset(sk);
 failure:
 	inet->inet_dport = 0;
 	sk->sk_route_caps = 0;
 	return err;
 }","[10, 105, 106, 129, 130, 104, 126, 127, 128]","The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call."
2826,"CmdResult Handle (const std::vector<std::string>& parameters, User *user)
{

if (user->registered != REG_ALL)
{
if (!cap.ext.get(user))
return CMD_FAILURE;

SaslAuthenticator *sasl = authExt.get(user);
if (!sasl)
authExt.set(user, new SaslAuthenticator(user, parameters[0]));
else if (sasl->SendClientMessage(parameters) == false)
{
sasl->AnnounceState();
authExt.unset(user);
}
}
return CMD_FAILURE;
}",[9],"The m_sasl module in InspIRCd before 2.0.23, when used with a service that supports SASL_EXTERNAL authentication, allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted SASL message."
204417,"  void PrintPreviewUI::SetPrintPreviewDataForIndex(
      int index,
      const base::RefCountedBytes* data) {
  print_preview_data_service()->SetDataEntry(preview_ui_addr_str_, index, data);
   print_preview_data_service()->SetDataEntry(id_, index, data);
  }","[5, 4]",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
201675," static void parse_content_range(URLContext *h, const char *p)
 {
     HTTPContext *s = h->priv_data;
     const char *slash;
  
      if (!strncmp(p, ""bytes "", 6)) {
          p     += 6;
        s->off = strtoll(p, NULL, 10);
         s->off = strtoull(p, NULL, 10);
          if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
             s->filesize = strtoull(slash + 1, NULL, 10);
      }
      if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
          h->is_streamed = 0;  
 }","[9, 12, 8, 11]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response."
7858,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const Tensor& filter_sizes = context->input(1);
const Tensor& out_backprop = context->input(2);
OP_REQUIRES(
context, TensorShapeUtils::IsVector(filter_sizes.shape()),
errors::InvalidArgument(
""Conv2DCustomBackpropFilter: filter_sizes input must be 1-dim, ""
""not "",
filter_sizes.dims()));
TensorShape filter_shape;
OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(
filter_sizes.vec<int32>(), &filter_shape));

ConvBackpropDimensions dims;
OP_REQUIRES_OK(
context,
ConvBackpropComputeDimensionsV2(
""Conv2DCustomBackpropFilter"",                      2, input.shape(),
filter_shape, out_backprop.shape(), dilations_, strides_, padding_,
explicit_paddings_, data_format_, &dims));

Tensor* filter_backprop;
OP_REQUIRES_OK(context,
context->allocate_output(0, filter_shape, &filter_backprop));


if (filter_shape.num_elements() == 0) {
return;
}

int64 pad_top, pad_bottom;
int64 pad_left, pad_right;
if (padding_ == Padding::EXPLICIT) {
pad_top = explicit_paddings_[2];
pad_bottom = explicit_paddings_[3];
pad_left = explicit_paddings_[4];
pad_right = explicit_paddings_[5];
}
OP_REQUIRES_OK(
context,
GetWindowedOutputSizeVerbose(
dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,
dims.spatial_dims[0].stride, padding_,
&dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));
OP_REQUIRES_OK(
context,
GetWindowedOutputSizeVerbose(
dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,
dims.spatial_dims[1].stride, padding_,
&dims.spatial_dims[1].output_size, &pad_left, &pad_right));
#if defined TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS && \
    defined TENSORFLOW_USE_LIBXSMM_BACKWARD_CONVOLUTIONS
if (pad_left == pad_right && pad_top == pad_bottom) {
if (LaunchXsmmBackwardFilter<Device, T>()(
context, context->eigen_device<Device>(), input.tensor<T, 4>(),
filter_backprop->tensor<T, 4>(), out_backprop.tensor<T, 4>(),
dims.spatial_dims[0].input_size, dims.spatial_dims[1].input_size,
static_cast<int>(dims.spatial_dims[0].stride),
static_cast<int>(dims.spatial_dims[1].stride),
static_cast<int>(pad_top), static_cast<int>(pad_left),
data_format_)) {
return;
}
}
#endif


const int filter_total_size = dims.spatial_dims[0].filter_size *
dims.spatial_dims[1].filter_size *
dims.in_depth;

const int output_image_size =
dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size;










const size_t target_working_set_size = (30LL << 20) / sizeof(T);

const size_t size_A = output_image_size * filter_total_size;

const size_t size_B = output_image_size * dims.out_depth;

const size_t size_C = filter_total_size * dims.out_depth;

const size_t work_unit_size = size_A + size_B + size_C;

const size_t shard_size =
(target_working_set_size + work_unit_size - 1) / work_unit_size;

Tensor col_buffer;
OP_REQUIRES_OK(context,
context->allocate_temp(
DataTypeToEnum<T>::value,
TensorShape({static_cast<int64>(shard_size),
static_cast<int64>(output_image_size),
static_cast<int64>(filter_total_size)}),
&col_buffer));


const int input_offset = dims.spatial_dims[0].input_size *
dims.spatial_dims[1].input_size * dims.in_depth;

const int output_offset = dims.spatial_dims[0].output_size *
dims.spatial_dims[1].output_size * dims.out_depth;

const T* input_data = input.template flat<T>().data();
T* col_buffer_data = col_buffer.template flat<T>().data();
const T* out_backprop_data = out_backprop.template flat<T>().data();
T* filter_backprop_data = filter_backprop->template flat<T>().data();

typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
TensorMap;
typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
ConstTensorMap;

TensorMap C(filter_backprop_data, filter_total_size, dims.out_depth);
C.setZero();


Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;
contract_dims[0].first = 0;
contract_dims[0].second = 0;

auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());

for (int image_id = 0; image_id < dims.batch_size; image_id += shard_size) {
const int shard_limit =
std::min(static_cast<int>(shard_size),
static_cast<int>(dims.batch_size) - image_id);

auto shard = [&input_data, &col_buffer_data, &dims, &pad_top, &pad_left,
&pad_bottom, &pad_right, &input_offset,
&size_A](int64 start, int64 limit) {
for (int shard_id = start; shard_id < limit; ++shard_id) {
const T* input_data_shard = input_data + shard_id * input_offset;
T* col_data_shard = col_buffer_data + shard_id * size_A;



Im2col<T>(
input_data_shard, dims.in_depth, dims.spatial_dims[0].input_size,
dims.spatial_dims[1].input_size, dims.spatial_dims[0].filter_size,
dims.spatial_dims[1].filter_size, pad_top, pad_left, pad_bottom,
pad_right, dims.spatial_dims[0].stride,
dims.spatial_dims[1].stride, col_data_shard);
}
};
Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,
size_A, shard);

ConstTensorMap A(col_buffer_data, output_image_size * shard_limit,
filter_total_size);
ConstTensorMap B(out_backprop_data, output_image_size * shard_limit,
dims.out_depth);


C.device(context->eigen_cpu_device()) += A.contract(B, contract_dims);

input_data += input_offset * shard_limit;
out_backprop_data += output_offset * shard_limit;
}
}","[73, 95]","TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a division by zero to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L513-L522) computes a divisor based on user provided data (i.e., the shape of the tensors given as arguments). If all shapes are empty then `work_unit_size` is 0. Since there is no check for this case before division, this results in a runtime exception, with potential to be abused for a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
7339,"static int remarkupvals (global_State *g) {
lua_State *thread;
lua_State **p = &g->twups;
int work = 0;
while ((thread = *p) != NULL) {
work++;
lua_assert(!isblack(thread));
if (isgray(thread) && thread->openupval != NULL)
p = &thread->twups;
else {
UpVal *uv;
*p = thread->twups;
thread->twups = thread;
for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {
work++;
if (!iswhite(uv))
markvalue(g, uv->v);
}
}
}
return work;
}","[12, 15]","lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage."
206518," CreateDataReductionProxyChromeIOData(
     Profile* profile,
     const scoped_refptr<base::SingleThreadTaskRunner>& io_task_runner,
     const scoped_refptr<base::SingleThreadTaskRunner>& ui_task_runner) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
    DCHECK(profile);
    DCHECK(profile->GetPrefs());
  
  data_reduction_proxy::DataReductionProxySettings*
      data_reduction_proxy_settings =
          DataReductionProxyChromeSettingsFactory::GetForBrowserContext(
              profile);
  bool enabled = data_reduction_proxy_settings &&
                 data_reduction_proxy_settings->IsDataSaverEnabledByUser();
   bool enabled = data_reduction_proxy::DataReductionProxySettings::
       IsDataSaverEnabledByUser(profile->GetPrefs());
  
    std::unique_ptr<data_reduction_proxy::DataReductionProxyIOData>
        data_reduction_proxy_io_data(
           new data_reduction_proxy::DataReductionProxyIOData(
               DataReductionProxyChromeSettings::GetClient(),
               profile->GetPrefs(), content::GetNetworkConnectionTracker(),
               io_task_runner, ui_task_runner, enabled, GetUserAgent(),
               version_info::GetChannelString(chrome::GetChannel())));
 
   data_reduction_proxy_io_data->set_lofi_decider(
       std::make_unique<data_reduction_proxy::ContentLoFiDecider>());
   data_reduction_proxy_io_data->set_resource_type_provider(
       std::make_unique<data_reduction_proxy::ContentResourceTypeProvider>());
   data_reduction_proxy_io_data->set_lofi_ui_service(
       std::make_unique<data_reduction_proxy::ContentLoFiUIService>(
           ui_task_runner, base::Bind(&OnLoFiResponseReceivedOnUI)));
 
   return data_reduction_proxy_io_data;
 }","[15, 16, 9, 10, 11, 12, 13, 14]","An off by one error resulting in an allocation of zero size in FFmpeg in Google Chrome prior to 54.0.2840.98 for Mac, and 54.0.2840.99 for Windows, and 54.0.2840.100 for Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted video file."
202021," do_command (unsigned char c)
 {
 	static int dtr_up = 0;
 	int newbaud, newflow, newparity, newbits;
 	const char *xfr_cmd;
 	char *fname;
 	int r;
 
 	switch (c) {
 	case KEY_EXIT:
 		return 1;
 	case KEY_QUIT:
 		term_set_hupcl(tty_fd, 0);
 		term_flush(tty_fd);
 		term_apply(tty_fd);
 		term_erase(tty_fd);
 		return 1;
 	case KEY_STATUS:
 		show_status(dtr_up);
 		break;
 	case KEY_PULSE:
 		fd_printf(STO, ""\r\n*** pulse DTR ***\r\n"");
 		if ( term_pulse_dtr(tty_fd) < 0 )
 			fd_printf(STO, ""*** FAILED\r\n"");
 		break;
 	case KEY_TOGGLE:
 		if ( dtr_up )
 			r = term_lower_dtr(tty_fd);
 		else
 			r = term_raise_dtr(tty_fd);
 		if ( r >= 0 ) dtr_up = ! dtr_up;
 		fd_printf(STO, ""\r\n*** DTR: %s ***\r\n"", 
 				  dtr_up ? ""up"" : ""down"");
 		break;
 	case KEY_BAUD_UP:
 	case KEY_BAUD_DN:
 		if (c == KEY_BAUD_UP)
 			opts.baud = baud_up(opts.baud);
 		else 
 			opts.baud = baud_down(opts.baud);
 		term_set_baudrate(tty_fd, opts.baud);
 		tty_q.len = 0; term_flush(tty_fd);
 		term_apply(tty_fd);
 		newbaud = term_get_baudrate(tty_fd, NULL);
 		if ( opts.baud != newbaud ) {
 			fd_printf(STO, ""\r\n*** baud: %d (%d) ***\r\n"", 
 					  opts.baud, newbaud);
 		} else {
 			fd_printf(STO, ""\r\n*** baud: %d ***\r\n"", opts.baud);
 		}
 		set_tty_write_sz(newbaud);
 		break;
 	case KEY_FLOW:
 		opts.flow = flow_next(opts.flow);
 		term_set_flowcntrl(tty_fd, opts.flow);
 		tty_q.len = 0; term_flush(tty_fd);
 		term_apply(tty_fd);
 		newflow = term_get_flowcntrl(tty_fd);
 		if ( opts.flow != newflow ) {
 			fd_printf(STO, ""\r\n*** flow: %s (%s) ***\r\n"", 
 					  flow_str[opts.flow], flow_str[newflow]);
 		} else {
 			fd_printf(STO, ""\r\n*** flow: %s ***\r\n"", 
 					  flow_str[opts.flow]);
 		}
 		break;
 	case KEY_PARITY:
 		opts.parity = parity_next(opts.parity);
 		term_set_parity(tty_fd, opts.parity);
 		tty_q.len = 0; term_flush(tty_fd);
 		term_apply(tty_fd);
 		newparity = term_get_parity(tty_fd);
 		if (opts.parity != newparity ) {
 			fd_printf(STO, ""\r\n*** parity: %s (%s) ***\r\n"",
 					  parity_str[opts.parity], 
 					  parity_str[newparity]);
 		} else {
 			fd_printf(STO, ""\r\n*** parity: %s ***\r\n"", 
 					  parity_str[opts.parity]);
 		}
 		break;
 	case KEY_BITS:
 		opts.databits = bits_next(opts.databits);
 		term_set_databits(tty_fd, opts.databits);
 		tty_q.len = 0; term_flush(tty_fd);
 		term_apply(tty_fd);
 		newbits = term_get_databits(tty_fd);
 		if (opts.databits != newbits ) {
 			fd_printf(STO, ""\r\n*** databits: %d (%d) ***\r\n"",
 					  opts.databits, newbits);
 		} else {
 			fd_printf(STO, ""\r\n*** databits: %d ***\r\n"", 
 					  opts.databits);
 		}
 		break;
 	case KEY_LECHO:
 		opts.lecho = ! opts.lecho;
 		fd_printf(STO, ""\r\n*** local echo: %s ***\r\n"", 
 				  opts.lecho ? ""yes"" : ""no"");
 		break;
 	case KEY_SEND:
 	case KEY_RECEIVE:
 		xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
 		if ( xfr_cmd[0] == '\0' ) {
 			fd_printf(STO, ""\r\n*** command disabled ***\r\n"");
 			break;
 		}
 		fname = read_filename();
 		if (fname == NULL) {
  			fd_printf(STO, ""*** cannot read filename ***\r\n"");
  			break;
  		}
		run_cmd(tty_fd, xfr_cmd, fname, NULL);
 		run_cmd(tty_fd, xfr_cmd, fname);
  		free(fname);
  		break;
  	case KEY_BREAK:
 		term_break(tty_fd);
 		fd_printf(STO, ""\r\n*** break sent ***\r\n"");
 		break;
 	default:
 		break;
 	}
 
 	return 0;
 }","[114, 113]",picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.
202207," static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,
 		unsigned long arg)
 {
 	cd_dbg(CD_DO_IOCTL, ""entering CDROM_DRIVE_STATUS\n"");
 
 	if (!(cdi->ops->capability & CDC_DRIVE_STATUS))
 		return -ENOSYS;
  	if (!CDROM_CAN(CDC_SELECT_DISC) ||
  	    (arg == CDSL_CURRENT || arg == CDSL_NONE))
  		return cdi->ops->drive_status(cdi, CDSL_CURRENT);
	if (((int)arg >= cdi->capacity))
 	if (arg >= cdi->capacity)
  		return -EINVAL;
  	return cdrom_slot_status(cdi, arg);
  }","[12, 11]",An issue was discovered in the Linux kernel before 4.18.6. An information leak in cdrom_ioctl_drive_status in drivers/cdrom/cdrom.c could be used by local attackers to read kernel memory because a cast from unsigned long to int interferes with bounds checking. This is similar to CVE-2018-10940.
203346," pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
                      const uint8_t *cert, size_t cert_len,
                      krb5_const_principal princ, const void *opts,
                      const struct _krb5_db_entry_new *db_entry,
                      char ***authinds_out)
 {
     krb5_error_code ret;
     int valid_eku;
     const struct certauth_req_opts *req_opts = opts;
 
     *authinds_out = NULL;
 
      
     ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,
                             &valid_eku);
     if (ret)
         return ret;
 
     if (!valid_eku) {
         TRACE_PKINIT_SERVER_EKU_REJECT(context);
          return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
      }
  
    return 0;
     return KRB5_PLUGIN_NO_HANDLE;
  }","[25, 24]",An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.
203269," static void copy_xauthority(void) {
 	char *src = RUN_XAUTHORITY_FILE ;
  	char *dest;
  	if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1)
  		errExit(""asprintf"");
 	
  	if (is_link(dest)) {
  		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
  		exit(1);
  	}
  
	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
	if (chown(dest, getuid(), getgid()) < 0)
		errExit(""chown"");
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
		errExit(""chmod"");
 	copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);  
 	fs_logger2(""clone"", dest);
 	
  	unlink(src);
  }","[6, 30, 31, 32, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]","Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180."
206191,"   void DetachWebContentsTest(DiscardReason reason) {
     LifecycleUnit* first_lifecycle_unit = nullptr;
     LifecycleUnit* second_lifecycle_unit = nullptr;
     CreateTwoTabs(true  , &first_lifecycle_unit,
                   &second_lifecycle_unit);
 
     ExpectCanDiscardTrueAllReasons(first_lifecycle_unit);
     std::unique_ptr<content::WebContents> owned_contents =
         tab_strip_model_->DetachWebContentsAt(0);
     ExpectCanDiscardFalseTrivialAllReasons(first_lifecycle_unit);
 
     NoUnloadListenerTabStripModelDelegate other_tab_strip_model_delegate;
     TabStripModel other_tab_strip_model(&other_tab_strip_model_delegate,
                                         profile());
      other_tab_strip_model.AddObserver(source_);
  
    EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(testing::_));
     EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(::testing::_));
      other_tab_strip_model.AppendWebContents(CreateTestWebContents(),
                                               true);
  
     other_tab_strip_model.AppendWebContents(std::move(owned_contents), false);
      ExpectCanDiscardTrueAllReasons(first_lifecycle_unit);
  
      EXPECT_EQ(LifecycleUnitState::ACTIVE, first_lifecycle_unit->GetState());
    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));
     EXPECT_CALL(tab_observer_, OnDiscardedStateChange(::testing::_, true));
      first_lifecycle_unit->Discard(reason);
  
    testing::Mock::VerifyAndClear(&tab_observer_);
     ::testing::Mock::VerifyAndClear(&tab_observer_);
      TransitionFromPendingDiscardToDiscardedIfNeeded(reason,
                                                      first_lifecycle_unit);
  
     CloseTabsAndExpectNotifications(&other_tab_strip_model,
                                     {first_lifecycle_unit});
   }","[18, 27, 31, 17, 26, 30]","Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects."
201614," struct key *key_get_instantiation_authkey(key_serial_t target_id)
 {
 	char description[16];
 	struct keyring_search_context ctx = {
  		.index_key.type		= &key_type_request_key_auth,
  		.index_key.description	= description,
  		.cred			= current_cred(),
		.match_data.cmp		= user_match,
 		.match_data.cmp		= key_default_cmp,
  		.match_data.raw_data	= description,
  		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
  	};
 	struct key *authkey;
 	key_ref_t authkey_ref;
 
 	sprintf(description, ""%x"", target_id);
 
 	authkey_ref = search_process_keyrings(&ctx);
 
 	if (IS_ERR(authkey_ref)) {
 		authkey = ERR_CAST(authkey_ref);
 		if (authkey == ERR_PTR(-EAGAIN))
 			authkey = ERR_PTR(-ENOKEY);
 		goto error;
 	}
 
 	authkey = key_ref_to_ptr(authkey_ref);
 	if (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
 		key_put(authkey);
 		authkey = ERR_PTR(-EKEYREVOKED);
 	}
 
 error:
 	return authkey;
 }","[9, 8]","The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c."
200654," static long restore_tm_sigcontexts(struct pt_regs *regs,
 				   struct sigcontext __user *sc,
 				   struct sigcontext __user *tm_sc)
 {
 #ifdef CONFIG_ALTIVEC
 	elf_vrreg_t __user *v_regs, *tm_v_regs;
 #endif
 	unsigned long err = 0;
 	unsigned long msr;
 #ifdef CONFIG_VSX
 	int i;
 #endif
 	 
 	err |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));
 	err |= __copy_from_user(&current->thread.ckpt_regs, sc->gp_regs,
 				sizeof(regs->gpr));
 
 	 
 	err |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);
 	err |= __get_user(current->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);
  
  	 
  	err |= __get_user(msr, &sc->gp_regs[PT_MSR]);
 	 
 	if (MSR_TM_RESV(msr))
 		return -EINVAL;
 
  	 
  	regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);
  
 	 
 	regs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);
 
 	 
 	err |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);
 	err |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);
 	err |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);
 	err |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);
 	err |= __get_user(current->thread.ckpt_regs.ctr,
 			  &sc->gp_regs[PT_CTR]);
 	err |= __get_user(current->thread.ckpt_regs.link,
 			  &sc->gp_regs[PT_LNK]);
 	err |= __get_user(current->thread.ckpt_regs.xer,
 			  &sc->gp_regs[PT_XER]);
 	err |= __get_user(current->thread.ckpt_regs.ccr,
 			  &sc->gp_regs[PT_CCR]);
 
 	 
 	err |= __get_user(regs->trap, &sc->gp_regs[PT_TRAP]);
 	err |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);
 	err |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);
 	err |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);
 
 	 
 	discard_lazy_cpu_state();
 
 	 
 	regs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);
 
 #ifdef CONFIG_ALTIVEC
 	err |= __get_user(v_regs, &sc->v_regs);
 	err |= __get_user(tm_v_regs, &tm_sc->v_regs);
 	if (err)
 		return err;
 	if (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))
 		return -EFAULT;
 	if (tm_v_regs && !access_ok(VERIFY_READ,
 				    tm_v_regs, 34 * sizeof(vector128)))
 		return -EFAULT;
 	 
 	if (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {
 		err |= __copy_from_user(&current->thread.vr_state, v_regs,
 					33 * sizeof(vector128));
 		err |= __copy_from_user(&current->thread.transact_vr, tm_v_regs,
 					33 * sizeof(vector128));
 	}
 	else if (current->thread.used_vr) {
 		memset(&current->thread.vr_state, 0, 33 * sizeof(vector128));
 		memset(&current->thread.transact_vr, 0, 33 * sizeof(vector128));
 	}
 	 
 	if (v_regs != NULL && tm_v_regs != NULL) {
 		err |= __get_user(current->thread.vrsave,
 				  (u32 __user *)&v_regs[33]);
 		err |= __get_user(current->thread.transact_vrsave,
 				  (u32 __user *)&tm_v_regs[33]);
 	}
 	else {
 		current->thread.vrsave = 0;
 		current->thread.transact_vrsave = 0;
 	}
 	if (cpu_has_feature(CPU_FTR_ALTIVEC))
 		mtspr(SPRN_VRSAVE, current->thread.vrsave);
 #endif  
 	 
 	err |= copy_fpr_from_user(current, &sc->fp_regs);
 	err |= copy_transact_fpr_from_user(current, &tm_sc->fp_regs);
 #ifdef CONFIG_VSX
 	 
 	if (v_regs && ((msr & MSR_VSX) != 0)) {
 		v_regs += ELF_NVRREG;
 		tm_v_regs += ELF_NVRREG;
 		err |= copy_vsx_from_user(current, v_regs);
 		err |= copy_transact_vsx_from_user(current, tm_v_regs);
 	} else {
 		for (i = 0; i < 32 ; i++) {
 			current->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;
 			current->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;
 		}
 	}
 #endif
 	tm_enable();
 	 
 	current->thread.tm_texasr |= TEXASR_FS;
 	 
 	tm_recheckpoint(&current->thread, msr);
 
 	 
 	if (msr & MSR_FP) {
 		do_load_up_transact_fpu(&current->thread);
 		regs->msr |= (MSR_FP | current->thread.fpexc_mode);
 	}
 #ifdef CONFIG_ALTIVEC
 	if (msr & MSR_VEC) {
 		do_load_up_transact_altivec(&current->thread);
 		regs->msr |= MSR_VEC;
 	}
 #endif
 
 	return err;
 }","[24, 25, 26, 27]","The signal implementation in the Linux kernel before 4.3.5 on powerpc platforms does not check for an MSR with both the S and T bits set, which allows local users to cause a denial of service (TM Bad Thing exception and panic) via a crafted application."
207042," void FrameLoader::StartNavigation(const FrameLoadRequest& passed_request,
                                   WebFrameLoadType frame_load_type,
                                   NavigationPolicy policy) {
   CHECK(!IsBackForwardLoadType(frame_load_type));
   DCHECK(passed_request.TriggeringEventInfo() !=
          WebTriggeringEventInfo::kUnknown);
 
   DCHECK(frame_->GetDocument());
   if (HTMLFrameOwnerElement* element = frame_->DeprecatedLocalOwner())
     element->CancelPendingLazyLoad();
 
   if (in_stop_all_loaders_)
     return;
 
   FrameLoadRequest request(passed_request);
   ResourceRequest& resource_request = request.GetResourceRequest();
   const KURL& url = resource_request.Url();
   Document* origin_document = request.OriginDocument();
 
   resource_request.SetHasUserGesture(
       LocalFrame::HasTransientUserActivation(frame_));
 
   if (!PrepareRequestForThisFrame(request))
     return;
 
   Frame* target_frame =
       request.Form() ? nullptr
                      : frame_->FindFrameForNavigation(
                            AtomicString(request.FrameName()), *frame_, url);
 
   bool should_navigate_target_frame = policy == kNavigationPolicyCurrentTab;
 
   if (target_frame && target_frame != frame_ && should_navigate_target_frame) {
     if (target_frame->IsLocalFrame() &&
         !ToLocalFrame(target_frame)->IsNavigationAllowed()) {
       return;
     }
 
     bool was_in_same_page = target_frame->GetPage() == frame_->GetPage();
 
     request.SetFrameName(""_self"");
     target_frame->Navigate(request, frame_load_type);
     Page* page = target_frame->GetPage();
     if (!was_in_same_page && page)
       page->GetChromeClient().Focus(frame_);
     return;
   }
 
   SetReferrerForFrameRequest(request);
 
   if (!target_frame && !request.FrameName().IsEmpty()) {
     if (policy == kNavigationPolicyDownload) {
       Client()->DownloadURL(resource_request,
                             DownloadCrossOriginRedirects::kFollow);
       return;   
     } else if (should_navigate_target_frame) {
       resource_request.SetFrameType(
           network::mojom::RequestContextFrameType::kAuxiliary);
       CreateWindowForRequest(request, *frame_);
       return;   
     }
   }
 
   if (!frame_->IsNavigationAllowed() ||
       frame_->GetDocument()->PageDismissalEventBeingDispatched() !=
           Document::kNoDismissal) {
     return;
   }
 
   frame_load_type = DetermineFrameLoadType(resource_request, origin_document,
                                            KURL(), frame_load_type);
 
   bool same_document_navigation =
       policy == kNavigationPolicyCurrentTab &&
       ShouldPerformFragmentNavigation(
           request.Form(), resource_request.HttpMethod(), frame_load_type, url);
 
   if (same_document_navigation) {
     CommitSameDocumentNavigation(
         url, frame_load_type, nullptr, request.ClientRedirect(),
         origin_document,
         request.TriggeringEventInfo() != WebTriggeringEventInfo::kNotFromEvent,
         nullptr  );
     return;
   }
 
   WebNavigationType navigation_type = DetermineNavigationType(
       frame_load_type, resource_request.HttpBody() || request.Form(),
       request.TriggeringEventInfo() != WebTriggeringEventInfo::kNotFromEvent);
   resource_request.SetRequestContext(
       DetermineRequestContextFromNavigationType(navigation_type));
   resource_request.SetFrameType(
       frame_->IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel
                             : network::mojom::RequestContextFrameType::kNested);
 
   mojom::blink::NavigationInitiatorPtr navigation_initiator;
   if (origin_document && origin_document->GetContentSecurityPolicy()
                              ->ExperimentalFeaturesEnabled()) {
     WebContentSecurityPolicyList initiator_csp =
         origin_document->GetContentSecurityPolicy()
             ->ExposeForNavigationalChecks();
     resource_request.SetInitiatorCSP(initiator_csp);
     auto request = mojo::MakeRequest(&navigation_initiator);
      origin_document->BindNavigationInitiatorRequest(std::move(request));
    }
  
   last_origin_document_ = origin_document;
 
    RecordLatestRequiredCSP();
 
 
 
   ModifyRequestForCSP(resource_request, origin_document);
 
   DCHECK(Client()->HasWebView());
   if (url.PotentiallyDanglingMarkup() && url.ProtocolIsInHTTPFamily()) {
     Deprecation::CountDeprecation(
         frame_, WebFeature::kCanRequestURLHTTPContainingNewline);
     return;
   }
 
   bool has_transient_activation =
       LocalFrame::HasTransientUserActivation(frame_);
   if (frame_->IsMainFrame() && origin_document &&
       frame_->GetPage() == origin_document->GetPage()) {
     LocalFrame::ConsumeTransientUserActivation(frame_);
   }
 
   Client()->BeginNavigation(
       resource_request, origin_document, nullptr  ,
       navigation_type, policy, has_transient_activation, frame_load_type,
       request.ClientRedirect() == ClientRedirectPolicy::kClientRedirect,
       request.TriggeringEventInfo(), request.Form(),
       request.ShouldCheckMainWorldContentSecurityPolicy(),
       request.GetBlobURLToken(), request.GetInputStartTime(),
       request.HrefTranslate().GetString(), std::move(navigation_initiator));
 }","[107, 108]",Incorrect inheritance of a new document's policy in Content Security Policy in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to bypass content security policy via a crafted HTML page.
207931," WORD32 ih264d_parse_islice(dec_struct_t *ps_dec,
                             UWORD16 u2_first_mb_in_slice)
 {
  dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
     UWORD32 u4_temp;
     WORD32 i_temp;
     WORD32 ret;
 
   
   
   
   
   
 
      if(ps_slice->u1_nal_ref_idc != 0)
      {
          if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(
                            ps_dec);
         {
             i_temp = ih264d_read_mmco_commands(ps_dec);
             if (i_temp < 0)
             {
                 return ERROR_DBP_MANAGER_T;
             }
             ps_dec->u4_bitoffset = i_temp;
         }
          else
              ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
      }
   
 
   
     i_temp = ps_pps->u1_pic_init_qp
  + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
  if((i_temp < 0) || (i_temp > 51))
  return ERROR_INV_RANGE_QP_T;
     ps_slice->u1_slice_qp = i_temp;
     COPYTHECONTEXT(""SH: slice_qp_delta"",
                     ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);
 
  if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
  {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);
 
  if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
  {
  return ERROR_INV_SLICE_HDR_T;
  }
         ps_slice->u1_disable_dblk_filter_idc = u4_temp;
  if(u4_temp != 1)
  {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
  << 1;
  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
  {
  return ERROR_INV_SLICE_HDR_T;
  }
             ps_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                             ps_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
  << 1;
  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
  {
  return ERROR_INV_SLICE_HDR_T;
  }
             ps_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                             ps_slice->i1_slice_beta_offset >> 1);
 
  }
  else
  {
             ps_slice->i1_slice_alpha_c0_offset = 0;
             ps_slice->i1_slice_beta_offset = 0;
  }
  }
  else
  {
         ps_slice->u1_disable_dblk_filter_idc = 0;
         ps_slice->i1_slice_alpha_c0_offset = 0;
         ps_slice->i1_slice_beta_offset = 0;
  }
 
   
   
     ps_dec->u2_mv_2mb[0] = 0;
     ps_dec->u2_mv_2mb[1] = 0;
 
 
   
     ps_dec->u1_slice_header_done = 2;
 
  if(ps_pps->u1_entropy_coding_mode)
  {
         SWITCHOFFTRACE; SWITCHONTRACECABAC;
  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
  {
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
  }
  else
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
 
         ret = ih264d_parse_islice_data_cabac(ps_dec, ps_slice,
                                              u2_first_mb_in_slice);
  if(ret != OK)
  return ret;
         SWITCHONTRACE; SWITCHOFFTRACECABAC;
  }
  else
  {
  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
  {
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
  }
  else
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
         ret = ih264d_parse_islice_data_cavlc(ps_dec, ps_slice,
                                        u2_first_mb_in_slice);
  if(ret != OK)
  return ret;
  }
 
  return OK;
 }","[23, 24, 25, 26, 27, 28, 29, 30, 21, 22]","The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142."
1145,"static void do_pclose(FILE *fin, FILE *fout) {
char buf[BUFFER_SIZE];

int64_t fptr = 0;
read_buf(fin, buf);
sscanf(buf, ""%"" PRId64, &fptr);
FILE *f = (FILE *)fptr;
int ret = ::pclose(f);

fprintf(fout, ""%d\n"", ret);
if (ret < 0) {
fprintf(fout, ""%d\n"", errno);
}
fflush(fout);
}","[2, 5, 6, 10, 12]",CRLF injection vulnerability in the LightProcess protocol implementation in hphp/util/light-process.cpp in Facebook HipHop Virtual Machine (HHVM) before 2.4.2 allows remote attackers to execute arbitrary commands by entering a \n (newline) character before the end of a string.
7992,"GF_Err latm_dmx_process(GF_Filter *filter)
{
GF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u32 pos;
u8 *data, *output;
u32 pck_size, prev_pck_size;
u64 cts = GF_FILTER_NO_TS;

if (ctx->in_error)
return ctx->in_error;


if (!ctx->duration.num)
latm_dmx_check_dur(filter, ctx);

if (ctx->opid && !ctx->is_playing)
return GF_OK;

pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
if (!ctx->latm_buffer_size) {
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
} else {
return GF_OK;
}
}

data = (char *) gf_filter_pck_get_data(pck, &pck_size);


if (ctx->timescale && pck) {
cts = gf_filter_pck_get_cts(pck);
}

prev_pck_size = ctx->latm_buffer_size;

if (pck && !ctx->resume_from) {
if (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {
ctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;
ctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);
}
memcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);
ctx->latm_buffer_size += pck_size;
}

if (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);
else gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);

if (ctx->resume_from) {
gf_bs_seek(ctx->bs, ctx->resume_from-1);
ctx->resume_from = 0;
}

if (cts == GF_FILTER_NO_TS)
prev_pck_size = 0;


while (1) {
pos = (u32) gf_bs_get_position(ctx->bs);
u8 latm_buffer[4096];
u32 latm_frame_size = 4096;
if (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;

if (ctx->in_seek) {
u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);
if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {

ctx->in_seek = GF_FALSE;
}
}

latm_dmx_check_pid(filter, ctx);

if (!ctx->is_playing) {
ctx->resume_from = pos+1;
return GF_OK;
}

if (!ctx->in_seek) {
GF_FilterSAPType sap = GF_FILTER_SAP_1;

dst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);

memcpy(output, latm_buffer, latm_frame_size);

gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);


if (ctx->acfg.base_object_type==GF_CODECID_USAC) {
if (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {
sap = GF_FILTER_SAP_1;
ctx->prev_sap = GF_TRUE;
} else {
sap = GF_FILTER_SAP_NONE;
ctx->prev_sap = GF_FALSE;
}
}
gf_filter_pck_set_sap(dst_pck, sap);

gf_filter_pck_send(dst_pck);
}
latm_dmx_update_cts(ctx);

if (prev_pck_size) {
pos = (u32) gf_bs_get_position(ctx->bs);
if (prev_pck_size<=pos) {
prev_pck_size=0;
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = pck;
if (pck)
gf_filter_pck_ref_props(&ctx->src_pck);
}
}
}

if (pck) {
pos = (u32) gf_bs_get_position(ctx->bs);
assert(ctx->latm_buffer_size >= pos);
memmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);
ctx->latm_buffer_size -= pos;
gf_filter_pid_drop_packet(ctx->ipid);
assert(!ctx->resume_from);
} else {
ctx->latm_buffer_size = 0;
return latm_dmx_process(filter);
}
return GF_OK;
}","[6, 7, 35, 35]","In filters/reframe_latm.c in GPAC 1.0.1 there is a Null Pointer Dereference, when gf_filter_pck_get_data is called. The first arg pck may be null with a crafted mp4 file,which results in a crash."
207370," int Effect_command(effect_handle_t  self,
  uint32_t            cmdCode,
  uint32_t            cmdSize,
  void *pCmdData,
  uint32_t *replySize,
  void *pReplyData){
  EffectContext * pContext = (EffectContext *) self;
  int retsize;
 
 
  if(pContext->EffectType == LVM_BASS_BOOST){
  }
  if(pContext->EffectType == LVM_VIRTUALIZER){
  }
  if(pContext->EffectType == LVM_EQUALIZER){
  }
  if(pContext->EffectType == LVM_VOLUME){
  }
 
  if (pContext == NULL){
         ALOGV(""\tLVM_ERROR : Effect_command ERROR pContext == NULL"");
  return -EINVAL;
  }
 
 
 
 
  
      switch (cmdCode){
          case EFFECT_CMD_INIT:
            if (pReplyData == NULL || *replySize != sizeof(int)){
             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
                  ALOGV(""\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d"",
                          pContext->EffectType);
                  return -EINVAL;
  }
  *(int *) pReplyData = 0;
  if(pContext->EffectType == LVM_BASS_BOOST){
                 android::BassSetStrength(pContext, 0);
  }
  if(pContext->EffectType == LVM_VIRTUALIZER){
                 android::VirtualizerSetStrength(pContext, 0);
  }
  if(pContext->EffectType == LVM_EQUALIZER){
                 android::EqualizerSetPreset(pContext, 0);
  }
  if(pContext->EffectType == LVM_VOLUME){
  *(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);
  }
  break;
 
  
          case EFFECT_CMD_SET_CONFIG:
            if (pCmdData    == NULL||
                cmdSize     != sizeof(effect_config_t)||
                pReplyData  == NULL||
                *replySize  != sizeof(int)){
             if (pCmdData    == NULL || cmdSize     != sizeof(effect_config_t) ||
                     pReplyData  == NULL || replySize == NULL || *replySize  != sizeof(int)) {
                  ALOGV(""\tLVM_ERROR : Effect_command cmdCode Case: ""
                          ""EFFECT_CMD_SET_CONFIG: ERROR"");
                  return -EINVAL;
  }
  *(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);
 
              break;
  
          case EFFECT_CMD_GET_CONFIG:
            if (pReplyData == NULL ||
                *replySize != sizeof(effect_config_t)) {
             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {
                  ALOGV(""\tLVM_ERROR : Effect_command cmdCode Case: ""
                          ""EFFECT_CMD_GET_CONFIG: ERROR"");
                  return -EINVAL;
  }
 
             android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);
  break;
 
  case EFFECT_CMD_RESET:
             android::Effect_setConfig(pContext, &pContext->config);
  break;
 
 
          case EFFECT_CMD_GET_PARAM:{
  
             effect_param_t *p = (effect_param_t *)pCmdData;
 
             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||
                     cmdSize < (sizeof(effect_param_t) + p->psize) ||
                     pReplyData == NULL || replySize == NULL ||
                     *replySize < (sizeof(effect_param_t) + p->psize)) {
                 ALOGV(""\tLVM_ERROR : EFFECT_CMD_GET_PARAM: ERROR"");
                 return -EINVAL;
             }
 
             memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
 
             p = (effect_param_t *)pReplyData;
 
             int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
 
              if(pContext->EffectType == LVM_BASS_BOOST){
                if (pCmdData == NULL ||
                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                        pReplyData == NULL ||
                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){
                    ALOGV(""\tLVM_ERROR : BassBoost_command cmdCode Case: ""
                            ""EFFECT_CMD_GET_PARAM: ERROR"");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
                  p->status = android::BassBoost_getParameter(pContext,
                                                              p->data,
                                                              &p->vsize,
                                                              p->data + voffset);
                *replySize = sizeof(effect_param_t) + voffset + p->vsize;
 
              }
  
              if(pContext->EffectType == LVM_VIRTUALIZER){
                if (pCmdData == NULL ||
                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                        pReplyData == NULL ||
                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){
                    ALOGV(""\tLVM_ERROR : Virtualizer_command cmdCode Case: ""
                            ""EFFECT_CMD_GET_PARAM: ERROR"");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
                  p->status = android::Virtualizer_getParameter(pContext,
                                                                (void *)p->data,
                                                                &p->vsize,
                                                                p->data + voffset);
                *replySize = sizeof(effect_param_t) + voffset + p->vsize;
  
  }
 
              if(pContext->EffectType == LVM_EQUALIZER){
                if (pCmdData == NULL ||
                    cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                    pReplyData == NULL ||
                    *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))) {
                    ALOGV(""\tLVM_ERROR : Equalizer_command cmdCode Case: ""
                            ""EFFECT_CMD_GET_PARAM"");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
                  p->status = android::Equalizer_getParameter(pContext,
                                                              p->data,
                                                              &p->vsize,
                                                              p->data + voffset);
  
                *replySize = sizeof(effect_param_t) + voffset + p->vsize;
 
              }
              if(pContext->EffectType == LVM_VOLUME){
                if (pCmdData == NULL ||
                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                        pReplyData == NULL ||
                        *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){
                    ALOGV(""\tLVM_ERROR : Volume_command cmdCode Case: ""
                            ""EFFECT_CMD_GET_PARAM: ERROR"");
                    return -EINVAL;
                }
                effect_param_t *p = (effect_param_t *)pCmdData;
                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
                p = (effect_param_t *)pReplyData;
                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
                  p->status = android::Volume_getParameter(pContext,
                                                           (void *)p->data,
                                                           &p->vsize,
                                                           p->data + voffset);
  
                *replySize = sizeof(effect_param_t) + voffset + p->vsize;
              }
             *replySize = sizeof(effect_param_t) + voffset + p->vsize;
 
          } break;
          case EFFECT_CMD_SET_PARAM:{
  if(pContext->EffectType == LVM_BASS_BOOST){
 
  
                if (pCmdData   == NULL||
                    cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t))||
                    pReplyData == NULL||
                    *replySize != sizeof(int32_t)){
                 if (pCmdData   == NULL ||
                         cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||
                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
                      ALOGV(""\tLVM_ERROR : BassBoost_command cmdCode Case: ""
                              ""EFFECT_CMD_SET_PARAM: ERROR"");
                      return -EINVAL;
  }
  effect_param_t *p = (effect_param_t *) pCmdData;
 
  if (p->psize != sizeof(int32_t)){
                     ALOGV(""\tLVM_ERROR : BassBoost_command cmdCode Case: ""
  ""EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)"");
  return -EINVAL;
  }
 
 
  *(int *)pReplyData = android::BassBoost_setParameter(pContext,
  (void *)p->data,
                                                                     p->data + p->psize);
  }
  if(pContext->EffectType == LVM_VIRTUALIZER){
 
  
                  if (pCmdData   == NULL ||
                    cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||
                    cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||
                    pReplyData == NULL ||
                    *replySize != sizeof(int32_t)){
                          
                         cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||
                         cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||
                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
                      ALOGV(""\tLVM_ERROR : Virtualizer_command cmdCode Case: ""
                              ""EFFECT_CMD_SET_PARAM: ERROR"");
                      return -EINVAL;
  }
  effect_param_t *p = (effect_param_t *) pCmdData;
 
  if (p->psize != sizeof(int32_t)){
                     ALOGV(""\tLVM_ERROR : Virtualizer_command cmdCode Case: ""
  ""EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)"");
  return -EINVAL;
  }
 
 
  *(int *)pReplyData = android::Virtualizer_setParameter(pContext,
  (void *)p->data,
                                                                        p->data + p->psize);
  }
  if(pContext->EffectType == LVM_EQUALIZER){
 
  
                  if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                    pReplyData == NULL || *replySize != sizeof(int32_t)) {
                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
                      ALOGV(""\tLVM_ERROR : Equalizer_command cmdCode Case: ""
                              ""EFFECT_CMD_SET_PARAM: ERROR"");
                      return -EINVAL;
  }
  effect_param_t *p = (effect_param_t *) pCmdData;
 
  *(int *)pReplyData = android::Equalizer_setParameter(pContext,
  (void *)p->data,
                                                                      p->data + p->psize);
  }
  if(pContext->EffectType == LVM_VOLUME){
 
  
                if (    pCmdData   == NULL||
                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t))||
                        pReplyData == NULL||
                        *replySize != sizeof(int32_t)){
                 if (pCmdData   == NULL ||
                         cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t)) ||
                         pReplyData == NULL || replySize == NULL ||
                         *replySize != sizeof(int32_t)) {
                      ALOGV(""\tLVM_ERROR : Volume_command cmdCode Case: ""
                              ""EFFECT_CMD_SET_PARAM: ERROR"");
                      return -EINVAL;
  }
  effect_param_t *p = (effect_param_t *) pCmdData;
 
  *(int *)pReplyData = android::Volume_setParameter(pContext,
  (void *)p->data,
                                                                  p->data + p->psize);
  }
  } break;
 
  
          case EFFECT_CMD_ENABLE:
              ALOGV(""\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start"");
            if (pReplyData == NULL || *replySize != sizeof(int)){
             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
                  ALOGV(""\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR"");
                  return -EINVAL;
              }
 
  *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);
  break;
 
  
          case EFFECT_CMD_DISABLE:
            if (pReplyData == NULL || *replySize != sizeof(int)){
             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
                  ALOGV(""\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR"");
                  return -EINVAL;
              }
  *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);
  break;
 
 
          case EFFECT_CMD_SET_DEVICE:
          {
              ALOGV(""\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start"");
             if (pCmdData   == NULL){
                 ALOGV(""\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR"");
                 return -EINVAL;
             }
 
              uint32_t device = *(uint32_t *)pCmdData;
              pContext->pBundledContext->nOutputDevice = (audio_devices_t) device;
  
  if (pContext->EffectType == LVM_BASS_BOOST) {
  if((device == AUDIO_DEVICE_OUT_SPEAKER) ||
  (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||
  (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){
                     ALOGV(""\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d"",
  *(int32_t *)pCmdData);
                     ALOGV(""\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST"");
 
 
  if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {
                         ALOGV(""\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d"",
  *(int32_t *)pCmdData);
                         android::LvmEffect_disable(pContext);
  }
                     pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;
  } else {
                     ALOGV(""\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d"",
  *(int32_t *)pCmdData);
 
 
  if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {
                         ALOGV(""\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d"",
  *(int32_t *)pCmdData);
                         android::LvmEffect_enable(pContext);
  }
                     pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;
  }
  }
  if (pContext->EffectType == LVM_VIRTUALIZER) {
  if (pContext->pBundledContext->nVirtualizerForcedDevice == AUDIO_DEVICE_NONE) {
  if (android::VirtualizerIsDeviceSupported(device) != 0) {
                         ALOGV(""\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d"",
  *(int32_t *)pCmdData);
                         ALOGV(""\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER"");
 
 
  if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {
                             ALOGV(""\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d"",
  *(int32_t *)pCmdData);
                             android::LvmEffect_disable(pContext);
  }
                         pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;
  } else {
                         ALOGV(""\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d"",
  *(int32_t *)pCmdData);
 
 
  if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){
                             ALOGV(""\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d"",
  *(int32_t *)pCmdData);
                             android::LvmEffect_enable(pContext);
  }
                         pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;
  }
  }  
  }
             ALOGV(""\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end"");
  break;
  }
  case EFFECT_CMD_SET_VOLUME:
  {
  uint32_t leftVolume, rightVolume;
  int16_t  leftdB, rightdB;
  int16_t  maxdB, pandB;
  int32_t  vol_ret[2] = {1<<24,1<<24};  
  int      status = 0;
  LVM_ControlParams_t ActiveParams;  
             LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS;  
 
  if(pReplyData == LVM_NULL){
 
                  break;
              }
  
            if (pCmdData == NULL ||
                cmdSize != 2 * sizeof(uint32_t)) {
             if (pCmdData == NULL || cmdSize != 2 * sizeof(uint32_t) || pReplyData == NULL ||
                     replySize == NULL || *replySize < 2*sizeof(int32_t)) {
                  ALOGV(""\tLVM_ERROR : Effect_command cmdCode Case: ""
                          ""EFFECT_CMD_SET_VOLUME: ERROR"");
                  return -EINVAL;
  }
 
             leftVolume  = ((*(uint32_t *)pCmdData));
             rightVolume = ((*((uint32_t *)pCmdData + 1)));
 
  if(leftVolume == 0x1000000){
                 leftVolume -= 1;
  }
  if(rightVolume == 0x1000000){
                 rightVolume -= 1;
  }
 
             leftdB  = android::LVC_Convert_VolToDb(leftVolume);
             rightdB = android::LVC_Convert_VolToDb(rightVolume);
 
             pandB = rightdB - leftdB;
 
             maxdB = leftdB;
  if(rightdB > maxdB){
                 maxdB = rightdB;
  }
 
             memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);
             android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));
 
   
  LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);
             LVM_ERROR_CHECK(LvmStatus, ""LVM_GetControlParameters"", ""VolumeSetStereoPosition"")
  if(LvmStatus != LVM_SUCCESS) return -EINVAL;
 
   
  ActiveParams.VC_Balance  = pandB;
             ALOGV(""\t\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\n"", ActiveParams.VC_Balance );
 
   
  LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);
             LVM_ERROR_CHECK(LvmStatus, ""LVM_SetControlParameters"", ""VolumeSetStereoPosition"")
  if(LvmStatus != LVM_SUCCESS) return -EINVAL;
  break;
  }
  case EFFECT_CMD_SET_AUDIO_MODE:
  break;
  default:
  return -EINVAL;
  }
 
  return 0;
 }  ","[32, 58, 59, 71, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 186, 187, 197, 198, 199, 225, 226, 227, 228, 251, 269, 270, 271, 272, 289, 300, 311, 312, 313, 314, 315, 395, 396, 31, 54, 55, 56, 57, 69, 70, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 120, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 141, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 163, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 184, 193, 194, 195, 196, 221, 222, 223, 224, 250, 265, 266, 267, 268, 288, 299, 393, 394]","Multiple heap-based buffer overflows in libeffects in the Audio Policy Service in mediaserver in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application, aka internal bug 21953516."
197752,"  pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)
  {
         pdf_gstate *gstate = pr->gstate + pr->gtop;
         fz_matrix image_ctm;
         fz_rect bbox;
       softmask_save softmask = { NULL };
  
         if (pr->super.hidden)
                 return;
 			break;
 		case PDF_MAT_SHADE:
 			if (gstate->fill.shade)
 			{
 				fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
         bbox = fz_unit_rect;
         fz_transform_rect(&bbox, &image_ctm);
  
       if (image->mask)
        if (image->mask && gstate->blendmode)
         {
                  
               if (gstate->blendmode)
                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);
               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);
       }
       else
               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);
                fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);
  
       if (!image->colorspace)
       {
               switch (gstate->fill.kind)
                fz_try(ctx)
                        fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);
                fz_catch(ctx)
                 {
               case PDF_MAT_NONE:
                       break;
               case PDF_MAT_COLOR:
                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,
                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);
                       break;
               case PDF_MAT_PATTERN:
                       if (gstate->fill.pattern)
                       {
                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);
                               fz_pop_clip(ctx, pr->dev);
                       }
                       break;
               case PDF_MAT_SHADE:
                       if (gstate->fill.shade)
                       {
                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);
                               fz_pop_clip(ctx, pr->dev);
                       }
                       break;
                        fz_end_group(ctx, pr->dev);
                        fz_rethrow(ctx);
                 }
 
                fz_try(ctx)
                        pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);
                fz_always(ctx)
                {
                        fz_pop_clip(ctx, pr->dev);
                        fz_end_group(ctx, pr->dev);
                }
                fz_catch(ctx)
                        fz_rethrow(ctx);
         }
       else
        else if (image->mask)
         {
               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);
                fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);
                fz_try(ctx)
                        pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);
                fz_always(ctx)
                        fz_pop_clip(ctx, pr->dev);
                fz_catch(ctx)
                        fz_rethrow(ctx);
         }
       if (image->mask)
        else
         {
               fz_pop_clip(ctx, pr->dev);
               if (gstate->blendmode)
                       fz_end_group(ctx, pr->dev);
                softmask_save softmask = { NULL };
 
                gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);
 
                fz_try(ctx)
                        pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);
                fz_always(ctx)
                        pdf_end_group(ctx, pr, &softmask);
                fz_catch(ctx)
                        fz_rethrow(ctx);
         }
       else
               pdf_end_group(ctx, pr, &softmask);
  }
  
  static void
 
 		if (pr->clip)
 		{
 			gstate->clip_depth++;
 			fz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);
 			pr->clip = 0;
 		}
 
 		if (pr->super.hidden)
 			dostroke = dofill = 0;
 
 		if (dofill || dostroke)
 			gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);
 
 		if (dofill && dostroke)
 		{
 			 
 			if (gstate->stroke.alpha == 0)
 			{
 				 
 			}
 			else if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)
 			{
 				 
 			}
 			else
 			{
 				knockout_group = 1;
 				fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);
 			}
 		}
 
 		if (dofill)
 		{
 			switch (gstate->fill.kind)
 			{
 			case PDF_MAT_NONE:
 				break;
 			case PDF_MAT_COLOR:
 				fz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,
 					gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);
 				break;
 			case PDF_MAT_PATTERN:
 				if (gstate->fill.pattern)
 				{
 					fz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);
 					pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);
 					fz_pop_clip(ctx, pr->dev);
 				}
 				break;
 			case PDF_MAT_SHADE:
 				if (gstate->fill.shade)
 				{
 					fz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);
 					 
 					fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);
 					fz_pop_clip(ctx, pr->dev);
 				}
 				break;
 			}
 		}
 
 		if (dostroke)
 		{
 			switch (gstate->stroke.kind)
 			{
 			case PDF_MAT_NONE:
 				break;
 			case PDF_MAT_COLOR:
 				fz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,
 					gstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);
 				break;
 			case PDF_MAT_PATTERN:
 				if (gstate->stroke.pattern)
 				{
 					fz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);
 					pdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);
 					fz_pop_clip(ctx, pr->dev);
 				}
 				break;
 			case PDF_MAT_SHADE:
 				if (gstate->stroke.shade)
 				{
 					fz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);
 					fz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);
 					fz_pop_clip(ctx, pr->dev);
 				}
 				break;
 			}
 		}
 
 		if (knockout_group)
 			fz_end_group(ctx, pr->dev);
 
 		if (dofill || dostroke)
 			pdf_end_group(ctx, pr, &softmask);
 	}","[19, 28, 33, 34, 35, 59, 60, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 74, 77, 78, 79, 80, 81, 82, 83, 86, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 6, 18, 22, 23, 24, 25, 26, 27, 30, 31, 32, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 73, 76, 85, 88, 89, 90, 102, 103]","In MuPDF 1.12.0 and earlier, multiple reachable assertions in the PDF parser allow an attacker to cause a denial of service (assert crash) via a crafted file."
201165," void Huff_Compress(msg_t *mbuf, int offset) {
 	int			i, ch, size;
 	byte		seq[65536];
 	byte*		buffer;
 	huff_t		huff;
 
 	size = mbuf->cursize - offset;
 	buffer = mbuf->data+ + offset;
 
 	if (size<=0) {
 		return;
 	}
 
 	Com_Memset(&huff, 0, sizeof(huff_t));
 	huff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);
 	huff.tree->symbol = NYT;
 	huff.tree->weight = 0;
 	huff.lhead->next = huff.lhead->prev = NULL;
 	huff.tree->parent = huff.tree->left = huff.tree->right = NULL;
 
 	seq[0] = (size>>8);
 	seq[1] = size&0xff;
 
 	bloc = 16;
  
  	for (i=0; i<size; i++ ) {
  		ch = buffer[i];
		Huff_transmit(&huff, ch, seq);						 
 		Huff_transmit(&huff, ch, seq, size<<3);						 
  		Huff_addRef(&huff, (byte)ch);								 
  	}
  
 	bloc += 8;												 
 
 	mbuf->cursize = (bloc>>3) + offset;
 	Com_Memcpy(mbuf->data+offset, seq, (bloc>>3));
 }","[29, 28]",Buffer overflow in ioquake3 before 2017-08-02 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted packet.
205952," bool ScreenLayoutObserver::GetDisplayMessageForNotification(
     const ScreenLayoutObserver::DisplayInfoMap& old_info,
     base::string16* out_message,
     base::string16* out_additional_message) {
   if (old_display_mode_ != current_display_mode_) {
     if (current_display_mode_ == DisplayMode::MIRRORING) {
       *out_message = GetEnterMirrorModeMessage();
       return true;
     }
     if (old_display_mode_ == DisplayMode::MIRRORING &&
         GetExitMirrorModeMessage(out_message, out_additional_message)) {
       return true;
     }
 
     if (current_display_mode_ == DisplayMode::UNIFIED) {
       *out_message = GetEnterUnifiedModeMessage();
       return true;
     }
     if (old_display_mode_ == DisplayMode::UNIFIED) {
       *out_message = GetExitUnifiedModeMessage();
       return true;
     }
 
     if (current_display_mode_ == DisplayMode::DOCKED ||
         old_display_mode_ == DisplayMode::DOCKED) {
       return false;
     }
   }
 
   if (display_info_.size() < old_info.size()) {
     for (const auto& iter : old_info) {
       if (display_info_.count(iter.first))
         continue;
 
       *out_message =
           GetDisplayRemovedMessage(iter.second, out_additional_message);
       return true;
     }
   } else if (display_info_.size() > old_info.size()) {
     for (const auto& iter : display_info_) {
       if (old_info.count(iter.first))
         continue;
 
       *out_message = GetDisplayAddedMessage(iter.first, out_additional_message);
       return true;
     }
   }
 
   for (const auto& iter : display_info_) {
     DisplayInfoMap::const_iterator old_iter = old_info.find(iter.first);
     if (old_iter == old_info.end()) {
       NOTREACHED() << ""A display mode transition that should have been handled""
                       ""earlier."";
       return false;
     }
 
     if (iter.second.configured_ui_scale() !=
         old_iter->second.configured_ui_scale()) {
       *out_additional_message = l10n_util::GetStringFUTF16(
           IDS_ASH_STATUS_TRAY_DISPLAY_RESOLUTION_CHANGED,
            GetDisplayName(iter.first), GetDisplaySize(iter.first));
        return true;
      }
    if (iter.second.GetActiveRotation() !=
        old_iter->second.GetActiveRotation()) {
      
      
     if (iter.second.active_rotation_source() !=
             display::Display::ROTATION_SOURCE_ACCELEROMETER &&
         iter.second.GetActiveRotation() !=
             old_iter->second.GetActiveRotation()) {
        int rotation_text_id = 0;
        switch (iter.second.GetActiveRotation()) {
          case display::Display::ROTATE_0:
           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_STANDARD_ORIENTATION;
           break;
         case display::Display::ROTATE_90:
           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_90;
           break;
         case display::Display::ROTATE_180:
           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_180;
           break;
         case display::Display::ROTATE_270:
           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_270;
           break;
       }
       *out_additional_message = l10n_util::GetStringFUTF16(
           IDS_ASH_STATUS_TRAY_DISPLAY_ROTATED, GetDisplayName(iter.first),
           l10n_util::GetStringUTF16(rotation_text_id));
       return true;
     }
   }
 
   return false;
 }","[66, 67, 68, 69, 70, 71, 64, 65]","Google Chrome before 41.0.2272.118 does not properly handle the interaction of IPC, the Gamepad API, and Google V8, which allows remote attackers to execute arbitrary code via unspecified vectors."
199566," int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 {
 	flush_fp_to_thread(src);
  	flush_altivec_to_thread(src);
  	flush_vsx_to_thread(src);
  	flush_spe_to_thread(src);
 	 
 	__switch_to_tm(src);
 	tm_recheckpoint_new_task(src);
  
  	*dst = *src;
  
 	clear_task_ebb(dst);
 
 	return 0;
 }","[7, 8, 9]","The arch_dup_task_struct function in the Transactional Memory (TM) implementation in arch/powerpc/kernel/process.c in the Linux kernel before 3.13.7 on the powerpc platform does not properly interact with the clone and fork system calls, which allows local users to cause a denial of service (Program Check and system crash) via certain instructions that are executed with the processor in the Transactional state."
5851,"gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
{
TIFF* tif = img->tif;
tileContigRoutine put = img->put.contig;
uint32 row, y, nrow, nrowsub, rowstoread;
tmsize_t pos;
unsigned char* buf = NULL;
uint32 rowsperstrip;
uint16 subsamplinghor,subsamplingver;
uint32 imagewidth = img->width;
tmsize_t scanline;
int32 fromskew, toskew;
int ret = 1, flip;
tmsize_t maxstripsize;

TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);
if( subsamplingver == 0 ) {
TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), ""Invalid vertical YCbCr subsampling"");
return (0);
}

maxstripsize = TIFFStripSize(tif);

flip = setorientation(img);
if (flip & FLIP_VERTICALLY) {
y = h - 1;
toskew = -(int32)(w + w);
} else {
y = 0;
toskew = -(int32)(w - w);
}

TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);

scanline = TIFFScanlineSize(tif);
fromskew = (w < imagewidth ? imagewidth - w : 0);
for (row = 0; row < h; row += nrow)
{
rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;
nrow = (row + rowstoread > h ? h - row : rowstoread);
nrowsub = nrow;
if ((nrowsub%subsamplingver)!=0)
nrowsub+=subsamplingver-nrowsub%subsamplingver;
if (_TIFFReadEncodedStripAndAllocBuffer(tif,
TIFFComputeStrip(tif,row+img->row_offset, 0),
(void**)(&buf),
maxstripsize,
((row + img->row_offset)%rowsperstrip + nrowsub) * scanline)==(tmsize_t)(-1)
&& (buf == NULL || img->stoponerr))
{
ret = 0;
break;
}

pos = ((row + img->row_offset) % rowsperstrip) * scanline +
((tmsize_t) img->col_offset * img->samplesperpixel);
(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);
y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);
}

if (flip & FLIP_HORIZONTALLY) {
uint32 line;

for (line = 0; line < h; line++) {
uint32 *left = raster + (line * w);
uint32 *right = left + w - 1;

while ( left < right ) {
uint32 temp = *left;
*left = *right;
*right = temp;
left++;
right--;
}
}
}

_TIFFfree(buf);
return (ret);
}","[39, 44, 48]","tif_getimage.c in LibTIFF through 4.0.10, as used in GDAL through 3.0.1 and other products, has an integer overflow that potentially causes a heap-based buffer overflow via a crafted RGBA image, related to a ""Negative-size-param"" condition."
198892," nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,
 		    struct nfs_getaclres *res)
 {
 	struct compound_hdr hdr;
 	int status;
 
 	status = decode_compound_hdr(xdr, &hdr);
 	if (status)
 		goto out;
 	status = decode_sequence(xdr, &res->seq_res, rqstp);
 	if (status)
 		goto out;
  	status = decode_putfh(xdr);
  	if (status)
  		goto out;
	status = decode_getacl(xdr, rqstp, &res->acl_len);
 	status = decode_getacl(xdr, rqstp, res);
  
  out:
  	return status;
 }","[17, 16]","The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words."
200108," static int wddx_stack_destroy(wddx_stack *stack)
 {
 	register int i;
  
  	if (stack->elements) {
  		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
 			if (((st_entry *)stack->elements[i])->data
 					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
  				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
  			}
  			if (((st_entry *)stack->elements[i])->varname) {
 				efree(((st_entry *)stack->elements[i])->varname);
 			}
 			efree(stack->elements[i]);
 		}
 		efree(stack->elements);
 	}
 	return SUCCESS;
 }","[8, 9, 7]","Use-after-free vulnerability in the wddx_stack_destroy function in ext/wddx/wddx.c in PHP before 5.6.26 and 7.x before 7.0.11 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a wddxPacket XML document that lacks an end-tag for a recordset field element, leading to mishandling in a wddx_deserialize call."
198656," ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
 {
 	struct session_state *state = ssh->state;
 	u_int padlen, need;
 	u_char *cp;
 	u_int maclen, aadlen = 0, authlen = 0, block_size;
 	struct sshenc *enc   = NULL;
 	struct sshmac *mac   = NULL;
 	struct sshcomp *comp = NULL;
 	int r;
 
 	*typep = SSH_MSG_NONE;
 
 	if (state->packet_discard)
 		return 0;
 
 	if (state->newkeys[MODE_IN] != NULL) {
 		enc  = &state->newkeys[MODE_IN]->enc;
 		mac  = &state->newkeys[MODE_IN]->mac;
 		comp = &state->newkeys[MODE_IN]->comp;
 		 
 		if ((authlen = cipher_authlen(enc->cipher)) != 0)
 			mac = NULL;
 	}
 	maclen = mac && mac->enabled ? mac->mac_len : 0;
 	block_size = enc ? enc->block_size : 8;
 	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;
 
 	if (aadlen && state->packlen == 0) {
 		if (cipher_get_length(state->receive_context,
 		    &state->packlen, state->p_read.seqnr,
 		    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)
 			return 0;
 		if (state->packlen < 1 + 4 ||
 		    state->packlen > PACKET_MAX_SIZE) {
 #ifdef PACKET_DEBUG
 			sshbuf_dump(state->input, stderr);
 #endif
 			logit(""Bad packet length %u."", state->packlen);
 			if ((r = sshpkt_disconnect(ssh, ""Packet corrupt"")) != 0)
 				return r;
 			return SSH_ERR_CONN_CORRUPT;
 		}
 		sshbuf_reset(state->incoming_packet);
 	} else if (state->packlen == 0) {
 		 
 		if (sshbuf_len(state->input) < block_size)
 			return 0;
 		sshbuf_reset(state->incoming_packet);
 		if ((r = sshbuf_reserve(state->incoming_packet, block_size,
 		    &cp)) != 0)
 			goto out;
 		if ((r = cipher_crypt(state->receive_context,
 		    state->p_send.seqnr, cp, sshbuf_ptr(state->input),
 		    block_size, 0, 0)) != 0)
 			goto out;
 		state->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));
 		if (state->packlen < 1 + 4 ||
 		    state->packlen > PACKET_MAX_SIZE) {
 #ifdef PACKET_DEBUG
 			fprintf(stderr, ""input: \n"");
 			sshbuf_dump(state->input, stderr);
 			fprintf(stderr, ""incoming_packet: \n"");
 			sshbuf_dump(state->incoming_packet, stderr);
 #endif
 			logit(""Bad packet length %u."", state->packlen);
 			return ssh_packet_start_discard(ssh, enc, mac, 0,
 			    PACKET_MAX_SIZE);
 		}
 		if ((r = sshbuf_consume(state->input, block_size)) != 0)
 			goto out;
 	}
 	DBG(debug(""input: packet len %u"", state->packlen+4));
 
 	if (aadlen) {
 		 
 		need = state->packlen;
 	} else {
 		 
 		need = 4 + state->packlen - block_size;
 	}
 	DBG(debug(""partial packet: block %d, need %d, maclen %d, authlen %d,""
 	    "" aadlen %d"", block_size, need, maclen, authlen, aadlen));
 	if (need % block_size != 0) {
 		logit(""padding error: need %d block %d mod %d"",
 		    need, block_size, need % block_size);
 		return ssh_packet_start_discard(ssh, enc, mac, 0,
 		    PACKET_MAX_SIZE - block_size);
 	}
 	 
 	if (sshbuf_len(state->input) < aadlen + need + authlen + maclen)
 		return 0;  
 #ifdef PACKET_DEBUG
 	fprintf(stderr, ""read_poll enc/full: "");
 	sshbuf_dump(state->input, stderr);
 #endif
 	 
 	if (mac && mac->enabled && mac->etm) {
 		if ((r = mac_check(mac, state->p_read.seqnr,
 		    sshbuf_ptr(state->input), aadlen + need,
 		    sshbuf_ptr(state->input) + aadlen + need + authlen,
 		    maclen)) != 0) {
 			if (r == SSH_ERR_MAC_INVALID)
 				logit(""Corrupted MAC on input."");
 			goto out;
 		}
 	}
 	if ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,
 	    &cp)) != 0)
 		goto out;
 	if ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,
 	    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)
 		goto out;
 	if ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)
 		goto out;
 	if (mac && mac->enabled) {
 		 
 		if (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,
 		    sshbuf_ptr(state->incoming_packet),
 		    sshbuf_len(state->incoming_packet),
 		    sshbuf_ptr(state->input), maclen)) != 0) {
 			if (r != SSH_ERR_MAC_INVALID)
 				goto out;
 			logit(""Corrupted MAC on input."");
 			if (need > PACKET_MAX_SIZE)
 				return SSH_ERR_INTERNAL_ERROR;
 			return ssh_packet_start_discard(ssh, enc, mac,
 			    sshbuf_len(state->incoming_packet),
 			    PACKET_MAX_SIZE - need);
 		}
 		 
 		DBG(debug(""MAC #%d ok"", state->p_read.seqnr));
 		if ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)
 			goto out;
 	}
 	if (seqnr_p != NULL)
 		*seqnr_p = state->p_read.seqnr;
 	if (++state->p_read.seqnr == 0)
 		logit(""incoming seqnr wraps around"");
 	if (++state->p_read.packets == 0)
 		if (!(ssh->compat & SSH_BUG_NOREKEY))
 			return SSH_ERR_NEED_REKEY;
 	state->p_read.blocks += (state->packlen + 4) / block_size;
 	state->p_read.bytes += state->packlen + 4;
 
 	 
 	padlen = sshbuf_ptr(state->incoming_packet)[4];
 	DBG(debug(""input: padlen %d"", padlen));
 	if (padlen < 4)	{
 		if ((r = sshpkt_disconnect(ssh,
 		    ""Corrupted padlen %d on input."", padlen)) != 0 ||
 		    (r = ssh_packet_write_wait(ssh)) != 0)
 			return r;
 		return SSH_ERR_CONN_CORRUPT;
 	}
 
 	 
 	if ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||
 	    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))
 		goto out;
 
 	DBG(debug(""input: len before de-compress %zd"",
 	    sshbuf_len(state->incoming_packet)));
 	if (comp && comp->enabled) {
 		sshbuf_reset(state->compression_buffer);
 		if ((r = uncompress_buffer(ssh, state->incoming_packet,
 		    state->compression_buffer)) != 0)
 			goto out;
 		sshbuf_reset(state->incoming_packet);
 		if ((r = sshbuf_putb(state->incoming_packet,
 		    state->compression_buffer)) != 0)
 			goto out;
 		DBG(debug(""input: len after de-compress %zd"",
 		    sshbuf_len(state->incoming_packet)));
 	}
 	 
 	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
 		goto out;
 	if (ssh_packet_log_type(*typep))
 		debug3(""receive packet: type %u"", *typep);
 	if (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {
 		if ((r = sshpkt_disconnect(ssh,
 		    ""Invalid ssh2 packet type: %d"", *typep)) != 0 ||
 		    (r = ssh_packet_write_wait(ssh)) != 0)
  			return r;
  		return SSH_ERR_PROTOCOL_ERROR;
  	}
	if (*typep == SSH2_MSG_NEWKEYS)
		r = ssh_set_newkeys(ssh, MODE_IN);
	else if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
 	if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
  		r = ssh_packet_enable_delayed_compress(ssh);
  	else
  		r = 0;
 	else
 		r = 0;
 #ifdef PACKET_DEBUG
 	fprintf(stderr, ""read/plain[%d]:\r\n"", *typep);
 	sshbuf_dump(state->incoming_packet, stderr);
 #endif
 	 
 	state->packlen = 0;
 
 	 
 	if (ssh_packet_need_rekeying(ssh, 0)) {
 		debug3(""%s: rekex triggered"", __func__);
 		if ((r = kex_start_rekex(ssh)) != 0)
 			return r;
 	}
  out:
 	return r;
 }","[191, 188, 189, 190]","sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c."
205159," void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)
 {
     RenderStyle* oldStyle = style();
  
      setReplaced(newStyle.isDisplayInlineType());
  
    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {
     if (oldStyle && parent() && diff.needsFullLayout() && oldStyle->position() != newStyle.position()) {
          if (newStyle.position() == StaticPosition)
             removePositionedObjects(0, NewContainingBlock);
         else if (oldStyle->position() == StaticPosition) {
             RenderObject* cb = parent();
             while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {
                 if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {
                     cb = cb->containingBlock();
                     break;
                 }
                 cb = cb->parent();
             }
 
             if (cb->isRenderBlock())
                 toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);
         }
     }
 
     RenderBox::styleWillChange(diff, newStyle);
 }","[8, 7]",The Web Audio implementation in Google Chrome before 25.0.1364.152 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors.
205890," static bool ExecuteTranspose(LocalFrame& frame,
                               Event*,
                               EditorCommandSource,
                               const String&) {
  frame.GetEditor().Transpose();
   Transpose(frame);
    return true;
  }","[6, 5]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
206372,"  void PrintViewManager::PrintPreviewDone() {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK_NE(NOT_PREVIEWING, print_preview_state_);
   if (print_preview_state_ == NOT_PREVIEWING)
     return;
  
    if (print_preview_state_ == SCRIPTED_PREVIEW) {
      auto& map = g_scripted_print_preview_closure_map.Get();
     auto it = map.find(scripted_print_preview_rph_);
     CHECK(it != map.end());
     it->second.Run();
     map.erase(it);
     scripted_print_preview_rph_ = nullptr;
   }
   print_preview_state_ = NOT_PREVIEWING;
   print_preview_rfh_ = nullptr;
 }","[4, 5, 3]",A use after free in printing in Google Chrome prior to 57.0.2987.133 for Linux and Windows allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
201375," int yr_re_match(
     RE* re,
     const char* target)
 {
   return yr_re_exec(
        re->code,
        (uint8_t*) target,
        strlen(target),
       0,
        re->flags | RE_FLAGS_SCAN,
        NULL,
        NULL);
 }",[9],libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.
204532,"   ReleaseAccelerator(ui::KeyboardCode keycode,
                     bool shift_pressed,
                     bool ctrl_pressed,
                     bool alt_pressed)
      : ui::Accelerator(keycode, shift_pressed, ctrl_pressed, alt_pressed) {
   ReleaseAccelerator(ui::KeyboardCode keycode, int modifiers)
       : ui::Accelerator(keycode, modifiers) {
      set_type(ui::ET_KEY_RELEASED);
    }","[6, 7, 2, 3, 4, 5]",Use-after-free vulnerability in the PDF functionality in Google Chrome before 21.0.1180.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted document.
198740," static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		       size_t len)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct ipcm_cookie ipc;
 	struct rtable *rt = NULL;
 	int free = 0;
 	__be32 daddr;
  	__be32 saddr;
  	u8  tos;
  	int err;
 	struct ip_options_data opt_copy;
  
  	err = -EMSGSIZE;
  	if (len > 0xFFFF)
 		goto out;
 
 	 
 
 	err = -EOPNOTSUPP;
 	if (msg->msg_flags & MSG_OOB)	 
 		goto out;                
 
 	 
 
 	if (msg->msg_namelen) {
 		struct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;
 		err = -EINVAL;
 		if (msg->msg_namelen < sizeof(*usin))
 			goto out;
 		if (usin->sin_family != AF_INET) {
 			static int complained;
 			if (!complained++)
 				printk(KERN_INFO ""%s forgot to set AF_INET in ""
 						 ""raw sendmsg. Fix it!\n"",
 						 current->comm);
 			err = -EAFNOSUPPORT;
 			if (usin->sin_family)
 				goto out;
 		}
 		daddr = usin->sin_addr.s_addr;
 		 
 	} else {
 		err = -EDESTADDRREQ;
 		if (sk->sk_state != TCP_ESTABLISHED)
 			goto out;
 		daddr = inet->inet_daddr;
 	}
 
 	ipc.addr = inet->inet_saddr;
 	ipc.opt = NULL;
 	ipc.tx_flags = 0;
 	ipc.oif = sk->sk_bound_dev_if;
 
 	if (msg->msg_controllen) {
 		err = ip_cmsg_send(sock_net(sk), msg, &ipc);
 		if (err)
 			goto out;
 		if (ipc.opt)
 			free = 1;
 	}
 
  	saddr = ipc.addr;
  	ipc.addr = daddr;
  
	if (!ipc.opt)
		ipc.opt = inet->opt;
 	if (!ipc.opt) {
 		struct ip_options_rcu *inet_opt;
 
 		rcu_read_lock();
 		inet_opt = rcu_dereference(inet->inet_opt);
 		if (inet_opt) {
 			memcpy(&opt_copy, inet_opt,
 			       sizeof(*inet_opt) + inet_opt->opt.optlen);
 			ipc.opt = &opt_copy.opt;
 		}
 		rcu_read_unlock();
 	}
  
  	if (ipc.opt) {
  		err = -EINVAL;
 		 
  		if (inet->hdrincl)
  			goto done;
		if (ipc.opt->srr) {
 		if (ipc.opt->opt.srr) {
  			if (!daddr)
  				goto done;
			daddr = ipc.opt->faddr;
 			daddr = ipc.opt->opt.faddr;
  		}
  	}
  	tos = RT_CONN_FLAGS(sk);
 	if (msg->msg_flags & MSG_DONTROUTE)
 		tos |= RTO_ONLINK;
 
 	if (ipv4_is_multicast(daddr)) {
 		if (!ipc.oif)
 			ipc.oif = inet->mc_index;
 		if (!saddr)
 			saddr = inet->mc_addr;
 	}
 
 	{
 		struct flowi4 fl4;
 
 		flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
 				   RT_SCOPE_UNIVERSE,
 				   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,
 				   FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0);
 
 		if (!inet->hdrincl) {
 			err = raw_probe_proto_opt(&fl4, msg);
 			if (err)
 				goto done;
 		}
 
 		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
 		rt = ip_route_output_flow(sock_net(sk), &fl4, sk);
 		if (IS_ERR(rt)) {
 			err = PTR_ERR(rt);
 			rt = NULL;
 			goto done;
 		}
 	}
 
 	err = -EACCES;
 	if (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))
 		goto done;
 
 	if (msg->msg_flags & MSG_CONFIRM)
 		goto do_confirm;
 back_from_confirm:
 
 	if (inet->hdrincl)
 		err = raw_send_hdrinc(sk, msg->msg_iov, len,
 					&rt, msg->msg_flags);
 
 	 else {
 		if (!ipc.addr)
 			ipc.addr = rt->rt_dst;
 		lock_sock(sk);
 		err = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, len, 0,
 					&ipc, &rt, msg->msg_flags);
 		if (err)
 			ip_flush_pending_frames(sk);
 		else if (!(msg->msg_flags & MSG_MORE)) {
 			err = ip_push_pending_frames(sk);
 			if (err == -ENOBUFS && !inet->recverr)
 				err = 0;
 		}
 		release_sock(sk);
 	}
 done:
 	if (free)
 		kfree(ipc.opt);
 	ip_rt_put(rt);
 
 out:
 	if (err < 0)
 		return err;
 	return len;
 
 do_confirm:
 	dst_confirm(&rt->dst);
 	if (!(msg->msg_flags & MSG_PROBE) || len)
 		goto back_from_confirm;
 	err = 0;
 	goto done;
 }","[12, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 87, 91, 66, 67, 86, 90]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
199603," static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)
 {
 	zval *IM, *POINTS;
 	long NPOINTS, COL;
 	zval **var = NULL;
 	gdImagePtr im;
 	gdPointPtr points;
 	int npoints, col, nelem, i;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rall"", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {
 		return;
 	}
 
 	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
 
 	npoints = NPOINTS;
 	col = COL;
 
 	nelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));
 	if (nelem < 6) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have at least 3 points in your array"");
 		RETURN_FALSE;
 	}
 	if (npoints <= 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must give a positive number of points"");
 		RETURN_FALSE;
 	}
 	if (nelem < npoints * 2) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Trying to use %d points in array with only %d points"", npoints, nelem/2);
 		RETURN_FALSE;
 	}
 
 	points = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);
  
  	for (i = 0; i < npoints; i++) {
  		if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {
			SEPARATE_ZVAL((var));
			convert_to_long(*var);
			points[i].x = Z_LVAL_PP(var);
 			if (Z_TYPE_PP(var) != IS_LONG) {
 				zval lval;
 				lval = **var;
 				zval_copy_ctor(&lval);
 				convert_to_long(&lval);
 				points[i].x = Z_LVAL(lval);
 			} else {
 				points[i].x = Z_LVAL_PP(var);
 			}
  		}
  		if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {
			SEPARATE_ZVAL(var);
			convert_to_long(*var);
			points[i].y = Z_LVAL_PP(var);
 			if (Z_TYPE_PP(var) != IS_LONG) {
 				zval lval;
 				lval = **var;
 				zval_copy_ctor(&lval);
 				convert_to_long(&lval);
 				points[i].y = Z_LVAL(lval);
 			} else {
 				points[i].y = Z_LVAL_PP(var);
 			}
  		}
  	}
  
 	if (filled) {
 		gdImageFilledPolygon(im, points, npoints, col);
 	} else {
 		gdImagePolygon(im, points, npoints, col);
 	}
 
 	efree(points);
 	RETURN_TRUE;
 }","[40, 41, 42, 43, 44, 45, 46, 47, 48, 54, 55, 56, 57, 58, 59, 60, 61, 62, 37, 38, 39, 51, 52, 53]","ext/gd/gd.c in PHP 5.5.x before 5.5.9 does not check data types, which might allow remote attackers to obtain sensitive information by using a (1) string or (2) array data type in place of a numeric data type, as demonstrated by an imagecrop function call with a string for the x dimension value, a different vulnerability than CVE-2013-7226."
7967,"static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)
{
u32 i;
s32 pps_id;
VVC_PPS *pps;


pps_id = gf_bs_read_int_log(bs, 6, ""pps_id"");

if ((pps_id < 0) || (pps_id >= 64)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong PPS ID %d in PPS\n"", pps_id));
return -1;
}
pps = &vvc->pps[pps_id];

if (!pps->state) {
pps->id = pps_id;
pps->state = 1;
}
pps->sps_id = gf_bs_read_int_log(bs, 4, ""sps_id"");
if (pps->sps_id >= 16) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong SPS ID %d in PPS\n"", pps->sps_id));
pps->sps_id=0;
return -1;
}
vvc->sps_active_idx = pps->sps_id;
pps->mixed_nal_types = gf_bs_read_int_log(bs, 1, ""mixed_nal_types"");
pps->width = gf_bs_read_ue_log(bs, ""width"");
pps->height = gf_bs_read_ue_log(bs, ""height"");
pps->conf_window = gf_bs_read_int_log(bs, 1, ""conformance_window_flag"");
if (pps->conf_window) {
pps->cw_left = gf_bs_read_ue_log(bs, ""conf_win_left_offset"");
pps->cw_right = gf_bs_read_ue_log(bs, ""conf_win_right_offset"");
pps->cw_top = gf_bs_read_ue_log(bs, ""conf_win_top_offset"");
pps->cw_bottom = gf_bs_read_ue_log(bs, ""conf_win_bottom_offset"");
}

if (gf_bs_read_int_log(bs, 1, ""scaling_window_explicit_signalling_flag"")) {
gf_bs_read_se_log(bs, ""scaling_win_left_offset"");
gf_bs_read_se_log(bs, ""scaling_win_right_offset"");
gf_bs_read_se_log(bs, ""scaling_win_top_offset"");
gf_bs_read_se_log(bs, ""scaling_win_bottom_offset"");
}
pps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, ""output_flag_present_flag"");
pps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, ""no_pic_partition_flag"");
pps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, ""subpic_id_mapping_present_flag"");
if (pps->subpic_id_mapping_present_flag) {
u32 pps_subpic_id_len, pps_num_subpics=0;
if (!pps->no_pic_partition_flag) {
pps_num_subpics = 1+gf_bs_read_ue_log(bs, ""pps_num_subpics_minus1"");
}
pps_subpic_id_len = 1 + gf_bs_read_ue(bs);
for (i=0; i<pps_num_subpics; i++) {
gf_bs_read_int_log_idx(bs, pps_subpic_id_len, ""subpic_id"", i);
}
}
if (!pps->no_pic_partition_flag) {
gf_bs_read_int_log(bs, 2, ""pps_log2_ctu_size_minus5"");
u32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, ""num_exp_tile_columns_minus1"");
u32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, ""num_exp_tile_rows_minus1"");
for (i=0; i<num_exp_tile_columns; i++)
gf_bs_read_ue_log_idx(bs, ""tile_column_width_minus1"", i);
for (i=0; i<num_exp_tile_rows; i++)
gf_bs_read_ue_log_idx(bs, ""tile_row_height_minus1"", i);


return pps_id;
}




return pps_id;
}",[21],There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.
201938," safe_fprintf(FILE *f, const char *fmt, ...)
 {
 	char fmtbuff_stack[256];  
 	char outbuff[256];  
 	char *fmtbuff_heap;  
 	char *fmtbuff;   
 	int fmtbuff_length;
 	int length, n;
 	va_list ap;
 	const char *p;
 	unsigned i;
 	wchar_t wc;
 	char try_wc;
 
 	 
 	fmtbuff_heap = NULL;
 	fmtbuff_length = sizeof(fmtbuff_stack);
 	fmtbuff = fmtbuff_stack;
 
 	 
 	va_start(ap, fmt);
 	length = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);
 	va_end(ap);
 
 	 
 	while (length < 0 || length >= fmtbuff_length) {
 		if (length >= fmtbuff_length)
 			fmtbuff_length = length+1;
 		else if (fmtbuff_length < 8192)
 			fmtbuff_length *= 2;
 		else if (fmtbuff_length < 1000000)
 			fmtbuff_length += fmtbuff_length / 4;
 		else {
 			length = fmtbuff_length;
 			fmtbuff_heap[length-1] = '\0';
 			break;
 		}
 		free(fmtbuff_heap);
 		fmtbuff_heap = malloc(fmtbuff_length);
 
 		 
 		if (fmtbuff_heap != NULL) {
 			fmtbuff = fmtbuff_heap;
 			va_start(ap, fmt);
 			length = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);
 			va_end(ap);
 		} else {
 			 
 			length = sizeof(fmtbuff_stack) - 1;
 			break;
 		}
 	}
 
 	 
 	if (mbtowc(NULL, NULL, 1) == -1) {  
 		 
 		free(fmtbuff_heap);
 		return;
 	}
 
 	 
 	p = fmtbuff;
 	i = 0;
 	try_wc = 1;
 	while (*p != '\0') {
 
 		 
 		if (try_wc && (n = mbtowc(&wc, p, length)) != -1) {
 			length -= n;
 			if (iswprint(wc) && wc != L'\\') {
 				 
 				while (n-- > 0)
 					outbuff[i++] = *p++;
 			} else {
 				 
 				while (n-- > 0)
 					i += (unsigned)bsdtar_expand_char(
 					    outbuff, i, *p++);
 			}
 		} else {
 			 
 			i += (unsigned)bsdtar_expand_char(outbuff, i, *p++);
 			try_wc = 0;
  		}
  
  		 
		if (i > (sizeof(outbuff) - 20)) {
 		if (i > (sizeof(outbuff) - 128)) {
  			outbuff[i] = '\0';
  			fprintf(f, ""%s"", outbuff);
  			i = 0;
 		}
 	}
 	outbuff[i] = '\0';
 	fprintf(f, ""%s"", outbuff);
 
 	 
 	free(fmtbuff_heap);
 }","[88, 87]",Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.
199586," QTN2QT(QTNode *in)
 {
 	TSQuery		out;
 	int			len;
 	int			sumlen = 0,
 				nnode = 0;
  	QTN2QTState state;
  
  	cntsize(in, &sumlen, &nnode);
 
 	if (TSQUERY_TOO_BIG(nnode, sumlen))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 				 errmsg(""tsquery is too large"")));
  	len = COMPUTESIZE(nnode, sumlen);
  
  	out = (TSQuery) palloc0(len);
 	SET_VARSIZE(out, len);
 	out->size = nnode;
 
 	state.curitem = GETQUERY(out);
 	state.operand = state.curoperand = GETOPERAND(out);
 
 	fillQT(&state, in);
 	return out;
 }","[10, 11, 12, 13, 14]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions."
207999," OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(
         OMX_BUFFERHEADERTYPE **header,
         OMX_U32 portIndex,
         OMX_PTR appPrivate,
         OMX_U32 size,
         OMX_U8 *ptr) {
 
      Mutex::Autolock autoLock(mLock);
      CHECK_LT(portIndex, mPorts.size());
  
     PortInfo *port = &mPorts.editItemAt(portIndex);
     if (size < port->mDef.nBufferSize) {
         ALOGE(""b/63522430, Buffer size is too small."");
         android_errorWriteLog(0x534e4554, ""63522430"");
         return OMX_ErrorBadParameter;
     }
 
      *header = new OMX_BUFFERHEADERTYPE;
      (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
      (*header)->nVersion.s.nVersionMajor = 1;
  (*header)->nVersion.s.nVersionMinor = 0;
  (*header)->nVersion.s.nRevision = 0;
  (*header)->nVersion.s.nStep = 0;
  (*header)->pBuffer = ptr;
  (*header)->nAllocLen = size;
  (*header)->nFilledLen = 0;
  (*header)->nOffset = 0;
  (*header)->pAppPrivate = appPrivate;
  (*header)->pPlatformPrivate = NULL;
  (*header)->pInputPortPrivate = NULL;
  (*header)->pOutputPortPrivate = NULL;
  (*header)->hMarkTargetComponent = NULL;
  (*header)->pMarkData = NULL;
  (*header)->nTickCount = 0;
  (*header)->nTimeStamp = 0;
  (*header)->nFlags = 0;
 
      (*header)->nOutputPortIndex = portIndex;
      (*header)->nInputPortIndex = portIndex;
  
    PortInfo *port = &mPorts.editItemAt(portIndex);
      CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
  
      CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);
 
     port->mBuffers.push();
 
  BufferInfo *buffer =
  &port->mBuffers.editItemAt(port->mBuffers.size() - 1);
 
     buffer->mHeader = *header;
     buffer->mOwnedByUs = false;
 
  if (port->mBuffers.size() == port->mDef.nBufferCountActual) {
         port->mDef.bPopulated = OMX_TRUE;
         checkTransitions();
  }
 
  return OMX_ErrorNone;
 }","[11, 12, 13, 14, 15, 16, 17, 41]","An information disclosure vulnerability in the Android media framework (libstagefright). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63522430."
207845," long Track::GetNext(const BlockEntry* pCurrEntry,
  const BlockEntry*& pNextEntry) const {
   assert(pCurrEntry);
   assert(!pCurrEntry->EOS());  
 
  const Block* const pCurrBlock = pCurrEntry->GetBlock();
   assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
  if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
  return -1;
 
  const Cluster* pCluster = pCurrEntry->GetCluster();
   assert(pCluster);
   assert(!pCluster->EOS());
 
  long status = pCluster->GetNext(pCurrEntry, pNextEntry);
 
  if (status < 0)  
  return status;
 
  for (int i = 0;;) {
  while (pNextEntry) {
  const Block* const pNextBlock = pNextEntry->GetBlock();
       assert(pNextBlock);
 
  if (pNextBlock->GetTrackNumber() == m_info.number)
  return 0;
 
       pCurrEntry = pNextEntry;
 
       status = pCluster->GetNext(pCurrEntry, pNextEntry);
 
  if (status < 0)  
  return status;
  }
 
     pCluster = m_pSegment->GetNext(pCluster);
 
  if (pCluster == NULL) {
       pNextEntry = GetEOS();
  return 1;
 
      }
  
      if (pCluster->EOS()) {
#if 0
            if (m_pSegment->Unparsed() <= 0)    
            {
                pNextEntry = GetEOS();
                return 1;
            }
#else
        if (m_pSegment->DoneParsing()) {
          pNextEntry = GetEOS();
          return 1;
        }
#endif
  
 
       pNextEntry = NULL;
  return E_BUFFER_NOT_FULL;
  }
 
     status = pCluster->GetFirst(pNextEntry);
 
  if (status < 0)  
  return status;
 
  if (pNextEntry == NULL)  
  continue;
 
  ++i;
 
  if (i >= 100)
  break;
  }
 
 
   pNextEntry = GetEOS();  
  return 1;
 }","[45, 46, 47, 48, 49, 50, 51, 56]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
198723," int cipso_v4_sock_setattr(struct sock *sk,
 			  const struct cipso_v4_doi *doi_def,
 			  const struct netlbl_lsm_secattr *secattr)
 {
 	int ret_val = -EPERM;
  	unsigned char *buf = NULL;
  	u32 buf_len;
  	u32 opt_len;
	struct ip_options *opt = NULL;
 	struct ip_options_rcu *old, *opt = NULL;
  	struct inet_sock *sk_inet;
  	struct inet_connection_sock *sk_conn;
  
 	 
 	if (sk == NULL)
 		return 0;
 
 	 
 	buf_len = CIPSO_V4_OPT_LEN_MAX;
 	buf = kmalloc(buf_len, GFP_ATOMIC);
 	if (buf == NULL) {
 		ret_val = -ENOMEM;
 		goto socket_setattr_failure;
 	}
 
 	ret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);
 	if (ret_val < 0)
 		goto socket_setattr_failure;
 	buf_len = ret_val;
 
 	 
 	opt_len = (buf_len + 3) & ~3;
 	opt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);
 	if (opt == NULL) {
  		ret_val = -ENOMEM;
  		goto socket_setattr_failure;
  	}
	memcpy(opt->__data, buf, buf_len);
	opt->optlen = opt_len;
	opt->cipso = sizeof(struct iphdr);
 	memcpy(opt->opt.__data, buf, buf_len);
 	opt->opt.optlen = opt_len;
 	opt->opt.cipso = sizeof(struct iphdr);
  	kfree(buf);
  	buf = NULL;
  
  	sk_inet = inet_sk(sk);
 
 	old = rcu_dereference_protected(sk_inet->inet_opt, sock_owned_by_user(sk));
  	if (sk_inet->is_icsk) {
  		sk_conn = inet_csk(sk);
		if (sk_inet->opt)
			sk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;
		sk_conn->icsk_ext_hdr_len += opt->optlen;
 		if (old)
 			sk_conn->icsk_ext_hdr_len -= old->opt.optlen;
 		sk_conn->icsk_ext_hdr_len += opt->opt.optlen;
  		sk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);
  	}
	opt = xchg(&sk_inet->opt, opt);
	kfree(opt);
 	rcu_assign_pointer(sk_inet->inet_opt, opt);
 	if (old)
 		call_rcu(&old->rcu, opt_kfree_rcu);
  
  	return 0;
  
 socket_setattr_failure:
 	kfree(buf);
 	kfree(opt);
 	return ret_val;
 }","[10, 41, 42, 43, 48, 49, 55, 56, 57, 62, 63, 64, 9, 38, 39, 40, 52, 53, 54, 60, 61]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
202281," static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
 {
 	struct ucma_multicast *mc;
 
 	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
 	if (!mc)
  		return NULL;
  
  	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
 	mc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);
  	mutex_unlock(&mut);
  	if (mc->id < 0)
  		goto error;
 
 	mc->ctx = ctx;
 	list_add_tail(&mc->list, &ctx->mc_list);
 	return mc;
 
 error:
 	kfree(mc);
 	return NULL;
 }","[11, 10]","drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free)."
200497," static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,
 					      struct sk_buff *skb,
 					      struct request_sock *req,
 					      struct dst_entry *dst,
 					      struct request_sock *req_unhash,
 					      bool *own_req)
 {
  	struct inet_request_sock *ireq = inet_rsk(req);
  	struct ipv6_pinfo *newnp;
  	const struct ipv6_pinfo *np = inet6_sk(sk);
 	struct ipv6_txoptions *opt;
  	struct inet_sock *newinet;
  	struct dccp6_sock *newdp6;
  	struct sock *newsk;
 
 	if (skb->protocol == htons(ETH_P_IP)) {
 		 
 		newsk = dccp_v4_request_recv_sock(sk, skb, req, dst,
 						  req_unhash, own_req);
 		if (newsk == NULL)
 			return NULL;
 
 		newdp6 = (struct dccp6_sock *)newsk;
 		newinet = inet_sk(newsk);
 		newinet->pinet6 = &newdp6->inet6;
 		newnp = inet6_sk(newsk);
 
 		memcpy(newnp, np, sizeof(struct ipv6_pinfo));
 
 		newnp->saddr = newsk->sk_v6_rcv_saddr;
 
 		inet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;
 		newsk->sk_backlog_rcv = dccp_v4_do_rcv;
 		newnp->pktoptions  = NULL;
 		newnp->opt	   = NULL;
 		newnp->mcast_oif   = inet6_iif(skb);
 		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
 
 		 
 
 		 
 		dccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);
 
 		return newsk;
 	}
 
 
 	if (sk_acceptq_is_full(sk))
 		goto out_overflow;
 
 	if (!dst) {
 		struct flowi6 fl6;
 
 		dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);
 		if (!dst)
 			goto out;
 	}
 
 	newsk = dccp_create_openreq_child(sk, req, skb);
 	if (newsk == NULL)
 		goto out_nonewsk;
 
 	 
 
 	__ip6_dst_store(newsk, dst, NULL, NULL);
 	newsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
 						      NETIF_F_TSO);
 	newdp6 = (struct dccp6_sock *)newsk;
 	newinet = inet_sk(newsk);
 	newinet->pinet6 = &newdp6->inet6;
 	newnp = inet6_sk(newsk);
 
 	memcpy(newnp, np, sizeof(struct ipv6_pinfo));
 
 	newsk->sk_v6_daddr	= ireq->ir_v6_rmt_addr;
 	newnp->saddr		= ireq->ir_v6_loc_addr;
 	newsk->sk_v6_rcv_saddr	= ireq->ir_v6_loc_addr;
 	newsk->sk_bound_dev_if	= ireq->ir_iif;
 
 	 
 	newinet->inet_opt = NULL;
 
 	 
 	newnp->rxopt.all = np->rxopt.all;
 
 	newnp->pktoptions = NULL;
 	newnp->opt	  = NULL;
 	newnp->mcast_oif  = inet6_iif(skb);
 	newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;
 
 	 
	if (np->opt != NULL)
		newnp->opt = ipv6_dup_options(newsk, np->opt);
 	opt = rcu_dereference(np->opt);
 	if (opt) {
 		opt = ipv6_dup_options(newsk, opt);
 		RCU_INIT_POINTER(newnp->opt, opt);
 	}
  	inet_csk(newsk)->icsk_ext_hdr_len = 0;
	if (newnp->opt != NULL)
		inet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +
						     newnp->opt->opt_flen);
 	if (opt)
 		inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
 						    opt->opt_flen;
  
  	dccp_sync_mss(newsk, dst_mtu(dst));
  
 	newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
 	newinet->inet_rcv_saddr = LOOPBACK4_IPV6;
 
 	if (__inet_inherit_port(sk, newsk) < 0) {
 		inet_csk_prepare_forced_close(newsk);
 		dccp_done(newsk);
 		goto out;
 	}
 	*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
 	 
 	if (*own_req && ireq->pktopts) {
 		newnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);
 		consume_skb(ireq->pktopts);
 		ireq->pktopts = NULL;
 		if (newnp->pktoptions)
 			skb_set_owner_r(newnp->pktoptions, newsk);
 	}
 
 	return newsk;
 
 out_overflow:
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
 out_nonewsk:
 	dst_release(dst);
 out:
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);
 	return NULL;
 }","[11, 94, 95, 96, 97, 98, 103, 104, 105, 92, 93, 100, 101, 102]","The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call."
203938,"   bool ChangeInputMethodViaIBus(const std::string& input_method_id) {
     if (!initialized_successfully_)
       return false;
 
     std::string input_method_id_to_switch = input_method_id;
 
     if (!InputMethodIsActivated(input_method_id)) {
      scoped_ptr<InputMethodDescriptors> input_methods(GetActiveInputMethods());
       scoped_ptr<input_method::InputMethodDescriptors> input_methods(
           GetActiveInputMethods());
        DCHECK(!input_methods->empty());
        if (!input_methods->empty()) {
          input_method_id_to_switch = input_methods->at(0).id;
         LOG(INFO) << ""Can't change the current input method to ""
                   << input_method_id << "" since the engine is not preloaded. ""
                   << ""Switch to "" << input_method_id_to_switch << "" instead."";
        }
      }
  
    if (chromeos::ChangeInputMethod(input_method_status_connection_,
                                    input_method_id_to_switch.c_str())) {
     if (ibus_controller_->ChangeInputMethod(input_method_id_to_switch)) {
        return true;
      }
  
     LOG(ERROR) << ""Can't switch input method to "" << input_method_id_to_switch;
     return false;
   }","[9, 10, 22, 8, 20, 21]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
203896," PassRefPtr<DocumentFragment> createFragmentFromSource(const String& markup, Element* contextElement, ExceptionCode& ec)
 PassRefPtr<DocumentFragment> createFragmentForInnerOuterHTML(const String& markup, Element* contextElement, ExceptionCode& ec)
  {
      Document* document = contextElement->document();
      RefPtr<DocumentFragment> fragment = DocumentFragment::create(document);
 
     if (document->isHTMLDocument()) {
         fragment->parseHTML(markup, contextElement);
         return fragment;
     }
 
     bool wasValid = fragment->parseXML(markup, contextElement);
     if (!wasValid) {
         ec = INVALID_STATE_ERR;
         return 0;
     }
      return fragment.release();
  }",[2],"Google Chrome before 13.0.782.107 does not prevent calls to functions in other frames, which allows remote attackers to bypass intended access restrictions via a crafted web site, related to a *cross-frame function leak.*"
206823,"  void PlatformSensorProviderMac::CreateSensorInternal(
      mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     SensorReadingSharedBuffer* reading_buffer,
      const CreateSensorCallback& callback) {
    switch (type) {
      case mojom::SensorType::AMBIENT_LIGHT: {
        scoped_refptr<PlatformSensor> sensor =
          new PlatformSensorAmbientLightMac(std::move(mapping), this);
           new PlatformSensorAmbientLightMac(reading_buffer, this);
        callback.Run(std::move(sensor));
        break;
      }
      case mojom::SensorType::ACCELEROMETER: {
        callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(
          std::move(mapping), this));
           reading_buffer, this));
        break;
      }
      case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {
        auto fusion_algorithm = std::make_unique<
            RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
      PlatformSensorFusion::Create(std::move(mapping), this,
       PlatformSensorFusion::Create(reading_buffer, this,
                                     std::move(fusion_algorithm), callback);
        break;
      }
     case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION: {
       auto orientation_quaternion_fusion_algorithm_using_euler_angles =
           std::make_unique<
               OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
               false  );
        PlatformSensorFusion::Create(
          std::move(mapping), this,
           reading_buffer, this,
            std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),
            callback);
        break;
     }
     default:
       callback.Run(nullptr);
   }
 }","[4, 10, 17, 24, 35, 3, 9, 16, 23, 34]",Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.
6120,"static void listdir(unsigned int depth, int f, void * const tls_fd,
const char *name)
{
PureFileInfo *dir;
char *names;
PureFileInfo *s;
PureFileInfo *r;
int d;

if (depth >= max_ls_depth || matches >= max_ls_files) {
return;
}
if ((dir = sreaddir(&names)) == NULL) {
addreply(226, MSG_CANT_READ_FILE, name);
return;
}
s = dir;
while (s->name_offset != (size_t) -1) {
d = 0;
if (FI_NAME(s)[0] != '.') {
d = listfile(s, NULL);
} else if (opt_a) {
if (FI_NAME(s)[1] == 0 ||
(FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {
listfile(s, NULL);
} else {
d = listfile(s, NULL);
}
}
if (!d) {
s->name_offset = (size_t) -1;
}
s++;
}
outputfiles(f, tls_fd);
r = dir;
while (opt_R && r != s) {
if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {
char *alloca_subdir;
const size_t sizeof_subdir = PATH_MAX + 1U;

if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
goto toomany;
}
if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, ""%s/%s"",
name, FI_NAME(r)), sizeof_subdir)) {
goto nolist;
}
wrstr(f, tls_fd, ""\r\n\r\n"");
wrstr(f, tls_fd, alloca_subdir);
wrstr(f, tls_fd, "":\r\n\r\n"");
listdir(depth + 1U, f, tls_fd, alloca_subdir);
nolist:
ALLOCA_FREE(alloca_subdir);
if (matches >= max_ls_files) {
goto toomany;
}
if (chdir("".."")) {
if (chdir(wd) || chdir(name)) {
die(421, LOG_ERR, ""chdir: %s"", strerror(errno));
}
}
}
r++;
}
toomany:
free(names);
free(dir);
names = NULL;
}","[8, 37, 39, 40, 42, 43, 53, 54, 67]","In Pure-FTPd 1.0.49, a stack exhaustion issue was discovered in the listdir function in ls.c."
199249,"  PHP_FUNCTION(radius_get_vendor_attr)
  {
	int res;
	const void *data;
 	const void *data, *raw;
  	int len;
  	u_int32_t vendor;
 	unsigned char type;
 	size_t data_len;
  
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &raw, &len) == FAILURE) {
  		return;
  	}
  
	res = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);
	if (res == -1) {
 	if (rad_get_vendor_attr(&vendor, &type, &data, &data_len, raw, len) == -1) {
  		RETURN_FALSE;
  	} else {
  
  		array_init(return_value);
		add_assoc_long(return_value, ""attr"", res);
 		add_assoc_long(return_value, ""attr"", type);
  		add_assoc_long(return_value, ""vendor"", vendor);
		add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);
 		add_assoc_stringl(return_value, ""data"", (char *) data, data_len, 1);
  		return;
  	}
  }","[5, 8, 9, 12, 18, 24, 27, 3, 4, 11, 16, 17, 23, 26]",Buffer overflow in the radius_get_vendor_attr function in the Radius extension before 1.2.7 for PHP allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large Vendor Specific Attributes (VSA) length value.
202765," static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,
   const size_t data_size)
 {
 #define MaxCode(number_bits)  ((one << (number_bits))-1)
 #define MaxHashTable  5003
 #define MaxGIFBits  12UL
 #define MaxGIFTable  (1UL << MaxGIFBits)
 #define GIFOutputCode(code) \
 { \
     \
   if (bits > 0) \
     datum|=(size_t) (code) << bits; \
   else \
     datum=(size_t) (code); \
   bits+=number_bits; \
   while (bits >= 8) \
   { \
       \
     packet[length++]=(unsigned char) (datum & 0xff); \
     if (length >= 254) \
       { \
         (void) WriteBlobByte(image,(unsigned char) length); \
         (void) WriteBlob(image,length,packet); \
         length=0; \
       } \
     datum>>=8; \
     bits-=8; \
   } \
   if (free_code > max_code)  \
     { \
       number_bits++; \
       if (number_bits == MaxGIFBits) \
         max_code=MaxGIFTable; \
       else \
         max_code=MaxCode(number_bits); \
     } \
 }
 
   IndexPacket
     index;
 
   short
     *hash_code,
     *hash_prefix,
     waiting_code;
 
   size_t
     bits,
     clear_code,
     datum,
     end_of_information_code,
     free_code,
     length,
     max_code,
     next_pixel,
     number_bits,
     one,
     pass;
 
   ssize_t
     displacement,
     offset,
     k,
     y;
 
   unsigned char
     *packet,
     *hash_suffix;
 
    
   assert(image != (Image *) NULL);
   one=1;
   packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));
   hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));
   hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));
   hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,
     sizeof(*hash_suffix));
   if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||
       (hash_prefix == (short *) NULL) ||
       (hash_suffix == (unsigned char *) NULL))
     {
       if (packet != (unsigned char *) NULL)
         packet=(unsigned char *) RelinquishMagickMemory(packet);
       if (hash_code != (short *) NULL)
         hash_code=(short *) RelinquishMagickMemory(hash_code);
       if (hash_prefix != (short *) NULL)
         hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);
       if (hash_suffix != (unsigned char *) NULL)
         hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);
       return(MagickFalse);
     }
    
   (void) memset(packet,0,256*sizeof(*packet));
   (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));
   (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));
   (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));
   number_bits=data_size;
   max_code=MaxCode(number_bits);
   clear_code=((short) one << (data_size-1));
   end_of_information_code=clear_code+1;
   free_code=clear_code+2;
   length=0;
   datum=0;
   bits=0;
   GIFOutputCode(clear_code);
    
   offset=0;
   pass=0;
   waiting_code=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register const IndexPacket
       *magick_restrict indexes;
 
     register const PixelPacket
       *magick_restrict p;
 
     register ssize_t
       x;
 
     p=GetVirtualPixels(image,0,offset,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     indexes=GetVirtualIndexQueue(image);
     if (y == 0)
       {
         waiting_code=(short) (*indexes);
         p++;
       }
     for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)
     {
         
       next_pixel=MagickFalse;
       displacement=1;
        index=(IndexPacket) ((size_t) GetPixelIndex(indexes+x) & 0xff);
        p++;
        k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);
        if (k >= MaxHashTable)
          k-=MaxHashTable;
      next_pixel=MagickFalse;
      displacement=1;
       if (k < 0)
         continue;
        if (hash_code[k] > 0)
          {
            if ((hash_prefix[k] == waiting_code) &&
               (hash_suffix[k] == (unsigned char) index))
             {
               waiting_code=hash_code[k];
               continue;
             }
           if (k != 0)
             displacement=MaxHashTable-k;
           for ( ; ; )
           {
             k-=displacement;
             if (k < 0)
               k+=MaxHashTable;
             if (hash_code[k] == 0)
               break;
             if ((hash_prefix[k] == waiting_code) &&
                 (hash_suffix[k] == (unsigned char) index))
               {
                 waiting_code=hash_code[k];
                 next_pixel=MagickTrue;
                 break;
               }
           }
           if (next_pixel != MagickFalse)
             continue;
         }
       GIFOutputCode(waiting_code);
       if (free_code < MaxGIFTable)
         {
           hash_code[k]=(short) free_code++;
           hash_prefix[k]=waiting_code;
           hash_suffix[k]=(unsigned char) index;
         }
       else
         {
            
           for (k=0; k < MaxHashTable; k++)
             hash_code[k]=0;
            
           free_code=clear_code+2;
           GIFOutputCode(clear_code);
           number_bits=data_size;
           max_code=MaxCode(number_bits);
         }
       waiting_code=(short) index;
     }
     if (image_info->interlace == NoInterlace)
       offset++;
     else
       switch (pass)
       {
         case 0:
         default:
         {
           offset+=8;
           if (offset >= (ssize_t) image->rows)
             {
               pass++;
               offset=4;
             }
           break;
         }
         case 1:
         {
           offset+=8;
           if (offset >= (ssize_t) image->rows)
             {
               pass++;
               offset=2;
             }
           break;
         }
         case 2:
         {
           offset+=4;
           if (offset >= (ssize_t) image->rows)
             {
               pass++;
               offset=1;
             }
           break;
         }
         case 3:
         {
           offset+=2;
           break;
         }
       }
   }
    
   GIFOutputCode(waiting_code);
   GIFOutputCode(end_of_information_code);
   if (bits > 0)
     {
        
       packet[length++]=(unsigned char) (datum & 0xff);
       if (length >= 254)
         {
           (void) WriteBlobByte(image,(unsigned char) length);
           (void) WriteBlob(image,length,packet);
           length=0;
         }
     }
    
   if (length > 0)
     {
       (void) WriteBlobByte(image,(unsigned char) length);
       (void) WriteBlob(image,length,packet);
     }
    
   hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);
   hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);
   hash_code=(short *) RelinquishMagickMemory(hash_code);
   packet=(unsigned char *) RelinquishMagickMemory(packet);
   return(MagickTrue);
 }","[133, 134, 142, 143, 140, 141]",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow in MagickCore/fourier.c in ComplexImage.
198920," jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)
 {
 	 
  	u64 nsec = (u64)jiffies * TICK_NSEC;
	long rem;
	value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);
 	u32 rem;
 	value->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);
  	value->tv_usec = rem / NSEC_PER_USEC;
  }","[7, 8, 5, 6]",The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.
203295," static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define RMT_EQUAL_RGB  1
 #define RMT_NONE  0
 #define RMT_RAW  2
 #define RT_STANDARD  1
 #define RT_ENCODED  2
 #define RT_FORMAT_RGB  3
 
   typedef struct _SUNInfo
   {
     unsigned int
       magic,
       width,
       height,
       depth,
       length,
       type,
       maptype,
       maplength;
   } SUNInfo;
 
   Image
     *image;
 
   int
     bit;
 
   MagickBooleanType
     status;
 
   MagickSizeType
     number_pixels;
 
   register Quantum
     *q;
 
   register ssize_t
     i,
     x;
 
   register unsigned char
     *p;
 
    size_t
      bytes_per_line,
      extent,
    height,
    length;
     height;
  
    ssize_t
      count,
     y;
 
   SUNInfo
     sun_info;
 
   unsigned char
     *sun_data,
     *sun_pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
   sun_info.magic=ReadBlobMSBLong(image);
   do
   {
      
     if (sun_info.magic != 0x59a66a95)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     sun_info.width=ReadBlobMSBLong(image);
     sun_info.height=ReadBlobMSBLong(image);
     sun_info.depth=ReadBlobMSBLong(image);
     sun_info.length=ReadBlobMSBLong(image);
     sun_info.type=ReadBlobMSBLong(image);
     sun_info.maptype=ReadBlobMSBLong(image);
     sun_info.maplength=ReadBlobMSBLong(image);
     extent=sun_info.height*sun_info.width;
     if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
         (sun_info.type != RT_FORMAT_RGB))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     if ((sun_info.depth == 0) || (sun_info.depth > 32))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
         (sun_info.maptype != RMT_RAW))
       ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
     image->columns=sun_info.width;
     image->rows=sun_info.height;
     image->depth=sun_info.depth <= 8 ? sun_info.depth :
       MAGICKCORE_QUANTUM_DEPTH;
     if (sun_info.depth < 24)
       {
         size_t
           one;
 
         image->colors=sun_info.maplength;
         one=1;
         if (sun_info.maptype == RMT_NONE)
           image->colors=one << sun_info.depth;
         if (sun_info.maptype == RMT_EQUAL_RGB)
           image->colors=sun_info.maplength/3;
         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     switch (sun_info.maptype)
     {
       case RMT_NONE:
         break;
       case RMT_EQUAL_RGB:
       {
         unsigned char
           *sun_colormap;
 
          
         sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
           sizeof(*sun_colormap));
         if (sun_colormap == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         count=ReadBlob(image,image->colors,sun_colormap);
         if (count != (ssize_t) image->colors)
           ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
         for (i=0; i < (ssize_t) image->colors; i++)
           image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
             sun_colormap[i]);
         count=ReadBlob(image,image->colors,sun_colormap);
         if (count != (ssize_t) image->colors)
           ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
         for (i=0; i < (ssize_t) image->colors; i++)
           image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
             sun_colormap[i]);
         count=ReadBlob(image,image->colors,sun_colormap);
         if (count != (ssize_t) image->colors)
           ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
         for (i=0; i < (ssize_t) image->colors; i++)
           image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
             sun_colormap[i]);
         sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
         break;
       }
       case RMT_RAW:
       {
         unsigned char
           *sun_colormap;
 
          
         sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
           sizeof(*sun_colormap));
         if (sun_colormap == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         count=ReadBlob(image,sun_info.maplength,sun_colormap);
         if (count != (ssize_t) sun_info.maplength)
           ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
         sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
         break;
       }
       default:
         ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
     }
     image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
       UndefinedPixelTrait;
     image->columns=sun_info.width;
     image->rows=sun_info.height;
     if (image_info->ping != MagickFalse)
       {
         (void) CloseBlob(image);
         return(GetFirstImageInList(image));
       }
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
     if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
         sun_info.length || !sun_info.length)
       ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
     number_pixels=(MagickSizeType) image->columns*image->rows;
     if ((sun_info.type != RT_ENCODED) && 
         ((number_pixels*sun_info.depth) > (8*sun_info.length)))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     bytes_per_line=sun_info.width*sun_info.depth;
     sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
       sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
     if (sun_data == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
     if (count != (ssize_t) sun_info.length)
       ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
     height=sun_info.height;
     if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
         ((bytes_per_line/sun_info.depth) != sun_info.width))
       ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
     bytes_per_line+=15;
     bytes_per_line<<=1;
     if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
       ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
     bytes_per_line>>=4;
     sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
       bytes_per_line*sizeof(*sun_pixels));
     if (sun_pixels == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     if (sun_info.type == RT_ENCODED)
       (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
         height);
     else
       {
         if (sun_info.length > (height*bytes_per_line))
           ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
         (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);
       }
     sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
      
     p=sun_pixels;
     if (sun_info.depth == 1)
       for (y=0; y < (ssize_t) image->rows; y++)
       {
         q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
         if (q == (Quantum *) NULL)
           break;
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=7; bit >= 0; bit--)
           {
             SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
               q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
             for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
             {
               SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
                 0x01),q);
               q+=GetPixelChannels(image);
             }
             p++;
           }
         if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
           p++;
         if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
               image->rows);
             if (status == MagickFalse)
               break;
           }
       }
      else
        if (image->storage_class == PseudoClass)
          {
          if (bytes_per_line == 0)
            bytes_per_line=image->columns;
          length=image->rows*(image->columns+image->columns % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               SetPixelIndex(image,*p++,q);
               q+=GetPixelChannels(image);
             }
             if ((image->columns % 2) != 0)
               p++;
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
         }
       else
         {
           size_t
             bytes_per_pixel;
 
           bytes_per_pixel=3;
           if (image->alpha_trait != UndefinedPixelTrait)
              bytes_per_pixel++;
            if (bytes_per_line == 0)
              bytes_per_line=bytes_per_pixel*image->columns;
          length=image->rows*(bytes_per_line+bytes_per_line % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (image->alpha_trait != UndefinedPixelTrait)
                 SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
               if (sun_info.type == RT_STANDARD)
                 {
                   SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                   SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                   SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                 }
               else
                 {
                   SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                   SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                   SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                 }
               if (image->colors != 0)
                 {
                   SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                     GetPixelRed(image,q)].red),q);
                   SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                     GetPixelGreen(image,q)].green),q);
                   SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                     GetPixelBlue(image,q)].blue),q);
                 }
               q+=GetPixelChannels(image);
             }
             if (((bytes_per_pixel*image->columns) % 2) != 0)
               p++;
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
         }
     if (image->storage_class == PseudoClass)
       (void) SyncImage(image,exception);
     sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     sun_info.magic=ReadBlobMSBLong(image);
     if (sun_info.magic == 0x59a66a95)
       {
          
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while (sun_info.magic == 0x59a66a95);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[50, 48, 49, 271, 272, 273, 274, 275, 276, 277, 311, 312, 313, 314, 315]",coders/sun.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted SUN file.
207499," static uint16_t transmit_data_on(int fd, uint8_t *data, uint16_t length) {
   assert(data != NULL);
   assert(length > 0);
 
  
    uint16_t transmitted_length = 0;
    while (length > 0) {
    ssize_t ret = write(fd, data + transmitted_length, length);
     ssize_t ret = TEMP_FAILURE_RETRY(write(fd, data + transmitted_length, length));
      switch (ret) {
        case -1:
          LOG_ERROR(""In %s, error writing to the serial port with fd %d: %s"", __func__, fd, strerror(errno));
  return transmitted_length;
  case 0:
  return transmitted_length;
  default:
         transmitted_length += ret;
         length -= ret;
  break;
  }
  }
 
  return transmitted_length;
 }","[9, 8]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
200311," parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,
  			    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr)
  {
  	guint32 tvb_len = tvb_reported_length (tvb);
	guint32 off     = offset;
 	guint32 off     = offset, last_off;
  	guint32 len;
  	guint   str_len;
  	guint32 ent;
 	guint32 idx;
 	guint8  peek;
  
  	DebugLog((""parse_wbxml_attr (level = %u, offset = %u)\n"", level, offset));
  	 
 	last_off = off;
  	while (off < tvb_len) {
  		peek = tvb_get_guint8 (tvb, off);
  		DebugLog((""ATTR: (top of while) level = %3u, peek = 0x%02X, ""
 			  ""off = %u, tvb_len = %u\n"", level, peek, off, tvb_len));
 		if ((peek & 0x3F) < 5) switch (peek) {  
 		case 0x00:  
 			*codepage_attr = tvb_get_guint8 (tvb, off+1);
 			proto_tree_add_text (tree, tvb, off, 2,
 					     ""      |  Attr | A -->%3d ""
 					     ""| SWITCH_PAGE (Attr code page)    |"",
 					     *codepage_attr);
 			off += 2;
 			break;
 		case 0x01:  
 			 
 			off++;
 			DebugLog((""ATTR: level = %u, Return: len = %u\n"",
 				  level, off - offset));
 			return (off - offset);
 		case 0x02:  
 			ent = tvb_get_guintvar (tvb, off+1, &len);
 			proto_tree_add_text (tree, tvb, off, 1+len,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| ENTITY                          ""
 					     ""|     %s'&#%u;'"",
 					     level, *codepage_attr, Indent (level), ent);
 			off += 1+len;
 			break;
 		case 0x03:  
 			len = tvb_strsize (tvb, off+1);
 			proto_tree_add_text (tree, tvb, off, 1+len,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| STR_I (Inline string)           ""
 					     ""|     %s\'%s\'"",
 					     level, *codepage_attr, Indent (level),
 					     tvb_format_text (tvb, off+1, len-1));
 			off += 1+len;
 			break;
 		case 0x04:  
 			idx = tvb_get_guintvar (tvb, off+1, &len);
 			str_len = tvb_strsize (tvb, str_tbl+idx);
 			proto_tree_add_text (tree, tvb, off, 1+len,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| LITERAL (Literal Attribute)     ""
 					     ""|   %s<%s />"",
 					     level, *codepage_attr, Indent (level),
 					     tvb_format_text (tvb, str_tbl+idx, str_len-1));
 			off += 1+len;
 			break;
 		case 0x40:  
 		case 0x41:  
 		case 0x42:  
 			 
 			len = tvb_strsize (tvb, off+1);
 			proto_tree_add_text (tree, tvb, off, 1+len,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| EXT_I_%1x    (Extension Token)    ""
 					     ""|     %s(Inline string extension: \'%s\')"",
 					     level, *codepage_attr, peek & 0x0f, Indent (level),
 					     tvb_format_text (tvb, off+1, len-1));
 			off += 1+len;
 			break;
 			 
 			 
 		case 0x80:  
 		case 0x81:  
 		case 0x82:  
 			 
 			idx = tvb_get_guintvar (tvb, off+1, &len);
 			proto_tree_add_text (tree, tvb, off, 1+len,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| EXT_T_%1x    (Extension Token)    ""
 					     ""|     %s(Extension Token, integer value: %u)"",
 					     level, *codepage_attr, peek & 0x0f, Indent (level),
 					     idx);
 			off += 1+len;
 			break;
 		case 0x83:  
 			idx = tvb_get_guintvar (tvb, off+1, &len);
 			str_len = tvb_strsize (tvb, str_tbl+idx);
 			proto_tree_add_text (tree, tvb, off, 1+len,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| STR_T (Tableref string)         ""
 					     ""|     %s\'%s\'"",
 					     level, *codepage_attr, Indent (level),
 					     tvb_format_text (tvb, str_tbl+idx, str_len-1));
 			off += 1+len;
 			break;
 			 
 		case 0xC0:  
 		case 0xC1:  
 		case 0xC2:  
 			 
 			proto_tree_add_text (tree, tvb, off, 1,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| EXT_%1x      (Extension Token)    ""
 					     ""|     %s(Single-byte extension)"",
 					     level, *codepage_attr, peek & 0x0f, Indent (level));
 			off++;
 			break;
 		case 0xC3:  
 			if (tvb_get_guint8 (tvb, 0)) {  
 				idx = tvb_get_guintvar (tvb, off+1, &len);
 				proto_tree_add_text (tree, tvb, off, 1 + len + idx,
 						     ""  %3d |  Attr | A %3d    ""
 						     ""| OPAQUE (Opaque data)            ""
 						     ""|       %s(%d bytes of opaque data)"",
 						     level, *codepage_attr, Indent (level), idx);
 				off += 1+len+idx;
 			} else {  
 				proto_tree_add_text (tree, tvb, off, 1,
 						     ""  %3d |  Attr | A %3d    ""
 						     ""| RESERVED_2     (Invalid Token!) ""
 						     ""| WBXML 1.0 parsing stops here."",
 						     level, *codepage_attr);
 				 
 				off = tvb_len;
 				DebugLog((""ATTR: level = %u, Return: len = %u\n"",
 					  level, off - offset));
 				return (off - offset);
 			}
 			break;
 			 
 		default:
 			proto_tree_add_text (tree, tvb, off, 1,
 					     ""  %3d |  Attr | A %3d    ""
 					     ""| %-10s     (Invalid Token!) ""
 					     ""| WBXML parsing stops here."",
 					     level, *codepage_attr,
 					     val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, ""(unknown 0x%x)""));
 			 
 			off = tvb_len;
 			break;
 		} else {  
 			if (peek & 0x80) {  
 				proto_tree_add_text (tree, tvb, off, 1,
 						     ""  %3d |  Attr | A %3d    ""
 						     ""|   Known attrValue 0x%02X          ""
 						     ""|       %sattrValue_0x%02X"",
 						     level, *codepage_attr, peek & 0x7f, Indent (level),
 						     peek);
 				off++;
 			} else {  
 				proto_tree_add_text (tree, tvb, off, 1,
 						     ""  %3d |  Attr | A %3d    ""
 						     ""|   Known attrStart 0x%02X          ""
 						     ""|   %sattrStart_0x%02X"",
 						     level, *codepage_attr, peek & 0x7f, Indent (level),
 						     peek);
  				off++;
  			}
  		}
 		if (off < last_off) {
 			THROW(ReportedBoundsError);
 		}
 		last_off = off;
  	}  
  	DebugLog((""ATTR: level = %u, Return: len = %u (end of function body)\n"",
  		  level, off - offset));
 	return (off - offset);
 }","[6, 15, 168, 169, 170, 171, 5]","epan/dissectors/packet-wbxml.c in the WBXML dissector in Wireshark 1.12.x before 1.12.12 mishandles offsets, which allows remote attackers to cause a denial of service (integer overflow and infinite loop) via a crafted packet."
207749,"  main(void)
  {
  unsigned int i;
  unsigned char buf[MAX_LENGTH];
  unsigned long crc;
  unsigned char c;
  int inchar;
 
 
   
     for (i=8; i; i--)
     {
      c=GETBREAK;
       GETBREAK;
        putchar(c);
     }
  
if (inchar != EOF)
 if (inchar == c)  
  for (;;)
   {
      
     unsigned long length;  
   c=GETBREAK; buf[0] = c; length  = c; length <<= 8;
   c=GETBREAK; buf[1] = c; length += c; length <<= 8;
   c=GETBREAK; buf[2] = c; length += c; length <<= 8;
   c=GETBREAK; buf[3] = c; length += c;
    GETBREAK; buf[0] = c; length  = c; length <<= 8;
    GETBREAK; buf[1] = c; length += c; length <<= 8;
    GETBREAK; buf[2] = c; length += c; length <<= 8;
    GETBREAK; buf[3] = c; length += c;
  
      
   c=GETBREAK; buf[4] = c;
   c=GETBREAK; buf[5] = c;
   c=GETBREAK; buf[6] = c;
   c=GETBREAK; buf[7] = c;
    GETBREAK; buf[4] = c;
    GETBREAK; buf[5] = c;
    GETBREAK; buf[6] = c;
    GETBREAK; buf[7] = c;
  
  
      
  if (buf[4] == 105 && buf[5] == 84 && buf[6] == 88 && buf[7] == 116)
  {
  if (length >= MAX_LENGTH-12)
  break;  
 
   
       crc = crc32(0, Z_NULL, 0);
 
 
         
        for (i=8; i < length + 12; i++)
        {
         c=GETBREAK; buf[i] = c;
          GETBREAK; buf[i] = c;
        }
  
       if (inchar != c)  
          break;
 
         
        crc = crc32(crc, buf+4, (uInt)length+4);
  
        for (;;)
        {
           
        if (((crc >> 24) & 0xff) == buf[length+8] &&
            ((crc >> 16) & 0xff) == buf[length+9] &&
            ((crc >>  8) & 0xff) == buf[length+10] &&
            ((crc      ) & 0xff) == buf[length+11])
         if (((crc >> 24) & 0xffU) == buf[length+8] &&
             ((crc >> 16) & 0xffU) == buf[length+9] &&
             ((crc >>  8) & 0xffU) == buf[length+10] &&
             ((crc      ) & 0xffU) == buf[length+11])
             break;
  
          length++;
 
 
          if (length >= MAX_LENGTH-12)
             break;
  
        c=GETBREAK;
        buf[length+11]=c;
         GETBREAK;
         buf[length+11] = c;
  
           
          crc = crc32(crc, buf+7+length, 1);
        }
  
       if (inchar != c)  
          break;
 
         
      buf[0] = (unsigned char)((length << 24) & 0xff);
      buf[1] = (unsigned char)((length << 16) & 0xff);
      buf[2] = (unsigned char)((length <<  8) & 0xff);
      buf[3] = (unsigned char)((length      ) & 0xff);
       buf[0] = (unsigned char)((length >> 24) & 0xffU);
       buf[1] = (unsigned char)((length >> 16) & 0xffU);
       buf[2] = (unsigned char)((length >>  8) & 0xffU);
       buf[3] = (unsigned char)((length      ) & 0xffU);
  
         
        for (i=0; i<length+12; i++)
          putchar(buf[i]);
  }
 
  
     else
     {
       if (inchar != c)  
          break;
 
         
        for (i=0; i<8; i++)
           putchar(buf[i]);
 
 
         
        for (i=8; i< length+12; i++)
        {
         c=GETBREAK;
          GETBREAK;
           putchar(c);
        }
  
      if (inchar == EOF)
       if (inchar != c)  
        {
           break;
        }
 
   
  if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)
 
           break;
     }
  
   if (inchar == EOF)
    if (inchar != c)  
        break;
  
     if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)
  break;
  }
 
  return 0;
 }","[14, 19, 28, 29, 30, 31, 38, 39, 40, 41, 58, 61, 62, 63, 74, 75, 76, 77, 88, 89, 95, 96, 97, 103, 104, 105, 106, 116, 117, 118, 128, 133, 145, 13, 18, 24, 25, 26, 27, 34, 35, 36, 37, 57, 70, 71, 72, 73, 86, 87, 99, 100, 101, 102, 127, 132, 144]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
205256,"  WorkerProcessLauncherTest::WorkerProcessLauncherTest()
    : message_loop_(MessageLoop::TYPE_IO) {
     : message_loop_(MessageLoop::TYPE_IO),
       client_pid_(GetCurrentProcessId()),
       permanent_error_(false) {
  }","[3, 4, 5, 2]",Use-after-free vulnerability in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving PDF fields.
201034," print_lcp_config_options(netdissect_options *ndo,
                          const u_char *p, int length)
 {
 	int len, opt;
 
 	if (length < 2)
 		return 0;
 	ND_TCHECK2(*p, 2);
 	len = p[1];
 	opt = p[0];
 	if (length < len)
 		return 0;
 	if (len < 2) {
 		if ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))
 			ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)"",
 			          lcpconfopts[opt], opt, len));
 		else
 			ND_PRINT((ndo, ""\n\tunknown LCP option 0x%02x"", opt));
 		return 0;
 	}
 	if ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))
 		ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u"", lcpconfopts[opt], opt, len));
 	else {
 		ND_PRINT((ndo, ""\n\tunknown LCP option 0x%02x"", opt));
 		return len;
 	}
 
 	switch (opt) {
 	case LCPOPT_VEXT:
 		if (len < 6) {
  			ND_PRINT((ndo, "" (length bogus, should be >= 6)""));
  			return len;
  		}
		ND_TCHECK2(*(p + 2), 3);
 		ND_TCHECK_24BITS(p + 2);
  		ND_PRINT((ndo, "": Vendor: %s (%u)"",
  			tok2str(oui_values,""Unknown"",EXTRACT_24BITS(p+2)),
  			EXTRACT_24BITS(p + 2)));
 #if 0
 		ND_TCHECK(p[5]);
 		ND_PRINT((ndo, "", kind: 0x%02x"", p[5]));
 		ND_PRINT((ndo, "", Value: 0x""));
 		for (i = 0; i < len - 6; i++) {
 			ND_TCHECK(p[6 + i]);
 			ND_PRINT((ndo, ""%02x"", p[6 + i]));
 		}
 #endif
 		break;
 	case LCPOPT_MRU:
 		if (len != 4) {
  			ND_PRINT((ndo, "" (length bogus, should be = 4)""));
  			return len;
  		}
		ND_TCHECK2(*(p + 2), 2);
 		ND_TCHECK_16BITS(p + 2);
  		ND_PRINT((ndo, "": %u"", EXTRACT_16BITS(p + 2)));
  		break;
  	case LCPOPT_ACCM:
  		if (len != 6) {
  			ND_PRINT((ndo, "" (length bogus, should be = 6)""));
  			return len;
  		}
		ND_TCHECK2(*(p + 2), 4);
 		ND_TCHECK_32BITS(p + 2);
  		ND_PRINT((ndo, "": 0x%08x"", EXTRACT_32BITS(p + 2)));
  		break;
  	case LCPOPT_AP:
  		if (len < 4) {
  			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
  			return len;
  		}
		ND_TCHECK2(*(p + 2), 2);
 		ND_TCHECK_16BITS(p + 2);
  		ND_PRINT((ndo, "": %s"", tok2str(ppptype2str, ""Unknown Auth Proto (0x04x)"", EXTRACT_16BITS(p + 2))));
  
  		switch (EXTRACT_16BITS(p+2)) {
 		case PPP_CHAP:
 			ND_TCHECK(p[4]);
 			ND_PRINT((ndo, "", %s"", tok2str(authalg_values, ""Unknown Auth Alg %u"", p[4])));
 			break;
 		case PPP_PAP:  
 		case PPP_EAP:
 		case PPP_SPAP:
 		case PPP_SPAP_OLD:
                         break;
 		default:
 			print_unknown_data(ndo, p, ""\n\t"", len);
 		}
 		break;
 	case LCPOPT_QP:
 		if (len < 4) {
  			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
  			return 0;
  		}
		ND_TCHECK2(*(p + 2), 2);
 		ND_TCHECK_16BITS(p+2);
  		if (EXTRACT_16BITS(p+2) == PPP_LQM)
  			ND_PRINT((ndo, "": LQR""));
  		else
 			ND_PRINT((ndo, "": unknown""));
 		break;
 	case LCPOPT_MN:
 		if (len != 6) {
  			ND_PRINT((ndo, "" (length bogus, should be = 6)""));
  			return 0;
  		}
		ND_TCHECK2(*(p + 2), 4);
 		ND_TCHECK_32BITS(p + 2);
  		ND_PRINT((ndo, "": 0x%08x"", EXTRACT_32BITS(p + 2)));
  		break;
  	case LCPOPT_PFC:
 		break;
 	case LCPOPT_ACFC:
 		break;
 	case LCPOPT_LD:
 		if (len != 4) {
  			ND_PRINT((ndo, "" (length bogus, should be = 4)""));
  			return 0;
  		}
		ND_TCHECK2(*(p + 2), 2);
 		ND_TCHECK_16BITS(p + 2);
  		ND_PRINT((ndo, "": 0x%04x"", EXTRACT_16BITS(p + 2)));
  		break;
  	case LCPOPT_CBACK:
 		if (len < 3) {
 			ND_PRINT((ndo, "" (length bogus, should be >= 3)""));
 			return 0;
 		}
 		ND_PRINT((ndo, "": ""));
 		ND_TCHECK(p[2]);
 		ND_PRINT((ndo, "": Callback Operation %s (%u)"",
                        tok2str(ppp_callback_values, ""Unknown"", p[2]),
                        p[2]));
 		break;
 	case LCPOPT_MLMRRU:
 		if (len != 4) {
  			ND_PRINT((ndo, "" (length bogus, should be = 4)""));
  			return 0;
  		}
		ND_TCHECK2(*(p + 2), 2);
 		ND_TCHECK_16BITS(p + 2);
  		ND_PRINT((ndo, "": %u"", EXTRACT_16BITS(p + 2)));
  		break;
  	case LCPOPT_MLED:
 		if (len < 3) {
 			ND_PRINT((ndo, "" (length bogus, should be >= 3)""));
 			return 0;
 		}
 		ND_TCHECK(p[2]);
 		switch (p[2]) {		 
 		case MEDCLASS_NULL:
 			ND_PRINT((ndo, "": Null""));
 			break;
 		case MEDCLASS_LOCAL:
 			ND_PRINT((ndo, "": Local""));  
 			break;
 		case MEDCLASS_IPV4:
 			if (len != 7) {
 				ND_PRINT((ndo, "" (length bogus, should be = 7)""));
 				return 0;
 			}
 			ND_TCHECK2(*(p + 3), 4);
 			ND_PRINT((ndo, "": IPv4 %s"", ipaddr_string(ndo, p + 3)));
 			break;
 		case MEDCLASS_MAC:
 			if (len != 9) {
 				ND_PRINT((ndo, "" (length bogus, should be = 9)""));
 				return 0;
 			}
 			ND_TCHECK2(*(p + 3), 6);
 			ND_PRINT((ndo, "": MAC %s"", etheraddr_string(ndo, p + 3)));
 			break;
 		case MEDCLASS_MNB:
 			ND_PRINT((ndo, "": Magic-Num-Block""));  
 			break;
 		case MEDCLASS_PSNDN:
 			ND_PRINT((ndo, "": PSNDN""));  
 			break;
 		default:
 			ND_PRINT((ndo, "": Unknown class %u"", p[2]));
 			break;
 		}
 		break;
 
  
 #if 0
 	case LCPOPT_DEP6:
 	case LCPOPT_FCSALT:
 	case LCPOPT_SDP:
 	case LCPOPT_NUMMODE:
 	case LCPOPT_DEP12:
 	case LCPOPT_DEP14:
 	case LCPOPT_DEP15:
 	case LCPOPT_DEP16:
         case LCPOPT_MLSSNHF:
 	case LCPOPT_PROP:
 	case LCPOPT_DCEID:
 	case LCPOPT_MPP:
 	case LCPOPT_LCPAOPT:
 	case LCPOPT_COBS:
 	case LCPOPT_PE:
 	case LCPOPT_MLHF:
 	case LCPOPT_I18N:
 	case LCPOPT_SDLOS:
 	case LCPOPT_PPPMUX:
 		break;
 #endif
 	default:
 		 
 		if (ndo->ndo_vflag < 2)
 			print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);
 		break;
 	}
 
 	if (ndo->ndo_vflag > 1)
 		print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);  
 
 	return len;
 
 trunc:
 	ND_PRINT((ndo, ""[|lcp]""));
 	return 0;
 }","[35, 55, 64, 73, 96, 108, 121, 141, 34, 54, 63, 72, 95, 107, 120, 140]",The PPP parser in tcpdump before 4.9.2 has a buffer over-read in print-ppp.c:print_ccp_config_options().
8454,"MagickExport void RegisterStaticModules(void)
{
size_t
extent;

ssize_t
i;

extent=sizeof(MagickModules)/sizeof(MagickModules[0]);
for (i=0; i < (ssize_t) extent; i++)
{
if (MagickModules[i].registered == MagickFalse)
{
(void) (MagickModules[i].register_module)();
MagickModules[i].registered=MagickTrue;
}
}
}",[14],"ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=""module"" rights=""none"" pattern=""PS"" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=""coder"" rights=""none"" pattern=""{PS,EPI,EPS,EPSF,EPSI}"" />."
206886," void BaseRenderingContext2D::setStrokeStyle(
     const StringOrCanvasGradientOrCanvasPattern& style) {
   DCHECK(!style.IsNull());
 
   String color_string;
   CanvasStyle* canvas_style = nullptr;
   if (style.IsString()) {
     color_string = style.GetAsString();
     if (color_string == GetState().UnparsedStrokeColor())
       return;
     Color parsed_color = 0;
     if (!ParseColorOrCurrentColor(parsed_color, color_string))
       return;
     if (GetState().StrokeStyle()->IsEquivalentRGBA(parsed_color.Rgb())) {
       ModifiableState().SetUnparsedStrokeColor(color_string);
       return;
     }
     canvas_style = CanvasStyle::CreateFromRGBA(parsed_color.Rgb());
   } else if (style.IsCanvasGradient()) {
     canvas_style = CanvasStyle::CreateFromGradient(style.GetAsCanvasGradient());
    } else if (style.IsCanvasPattern()) {
      CanvasPattern* canvas_pattern = style.GetAsCanvasPattern();
  
    if (OriginClean() && !canvas_pattern->OriginClean()) {
      SetOriginTainted();
      ClearResolvedFilters();
    }
     if (!origin_tainted_by_content_ && !canvas_pattern->OriginClean())
       SetOriginTaintedByContent();
  
      canvas_style = CanvasStyle::CreateFromPattern(canvas_pattern);
    }
 
   DCHECK(canvas_style);
 
   ModifiableState().SetStrokeStyle(canvas_style);
   ModifiableState().SetUnparsedStrokeColor(color_string);
   ModifiableState().ClearResolvedFilter();
 }","[28, 29, 24, 25, 26, 27]",Displacement map filters being applied to cross-origin images in Blink SVG rendering in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
205061," CmdBufferImageTransportFactory::CreateSharedSurfaceHandle() {
   if (!context_->makeContextCurrent()) {
     NOTREACHED() << ""Failed to make shared graphics context current"";
     return gfx::GLSurfaceHandle();
   }
 
    gfx::GLSurfaceHandle handle = gfx::GLSurfaceHandle(
        gfx::kNullPluginWindow, true);
    handle.parent_gpu_process_id = context_->GetGPUProcessID();
  handle.parent_client_id = context_->GetChannelID();
  handle.parent_context_id = context_->GetContextID();
  handle.parent_texture_id[0] = context_->createTexture();
  handle.parent_texture_id[1] = context_->createTexture();
  handle.sync_point = context_->insertSyncPoint();
    context_->flush();
    return handle;
  }","[10, 11, 12, 13, 14]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
203883," void GraphicsContext::fillRoundedRect(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight, const IntSize& bottomLeft, const IntSize& bottomRight, const Color& color, ColorSpace colorSpace)
 {
      if (paintingDisabled())
          return;
      
    notImplemented();
 #if USE(WXGC)
     Path path;
     path.addRoundedRect(rect, topLeft, topRight, bottomLeft, bottomRight);
     m_data->context->SetBrush(wxBrush(color));
     wxGraphicsContext* gc = m_data->context->GetGraphicsContext();
     gc->FillPath(*path.platformPath());
 #endif
  }","[7, 8, 9, 10, 11, 12, 13, 6]",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving floating styles.
202270," static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     AVIOContext *pb      = s->pb;
     AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar;
     FLVContext *flv      = s->priv_data;
     FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;
     unsigned ts;
     int size = pkt->size;
     uint8_t *data = NULL;
      int flags = -1, flags_size, ret;
      int64_t cur_offset = avio_tell(pb);
  
     if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {
         av_log(s, AV_LOG_WARNING, ""Empty audio Packet\n"");
         return AVERROR(EINVAL);
     }
 
      if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||
          par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)
          flags_size = 2;
     else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4)
         flags_size = 5;
     else
         flags_size = 1;
 
     if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264
             || par->codec_id == AV_CODEC_ID_MPEG4) {
         int side_size = 0;
         uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);
         if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {
             av_free(par->extradata);
             par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (!par->extradata) {
                 par->extradata_size = 0;
                 return AVERROR(ENOMEM);
             }
             memcpy(par->extradata, side, side_size);
             par->extradata_size = side_size;
             flv_write_codec_header(s, par, pkt->dts);
         }
     }
 
     if (flv->delay == AV_NOPTS_VALUE)
         flv->delay = -pkt->dts;
 
     if (pkt->dts < -flv->delay) {
         av_log(s, AV_LOG_WARNING,
                ""Packets are not in the proper order with respect to DTS\n"");
         return AVERROR(EINVAL);
     }
 
     ts = pkt->dts;
 
     if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) {
         write_metadata(s, ts);
         s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED;
     }
 
     avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000),
                       pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);
 
     switch (par->codec_type) {
     case AVMEDIA_TYPE_VIDEO:
         avio_w8(pb, FLV_TAG_TYPE_VIDEO);
 
         flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id);
 
         flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;
         break;
     case AVMEDIA_TYPE_AUDIO:
         flags = get_audio_flags(s, par);
 
         av_assert0(size);
 
         avio_w8(pb, FLV_TAG_TYPE_AUDIO);
         break;
     case AVMEDIA_TYPE_SUBTITLE:
     case AVMEDIA_TYPE_DATA:
         avio_w8(pb, FLV_TAG_TYPE_META);
         break;
     default:
         return AVERROR(EINVAL);
     }
 
     if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {
          
         if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)
             if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)
                 return ret;
     } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&
                (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {
         if (!s->streams[pkt->stream_index]->nb_frames) {
         av_log(s, AV_LOG_ERROR, ""Malformed AAC bitstream detected: ""
                ""use the audio bitstream filter 'aac_adtstoasc' to fix it ""
                ""('-bsf:a aac_adtstoasc' option with ffmpeg)\n"");
         return AVERROR_INVALIDDATA;
         }
         av_log(s, AV_LOG_WARNING, ""aac bitstream error\n"");
     }
 
      
     if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)
         av_log(s, AV_LOG_WARNING, ""Warning: Speex stream has more than ""
                                   ""8 frames per packet. Adobe Flash ""
                                   ""Player cannot handle this!\n"");
 
     if (sc->last_ts < ts)
         sc->last_ts = ts;
 
     if (size + flags_size >= 1<<24) {
         av_log(s, AV_LOG_ERROR, ""Too large packet with size %u >= %u\n"",
                size + flags_size, 1<<24);
         return AVERROR(EINVAL);
     }
 
     avio_wb24(pb, size + flags_size);
     put_timestamp(pb, ts);
     avio_wb24(pb, flv->reserved);
 
     if (par->codec_type == AVMEDIA_TYPE_DATA ||
         par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {
         int data_size;
         int64_t metadata_size_pos = avio_tell(pb);
         if (par->codec_id == AV_CODEC_ID_TEXT) {
             avio_w8(pb, AMF_DATA_TYPE_STRING);
             put_amf_string(pb, ""onTextData"");
             avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);
             avio_wb32(pb, 2);
             put_amf_string(pb, ""type"");
             avio_w8(pb, AMF_DATA_TYPE_STRING);
             put_amf_string(pb, ""Text"");
             put_amf_string(pb, ""text"");
             avio_w8(pb, AMF_DATA_TYPE_STRING);
             put_amf_string(pb, pkt->data);
             put_amf_string(pb, """");
             avio_w8(pb, AMF_END_OF_OBJECT);
         } else {
             avio_write(pb, data ? data : pkt->data, size);
         }
          
         data_size = avio_tell(pb) - metadata_size_pos;
         avio_seek(pb, metadata_size_pos - 10, SEEK_SET);
         avio_wb24(pb, data_size);
         avio_seek(pb, data_size + 10 - 3, SEEK_CUR);
         avio_wb32(pb, data_size + 11);
     } else {
         av_assert1(flags>=0);
         avio_w8(pb,flags);
         if (par->codec_id == AV_CODEC_ID_VP6)
             avio_w8(pb,0);
         if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {
             if (par->extradata_size)
                 avio_w8(pb, par->extradata[0]);
             else
                 avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) |
                              (FFALIGN(par->height, 16) - par->height));
         } else if (par->codec_id == AV_CODEC_ID_AAC)
             avio_w8(pb, 1);  
         else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {
             avio_w8(pb, 1);  
             avio_wb24(pb, pkt->pts - pkt->dts);
         }
 
         avio_write(pb, data ? data : pkt->data, size);
 
         avio_wb32(pb, size + flags_size + 11);  
         flv->duration = FFMAX(flv->duration,
                               pkt->pts + flv->delay + pkt->duration);
     }
 
     if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {
         switch (par->codec_type) {
             case AVMEDIA_TYPE_VIDEO:
                 flv->videosize += (avio_tell(pb) - cur_offset);
                 flv->lasttimestamp = flv->acurframeindex / flv->framerate;
                 if (pkt->flags & AV_PKT_FLAG_KEY) {
                     double ts = flv->acurframeindex / flv->framerate;
                     int64_t pos = cur_offset;
 
                     flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate;
                     flv->lastkeyframelocation = pos;
                     flv_append_keyframe_info(s, flv, ts, pos);
                 }
                 flv->acurframeindex++;
                 break;
 
             case AVMEDIA_TYPE_AUDIO:
                 flv->audiosize += (avio_tell(pb) - cur_offset);
                 break;
 
             default:
                 av_log(s, AV_LOG_WARNING, ""par->codec_type is type = [%d]\n"", par->codec_type);
                 break;
         }
     }
 
     av_free(data);
 
     return pb->error;
 }","[13, 14, 15, 16, 17]","The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 4.0.2 does not check for an empty audio packet, leading to an assertion failure."
208507,"  static void unset_active_map(const vpx_codec_enc_cfg_t *cfg,
                               vpx_codec_ctx_t *codec) {
  vpx_active_map_t map = {0};
   vpx_active_map_t map = {0, 0, 0};
  
    map.rows = (cfg->g_h + 15) / 16;
    map.cols = (cfg->g_w + 15) / 16;
  map.active_map = NULL;
 
  if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))
 
      die_codec(codec, ""Failed to set active map"");
  }","[4, 3]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
9148,"GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)
{
u32 i;
char str[1024];
GF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;

i=0;
str[0]=0;
while (1) {
str[i] = gf_bs_read_u8(bs);
if (!str[i]) break;
i++;
}
ISOM_DECREASE_SIZE(p, i);

p->content_script_types = gf_strdup(str);
return GF_OK;
}","[3, 4, 7, 8, 9, 10, 11, 12, 14, 16]","MP4Box is a component of GPAC-2.0.0, which is a widely-used third-party package on RPM Fusion. When MP4Box tries to parse a MP4 file, it calls the function `diST_box_read()` to read from video. In this function, it allocates a buffer `str` with fixed length. However, content read from `bs` is controllable by user, so is the length, which causes a buffer overflow."
199936," static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,
			      struct btrfs_path *path,
			      const char *name, int name_len)
 struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,
 						 struct btrfs_path *path,
 						 const char *name, int name_len)
  {
  	struct btrfs_dir_item *dir_item;
  	unsigned long name_ptr;
 	u32 total_len;
 	u32 cur = 0;
 	u32 this_len;
 	struct extent_buffer *leaf;
 
 	leaf = path->nodes[0];
 	dir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);
 	if (verify_dir_item(root, leaf, dir_item))
 		return NULL;
 
 	total_len = btrfs_item_size_nr(leaf, path->slots[0]);
 	while (cur < total_len) {
 		this_len = sizeof(*dir_item) +
 			btrfs_dir_name_len(leaf, dir_item) +
 			btrfs_dir_data_len(leaf, dir_item);
 		name_ptr = (unsigned long)(dir_item + 1);
 
 		if (btrfs_dir_name_len(leaf, dir_item) == name_len &&
 		    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)
 			return dir_item;
 
 		cur += this_len;
 		dir_item = (struct btrfs_dir_item *)((char *)dir_item +
 						     this_len);
 	}
 	return NULL;
 }","[4, 5, 6, 2, 3]","The Btrfs implementation in the Linux kernel before 3.19 does not ensure that the visible xattr state is consistent with a requested replacement, which allows local users to bypass intended ACL settings and gain privileges via standard filesystem operations (1) during an xattr-replacement time window, related to a race condition, or (2) after an xattr-replacement attempt that fails because the data does not fit."
198883," void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)
 void nfs4_close_sync(struct path *path, struct nfs4_state *state, fmode_t fmode)
  {
	__nfs4_close(path, state, mode, 1);
 	__nfs4_close(path, state, fmode, 1);
  }","[2, 5, 4]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
200492," parse_device(dev_t *pdev, struct archive *a, char *val)
 {
 #define MAX_PACK_ARGS 3
 	unsigned long numbers[MAX_PACK_ARGS];
 	char *p, *dev;
 	int argc;
 	pack_t *pack;
 	dev_t result;
 	const char *error = NULL;
 
 	memset(pdev, 0, sizeof(*pdev));
 	if ((dev = strchr(val, ',')) != NULL) {
 		 
 		*dev++ = '\0';
 		if ((pack = pack_find(val)) == NULL) {
 			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Unknown format `%s'"", val);
 			return ARCHIVE_WARN;
 		}
 		argc = 0;
 		while ((p = la_strsep(&dev, "","")) != NULL) {
 			if (*p == '\0') {
 				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
  				    ""Missing number"");
  				return ARCHIVE_WARN;
  			}
			numbers[argc++] = (unsigned long)mtree_atol(&p);
			if (argc > MAX_PACK_ARGS) {
 			if (argc >= MAX_PACK_ARGS) {
  				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
  				    ""Too many arguments"");
  				return ARCHIVE_WARN;
  			}
 			numbers[argc++] = (unsigned long)mtree_atol(&p);
  		}
  		if (argc < 2) {
  			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Not enough arguments"");
 			return ARCHIVE_WARN;
 		}
 		result = (*pack)(argc, numbers, &error);
 		if (error != NULL) {
 			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""%s"", error);
 			return ARCHIVE_WARN;
 		}
 	} else {
 		 
 		result = (dev_t)mtree_atol(&val);
 	}
 	*pdev = result;
 	return ARCHIVE_OK;
 #undef MAX_PACK_ARGS
 }","[29, 34, 27, 28]",Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.
204330,"  bool BaseSettingChange::Init(Profile* profile) {
  DCHECK(profile);
   DCHECK(profile && !profile_);
    profile_ = profile;
    return true;
  }","[3, 2]","Skia, as used in Google Chrome before 22.0.1229.79, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger an out-of-bounds write operation, a different vulnerability than CVE-2012-2883."
10034,"void LinearAlgebraOp<InputScalar, OutputScalar>::AnalyzeInputs(
OpKernelContext* context, TensorInputs* inputs,
TensorShapes* input_matrix_shapes, TensorShape* batch_shape) {
int input_rank = -1;
for (int i = 0; i < NumMatrixInputs(context); ++i) {
const Tensor& in = context->input(i);
if (i == 0) {
input_rank = in.dims();
OP_REQUIRES(
context, input_rank >= 2,
errors::InvalidArgument(""Input tensor "", i,
"" must have rank >= 2, got "", input_rank));



for (int dim = 0; dim < input_rank - 2; ++dim) {
batch_shape->AddDim(in.dim_size(dim));
}
} else {

OP_REQUIRES(context, input_rank == in.dims(),
errors::InvalidArgument(
""All input tensors must have the same rank.""));
for (int dim = 0; dim < input_rank - 2; ++dim) {
OP_REQUIRES(
context, in.dim_size(dim) == batch_shape->dim_size(dim),
errors::InvalidArgument(
""All input tensors must have the same outer dimensions.""));
}
}

const int row_dimension = input_rank - 2;
const int col_dimension = input_rank - 1;
const int64_t num_rows = in.dim_size(row_dimension);
const int64_t num_cols = in.dim_size(col_dimension);
input_matrix_shapes->emplace_back(
std::initializer_list<int64_t>({num_rows, num_cols}));
inputs->emplace_back(&in);
}

ValidateInputMatrixShapes(context, *input_matrix_shapes);
}",[41],"TensorFlow is an open source platform for machine learning. When `mlir::tfg::ConvertGenericFunctionToFunctionDef` is given empty function attributes, it gives a null dereference. We have patched the issue in GitHub commit aed36912609fc07229b4d0a7b44f3f48efc00fd0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
207433," void ASessionDescription::getFormatType(
  size_t index, unsigned long *PT,
  AString *desc, AString *params) const {
  AString format;
     getFormat(index, &format);
 
  const char *lastSpacePos = strrchr(format.c_str(), ' ');
     CHECK(lastSpacePos != NULL);
 
  char *end;
  unsigned long x = strtoul(lastSpacePos + 1, &end, 10);
     CHECK_GT(end, lastSpacePos + 1);
     CHECK_EQ(*end, '\0');
 
  
      *PT = x;
  
    char key[20];
    sprintf(key, ""a=rtpmap:%lu"", x);
     char key[32];
     snprintf(key, sizeof(key), ""a=rtpmap:%lu"", x);
  
      CHECK(findAttribute(index, key, desc));
  
    sprintf(key, ""a=fmtp:%lu"", x);
     snprintf(key, sizeof(key), ""a=fmtp:%lu"", x);
      if (!findAttribute(index, key, params)) {
          params->clear();
      }
 }","[20, 21, 26, 18, 19, 25]","Multiple buffer overflows in rtsp/ASessionDescription.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 25747670."
2733,"static void perf_remove_from_owner(struct perf_event *event)
{
struct task_struct *owner;

rcu_read_lock();
owner = ACCESS_ONCE(event->owner);






smp_read_barrier_depends();
if (owner) {





get_task_struct(owner);
}
rcu_read_unlock();

if (owner) {
mutex_lock(&owner->perf_event_mutex);






if (event->owner)
list_del_init(&event->owner_entry);
mutex_unlock(&owner->perf_event_mutex);
put_task_struct(owner);
}
}",[25],"kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 30955111."
202623,"  static void fpm_child_init(struct fpm_worker_pool_s *wp)  
  {
  	fpm_globals.max_requests = wp->config->pm_max_requests;
 	fpm_globals.listening_socket = dup(wp->listening_socket);
  
  	if (0 > fpm_stdio_init_child(wp)  ||
  	    0 > fpm_log_init_child(wp)    ||
 	    0 > fpm_status_init_child(wp) ||
 	    0 > fpm_unix_init_child(wp)   ||
 	    0 > fpm_signals_init_child()  ||
 	    0 > fpm_env_init_child(wp)    ||
 	    0 > fpm_php_init_child(wp)) {
 
 		zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name);
 		exit(FPM_EXIT_SOFTWARE);
 	}
 }
  ",[4],"An issue was discovered in PHP 7.3.x before 7.3.0alpha3, 7.2.x before 7.2.8, and before 7.1.20. The php-fpm master process restarts a child process in an endless loop when using program execution functions (e.g., passthru, exec, shell_exec, or system) with a non-blocking STDIN stream, causing this master process to consume 100% of the CPU, and consume disk space with a large volume of error logs, as demonstrated by an attack by a customer of a shared-hosting facility."
206506," void WebGLRenderingContextBase::linkProgram(WebGLProgram* program) {
   if (!ValidateWebGLProgramOrShader(""linkProgram"", program))
     return;
 
   if (program->ActiveTransformFeedbackCount() > 0) {
     SynthesizeGLError(
         GL_INVALID_OPERATION, ""linkProgram"",
         ""program being used by one or more active transform feedback objects"");
      return;
    }
  
   GLuint query = 0u;
   if (ExtensionEnabled(kKHRParallelShaderCompileName)) {
     ContextGL()->GenQueriesEXT(1, &query);
     ContextGL()->BeginQueryEXT(GL_PROGRAM_COMPLETION_QUERY_CHROMIUM, query);
   }
    ContextGL()->LinkProgram(ObjectOrZero(program));
   if (ExtensionEnabled(kKHRParallelShaderCompileName)) {
     ContextGL()->EndQueryEXT(GL_PROGRAM_COMPLETION_QUERY_CHROMIUM);
     addProgramCompletionQuery(program, query);
   }
 
    program->IncreaseLinkCount();
  }","[12, 13, 14, 15, 16, 18, 19, 20, 21, 22]","A heap use after free in V8 in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
206655," void WebGL2RenderingContextBase::texSubImage2D(GLenum target,
                                                GLint level,
                                                GLint xoffset,
                                                GLint yoffset,
                                                GLsizei width,
                                                GLsizei height,
                                                GLenum format,
                                                GLenum type,
                                                GLintptr offset) {
   if (isContextLost())
     return;
   if (!ValidateTexture2DBinding(""texSubImage2D"", target))
     return;
   if (!bound_pixel_unpack_buffer_) {
     SynthesizeGLError(GL_INVALID_OPERATION, ""texSubImage2D"",
                        ""no bound PIXEL_UNPACK_BUFFER"");
      return;
    }
   if (unpack_flip_y_ || unpack_premultiply_alpha_) {
     SynthesizeGLError(
         GL_INVALID_OPERATION, ""texSubImage2D"",
         ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed while uploading from PBO"");
     return;
   }
    if (!ValidateTexFunc(""texSubImage2D"", kTexSubImage, kSourceUnpackBuffer,
                         target, level, 0, width, height, 1, 0, format, type,
                         xoffset, yoffset, 0))
     return;
   if (!ValidateValueFitNonNegInt32(""texSubImage2D"", ""offset"", offset))
     return;
 
   ContextGL()->TexSubImage2D(target, level, xoffset, yoffset, width, height,
                              format, type,
                              reinterpret_cast<const void*>(offset));
 }","[19, 20, 21, 22, 23, 24]",Heap buffer overflow in WebGL in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
6308,"static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,
char *buf, u_int8_t client_hash) {
u_int16_t offset = 22, buf_out_len = 0;
if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;
u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);
offset += 4;


if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;


strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);
buf[buf_out_len++] = ';';
offset += len;

if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;

len = ntohl(*(u_int32_t*)&packet->payload[offset]);
offset += 4 + len;

if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;

len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;

if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;

len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(!client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;

if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;

len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;

if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;

len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(!client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;


if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
offset += len;
} else
offset += 4 + len;

if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;

len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(!client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
offset += len;
} else
offset += 4 + len;





#ifdef SSH_DEBUG
printf(""[SSH] %s\n"", buf);
#endif

return(buf_out_len);

invalid_payload:

#ifdef SSH_DEBUG
printf(""[SSH] Invalid packet payload\n"");
#endif

return(0);
}","[3, 22, 29, 30, 38, 39, 40, 47, 48, 56, 57, 58, 65, 66, 74, 75, 76, 83, 84, 92, 93, 94, 101, 102, 109, 110, 111, 118, 119, 126, 127, 128]","In nDPI through 3.2 Stable, the SSH protocol dissector has multiple KEXINIT integer overflows that result in a controlled remote heap overflow in concat_hash_string in ssh.c. Due to the granular nature of the overflow primitive and the ability to control both the contents and layout of the nDPI library's heap memory through remote input, this vulnerability may be abused to achieve full Remote Code Execution against any network inspection stack that is linked against nDPI and uses it to perform network traffic analysis."
201717," MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,
   const size_t quantum)
 {
    size_t
      extent;
  
  if (CheckMemoryOverflow(count,quantum) != MagickFalse)
   if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
      {
        memory=RelinquishMagickMemory(memory);
        return((void *) NULL);
     }
   extent=count*quantum;
   return(ResizeMagickMemory(memory,extent));
 }","[8, 7]","magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving *too many exceptions,* which trigger a buffer overflow."
207675," image_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this,
 image_transform_png_set_strip_alpha_set(const image_transform *this,
      transform_display *that, png_structp pp, png_infop pi)
  {
     png_set_strip_alpha(pp);
  this->next->set(this->next, that, pp, pi);
 
  }",[2],"Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
201491," int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 {
 	jas_stream_t *tmpstream;
 	bool extlen;
 	bool dataflag;
 
 	tmpstream = 0;
 
 	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
 
 	if (dataflag) {
 		if (!(tmpstream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (box->ops->putdata) {
 			if ((*box->ops->putdata)(box, tmpstream)) {
 				goto error;
 			}
 		}
 		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);
 		jas_stream_rewind(tmpstream);
 	}
 	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;
 	if (jp2_putuint32(out, extlen ? 1 : box->len)) {
 		goto error;
 	}
 	if (jp2_putuint32(out, box->type)) {
 		goto error;
 	}
 	if (extlen) {
 		if (jp2_putuint64(out, box->len)) {
 			goto error;
 		}
  	}
  
  	if (dataflag) {
		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {
 		if (jas_stream_copy(out, tmpstream, box->len -
 		  JP2_BOX_HDRLEN(false))) {
 			jas_eprintf(""cannot copy box data\n"");
  			goto error;
  		}
  		jas_stream_close(tmpstream);
 	}
 
 	return 0;
 
 error:
 
 	if (tmpstream) {
 		jas_stream_close(tmpstream);
 	}
 	return -1;
 }","[38, 39, 40, 37]",The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.
198017,"   tt_cmap8_validate( FT_Byte*      table,
                      FT_Validator  valid )
   {
     FT_Byte*   p = table + 4;
     FT_Byte*   is32;
     FT_UInt32  length;
     FT_UInt32  num_groups;
 
 
     if ( table + 16 + 8192 > valid->limit )
       FT_INVALID_TOO_SHORT;
 
     length = TT_NEXT_ULONG( p );
     if ( length > (FT_UInt32)( valid->limit - table ) || length < 8192 + 16 )
       FT_INVALID_TOO_SHORT;
 
     is32       = table + 12;
      p          = is32  + 8192;           
      num_groups = TT_NEXT_ULONG( p );
  
    if ( p + num_groups * 12 > valid->limit )
      
     if ( num_groups > (FT_UInt32)( valid->limit - p ) / 12 )
        FT_INVALID_TOO_SHORT;
  
       
       FT_UInt32  n, start, end, start_id, count, last = 0;
 
 
       for ( n = 0; n < num_groups; n++ )
       {
         FT_UInt   hi, lo;
 
 
         start    = TT_NEXT_ULONG( p );
         end      = TT_NEXT_ULONG( p );
         start_id = TT_NEXT_ULONG( p );
 
         if ( start > end )
           FT_INVALID_DATA;
 
         if ( n > 0 && start <= last )
           FT_INVALID_DATA;
 
  
          if ( valid->level >= FT_VALIDATE_TIGHT )
          {
          if ( start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) )
           FT_UInt32  d = end - start;
 
 
            
           if ( d > TT_VALID_GLYPH_COUNT( valid )             ||
                start_id >= TT_VALID_GLYPH_COUNT( valid ) - d )
              FT_INVALID_GLYPH_ID;
  
            count = (FT_UInt32)( end - start + 1 );
             {
               hi = (FT_UInt)( start >> 16 );
               lo = (FT_UInt)( start & 0xFFFFU );
 
               if ( (is32[hi >> 3] & ( 0x80 >> ( hi & 7 ) ) ) == 0 )
                 FT_INVALID_DATA;
 
               if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) == 0 )
                 FT_INVALID_DATA;
             }
           }
           else
           {
              
              
 
              
             if ( end & ~0xFFFFU )
               FT_INVALID_DATA;
 
             for ( ; count > 0; count--, start++ )
             {
               lo = (FT_UInt)( start & 0xFFFFU );
 
               if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) != 0 )
                 FT_INVALID_DATA;
             }
           }
         }
 
         last = end;
       }","[22, 23, 49, 50, 51, 52, 53, 54, 21, 48]",Multiple integer overflows in sfnt/ttcmap.c in FreeType before 2.5.4 allow remote attackers to cause a denial of service (out-of-bounds read or memory corruption) or possibly have unspecified other impact via a crafted cmap SFNT table.
199298," static void call_console_drivers(unsigned start, unsigned end)
 {
 	unsigned cur_index, start_print;
 	static int msg_level = -1;
 
 	BUG_ON(((int)(start - end)) > 0);
 
 	cur_index = start;
  	start_print = start;
  	while (cur_index != end) {
  		if (msg_level < 0 && ((end - cur_index) > 2)) {
 			 
 			char buf_prefix[SYSLOG_PRI_MAX_LENGTH+1];
 			unsigned i;
 			for (i = 0; i < ((end - cur_index)) && (i < SYSLOG_PRI_MAX_LENGTH); i++) {
 				buf_prefix[i] = LOG_BUF(cur_index + i);
 			}
 			buf_prefix[i] = '\0';  
 
  			 
			cur_index += log_prefix(&LOG_BUF(cur_index), &msg_level, NULL);
 			cur_index += log_prefix((const char *)&buf_prefix, &msg_level, NULL);
  			start_print = cur_index;
  		}
  		while (cur_index != end) {
 			char c = LOG_BUF(cur_index);
 
 			cur_index++;
 			if (c == '\n') {
 				if (msg_level < 0) {
 					 
 					msg_level = default_message_loglevel;
 				}
 				_call_console_drivers(start_print, cur_index, msg_level);
 				msg_level = -1;
 				start_print = cur_index;
 				break;
 			}
 		}
 	}
 	_call_console_drivers(start_print, end, msg_level);
 }","[12, 13, 14, 15, 16, 17, 18, 19, 22, 21]","The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call."
208220," OMX_ERRORTYPE SoftAVCEncoder::internalGetParameter(
         OMX_INDEXTYPE index, OMX_PTR params) {
  switch (index) {
  case OMX_IndexParamVideoBitrate:
  {
 
              OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
                  (OMX_VIDEO_PARAM_BITRATETYPE *) params;
  
             if (!isValidOMXParam(bitRate)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (bitRate->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
 
             bitRate->eControlRate = OMX_Video_ControlRateVariable;
             bitRate->nTargetBitrate = mBitrate;
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamVideoAvc:
  {
 
              OMX_VIDEO_PARAM_AVCTYPE *avcParams =
                  (OMX_VIDEO_PARAM_AVCTYPE *)params;
  
             if (!isValidOMXParam(avcParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (avcParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
 
             avcParams->eProfile = OMX_VIDEO_AVCProfileBaseline;
             OMX_U32 omxLevel = AVC_LEVEL2;
  if (OMX_ErrorNone !=
  ConvertAvcSpecLevelToOmxAvcLevel(mAVCEncLevel, &omxLevel)) {
  return OMX_ErrorUndefined;
  }
 
             avcParams->eLevel = (OMX_VIDEO_AVCLEVELTYPE) omxLevel;
             avcParams->nRefFrames = 1;
             avcParams->nBFrames = 0;
             avcParams->bUseHadamard = OMX_TRUE;
             avcParams->nAllowedPictureTypes =
  (OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP);
             avcParams->nRefIdx10ActiveMinus1 = 0;
             avcParams->nRefIdx11ActiveMinus1 = 0;
             avcParams->bWeightedPPrediction = OMX_FALSE;
             avcParams->bEntropyCodingCABAC = OMX_FALSE;
             avcParams->bconstIpred = OMX_FALSE;
             avcParams->bDirect8x8Inference = OMX_FALSE;
             avcParams->bDirectSpatialTemporal = OMX_FALSE;
             avcParams->nCabacInitIdc = 0;
  return OMX_ErrorNone;
  }
 
  default:
  return SoftVideoEncoderOMXComponent::internalGetParameter(index, params);
  }
 }","[10, 11, 12, 13, 29, 30, 31, 32]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
200790," static ssize_t generic_perform_write(struct file *file,
 				struct iov_iter *i, loff_t pos)
 {
 	struct address_space *mapping = file->f_mapping;
 	const struct address_space_operations *a_ops = mapping->a_ops;
 	long status = 0;
 	ssize_t written = 0;
 	unsigned int flags = 0;
 
 	 
 	if (segment_eq(get_fs(), KERNEL_DS))
 		flags |= AOP_FLAG_UNINTERRUPTIBLE;
 
 	do {
 		struct page *page;
 		pgoff_t index;		 
 		unsigned long offset;	 
 		unsigned long bytes;	 
 		size_t copied;		 
 		void *fsdata;
 
 		offset = (pos & (PAGE_CACHE_SIZE - 1));
 		index = pos >> PAGE_CACHE_SHIFT;
 		bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,
 						iov_iter_count(i));
 
 again:
 
 		 
 		if (unlikely(iov_iter_fault_in_readable(i, bytes))) {
 			status = -EFAULT;
 			break;
 		}
 
 		status = a_ops->write_begin(file, mapping, pos, bytes, flags,
 						&page, &fsdata);
 		if (unlikely(status))
 			break;
 
 		pagefault_disable();
 		copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);
 		pagefault_enable();
 		flush_dcache_page(page);
 
 		status = a_ops->write_end(file, mapping, pos, bytes, copied,
 						page, fsdata);
 		if (unlikely(status < 0))
 			break;
 		copied = status;
  
  		cond_resched();
  
 		iov_iter_advance(i, copied);
  		if (unlikely(copied == 0)) {
  			 
 			bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,
  						iov_iter_single_seg_count(i));
  			goto again;
  		}
		iov_iter_advance(i, copied);
  		pos += copied;
  		written += copied;
  
 		balance_dirty_pages_ratelimited(mapping);
 
 	} while (iov_iter_count(i));
 
 	return written ? written : status;
 }","[53, 60]","mm/filemap.c in the Linux kernel before 2.6.25 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers an iovec of zero length, followed by a page fault for an iovec of nonzero length."
207790," status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {
  Mutex::Autolock autoLock(mDRMLock);
  status_t err;
  if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {
  return err;
  }
 
  size_t len = (*buffer)->range_length();
 
  char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();
 
  DrmBuffer encryptedDrmBuffer(src, len);
  DrmBuffer decryptedDrmBuffer;
     decryptedDrmBuffer.length = len;
     decryptedDrmBuffer.data = new char[len];
  DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;
 
  if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,
  &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {
 
  if (decryptedDrmBuffer.data) {
  delete [] decryptedDrmBuffer.data;
             decryptedDrmBuffer.data = NULL;
  }
 
  return err;
  }
     CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);
 
  const char *mime;
     CHECK(getFormat()->findCString(kKeyMIMEType, &mime));
 
  if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {
  uint8_t *dstData = (uint8_t*)src;
  size_t srcOffset = 0;
  size_t dstOffset = 0;
 
         len = decryptedDrmBuffer.length;
  while (srcOffset < len) {
             CHECK(srcOffset + mNALLengthSize <= len);
  size_t nalLength = 0;
  const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);
 
  switch (mNALLengthSize) {
  case 1:
                     nalLength = *data;
  break;
  case 2:
                     nalLength = U16_AT(data);
  break;
  case 3:
                     nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);
  break;
  case 4:
                     nalLength = U32_AT(data);
  break;
  default:
                     CHECK(!""Should not be here."");
  break;
  }
 
             srcOffset += mNALLengthSize;
 
  size_t end = srcOffset + nalLength;
  if (end > len || end < srcOffset) {
  if (decryptedDrmBuffer.data) {
  delete [] decryptedDrmBuffer.data;
                     decryptedDrmBuffer.data = NULL;
  }
 
  return ERROR_MALFORMED;
  }
 
  if (nalLength == 0) {
 
                  continue;
              }
  
            CHECK(dstOffset + 4 <= (*buffer)->size());
             if (dstOffset > SIZE_MAX - 4 ||
                 dstOffset + 4 > SIZE_MAX - nalLength ||
                 dstOffset + 4 + nalLength > (*buffer)->size()) {
                 (*buffer)->release();
                 (*buffer) = NULL;
                 if (decryptedDrmBuffer.data) {
                     delete [] decryptedDrmBuffer.data;
                     decryptedDrmBuffer.data = NULL;
                 }
                 return ERROR_MALFORMED;
             }
  
              dstData[dstOffset++] = 0;
              dstData[dstOffset++] = 0;
             dstData[dstOffset++] = 0;
             dstData[dstOffset++] = 1;
             memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);
             srcOffset += nalLength;
             dstOffset += nalLength;
  }
 
         CHECK_EQ(srcOffset, len);
  (*buffer)->set_range((*buffer)->range_offset(), dstOffset);
 
  } else {
         memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);
  (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);
  }
 
  if (decryptedDrmBuffer.data) {
  delete [] decryptedDrmBuffer.data;
         decryptedDrmBuffer.data = NULL;
  }
 
  return OK;
 }","[80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 79]","DRMExtractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate a certain offset value, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28175045."
204567,"  DXVAVideoDecodeAccelerator::DXVAVideoDecodeAccelerator(
    media::VideoDecodeAccelerator::Client* client,
    base::ProcessHandle renderer_process)
     media::VideoDecodeAccelerator::Client* client)
      : client_(client),
        egl_config_(NULL),
        state_(kUninitialized),
        pictures_requested_(false),
      renderer_process_(renderer_process),
        last_input_buffer_id_(-1),
        inputs_before_decode_(0) {
    memset(&input_stream_info_, 0, sizeof(input_stream_info_));
   memset(&output_stream_info_, 0, sizeof(output_stream_info_));
 }","[4, 2, 3, 9]","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
198157," main (int argc, char *argv[])
 {
   struct gengetopt_args_info args_info;
   char *line = NULL;
   size_t linelen = 0;
   char *p, *r;
   uint32_t *q;
   unsigned cmdn = 0;
   int rc;
 
   setlocale (LC_ALL, """");
   set_program_name (argv[0]);
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
   if (cmdline_parser (argc, argv, &args_info) != 0)
     return EXIT_FAILURE;
 
   if (args_info.version_given)
     {
       version_etc (stdout, ""idn"", PACKAGE_NAME, VERSION,
 		   ""Simon Josefsson"", (char *) NULL);
       return EXIT_SUCCESS;
     }
 
   if (args_info.help_given)
     usage (EXIT_SUCCESS);
 
    
   if (args_info.hidden_nfkc_given)
     args_info.nfkc_given = 1;
 
   if (!args_info.stringprep_given &&
       !args_info.punycode_encode_given && !args_info.punycode_decode_given &&
       !args_info.idna_to_ascii_given && !args_info.idna_to_unicode_given &&
       !args_info.nfkc_given)
     args_info.idna_to_ascii_given = 1;
 
   if ((args_info.stringprep_given ? 1 : 0) +
       (args_info.punycode_encode_given ? 1 : 0) +
       (args_info.punycode_decode_given ? 1 : 0) +
       (args_info.idna_to_ascii_given ? 1 : 0) +
       (args_info.idna_to_unicode_given ? 1 : 0) +
       (args_info.nfkc_given ? 1 : 0) != 1)
     {
       error (0, 0, _(""only one of -s, -e, -d, -a, -u or -n can be specified""));
       usage (EXIT_FAILURE);
     }
 
   if (!args_info.quiet_given
       && args_info.inputs_num == 0
       && isatty (fileno (stdin)))
     fprintf (stderr, ""%s %s\n"" GREETING, PACKAGE, VERSION);
 
   if (args_info.debug_given)
     fprintf (stderr, _(""Charset `%s'.\n""), stringprep_locale_charset ());
 
   if (!args_info.quiet_given
       && args_info.inputs_num == 0
       && isatty (fileno (stdin)))
     fprintf (stderr, _(""Type each input string on a line by itself, ""
 		       ""terminated by a newline character.\n""));
 
   do
     {
       if (cmdn < args_info.inputs_num)
 	line = strdup (args_info.inputs[cmdn++]);
       else if (getline (&line, &linelen, stdin) == -1)
 	{
 	  if (feof (stdin))
 	    break;
 
  	  error (EXIT_FAILURE, errno, _(""input error""));
  	}
  
      if (line[strlen (line) - 1] == '\n')
	line[strlen (line) - 1] = '\0';
       if (strlen (line) > 0)
 	if (line[strlen (line) - 1] == '\n')
 	  line[strlen (line) - 1] = '\0';
  
        if (args_info.stringprep_given)
  	{
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""),
 		   stringprep_locale_charset ());
 
 	  q = stringprep_utf8_to_ucs4 (p, -1, NULL);
 	  if (!q)
 	    {
 	      free (p);
 	      error (EXIT_FAILURE, 0,
 		     _(""could not convert from UTF-8 to UCS-4""));
 	    }
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; q[i]; i++)
 		fprintf (stderr, ""input[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 	    }
 	  free (q);
 
 	  rc = stringprep_profile (p, &r,
 				   args_info.profile_given ?
 				   args_info.profile_arg : ""Nameprep"", 0);
 	  free (p);
 	  if (rc != STRINGPREP_OK)
 	    error (EXIT_FAILURE, 0, _(""stringprep_profile: %s""),
 		   stringprep_strerror (rc));
 
 	  q = stringprep_utf8_to_ucs4 (r, -1, NULL);
 	  if (!q)
 	    {
 	      free (r);
 	      error (EXIT_FAILURE, 0,
 		     _(""could not convert from UTF-8 to UCS-4""));
 	    }
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; q[i]; i++)
 		fprintf (stderr, ""output[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 	    }
 	  free (q);
 
 	  p = stringprep_utf8_to_locale (r);
 	  free (r);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""),
 		   stringprep_locale_charset ());
 
 	  fprintf (stdout, ""%s\n"", p);
 
 	  free (p);
 	}
 
       if (args_info.punycode_encode_given)
 	{
 	  char encbuf[BUFSIZ];
 	  size_t len, len2;
 
 	  p = stringprep_locale_to_utf8 (line);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""),
 		   stringprep_locale_charset ());
 
 	  q = stringprep_utf8_to_ucs4 (p, -1, &len);
 	  free (p);
 	  if (!q)
 	    error (EXIT_FAILURE, 0,
 		   _(""could not convert from UTF-8 to UCS-4""));
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; i < len; i++)
 		fprintf (stderr, ""input[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 	    }
 
 	  len2 = BUFSIZ - 1;
 	  rc = punycode_encode (len, q, NULL, &len2, encbuf);
 	  free (q);
 	  if (rc != PUNYCODE_SUCCESS)
 	    error (EXIT_FAILURE, 0, _(""punycode_encode: %s""),
 		   punycode_strerror (rc));
 
 	  encbuf[len2] = '\0';
 
 	  p = stringprep_utf8_to_locale (encbuf);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""),
 		   stringprep_locale_charset ());
 
 	  fprintf (stdout, ""%s\n"", p);
 
 	  free (p);
 	}
 
       if (args_info.punycode_decode_given)
 	{
 	  size_t len;
 
 	  len = BUFSIZ;
 	  q = (uint32_t *) malloc (len * sizeof (q[0]));
 	  if (!q)
 	    error (EXIT_FAILURE, ENOMEM, N_(""malloc""));
 
 	  rc = punycode_decode (strlen (line), line, &len, q, NULL);
 	  if (rc != PUNYCODE_SUCCESS)
 	    {
 	      free (q);
 	      error (EXIT_FAILURE, 0, _(""punycode_decode: %s""),
 		     punycode_strerror (rc));
 	    }
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; i < len; i++)
 		fprintf (stderr, ""output[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 	    }
 
 	  q[len] = 0;
 	  r = stringprep_ucs4_to_utf8 (q, -1, NULL, NULL);
 	  free (q);
 	  if (!r)
 	    error (EXIT_FAILURE, 0,
 		   _(""could not convert from UCS-4 to UTF-8""));
 
 	  p = stringprep_utf8_to_locale (r);
 	  free (r);
 	  if (!r)
 	    error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""),
 		   stringprep_locale_charset ());
 
 	  fprintf (stdout, ""%s\n"", p);
 
 	  free (p);
 	}
 
       if (args_info.idna_to_ascii_given)
 	{
 	  p = stringprep_locale_to_utf8 (line);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""),
 		   stringprep_locale_charset ());
 
 	  q = stringprep_utf8_to_ucs4 (p, -1, NULL);
 	  free (p);
 	  if (!q)
 	    error (EXIT_FAILURE, 0,
 		   _(""could not convert from UCS-4 to UTF-8""));
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; q[i]; i++)
 		fprintf (stderr, ""input[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 	    }
 
 	  rc = idna_to_ascii_4z (q, &p,
 				 (args_info.allow_unassigned_given ?
 				  IDNA_ALLOW_UNASSIGNED : 0) |
 				 (args_info.usestd3asciirules_given ?
 				  IDNA_USE_STD3_ASCII_RULES : 0));
 	  free (q);
 	  if (rc != IDNA_SUCCESS)
 	    error (EXIT_FAILURE, 0, _(""idna_to_ascii_4z: %s""),
 		   idna_strerror (rc));
 
 #ifdef WITH_TLD
 	  if (args_info.tld_flag && !args_info.no_tld_flag)
 	    {
 	      size_t errpos;
 
 	      rc = idna_to_unicode_8z4z (p, &q,
 					 (args_info.allow_unassigned_given ?
 					  IDNA_ALLOW_UNASSIGNED : 0) |
 					 (args_info.usestd3asciirules_given ?
 					  IDNA_USE_STD3_ASCII_RULES : 0));
 	      if (rc != IDNA_SUCCESS)
 		error (EXIT_FAILURE, 0, _(""idna_to_unicode_8z4z (TLD): %s""),
 		       idna_strerror (rc));
 
 	      if (args_info.debug_given)
 		{
 		  size_t i;
 		  for (i = 0; q[i]; i++)
 		    fprintf (stderr, ""tld[%lu] = U+%04x\n"",
 			     (unsigned long) i, q[i]);
 		}
 
 	      rc = tld_check_4z (q, &errpos, NULL);
 	      free (q);
 	      if (rc == TLD_INVALID)
 		error (EXIT_FAILURE, 0, _(""tld_check_4z (position %lu): %s""),
 		       (unsigned long) errpos, tld_strerror (rc));
 	      if (rc != TLD_SUCCESS)
 		error (EXIT_FAILURE, 0, _(""tld_check_4z: %s""),
 		       tld_strerror (rc));
 	    }
 #endif
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; p[i]; i++)
 		fprintf (stderr, ""output[%lu] = U+%04x\n"",
 			 (unsigned long) i, p[i]);
 	    }
 
 	  fprintf (stdout, ""%s\n"", p);
 
 	  free (p);
 	}
 
       if (args_info.idna_to_unicode_given)
 	{
 	  p = stringprep_locale_to_utf8 (line);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""),
 		   stringprep_locale_charset ());
 
 	  q = stringprep_utf8_to_ucs4 (p, -1, NULL);
 	  if (!q)
 	    {
 	      free (p);
 	      error (EXIT_FAILURE, 0,
 		     _(""could not convert from UCS-4 to UTF-8""));
 	    }
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; q[i]; i++)
 		fprintf (stderr, ""input[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 	    }
 	  free (q);
 
 	  rc = idna_to_unicode_8z4z (p, &q,
 				     (args_info.allow_unassigned_given ?
 				      IDNA_ALLOW_UNASSIGNED : 0) |
 				     (args_info.usestd3asciirules_given ?
 				      IDNA_USE_STD3_ASCII_RULES : 0));
 	  free (p);
 	  if (rc != IDNA_SUCCESS)
 	    error (EXIT_FAILURE, 0, _(""idna_to_unicode_8z4z: %s""),
 		   idna_strerror (rc));
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 	      for (i = 0; q[i]; i++)
 		fprintf (stderr, ""output[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 	    }
 
 #ifdef WITH_TLD
 	  if (args_info.tld_flag)
 	    {
 	      size_t errpos;
 
 	      rc = tld_check_4z (q, &errpos, NULL);
 	      if (rc == TLD_INVALID)
 		{
 		  free (q);
 		  error (EXIT_FAILURE, 0,
 			 _(""tld_check_4z (position %lu): %s""),
 			 (unsigned long) errpos, tld_strerror (rc));
 		}
 	      if (rc != TLD_SUCCESS)
 		{
 		  free (q);
 		  error (EXIT_FAILURE, 0, _(""tld_check_4z: %s""),
 			 tld_strerror (rc));
 		}
 	    }
 #endif
 
 	  r = stringprep_ucs4_to_utf8 (q, -1, NULL, NULL);
 	  free (q);
 	  if (!r)
 	    error (EXIT_FAILURE, 0,
 		   _(""could not convert from UTF-8 to UCS-4""));
 
 	  p = stringprep_utf8_to_locale (r);
 	  free (r);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""),
 		   stringprep_locale_charset ());
 
 	  fprintf (stdout, ""%s\n"", p);
 
 	  free (p);
 	}
 
       if (args_info.nfkc_given)
 	{
 	  p = stringprep_locale_to_utf8 (line);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""),
 		   stringprep_locale_charset ());
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 
 	      q = stringprep_utf8_to_ucs4 (p, -1, NULL);
 	      if (!q)
 		{
 		  free (p);
 		  error (EXIT_FAILURE, 0,
 			 _(""could not convert from UTF-8 to UCS-4""));
 		}
 
 	      for (i = 0; q[i]; i++)
 		fprintf (stderr, ""input[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 
 	      free (q);
 	    }
 
 	  r = stringprep_utf8_nfkc_normalize (p, -1);
 	  free (p);
 	  if (!r)
 	    error (EXIT_FAILURE, 0, _(""could not do NFKC normalization""));
 
 	  if (args_info.debug_given)
 	    {
 	      size_t i;
 
 	      q = stringprep_utf8_to_ucs4 (r, -1, NULL);
 	      if (!q)
 		{
 		  free (r);
 		  error (EXIT_FAILURE, 0,
 			 _(""could not convert from UTF-8 to UCS-4""));
 		}
 
 	      for (i = 0; q[i]; i++)
 		fprintf (stderr, ""output[%lu] = U+%04x\n"",
 			 (unsigned long) i, q[i]);
 
 	      free (q);
 	    }
 
 	  p = stringprep_utf8_to_locale (r);
 	  free (r);
 	  if (!p)
 	    error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""),
 		   stringprep_locale_charset ());
 
 	  fprintf (stdout, ""%s\n"", p);
 
 	  free (p);
 	}
 
       fflush (stdout);
     }
   while (!feof (stdin) && !ferror (stdin) && (args_info.inputs_num == 0 ||
 					      cmdn < args_info.inputs_num));
 
   free (line);
 
   return EXIT_SUCCESS;
 }","[78, 79, 80, 76, 77]","idn in libidn before 1.33 might allow remote attackers to obtain sensitive memory information by reading a zero byte as input, which triggers an out-of-bounds read, a different vulnerability than CVE-2015-8948."
208064," WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,
                                 WORD32 num_mb_skip,
                                 UWORD8 u1_is_idr_slice,
                                 UWORD16 u2_frame_num,
  pocstruct_t *ps_cur_poc,
                                 WORD32 prev_slice_err)
 {
     WORD32 i2_cur_mb_addr;
     UWORD32 u1_num_mbs, u1_num_mbsNby2;
     UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
     UWORD32 i2_mb_skip_run;
 
     UWORD32 u1_num_mbs_next, u1_end_of_row;
  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
     UWORD32 u1_slice_end;
     UWORD32 u1_tfr_n_mb;
     UWORD32 u1_decode_nmb;
  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
  deblk_mb_t *ps_cur_deblk_mb;
  dec_mb_info_t *ps_cur_mb_info;
  parse_pmbarams_t *ps_parse_mb_data;
     UWORD32 u1_inter_mb_type;
     UWORD32 u1_deblk_mb_type;
     UWORD16 u2_total_mbs_coded;
     UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
  parse_part_params_t *ps_part_info;
     WORD32 ret;
 
 
  if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
  {
         ih264d_err_pic_dispbuf_mgr(ps_dec);
  return 0;
  }
 
  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))
  {
         num_mb_skip++;
  }
     ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
  if(prev_slice_err == 1)
  {
   
         ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;
 
 
  if(!ps_dec->u1_first_slice_in_stream)
  {
             ih264d_end_of_pic(ps_dec, u1_is_idr_slice,
                 ps_dec->ps_cur_slice->u2_frame_num);
             ps_dec->s_cur_pic_poc.u2_frame_num =
                 ps_dec->ps_cur_slice->u2_frame_num;
  }
 
  {
             WORD32 i, j, poc = 0;
 
             ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;
 
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
 
  if(ps_dec->ps_cur_pic != NULL)
                 poc = ps_dec->ps_cur_pic->i4_poc + 2;
 
             j = -1;
  for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
  {
  if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
  {
  if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)
  {
                            j = i;
  break;
  }
  }
  }
 
 
              if(j == -1)
              {
                return ERROR_INV_SPS_PPS_T;
                 return ERROR_INV_SLICE_HDR_T;
              }
  
               
  if(ps_dec->u4_pic_buf_got == 0)
  {
                 ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
                 ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;
                 ps_dec->ps_cur_slice->u1_nal_unit_type = 1;
                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
                         ps_dec->ps_cur_slice->u2_frame_num,
  &ps_dec->ps_pps[j]);
 
  if(ret != OK)
  {
  return ret;
  }
  }
 
             ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;
 
             ps_dec->u4_output_present = 0;
 
  {
                 ih264d_get_next_display_field(ps_dec,
                                               ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
   
 
  if(0 != ps_dec->s_disp_op.u4_error_code)
  {
                     ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
  }
  else
                     ps_dec->u4_output_present = 1;
  }
 
  if(ps_dec->u1_separate_parse == 1)
  {
  if(ps_dec->u4_dec_thread_created == 0)
  {
                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,
  (void *)ih264d_decode_picture_thread,
  (void *)ps_dec);
 
                     ps_dec->u4_dec_thread_created = 1;
  }
 
  if((ps_dec->u4_num_cores == 3) &&
  ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
  && (ps_dec->u4_bs_deblk_thread_created == 0))
  {
                     ps_dec->u4_start_recon_deblk = 0;
                     ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
  (void *)ih264d_recon_deblk_thread,
  (void *)ps_dec);
                     ps_dec->u4_bs_deblk_thread_created = 1;
  }
  }
  }
         ps_dec->u4_first_slice_in_pic = 0;
  }
  else
  {
 
  dec_slice_struct_t *ps_parse_cur_slice;
         ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;
 
  if(ps_dec->u1_slice_header_done
  && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
  {
  if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))
  {
                 ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;
                 ps_dec->u2_cur_mb_addr--;
  }
 
             u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;
  if(u1_num_mbs)
  {
                 ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
  }
  else
  {
  if(ps_dec->u1_separate_parse)
  {
                     ps_cur_mb_info = ps_dec->ps_nmb_info;
  }
  else
  {
                     ps_cur_mb_info = ps_dec->ps_nmb_info
  + ps_dec->u4_num_mbs_prev_nmb - 1;
  }
  }
 
             ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
             ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;
 
             ps_dec->u1_mb_ngbr_availablity =
                     ps_cur_mb_info->u1_mb_ngbr_availablity;
 
  if(u1_num_mbs)
  {
                 ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
                 ps_dec->u2_cur_mb_addr--;
                 ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;
 
  if (ps_dec->u1_pr_sl_type == P_SLICE
  || ps_dec->u1_pr_sl_type == B_SLICE)
  {
                     ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
                     ps_dec->ps_part = ps_dec->ps_parse_part_params;
  }
 
                 u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
                 u1_end_of_row = (!u1_num_mbs_next)
  && (!(u1_mbaff && (u1_num_mbs & 0x01)));
                 u1_slice_end = 1;
                 u1_tfr_n_mb = 1;
                 ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 
  if(ps_dec->u1_separate_parse)
  {
                     ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                     ps_dec->ps_nmb_info += u1_num_mbs;
  }
  else
  {
                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
  }
                 ps_dec->u2_total_mbs_coded += u1_num_mbs;
                 ps_dec->u1_mb_idx = 0;
                 ps_dec->u4_num_mbs_cur_nmb = 0;
  }
 
  if(ps_dec->u2_total_mbs_coded
  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
                 ps_dec->u1_pic_decode_done = 1;
  return 0;
  }
 
   
  if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <
  (UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))
  {
                 ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
                 ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
                 ps_dec->u2_cur_slice_num++;
                 ps_dec->ps_parse_cur_slice++;
  }
 
  }
  else
  {
             ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
  + ps_dec->u2_cur_slice_num;
  }
  }
 
   
   
   
  {
         WORD32 num_entries;
         WORD32 size;
         UWORD8 *pu1_buf;
 
         num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
         num_entries = 2 * ((2 * num_entries) + 1);
 
         size = num_entries * sizeof(void *);
         size += PAD_MAP_IDX_POC * sizeof(void *);
 
         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
         pu1_buf += size * ps_dec->u2_cur_slice_num;
         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
  }
 
     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;
     ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
     ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;
 
  if(ps_dec->ps_cur_slice->u1_field_pic_flag)
         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;
 
     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;
     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
 
  if(ps_dec->u1_separate_parse)
  {
         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
  }
  else
  {
         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
  }
 
   
   
   
     u1_inter_mb_type = P_MB;
     u1_deblk_mb_type = D_INTER_MB;
 
     ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
     ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
     ps_dec->ps_part = ps_dec->ps_parse_part_params;
     ps_dec->u2_mbx =
  (MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));
     ps_dec->u2_mby =
  (DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));
     ps_dec->u2_mby <<= u1_mbaff;
 
   
   
   
     ps_dec->u1_slice_header_done = 2;
     ps_dec->u1_qp = ps_slice->u1_slice_qp;
     ih264d_update_qp(ps_dec, 0);
     u1_mb_idx = ps_dec->u1_mb_idx;
     ps_parse_mb_data = ps_dec->ps_parse_mb_data;
     u1_num_mbs = u1_mb_idx;
 
     u1_slice_end = 0;
     u1_tfr_n_mb = 0;
     u1_decode_nmb = 0;
     u1_num_mbsNby2 = 0;
     i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
     i2_mb_skip_run = num_mb_skip;
 
  while(!u1_slice_end)
  {
         UWORD8 u1_mb_type;
 
  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
  break;
 
         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
 
         ps_cur_mb_info->u1_Mux = 0;
         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;
 
         ps_cur_mb_info->u1_end_of_slice = 0;
 
   
         ps_parse_mb_data->u1_num_part = 1;
         ps_parse_mb_data->u1_isI_mb = 0;
 
   
   
   
   
  if (u1_mbaff)
             ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
  else
             ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
 
   
  if(ps_dec->u4_app_disable_deblk_frm == 0)
  {
             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                              ps_dec->u1_mb_ngbr_availablity,
                                              ps_dec->u1_cur_mb_fld_dec_flag);
  }
 
   
         ps_dec->i1_prev_mb_qp_delta = 0;
         ps_dec->u1_sub_mb_num = 0;
         ps_cur_mb_info->u1_mb_type = MB_SKIP;
         ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
         ps_cur_mb_info->u1_cbp = 0;
 
   
         ps_part_info = ps_dec->ps_part;
         ps_part_info->u1_is_direct = PART_DIRECT_16x16;
         ps_part_info->u1_sub_mb_num = 0;
         ps_dec->ps_part++;
 
   
         ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);
 
         ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
         ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;
 
         i2_mb_skip_run--;
 
         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;
 
  if (u1_mbaff)
  {
             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
  }
 
   
   
   
         i2_cur_mb_addr++;
 
         u1_num_mbs++;
         u1_num_mbsNby2++;
         ps_parse_mb_data++;
 
   
   
   
   
   
         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
         u1_slice_end = !i2_mb_skip_run;
         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
  || u1_slice_end;
         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;
 
  if(u1_decode_nmb)
  {
             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
             u1_num_mbsNby2 = 0;
 
             ps_parse_mb_data = ps_dec->ps_parse_mb_data;
             ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
  if(ps_dec->u1_separate_parse)
  {
                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                 ps_dec->ps_nmb_info +=  u1_num_mbs;
  }
  else
  {
                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
                                             u1_tfr_n_mb, u1_end_of_row);
  }
             ps_dec->u2_total_mbs_coded += u1_num_mbs;
  if(u1_tfr_n_mb)
                 u1_num_mbs = 0;
             u1_mb_idx = u1_num_mbs;
             ps_dec->u1_mb_idx = u1_num_mbs;
  }
  }
 
     ps_dec->u4_num_mbs_cur_nmb = 0;
     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
  - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;
 
     H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", ps_dec->ps_cur_slice->u4_mbs_in_slice);
 
 
   
  if(ps_dec->u4_first_slice_in_pic != 0)
  {
         ps_dec->ps_parse_cur_slice++;
         ps_dec->u2_cur_slice_num++;
  }
 
     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 
  if(ps_dec->u2_total_mbs_coded
  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
         ps_dec->u1_pic_decode_done = 1;
  }
 
  return 0;
 
 }","[87, 86]","A remote denial of service vulnerability in libavc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34097915."
205107," bool CopyDirectory(const FilePath& from_path,
                    const FilePath& to_path,
                    bool recursive) {
   base::ThreadRestrictions::AssertIOAllowed();
   DCHECK(to_path.value().find('*') == std::string::npos);
   DCHECK(from_path.value().find('*') == std::string::npos);
 
   char top_dir[PATH_MAX];
   if (base::strlcpy(top_dir, from_path.value().c_str(),
                     arraysize(top_dir)) >= arraysize(top_dir)) {
     return false;
   }
 
   FilePath real_to_path = to_path;
   if (PathExists(real_to_path)) {
     if (!AbsolutePath(&real_to_path))
       return false;
   } else {
     real_to_path = real_to_path.DirName();
     if (!AbsolutePath(&real_to_path))
       return false;
   }
   FilePath real_from_path = from_path;
   if (!AbsolutePath(&real_from_path))
     return false;
   if (real_to_path.value().size() >= real_from_path.value().size() &&
       real_to_path.value().compare(0, real_from_path.value().size(),
       real_from_path.value()) == 0)
     return false;
 
   bool success = true;
   int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
   if (recursive)
     traverse_type |= FileEnumerator::DIRECTORIES;
   FileEnumerator traversal(from_path, recursive, traverse_type);
 
   FileEnumerator::FindInfo info;
   FilePath current = from_path;
   if (stat(from_path.value().c_str(), &info.stat) < 0) {
     DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                 << from_path.value() << "" errno = "" << errno;
     success = false;
   }
   struct stat to_path_stat;
   FilePath from_path_base = from_path;
   if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
       S_ISDIR(to_path_stat.st_mode)) {
     from_path_base = from_path.DirName();
   }
 
    DCHECK(recursive || S_ISDIR(info.stat.st_mode));
  
    while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
      
      
     FilePath target_path(to_path);
     if (from_path_base != current) {
       if (!from_path_base.AppendRelativePath(current, &target_path)) {
         success = false;
         break;
       }
      }
    const FilePath target_path = to_path.Append(suffix);
  
      if (S_ISDIR(info.stat.st_mode)) {
        if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
           errno != EEXIST) {
         DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                     << target_path.value() << "" errno = "" << errno;
         success = false;
       }
     } else if (S_ISREG(info.stat.st_mode)) {
       if (!CopyFile(current, target_path)) {
         DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                     << target_path.value();
         success = false;
       }
     } else {
       DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                     << current.value();
     }
 
     current = traversal.Next();
     traversal.GetFindInfo(&info);
   }
 
   return success;
 }","[58, 59, 60, 61, 62, 63, 64, 65, 54, 55, 56, 57, 67]","Google Chrome before 25.0.1364.97 on Linux, and before 25.0.1364.99 on Mac OS X, does not properly handle pathnames during copy operations, which might make it easier for remote attackers to execute arbitrary programs via unspecified vectors."
9504,"int64_t TensorByteSize(const TensorProto& t) {

int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();
return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());
}",[3],"Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that `TensorByteSize` would trigger `CHECK` failures. `TensorShape` constructor throws a `CHECK`-fail if shape is partial or has a number of elements that would overflow the size of an `int`. The `PartialTensorShape` constructor instead does not cause a `CHECK`-abort if the shape is partial, which is exactly what this function needs to be able to return `-1`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
201801," static Image *ReadJPEGImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   char
     value[MaxTextExtent];
 
   const char
     *option;
 
   ErrorManager
     error_manager;
 
   Image
     *image;
 
   IndexPacket
     index;
 
   JSAMPLE
     *volatile jpeg_pixels;
 
   JSAMPROW
     scanline[1];
 
   MagickBooleanType
     debug,
     status;
 
   MagickSizeType
     number_pixels;
 
   MemoryInfo
     *memory_info;
 
   register ssize_t
     i;
 
   struct jpeg_decompress_struct
     jpeg_info;
 
   struct jpeg_error_mgr
     jpeg_error;
 
   register JSAMPLE
     *p;
 
   size_t
     units;
 
   ssize_t
     y;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   debug=IsEventLogging();
   (void) debug;
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
   (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
   (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
   jpeg_info.err=jpeg_std_error(&jpeg_error);
   jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
   jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
   memory_info=(MemoryInfo *) NULL;
   error_manager.image=image;
   if (setjmp(error_manager.error_recovery) != 0)
     {
       jpeg_destroy_decompress(&jpeg_info);
       if (error_manager.profile != (StringInfo *) NULL)
         error_manager.profile=DestroyStringInfo(error_manager.profile);
       (void) CloseBlob(image);
       number_pixels=(MagickSizeType) image->columns*image->rows;
       if (number_pixels != 0)
         return(GetFirstImageInList(image));
       InheritException(exception,&image->exception);
       return(DestroyImage(image));
     }
   jpeg_info.client_data=(void *) &error_manager;
   jpeg_create_decompress(&jpeg_info);
   JPEGSourceManager(&jpeg_info,image);
   jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
   option=GetImageOption(image_info,""profile:skip"");
   if (IsOptionMember(""ICC"",option) == MagickFalse)
     jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
   if (IsOptionMember(""IPTC"",option) == MagickFalse)
     jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
   for (i=1; i < 16; i++)
     if ((i != 2) && (i != 13) && (i != 14))
       if (IsOptionMember(""APP"",option) == MagickFalse)
         jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
   i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
   if ((image_info->colorspace == YCbCrColorspace) ||
       (image_info->colorspace == Rec601YCbCrColorspace) ||
       (image_info->colorspace == Rec709YCbCrColorspace))
     jpeg_info.out_color_space=JCS_YCbCr;
    
   units=0;
   if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
       (jpeg_info.Y_density != 1))
     {
       image->x_resolution=(double) jpeg_info.X_density;
       image->y_resolution=(double) jpeg_info.Y_density;
       units=(size_t) jpeg_info.density_unit;
     }
   if (units == 1)
     image->units=PixelsPerInchResolution;
   if (units == 2)
     image->units=PixelsPerCentimeterResolution;
   number_pixels=(MagickSizeType) image->columns*image->rows;
   option=GetImageOption(image_info,""jpeg:size"");
   if ((option != (const char *) NULL) &&
       (jpeg_info.out_color_space != JCS_YCbCr))
     {
       double
         scale_factor;
 
       GeometryInfo
         geometry_info;
 
       MagickStatusType
         flags;
 
        
       flags=ParseGeometry(option,&geometry_info);
       if ((flags & SigmaValue) == 0)
         geometry_info.sigma=geometry_info.rho;
       jpeg_calc_output_dimensions(&jpeg_info);
       image->magick_columns=jpeg_info.output_width;
       image->magick_rows=jpeg_info.output_height;
       scale_factor=1.0;
       if (geometry_info.rho != 0.0)
         scale_factor=jpeg_info.output_width/geometry_info.rho;
       if ((geometry_info.sigma != 0.0) &&
           (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
         scale_factor=jpeg_info.output_height/geometry_info.sigma;
       jpeg_info.scale_num=1U;
       jpeg_info.scale_denom=(unsigned int) scale_factor;
       jpeg_calc_output_dimensions(&jpeg_info);
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Scale factor: %.20g"",(double) scale_factor);
     }
 #if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
 #if defined(D_LOSSLESS_SUPPORTED)
   image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
     JPEGInterlace : NoInterlace;
   image->compression=jpeg_info.process == JPROC_LOSSLESS ?
     LosslessJPEGCompression : JPEGCompression;
   if (jpeg_info.data_precision > 8)
     (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
       ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
       image->filename);
   if (jpeg_info.data_precision == 16)
     jpeg_info.data_precision=12;
 #else
   image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
     NoInterlace;
   image->compression=JPEGCompression;
 #endif
 #else
   image->compression=JPEGCompression;
   image->interlace=JPEGInterlace;
 #endif
   option=GetImageOption(image_info,""jpeg:colors"");
   if (option != (const char *) NULL)
     {
        
       jpeg_info.quantize_colors=TRUE;
       jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
     }
   option=GetImageOption(image_info,""jpeg:block-smoothing"");
   if (option != (const char *) NULL)
     jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
       FALSE;
   jpeg_info.dct_method=JDCT_FLOAT;
   option=GetImageOption(image_info,""jpeg:dct-method"");
   if (option != (const char *) NULL)
     switch (*option)
     {
       case 'D':
       case 'd':
       {
         if (LocaleCompare(option,""default"") == 0)
           jpeg_info.dct_method=JDCT_DEFAULT;
         break;
       }
       case 'F':
       case 'f':
       {
         if (LocaleCompare(option,""fastest"") == 0)
           jpeg_info.dct_method=JDCT_FASTEST;
         if (LocaleCompare(option,""float"") == 0)
           jpeg_info.dct_method=JDCT_FLOAT;
         break;
       }
       case 'I':
       case 'i':
       {
         if (LocaleCompare(option,""ifast"") == 0)
           jpeg_info.dct_method=JDCT_IFAST;
         if (LocaleCompare(option,""islow"") == 0)
           jpeg_info.dct_method=JDCT_ISLOW;
         break;
       }
     }
   option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
   if (option != (const char *) NULL)
     jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
       FALSE;
   (void) jpeg_start_decompress(&jpeg_info);
   image->columns=jpeg_info.output_width;
   image->rows=jpeg_info.output_height;
   image->depth=(size_t) jpeg_info.data_precision;
   switch (jpeg_info.out_color_space)
   {
     case JCS_RGB:
     default:
     {
       (void) SetImageColorspace(image,sRGBColorspace);
       break;
     }
     case JCS_GRAYSCALE:
     {
       (void) SetImageColorspace(image,GRAYColorspace);
       break;
     }
     case JCS_YCbCr:
     {
       (void) SetImageColorspace(image,YCbCrColorspace);
       break;
     }
     case JCS_CMYK:
     {
       (void) SetImageColorspace(image,CMYKColorspace);
       break;
     }
   }
   if (IsITUFaxImage(image) != MagickFalse)
     {
       (void) SetImageColorspace(image,LabColorspace);
       jpeg_info.out_color_space=JCS_YCbCr;
     }
    if (option != (const char *) NULL)
      if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  if ((jpeg_info.output_components == 1) &&
      (jpeg_info.quantize_colors == 0))
   if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
      {
        size_t
          colors;
 
       colors=(size_t) GetQuantumRange(image->depth)+1;
       if (AcquireImageColormap(image,colors) == MagickFalse)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   if (image->debug != MagickFalse)
     {
       if (image->interlace != NoInterlace)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Interlace: progressive"");
       else
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Interlace: nonprogressive"");
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
         (int) jpeg_info.data_precision);
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
         (int) jpeg_info.output_width,(int) jpeg_info.output_height);
     }
   JPEGSetImageQuality(&jpeg_info,image);
   JPEGSetImageSamplingFactor(&jpeg_info,image);
   (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
     jpeg_info.out_color_space);
   (void) SetImageProperty(image,""jpeg:colorspace"",value);
   if (image_info->ping != MagickFalse)
     {
       jpeg_destroy_decompress(&jpeg_info);
       (void) CloseBlob(image);
       return(GetFirstImageInList(image));
     }
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       jpeg_destroy_decompress(&jpeg_info);
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
   if ((jpeg_info.output_components != 1) &&
       (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
     {
       jpeg_destroy_decompress(&jpeg_info);
       ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
     }
   memory_info=AcquireVirtualMemory((size_t) image->columns,
     jpeg_info.output_components*sizeof(*jpeg_pixels));
   if (memory_info == (MemoryInfo *) NULL)
     {
       jpeg_destroy_decompress(&jpeg_info);
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
    
   if (setjmp(error_manager.error_recovery) != 0)
     {
       if (memory_info != (MemoryInfo *) NULL)
         memory_info=RelinquishVirtualMemory(memory_info);
       jpeg_destroy_decompress(&jpeg_info);
       (void) CloseBlob(image);
       number_pixels=(MagickSizeType) image->columns*image->rows;
       if (number_pixels != 0)
         return(GetFirstImageInList(image));
       return(DestroyImage(image));
     }
   if (jpeg_info.quantize_colors != 0)
     {
       image->colors=(size_t) jpeg_info.actual_number_of_colors;
       if (jpeg_info.out_color_space == JCS_GRAYSCALE)
         for (i=0; i < (ssize_t) image->colors; i++)
         {
           image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
           image->colormap[i].green=image->colormap[i].red;
           image->colormap[i].blue=image->colormap[i].red;
           image->colormap[i].opacity=OpaqueOpacity;
         }
       else
         for (i=0; i < (ssize_t) image->colors; i++)
         {
           image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
           image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
           image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
           image->colormap[i].opacity=OpaqueOpacity;
         }
     }
   scanline[0]=(JSAMPROW) jpeg_pixels;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register IndexPacket
       *magick_restrict indexes;
 
     register ssize_t
       x;
 
     register PixelPacket
       *magick_restrict q;
 
     if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
       {
         (void) ThrowMagickException(exception,GetMagickModule(),
           CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
         continue;
       }
     p=jpeg_pixels;
     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
     if (q == (PixelPacket *) NULL)
       break;
     indexes=GetAuthenticIndexQueue(image);
     if (jpeg_info.data_precision > 8)
       {
         unsigned short
           scale;
 
         scale=65535/(unsigned short) GetQuantumRange((size_t)
           jpeg_info.data_precision);
         if (jpeg_info.output_components == 1)
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             size_t
               pixel;
 
             pixel=(size_t) (scale*GETJSAMPLE(*p));
             index=ConstrainColormapIndex(image,pixel);
             SetPixelIndex(indexes+x,index);
             SetPixelRGBO(q,image->colormap+(ssize_t) index);
             p++;
             q++;
           }
         else
           if (image->colorspace != CMYKColorspace)
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                 (scale*GETJSAMPLE(*p++))));
               SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                 (scale*GETJSAMPLE(*p++))));
               SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                 (scale*GETJSAMPLE(*p++))));
               SetPixelOpacity(q,OpaqueOpacity);
               q++;
             }
           else
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                 (unsigned short) (scale*GETJSAMPLE(*p++))));
               SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                 (unsigned short) (scale*GETJSAMPLE(*p++))));
               SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                 (unsigned short) (scale*GETJSAMPLE(*p++))));
               SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                 (unsigned short) (scale*GETJSAMPLE(*p++))));
               SetPixelOpacity(q,OpaqueOpacity);
               q++;
             }
       }
     else
       if (jpeg_info.output_components == 1)
         for (x=0; x < (ssize_t) image->columns; x++)
         {
           index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
           SetPixelIndex(indexes+x,index);
           SetPixelRGBO(q,image->colormap+(ssize_t) index);
           p++;
           q++;
         }
       else
         if (image->colorspace != CMYKColorspace)
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(q,ScaleCharToQuantum((unsigned char)
               GETJSAMPLE(*p++)));
             SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
               GETJSAMPLE(*p++)));
             SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
               GETJSAMPLE(*p++)));
             SetPixelOpacity(q,OpaqueOpacity);
             q++;
           }
         else
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
               GETJSAMPLE(*p++)));
             SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
               GETJSAMPLE(*p++)));
             SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
               GETJSAMPLE(*p++)));
             SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
               (unsigned char) GETJSAMPLE(*p++)));
             SetPixelOpacity(q,OpaqueOpacity);
             q++;
           }
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
     status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
       image->rows);
     if (status == MagickFalse)
       {
         jpeg_abort_decompress(&jpeg_info);
         break;
       }
   }
   if (status != MagickFalse)
     {
       error_manager.finished=MagickTrue;
       if (setjmp(error_manager.error_recovery) == 0)
         (void) jpeg_finish_decompress(&jpeg_info);
     }
    
   jpeg_destroy_decompress(&jpeg_info);
   memory_info=RelinquishVirtualMemory(memory_info);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[261, 259, 260]",Buffer overflow in coders/tiff.c in ImageMagick before 6.9.4-1 allows remote attackers to cause a denial of service (application crash) or have unspecified other impact via a crafted TIFF file.
202183,"  static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
  {
  	 
 	__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;
 	struct kvm_regs *regs = vcpu_gp_regs(vcpu);
 	int nr_regs = sizeof(*regs) / sizeof(__u32);
 	u32 off;
 
 	 
 	off = core_reg_offset_from_id(reg->id);
 	if (off >= nr_regs ||
  	    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)
  		return -ENOENT;
  
 	if (validate_core_offset(reg))
 		return -EINVAL;
 
  	if (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))
  		return -EFAULT;
  
 	return 0;
 }","[15, 16, 17]","arch/arm64/kvm/guest.c in KVM in the Linux kernel before 4.18.12 on the arm64 platform mishandles the KVM_SET_ON_REG ioctl. This is exploitable by attackers who can create virtual machines. An attacker can arbitrarily redirect the hypervisor flow of control (with full register control). An attacker can also cause a denial of service (hypervisor panic) via an illegal exception return. This occurs because of insufficient restrictions on userspace access to the core register file, and because PSTATE.M validation does not prevent unintended execution modes."
201242," static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)
 {
     SCPRContext *s = avctx->priv_data;
     GetByteContext *gb = &s->gb;
     int cx = 0, cx1 = 0, k = 0, clr = 0;
     int run, r, g, b, off, y = 0, x = 0, z, ret;
     unsigned backstep = linesize - avctx->width;
     const int cxshift = s->cxshift;
     unsigned lx, ly, ptype;
 
     reinit_tables(s);
     bytestream2_skip(gb, 2);
     init_rangecoder(&s->rc, gb);
 
     while (k < avctx->width + 1) {
         ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);
         if (ret < 0)
             return ret;
 
         cx1 = (cx << 6) & 0xFC0;
         cx = r >> cxshift;
         ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);
         if (ret < 0)
             return ret;
 
         cx1 = (cx << 6) & 0xFC0;
         cx = g >> cxshift;
         ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);
         if (ret < 0)
             return ret;
 
         cx1 = (cx << 6) & 0xFC0;
         cx = b >> cxshift;
 
         ret = decode_value(s, s->run_model[0], 256, 400, &run);
         if (ret < 0)
             return ret;
 
          clr = (b << 16) + (g << 8) + r;
          k += run;
          while (run-- > 0) {
             if (y >= avctx->height)
                 return AVERROR_INVALIDDATA;
 
              dst[y * linesize + x] = clr;
              lx = x;
              ly = y;
             x++;
             if (x >= avctx->width) {
                 x = 0;
                 y++;
             }
         }
     }
     off = -linesize - 1;
     ptype = 0;
 
     while (x < avctx->width && y < avctx->height) {
         ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);
         if (ret < 0)
             return ret;
         if (ptype == 0) {
             ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);
             if (ret < 0)
                 return ret;
 
             cx1 = (cx << 6) & 0xFC0;
             cx = r >> cxshift;
             ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);
             if (ret < 0)
                 return ret;
 
             cx1 = (cx << 6) & 0xFC0;
             cx = g >> cxshift;
             ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);
             if (ret < 0)
                 return ret;
 
             clr = (b << 16) + (g << 8) + r;
         }
         if (ptype > 5)
             return AVERROR_INVALIDDATA;
         ret = decode_value(s, s->run_model[ptype], 256, 400, &run);
         if (ret < 0)
             return ret;
 
         switch (ptype) {
         case 0:
             while (run-- > 0) {
                 if (y >= avctx->height)
                     return AVERROR_INVALIDDATA;
 
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         case 1:
             while (run-- > 0) {
                 if (y >= avctx->height)
                     return AVERROR_INVALIDDATA;
 
                 dst[y * linesize + x] = dst[ly * linesize + lx];
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             clr = dst[ly * linesize + lx];
             break;
         case 2:
             while (run-- > 0) {
                 if (y < 1 || y >= avctx->height)
                     return AVERROR_INVALIDDATA;
 
                 clr = dst[y * linesize + x + off + 1];
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         case 4:
             while (run-- > 0) {
                 uint8_t *odst = (uint8_t *)dst;
 
                 if (y < 1 || y >= avctx->height ||
                     (y == 1 && x == 0))
                     return AVERROR_INVALIDDATA;
 
                 if (x == 0) {
                     z = backstep;
                 } else {
                     z = 0;
                 }
 
                 r = odst[(ly * linesize + lx) * 4] +
                     odst[((y * linesize + x) + off - z) * 4 + 4] -
                     odst[((y * linesize + x) + off - z) * 4];
                 g = odst[(ly * linesize + lx) * 4 + 1] +
                     odst[((y * linesize + x) + off - z) * 4 + 5] -
                     odst[((y * linesize + x) + off - z) * 4 + 1];
                 b = odst[(ly * linesize + lx) * 4 + 2] +
                     odst[((y * linesize + x) + off - z) * 4 + 6] -
                     odst[((y * linesize + x) + off - z) * 4 + 2];
                 clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         case 5:
             while (run-- > 0) {
                 if (y < 1 || y >= avctx->height ||
                     (y == 1 && x == 0))
                     return AVERROR_INVALIDDATA;
 
                 if (x == 0) {
                     z = backstep;
                 } else {
                     z = 0;
                 }
 
                 clr = dst[y * linesize + x + off - z];
                 dst[y * linesize + x] = clr;
                 lx = x;
                 ly = y;
                 x++;
                 if (x >= avctx->width) {
                     x = 0;
                     y++;
                 }
             }
             break;
         }
 
         if (avctx->bits_per_coded_sample == 16) {
             cx1 = (clr & 0x3F00) >> 2;
             cx = (clr & 0xFFFFFF) >> 16;
         } else {
             cx1 = (clr & 0xFC00) >> 4;
             cx = (clr & 0xFFFFFF) >> 18;
         }
     }
 
     return 0;
 }","[42, 43, 44]","libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
207352," xsltShallowCopyElem(xsltTransformContextPtr ctxt, xmlNodePtr node,
 		    xmlNodePtr insert, int isLRE)
 {
     xmlNodePtr copy;
 
     if ((node->type == XML_DTD_NODE) || (insert == NULL))
 	return(NULL);
     if ((node->type == XML_TEXT_NODE) ||
 	(node->type == XML_CDATA_SECTION_NODE))
 	return(xsltCopyText(ctxt, insert, node, 0));
 
     copy = xmlDocCopyNode(node, insert->doc, 0);
      if (copy != NULL) {
  	copy->doc = ctxt->output;
  	copy = xsltAddChild(insert, copy);
         if (copy == NULL) {
              xsltTransformError(ctxt, NULL, node,
                 ""xsltShallowCopyElem: copy failed\n"");
              return (copy);
         }
  
  	if (node->type == XML_ELEMENT_NODE) {
  	     
 	    if (node->nsDef != NULL) {
 		 
 		if (isLRE)
 		    xsltCopyNamespaceList(ctxt, copy, node->nsDef);
 		else
 		    xsltCopyNamespaceListInternal(copy, node->nsDef);
 	    }
 
 	     
 	    if (node->ns != NULL) {
 		if (isLRE) {
 		     
 		    copy->ns = xsltGetNamespace(ctxt, node, node->ns, copy);
 		} else {
 		    copy->ns = xsltGetSpecialNamespace(ctxt,
 			node, node->ns->href, node->ns->prefix, copy);
 
 		}
 	    } else if ((insert->type == XML_ELEMENT_NODE) &&
 		       (insert->ns != NULL))
 	    {
 		 
 		xsltGetSpecialNamespace(ctxt, node, NULL, NULL, copy);
 	    }
 	}
     } else {
 	xsltTransformError(ctxt, NULL, node,
 		""xsltShallowCopyElem: copy %s failed\n"", node->name);
     }
     return(copy);
 }","[16, 17, 18, 19, 20]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
198751," static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
 			      struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
 	struct net *net = sock_net(sk);
 	struct unix_sock *u = unix_sk(sk);
 	struct sockaddr_un *sunaddr = msg->msg_name;
 	struct sock *other = NULL;
 	int namelen = 0;  
 	int err;
 	unsigned int hash;
 	struct sk_buff *skb;
 	long timeo;
 	struct scm_cookie tmp_scm;
 	int max_level;
 	int data_len = 0;
 
  	if (NULL == siocb->scm)
  		siocb->scm = &tmp_scm;
  	wait_for_unix_gc();
	err = scm_send(sock, msg, siocb->scm);
 	err = scm_send(sock, msg, siocb->scm, false);
  	if (err < 0)
  		return err;
  
 	err = -EOPNOTSUPP;
 	if (msg->msg_flags&MSG_OOB)
 		goto out;
 
 	if (msg->msg_namelen) {
 		err = unix_mkname(sunaddr, msg->msg_namelen, &hash);
 		if (err < 0)
 			goto out;
 		namelen = err;
 	} else {
 		sunaddr = NULL;
 		err = -ENOTCONN;
 		other = unix_peer_get(sk);
 		if (!other)
 			goto out;
 	}
 
 	if (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr
 	    && (err = unix_autobind(sock)) != 0)
 		goto out;
 
 	err = -EMSGSIZE;
 	if (len > sk->sk_sndbuf - 32)
 		goto out;
 
 	if (len > SKB_MAX_ALLOC)
 		data_len = min_t(size_t,
 				 len - SKB_MAX_ALLOC,
 				 MAX_SKB_FRAGS * PAGE_SIZE);
 
 	skb = sock_alloc_send_pskb(sk, len - data_len, data_len,
 				   msg->msg_flags & MSG_DONTWAIT, &err);
 	if (skb == NULL)
 		goto out;
 
 	err = unix_scm_to_skb(siocb->scm, skb, true);
 	if (err < 0)
 		goto out_free;
 	max_level = err + 1;
 	unix_get_secdata(siocb->scm, skb);
 
 	skb_put(skb, len - data_len);
 	skb->data_len = data_len;
 	skb->len = len;
 	err = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);
 	if (err)
 		goto out_free;
 
 	timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);
 
 restart:
 	if (!other) {
 		err = -ECONNRESET;
 		if (sunaddr == NULL)
 			goto out_free;
 
 		other = unix_find_other(net, sunaddr, namelen, sk->sk_type,
 					hash, &err);
 		if (other == NULL)
 			goto out_free;
 	}
 
 	if (sk_filter(other, skb) < 0) {
 		 
 		err = len;
 		goto out_free;
 	}
 
 	unix_state_lock(other);
 	err = -EPERM;
 	if (!unix_may_send(sk, other))
 		goto out_unlock;
 
 	if (sock_flag(other, SOCK_DEAD)) {
 		 
 		unix_state_unlock(other);
 		sock_put(other);
 
 		err = 0;
 		unix_state_lock(sk);
 		if (unix_peer(sk) == other) {
 			unix_peer(sk) = NULL;
 			unix_state_unlock(sk);
 
 			unix_dgram_disconnected(sk, other);
 			sock_put(other);
 			err = -ECONNREFUSED;
 		} else {
 			unix_state_unlock(sk);
 		}
 
 		other = NULL;
 		if (err)
 			goto out_free;
 		goto restart;
 	}
 
 	err = -EPIPE;
 	if (other->sk_shutdown & RCV_SHUTDOWN)
 		goto out_unlock;
 
 	if (sk->sk_type != SOCK_SEQPACKET) {
 		err = security_unix_may_send(sk->sk_socket, other->sk_socket);
 		if (err)
 			goto out_unlock;
 	}
 
 	if (unix_peer(other) != sk && unix_recvq_full(other)) {
 		if (!timeo) {
 			err = -EAGAIN;
 			goto out_unlock;
 		}
 
 		timeo = unix_wait_for_peer(other, timeo);
 
 		err = sock_intr_errno(timeo);
 		if (signal_pending(current))
 			goto out_free;
 
 		goto restart;
 	}
 
 	if (sock_flag(other, SOCK_RCVTSTAMP))
 		__net_timestamp(skb);
 	maybe_add_creds(skb, sock, other);
 	skb_queue_tail(&other->sk_receive_queue, skb);
 	if (max_level > unix_sk(other)->recursion_level)
 		unix_sk(other)->recursion_level = max_level;
 	unix_state_unlock(other);
 	other->sk_data_ready(other, len);
 	sock_put(other);
 	scm_destroy(siocb->scm);
 	return len;
 
 out_unlock:
 	unix_state_unlock(other);
 out_free:
 	kfree_skb(skb);
 out:
 	if (other)
 		sock_put(other);
 	scm_destroy(siocb->scm);
 	return err;
 }","[23, 22]","The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager."
207987," static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
  const size_t kNGroupsOffset = 12;
  const size_t kFirstGroupOffset = 16;
 
      const size_t kGroupSize = 12;
      const size_t kStartCharCodeOffset = 0;
      const size_t kEndCharCodeOffset = 4;
     const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;   
      
      if (kFirstGroupOffset > size) {
          return false;
      }
      uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
     if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
          return false;
      }
      for (uint32_t i = 0; i < nGroups; i++) {
  uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
  uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
  uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
         addRange(coverage, start, end + 1);  
  }
  return true;
 }","[8, 9, 15, 14]","Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298."
201137," _zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)
 {
     zip_uint8_t buf[CDENTRYSIZE];
     zip_uint16_t dostime, dosdate;
     zip_uint32_t size, variable_size;
     zip_uint16_t filename_len, comment_len, ef_len;
 
     bool from_buffer = (buffer != NULL);
 
     size = local ? LENTRYSIZE : CDENTRYSIZE;
 
     if (buffer) {
         if (_zip_buffer_left(buffer) < size) {
             zip_error_set(error, ZIP_ER_NOZIP, 0);
             return -1;
         }
     }
     else {
         if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {
             return -1;
         }
     }
 
     if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {
 	zip_error_set(error, ZIP_ER_NOZIP, 0);
         if (!from_buffer) {
             _zip_buffer_free(buffer);
         }
 	return -1;
     }
 
      
 
     _zip_dirent_init(zde);
     if (!local)
 	zde->version_madeby = _zip_buffer_get_16(buffer);
     else
 	zde->version_madeby = 0;
     zde->version_needed = _zip_buffer_get_16(buffer);
     zde->bitflags = _zip_buffer_get_16(buffer);
     zde->comp_method = _zip_buffer_get_16(buffer);
 
      
     dostime = _zip_buffer_get_16(buffer);
     dosdate = _zip_buffer_get_16(buffer);
     zde->last_mod = _zip_d2u_time(dostime, dosdate);
 
     zde->crc = _zip_buffer_get_32(buffer);
     zde->comp_size = _zip_buffer_get_32(buffer);
     zde->uncomp_size = _zip_buffer_get_32(buffer);
 
     filename_len = _zip_buffer_get_16(buffer);
     ef_len = _zip_buffer_get_16(buffer);
 
     if (local) {
 	comment_len = 0;
 	zde->disk_number = 0;
 	zde->int_attrib = 0;
 	zde->ext_attrib = 0;
 	zde->offset = 0;
     } else {
 	comment_len = _zip_buffer_get_16(buffer);
 	zde->disk_number = _zip_buffer_get_16(buffer);
 	zde->int_attrib = _zip_buffer_get_16(buffer);
 	zde->ext_attrib = _zip_buffer_get_32(buffer);
 	zde->offset = _zip_buffer_get_32(buffer);
     }
 
     if (!_zip_buffer_ok(buffer)) {
         zip_error_set(error, ZIP_ER_INTERNAL, 0);
         if (!from_buffer) {
             _zip_buffer_free(buffer);
         }
         return -1;
     }
 
     if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {
 	if (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {
 	     
 	    zde->encryption_method = ZIP_EM_UNKNOWN;
 	}
 	else {
 	    zde->encryption_method = ZIP_EM_TRAD_PKWARE;
 	}
     }
     else {
 	zde->encryption_method = ZIP_EM_NONE;
     }
 
     zde->filename = NULL;
     zde->extra_fields = NULL;
     zde->comment = NULL;
 
     variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;
 
     if (from_buffer) {
         if (_zip_buffer_left(buffer) < variable_size) {
             zip_error_set(error, ZIP_ER_INCONS, 0);
             return -1;
         }
     }
     else {
         _zip_buffer_free(buffer);
 
         if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {
             return -1;
         }
     }
 
     if (filename_len) {
 	zde->filename = _zip_read_string(buffer, src, filename_len, 1, error);
         if (!zde->filename) {
             if (zip_error_code_zip(error) == ZIP_ER_EOF) {
                 zip_error_set(error, ZIP_ER_INCONS, 0);
             }
             if (!from_buffer) {
                 _zip_buffer_free(buffer);
             }
 	    return -1;
         }
 
 	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
 	    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
 		zip_error_set(error, ZIP_ER_INCONS, 0);
                 if (!from_buffer) {
                     _zip_buffer_free(buffer);
                 }
 		return -1;
 	    }
 	}
     }
 
     if (ef_len) {
 	zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);
 
         if (ef == NULL) {
             if (!from_buffer) {
                 _zip_buffer_free(buffer);
             }
 	    return -1;
         }
         if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {
 	    free(ef);
             if (!from_buffer) {
                 _zip_buffer_free(buffer);
             }
 	    return -1;
 	}
 	free(ef);
 	if (local)
 	    zde->local_extra_fields_read = 1;
     }
 
     if (comment_len) {
 	zde->comment = _zip_read_string(buffer, src, comment_len, 0, error);
         if (!zde->comment) {
             if (!from_buffer) {
                 _zip_buffer_free(buffer);
             }
 	    return -1;
         }
 	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
 	    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
 		zip_error_set(error, ZIP_ER_INCONS, 0);
                 if (!from_buffer) {
                     _zip_buffer_free(buffer);
                 }
 		return -1;
 	    }
 	}
     }
 
     zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);
     zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);
 
      
 
     if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {
 	zip_uint16_t got_len;
         zip_buffer_t *ef_buffer;
 	const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);
 	 
         if (ef == NULL) {
             if (!from_buffer) {
                 _zip_buffer_free(buffer);
             }
 	    return -1;
         }
 
         if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {
             zip_error_set(error, ZIP_ER_MEMORY, 0);
             if (!from_buffer) {
                 _zip_buffer_free(buffer);
             }
             return -1;
         }
 
 	if (zde->uncomp_size == ZIP_UINT32_MAX)
 	    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);
 	else if (local) {
 	     
             (void)_zip_buffer_skip(ef_buffer, 8);  
 	}
 	if (zde->comp_size == ZIP_UINT32_MAX)
 	    zde->comp_size = _zip_buffer_get_64(ef_buffer);
 	if (!local) {
 	    if (zde->offset == ZIP_UINT32_MAX)
 		zde->offset = _zip_buffer_get_64(ef_buffer);
 	    if (zde->disk_number == ZIP_UINT16_MAX)
 		zde->disk_number = _zip_buffer_get_32(buffer);
 	}
 
         if (!_zip_buffer_eof(ef_buffer)) {
             zip_error_set(error, ZIP_ER_INCONS, 0);
             _zip_buffer_free(ef_buffer);
             if (!from_buffer) {
                 _zip_buffer_free(buffer);
             }
             return -1;
         }
         _zip_buffer_free(ef_buffer);
     }
 
     if (!_zip_buffer_ok(buffer)) {
         zip_error_set(error, ZIP_ER_INTERNAL, 0);
         if (!from_buffer) {
             _zip_buffer_free(buffer);
         }
         return -1;
     }
     if (!from_buffer) {
         _zip_buffer_free(buffer);
     }
 
      
     if (zde->offset > ZIP_INT64_MAX) {
 	zip_error_set(error, ZIP_ER_SEEK, EFBIG);
 	return -1;
      }
  
      if (!_zip_dirent_process_winzip_aes(zde, error)) {
	if (!from_buffer) {
	    _zip_buffer_free(buffer);
	}
  	return -1;
      }
  
     zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);
 
     return (zip_int64_t)(size + variable_size);
 }","[242, 243, 244]",Double free vulnerability in the _zip_dirent_read function in zip_dirent.c in libzip allows attackers to have unspecified impact via unknown vectors.
208163," status_t OMXNodeInstance::updateGraphicBufferInMeta(
         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
         OMX::buffer_id buffer) {
  Mutex::Autolock autoLock(mLock);
     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);
 
      return updateGraphicBufferInMeta_l(
              portIndex, graphicBuffer, buffer, header,
            portIndex == kPortIndexOutput  );
             true  );
  }","[10, 9]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
207598," int writepng_init(mainprog_info *mainprog_ptr)
 {
     png_structp  png_ptr;  
     png_infop  info_ptr;
  int color_type, interlace_type;
 
 
  
       
  
    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,
     png_ptr = png_create_write_struct(png_get_libpng_ver(NULL), mainprog_ptr,
        writepng_error_handler, NULL);
      if (!png_ptr)
          return 4;    
 
     info_ptr = png_create_info_struct(png_ptr);
  if (!info_ptr) {
         png_destroy_write_struct(&png_ptr, NULL);
  return 4;  
  }
 
 
   
 
  if (setjmp(mainprog_ptr->jmpbuf)) {
         png_destroy_write_struct(&png_ptr, &info_ptr);
  return 2;
  }
 
 
   
 
     png_init_io(png_ptr, mainprog_ptr->outfile);
 
 
   
 
     png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
  
 
 
   
 
  if (mainprog_ptr->pnmtype == 5)
         color_type = PNG_COLOR_TYPE_GRAY;
  else if (mainprog_ptr->pnmtype == 6)
         color_type = PNG_COLOR_TYPE_RGB;
  else if (mainprog_ptr->pnmtype == 8)
         color_type = PNG_COLOR_TYPE_RGB_ALPHA;
  else {
         png_destroy_write_struct(&png_ptr, &info_ptr);
  return 11;
  }
 
     interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 :
                                                PNG_INTERLACE_NONE;
 
     png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,
       mainprog_ptr->sample_depth, color_type, interlace_type,
       PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
 
  if (mainprog_ptr->gamma > 0.0)
         png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma);
 
  if (mainprog_ptr->have_bg) {  
         png_color_16  background;
 
         background.red = mainprog_ptr->bg_red;
         background.green = mainprog_ptr->bg_green;
         background.blue = mainprog_ptr->bg_blue;
         png_set_bKGD(png_ptr, info_ptr, &background);
  }
 
  if (mainprog_ptr->have_time) {
         png_time  modtime;
 
  png_convert_from_time_t(&modtime, mainprog_ptr->modtime);
         png_set_tIME(png_ptr, info_ptr, &modtime);
  }
 
  if (mainprog_ptr->have_text) {
         png_text  text[6];
  int  num_text = 0;
 
  if (mainprog_ptr->have_text & TEXT_TITLE) {
             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
             text[num_text].key = ""Title"";
             text[num_text].text = mainprog_ptr->title;
  ++num_text;
  }
  if (mainprog_ptr->have_text & TEXT_AUTHOR) {
             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
             text[num_text].key = ""Author"";
             text[num_text].text = mainprog_ptr->author;
  ++num_text;
  }
  if (mainprog_ptr->have_text & TEXT_DESC) {
             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
             text[num_text].key = ""Description"";
             text[num_text].text = mainprog_ptr->desc;
  ++num_text;
  }
  if (mainprog_ptr->have_text & TEXT_COPY) {
             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
             text[num_text].key = ""Copyright"";
             text[num_text].text = mainprog_ptr->copyright;
  ++num_text;
  }
  if (mainprog_ptr->have_text & TEXT_EMAIL) {
             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
             text[num_text].key = ""E-mail"";
             text[num_text].text = mainprog_ptr->email;
  ++num_text;
  }
  if (mainprog_ptr->have_text & TEXT_URL) {
             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
             text[num_text].key = ""URL"";
             text[num_text].text = mainprog_ptr->url;
  ++num_text;
  }
         png_set_text(png_ptr, info_ptr, text, num_text);
  }
 
 
   
 
     png_write_info(png_ptr, info_ptr);
 
 
   
 
 
   
 
     png_set_packing(png_ptr);
  
 
 
   
 
     mainprog_ptr->png_ptr = png_ptr;
     mainprog_ptr->info_ptr = info_ptr;
 
 
   
 
  return 0;
 }","[12, 11]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
8412,"static struct port_buffer *get_inbuf(struct port *port)
{
struct port_buffer *buf;
unsigned int len;

if (port->inbuf)
return port->inbuf;

buf = virtqueue_get_buf(port->in_vq, &len);
if (buf) {
buf->len = len;
buf->offset = 0;
port->stats.bytes_received += len;
}
return buf;
}",[11],"** DISPUTED ** In drivers/char/virtio_console.c in the Linux kernel before 5.13.4, data corruption or loss can be triggered by an untrusted device that supplies a buf->len value exceeding the buffer size. NOTE: the vendor indicates that the cited data corruption is not a vulnerability in any existing use case; the length validation was added solely for robustness in the face of anomalous host OS behavior."
204676,"   InstalledBubbleContent(Browser* browser,
                          const Extension* extension,
                          ExtensionInstalledBubble::BubbleType type,
                          SkBitmap* icon,
                          ExtensionInstalledBubble* bubble)
       : browser_(browser),
         extension_id_(extension->id()),
         bubble_(bubble),
         type_(type),
         info_(NULL) {
     ResourceBundle& rb = ResourceBundle::GetSharedInstance();
     const gfx::Font& font = rb.GetFont(ResourceBundle::BaseFont);
 
     gfx::Size size(icon->width(), icon->height());
     if (size.width() > kIconSize || size.height() > kIconSize)
       size = gfx::Size(kIconSize, kIconSize);
     icon_ = new views::ImageView();
     icon_->SetImageSize(size);
     icon_->SetImage(*icon);
     AddChildView(icon_);
 
      string16 extension_name = UTF8ToUTF16(extension->name());
      base::i18n::AdjustStringForLocaleDirection(&extension_name);
      heading_ = new views::Label(l10n_util::GetStringFUTF16(
        IDS_EXTENSION_INSTALLED_HEADING,
        extension_name,
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME)));
         IDS_EXTENSION_INSTALLED_HEADING, extension_name));
      heading_->SetFont(rb.GetFont(ResourceBundle::MediumFont));
      heading_->SetMultiLine(true);
      heading_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
     AddChildView(heading_);
 
     switch (type_) {
       case ExtensionInstalledBubble::PAGE_ACTION: {
         info_ = new views::Label(l10n_util::GetStringUTF16(
             IDS_EXTENSION_INSTALLED_PAGE_ACTION_INFO));
         info_->SetFont(font);
         info_->SetMultiLine(true);
         info_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
         AddChildView(info_);
         break;
       }
       case ExtensionInstalledBubble::OMNIBOX_KEYWORD: {
         info_ = new views::Label(l10n_util::GetStringFUTF16(
             IDS_EXTENSION_INSTALLED_OMNIBOX_KEYWORD_INFO,
             UTF8ToUTF16(extension->omnibox_keyword())));
         info_->SetFont(font);
         info_->SetMultiLine(true);
         info_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
         AddChildView(info_);
         break;
       }
       case ExtensionInstalledBubble::APP: {
         views::Link* link = new views::Link(
             l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALLED_APP_INFO));
         link->set_listener(this);
         manage_ = link;
         manage_->SetFont(font);
         manage_->SetMultiLine(true);
         manage_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
         AddChildView(manage_);
         break;
       }
       default:
         break;
     }
 
     if (type_ != ExtensionInstalledBubble::APP) {
       manage_ = new views::Label(
           l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALLED_MANAGE_INFO));
       manage_->SetFont(font);
       manage_->SetMultiLine(true);
       manage_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);
       AddChildView(manage_);
     }
 
     close_button_ = new views::ImageButton(this);
     close_button_->SetImage(views::CustomButton::BS_NORMAL,
         rb.GetBitmapNamed(IDR_CLOSE_BAR));
     close_button_->SetImage(views::CustomButton::BS_HOT,
         rb.GetBitmapNamed(IDR_CLOSE_BAR_H));
     close_button_->SetImage(views::CustomButton::BS_PUSHED,
         rb.GetBitmapNamed(IDR_CLOSE_BAR_P));
     AddChildView(close_button_);
   }","[28, 25, 26, 27]","Skia, as used in Google Chrome before 19.0.1084.52, allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
204779," static v8::Handle<v8::Value> methodThatRequiresAllArgsAndThrowsCallback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestObj.methodThatRequiresAllArgsAndThrows"");
      if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestObj* imp = V8TestObj::toNative(args.Holder());
      ExceptionCode ec = 0;
      {
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
     RefPtr<TestObj> result = imp->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec);
     if (UNLIKELY(ec))
         goto fail;
     return toV8(result.release(), args.GetIsolate());
     }
     fail:
     V8Proxy::setDOMException(ec, args.GetIsolate());
     return v8::Handle<v8::Value>();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
199168," static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,
                              const uint8_t *src, int src_size)
 {
     int width, height;
     int hdr, zsize, npal, tidx = -1, ret;
     int i, j;
     const uint8_t *src_end = src + src_size;
     uint8_t pal[768], transp[3];
     uLongf dlen = (c->tile_width + 1) * c->tile_height;
     int sub_type;
     int nblocks, cblocks, bstride;
     int bits, bitbuf, coded;
     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +
                    tile_y * c->tile_height * c->framebuf_stride;
 
     if (src_size < 2)
         return AVERROR_INVALIDDATA;
 
     width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);
     height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);
 
     hdr = *src++;
     sub_type = hdr >> 5;
     if (sub_type == 0) {
         int j;
         memcpy(transp, src, 3);
         src += 3;
         for (j = 0; j < height; j++, dst += c->framebuf_stride)
             for (i = 0; i < width; i++)
                 memcpy(dst + i * 3, transp, 3);
         return 0;
     } else if (sub_type == 1) {
         return jpg_decode_data(&c->jc, width, height, src, src_end - src,
                                dst, c->framebuf_stride, NULL, 0, 0, 0);
     }
 
     if (sub_type != 2) {
         memcpy(transp, src, 3);
         src += 3;
     }
     npal = *src++ + 1;
     memcpy(pal, src, npal * 3); src += npal * 3;
     if (sub_type != 2) {
         for (i = 0; i < npal; i++) {
             if (!memcmp(pal + i * 3, transp, 3)) {
                tidx = i;
                break;
             }
         }
     }
 
     if (src_end - src < 2)
          return 0;
      zsize = (src[0] << 8) | src[1]; src += 2;
  
    if (src_end - src < zsize)
     if (src_end - src < zsize + (sub_type != 2))
          return AVERROR_INVALIDDATA;
  
      ret = uncompress(c->kempf_buf, &dlen, src, zsize);
     if (ret)
         return AVERROR_INVALIDDATA;
     src += zsize;
 
     if (sub_type == 2) {
         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
                           NULL, 0, width, height, pal, npal, tidx);
         return 0;
     }
 
     nblocks = *src++ + 1;
     cblocks = 0;
     bstride = FFALIGN(width, 16) >> 4;
     bits = 0;
      for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {
          for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {
              if (!bits) {
                 if (src >= src_end)
                     return AVERROR_INVALIDDATA;
                  bitbuf = *src++;
                  bits   = 8;
              }
             coded = bitbuf & 1;
             bits--;
             bitbuf >>= 1;
             cblocks += coded;
             if (cblocks > nblocks)
                 return AVERROR_INVALIDDATA;
             c->kempf_flags[j + i * bstride] = coded;
         }
     }
 
     memset(c->jpeg_tile, 0, c->tile_stride * height);
     jpg_decode_data(&c->jc, width, height, src, src_end - src,
                     c->jpeg_tile, c->tile_stride,
                     c->kempf_flags, bstride, nblocks, 0);
 
     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
                       c->jpeg_tile, c->tile_stride,
                       width, height, pal, npal, tidx);
 
     return 0;
 }","[57, 78, 79, 56]",The kempf_decode_tile function in libavcodec/g2meet.c in FFmpeg before 2.0.1 allows remote attackers to cause a denial of service (out-of-bounds heap write) via a G2M4 encoded file.
204439," void GDataCacheMetadataMap::Initialize(
     const std::vector<FilePath>& cache_paths) {
    AssertOnSequencedWorkerPool();
  
    if (cache_paths.size() < GDataCache::NUM_CACHE_TYPES) {
    LOG(ERROR) << ""Size of cache_paths is invalid."";
     DLOG(ERROR) << ""Size of cache_paths is invalid."";
      return;
    }
  
  if (!GDataCache::CreateCacheDirectories(cache_paths))
   if (!CreateCacheDirectories(cache_paths))
      return;
  
   if (!ChangeFilePermissions(cache_paths[GDataCache::CACHE_TYPE_PERSISTENT],
                              S_IRWXU | S_IXGRP | S_IXOTH))
     return;
 
   DVLOG(1) << ""Scanning directories"";
  
  ResourceIdToFilePathMap persistent_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_PERSISTENT,
                     &cache_map_,
                     &persistent_file_map);
  ResourceIdToFilePathMap tmp_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_TMP,
                     &cache_map_,
                     &tmp_file_map);
  ResourceIdToFilePathMap pinned_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_PINNED,
                     &cache_map_,
                     &pinned_file_map);
  ResourceIdToFilePathMap outgoing_file_map;
  ScanCacheDirectory(cache_paths,
                     GDataCache::CACHE_TYPE_OUTGOING,
                     &cache_map_,
                     &outgoing_file_map);
  RemoveInvalidFilesFromPersistentDirectory(persistent_file_map,
                                            outgoing_file_map,
                                            &cache_map_);
   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_PERSISTENT,
                      &cache_map_);
   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_TMP, &cache_map_);
 
    
    
    
    
    
    
    
   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_PINNED, &cache_map_);
   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_OUTGOING, &cache_map_);
 
    DVLOG(1) << ""Directory scan finished"";
  }","[7, 12, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 6, 11, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43]",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
199836," spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_ctx_id_t context,
 			 int prf_key,
 			 const gss_buffer_t prf_in,
 			 ssize_t desired_output_len,
  			 gss_buffer_t prf_out)
  {
  	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
 
 	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
 		return (GSS_S_NO_CONTEXT);
 
  	ret = gss_pseudo_random(minor_status,
				context,
 				sc->ctx_handle,
  				prf_key,
  				prf_in,
  				desired_output_len,
 				prf_out);
         return (ret);
 }","[9, 10, 11, 12, 13, 16, 15]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
207446," static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
 {
  int i;
 
   
  for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)
  {
   
  if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)
  {
   
  if (check_a2dp_ready(common) == 0)
 
                  break;
  
              ERROR(""error : a2dp not ready, wait 250 ms and retry"");
            usleep(250000);
             TEMP_FAILURE_RETRY(usleep(250000));
              skt_disconnect(common->ctrl_fd);
              common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
          }
  
           
        usleep(250000);
         TEMP_FAILURE_RETRY(usleep(250000));
      }
  }","[18, 25, 17, 24]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
85,"static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)
{
unsigned char l, n = 0;
char callsign[11];

do {
switch (*p & 0xC0) {
case 0x00:
p   += 2;
n   += 2;
len -= 2;
break;

case 0x40:
p   += 3;
n   += 3;
len -= 3;
break;

case 0x80:
p   += 4;
n   += 4;
len -= 4;
break;

case 0xC0:
l = p[1];
if (*p == FAC_CCITT_DEST_NSAP) {
memcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);
memcpy(callsign, p + 12,   l - 10);
callsign[l - 10] = '\0';
asc2ax(&facilities->source_call, callsign);
}
if (*p == FAC_CCITT_SRC_NSAP) {
memcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);
memcpy(callsign, p + 12, l - 10);
callsign[l - 10] = '\0';
asc2ax(&facilities->dest_call, callsign);
}
p   += l + 2;
n   += l + 2;
len -= l + 2;
break;
}
} while (*p != 0x00 && len > 0);

return n;
}",[28],"Array index error in the rose_parse_national function in net/rose/rose_subr.c in the Linux kernel before 2.6.39 allows remote attackers to cause a denial of service (heap memory corruption) or possibly have unspecified other impact by composing FAC_NATIONAL_DIGIS data that specifies a large number of digipeaters, and then sending this data to a ROSE socket."
206604," void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {
   if (ValidateDataOrigin(other->data_origin_)) {
     DCHECK(thread_checker_.CalledOnValidThread());
     valid_until_ = std::max(valid_until_, other->valid_until_);
     set_length(other->length_);
     cacheable_ |= other->cacheable_;
     range_supported_ |= other->range_supported_;
     if (last_modified_.is_null()) {
        last_modified_ = other->last_modified_;
      }
      bytes_read_from_cache_ += other->bytes_read_from_cache_;
    set_has_opaque_data(other->has_opaque_data_);
      
     set_is_cors_cross_origin(other->is_cors_cross_origin_);
      multibuffer()->MergeFrom(other->multibuffer());
    }
  }","[13, 14, 12]",Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.
206648," void DevToolsDataSource::StartDataRequest(
     const std::string& path,
     const content::ResourceRequestInfo::WebContentsGetter& wc_getter,
     const content::URLDataSource::GotDataCallback& callback) {
   std::string bundled_path_prefix(chrome::kChromeUIDevToolsBundledPath);
   bundled_path_prefix += ""/"";
   if (base::StartsWith(path, bundled_path_prefix,
                        base::CompareCase::INSENSITIVE_ASCII)) {
     StartBundledDataRequest(path.substr(bundled_path_prefix.length()),
                             callback);
     return;
   }
 
   std::string empty_path_prefix(chrome::kChromeUIDevToolsBlankPath);
   if (base::StartsWith(path, empty_path_prefix,
                        base::CompareCase::INSENSITIVE_ASCII)) {
     callback.Run(new base::RefCountedStaticMemory());
     return;
   }
 
   std::string remote_path_prefix(chrome::kChromeUIDevToolsRemotePath);
   remote_path_prefix += ""/"";
   if (base::StartsWith(path, remote_path_prefix,
                        base::CompareCase::INSENSITIVE_ASCII)) {
     GURL url(kRemoteFrontendBase + path.substr(remote_path_prefix.length()));
 
     CHECK_EQ(url.host(), kRemoteFrontendDomain);
     if (url.is_valid() && DevToolsUIBindings::IsValidRemoteFrontendURL(url)) {
       StartRemoteDataRequest(url, callback);
     } else {
       DLOG(ERROR) << ""Refusing to load invalid remote front-end URL"";
       callback.Run(new base::RefCountedStaticMemory(kHttpNotFound,
                                                     strlen(kHttpNotFound)));
     }
     return;
   }
 
   std::string custom_frontend_url =
       base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kCustomDevtoolsFrontend);
 
   if (custom_frontend_url.empty()) {
     callback.Run(NULL);
     return;
   }
 
   std::string custom_path_prefix(chrome::kChromeUIDevToolsCustomPath);
   custom_path_prefix += ""/"";
 
   if (base::StartsWith(path, custom_path_prefix,
                         base::CompareCase::INSENSITIVE_ASCII)) {
      GURL url = GURL(custom_frontend_url +
                      path.substr(custom_path_prefix.length()));
     DCHECK(url.is_valid());
      StartCustomDataRequest(url, callback);
      return;
    }
 
   callback.Run(NULL);
 }",[54],Insufficient policy enforcement in DevTools in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially leak user local file data via a crafted Chrome Extension.
6309,"static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,
char *buf, u_int8_t client_hash) {
u_int16_t offset = 22, buf_out_len = 0;
if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;
u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);
offset += 4;


if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;


strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);
buf[buf_out_len++] = ';';
offset += len;


len = ntohl(*(u_int32_t*)&packet->payload[offset]);
offset += 4 + len;


len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;


len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(!client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;


len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;


len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(!client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;


if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
offset += len;
} else
offset += 4 + len;


len = ntohl(*(u_int32_t*)&packet->payload[offset]);

if(!client_hash) {
offset += 4;

if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;

strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
offset += len;
} else
offset += 4 + len;





#ifdef SSH_DEBUG
printf(""[SSH] %s\n"", buf);
#endif

return(buf_out_len);

invalid_payload:

#ifdef SSH_DEBUG
printf(""[SSH] Invalid packet payload\n"");
#endif

return(0);
}","[19, 23, 39, 55, 71, 104]","In nDPI through 3.2 Stable, an out-of-bounds read in concat_hash_string in ssh.c can be exploited by a network-positioned attacker that can send malformed SSH protocol messages on a network segment monitored by nDPI's library."
5636,"WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,
const char *option,const char *arg1n,const char *arg2n)
{
const char
*arg1,
*arg2;

Image
*new_images;

MagickStatusType
status;

ssize_t
parse;

#define _image_info     (cli_wand->wand.image_info)
#define _images         (cli_wand->wand.images)
#define _exception      (cli_wand->wand.exception)
#define _draw_info      (cli_wand->draw_info)
#define _quantize_info  (cli_wand->quantize_info)
#define _process_flags  (cli_wand->process_flags)
#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)
#define IfNormalOp      (*option=='-')
#define IfPlusOp        (*option!='-')
#define IsNormalOp      IfNormalOp ? MagickTrue : MagickFalse

assert(cli_wand != (MagickCLI *) NULL);
assert(cli_wand->signature == MagickWandSignature);
assert(cli_wand->wand.signature == MagickWandSignature);
assert(_images != (Image *) NULL);

if (cli_wand->wand.debug != MagickFalse)
(void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),
""- List Operator: %s \""%s\"" \""%s\"""", option,
arg1n == (const char *) NULL ? ""null"" : arg1n,
arg2n == (const char *) NULL ? ""null"" : arg2n);

arg1 = arg1n;
arg2 = arg2n;


if ( (((_process_flags & ProcessInterpretProperities) != 0 )
|| ((_option_type & AlwaysInterpretArgsFlag) != 0)
)  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {

if (arg1n != (char *) NULL) {
arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);
if (arg1 == (char *) NULL) {
CLIWandException(OptionWarning,""InterpretPropertyFailure"",option);
arg1=arg1n;
}
}
if (arg2n != (char *) NULL) {
arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);
if (arg2 == (char *) NULL) {
CLIWandException(OptionWarning,""InterpretPropertyFailure"",option);
arg2=arg2n;
}
}
}
#undef _process_flags
#undef _option_type

status=MagickTrue;
new_images=NewImageList();

switch (*(option+1))
{
case 'a':
{
if (LocaleCompare(""append"",option+1) == 0)
{
new_images=AppendImages(_images,IsNormalOp,_exception);
break;
}
if (LocaleCompare(""average"",option+1) == 0)
{
CLIWandWarnReplaced(""-evaluate-sequence Mean"");
(void) CLIListOperatorImages(cli_wand,""-evaluate-sequence"",""Mean"",
NULL);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'c':
{
if (LocaleCompare(""channel-fx"",option+1) == 0)
{
new_images=ChannelFxImage(_images,arg1,_exception);
break;
}
if (LocaleCompare(""clut"",option+1) == 0)
{
Image
*clut_image;





new_images=RemoveFirstImageFromList(&_images);
clut_image=RemoveLastImageFromList(&_images);

if (clut_image == (Image *) NULL)
break;
(void) ClutImage(new_images,clut_image,new_images->interpolate,
_exception);
clut_image=DestroyImage(clut_image);
break;
}
if (LocaleCompare(""coalesce"",option+1) == 0)
{
new_images=CoalesceImages(_images,_exception);
break;
}
if (LocaleCompare(""combine"",option+1) == 0)
{
parse=(ssize_t) _images->colorspace;
if (_images->number_channels < GetImageListLength(_images))
parse=sRGBColorspace;
if ( IfPlusOp )
parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);
if (parse < 0)
CLIWandExceptArgBreak(OptionError,""UnrecognizedColorspace"",option,
arg1);
new_images=CombineImages(_images,(ColorspaceType) parse,_exception);
break;
}
if (LocaleCompare(""compare"",option+1) == 0)
{
double
distortion;

Image
*image,
*reconstruct_image;

MetricType
metric;





image=RemoveFirstImageFromList(&_images);
reconstruct_image=RemoveFirstImageFromList(&_images);

if (reconstruct_image == (Image *) NULL)
{
image=DestroyImage(image);
break;
}
metric=UndefinedErrorMetric;
option=GetImageOption(_image_info,""metric"");
if (option != (const char *) NULL)
metric=(MetricType) ParseCommandOption(MagickMetricOptions,
MagickFalse,option);
new_images=CompareImages(image,reconstruct_image,metric,&distortion,
_exception);
(void) distortion;
reconstruct_image=DestroyImage(reconstruct_image);
image=DestroyImage(image);
break;
}
if (LocaleCompare(""complex"",option+1) == 0)
{
parse=ParseCommandOption(MagickComplexOptions,MagickFalse,arg1);
if (parse < 0)
CLIWandExceptArgBreak(OptionError,""UnrecognizedEvaluateOperator"",
option,arg1);
new_images=ComplexImages(_images,(ComplexOperator) parse,_exception);
break;
}
if (LocaleCompare(""composite"",option+1) == 0)
{
CompositeOperator
compose;

const char*
value;

MagickBooleanType
clip_to_self;

Image
*mask_image,
*source_image;

RectangleInfo
geometry;


value=GetImageOption(_image_info,""compose"");
if (value == (const char *) NULL)
compose=OverCompositeOp;
else
compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,
MagickFalse,value);


clip_to_self=GetCompositeClipToSelf(compose);
value=GetImageOption(_image_info,""compose:clip-to-self"");
if (value != (const char *) NULL)
clip_to_self=IsStringTrue(value);
value=GetImageOption(_image_info,""compose:outside-overlay"");
if (value != (const char *) NULL)
clip_to_self=IsStringFalse(value);

new_images=RemoveFirstImageFromList(&_images);
source_image=RemoveFirstImageFromList(&_images);
if (source_image == (Image *) NULL)
break;


if (source_image->geometry != (char *) NULL)
{
RectangleInfo
resize_geometry;

(void) ParseRegionGeometry(source_image,source_image->geometry,
&resize_geometry,_exception);
if ((source_image->columns != resize_geometry.width) ||
(source_image->rows != resize_geometry.height))
{
Image
*resize_image;

resize_image=ResizeImage(source_image,resize_geometry.width,
resize_geometry.height,source_image->filter,_exception);
if (resize_image != (Image *) NULL)
{
source_image=DestroyImage(source_image);
source_image=resize_image;
}
}
}
SetGeometry(source_image,&geometry);
(void) ParseAbsoluteGeometry(source_image->geometry,&geometry);
GravityAdjustGeometry(new_images->columns,new_images->rows,
new_images->gravity, &geometry);
mask_image=RemoveFirstImageFromList(&_images);
if (mask_image == (Image *) NULL)
status&=CompositeImage(new_images,source_image,compose,clip_to_self,
geometry.x,geometry.y,_exception);
else
{
if ((compose == DisplaceCompositeOp) ||
(compose == DistortCompositeOp))
{
status&=CompositeImage(source_image,mask_image,
CopyGreenCompositeOp,MagickTrue,0,0,_exception);
status&=CompositeImage(new_images,source_image,compose,
clip_to_self,geometry.x,geometry.y,_exception);
}
else
{
Image
*clone_image;

clone_image=CloneImage(new_images,0,0,MagickTrue,_exception);
if (clone_image == (Image *) NULL)
break;
status&=CompositeImage(new_images,source_image,compose,
clip_to_self,geometry.x,geometry.y,_exception);
status&=CompositeImage(new_images,mask_image,
CopyAlphaCompositeOp,MagickTrue,0,0,_exception);
status&=CompositeImage(clone_image,new_images,OverCompositeOp,
clip_to_self,0,0,_exception);
new_images=DestroyImageList(new_images);
new_images=clone_image;
}
mask_image=DestroyImage(mask_image);
}
source_image=DestroyImage(source_image);
break;
}
if (LocaleCompare(""copy"",option+1) == 0)
{
Image
*source_image;

OffsetInfo
offset;

RectangleInfo
geometry;




if (IsGeometry(arg1) == MagickFalse)
CLIWandExceptArgBreak(OptionError,""InvalidArgument"",option,arg1);
if (IsGeometry(arg2) == MagickFalse)
CLIWandExceptArgBreak(OptionError,""InvalidArgument"",option,arg1);
(void) ParsePageGeometry(_images,arg2,&geometry,_exception);
offset.x=geometry.x;
offset.y=geometry.y;
source_image=_images;
if (source_image->next != (Image *) NULL)
source_image=source_image->next;
(void) ParsePageGeometry(source_image,arg1,&geometry,_exception);
(void) CopyImagePixels(_images,source_image,&geometry,&offset,
_exception);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'd':
{
if (LocaleCompare(""deconstruct"",option+1) == 0)
{
CLIWandWarnReplaced(""-layer CompareAny"");
(void) CLIListOperatorImages(cli_wand,""-layer"",""CompareAny"",NULL);
break;
}
if (LocaleCompare(""delete"",option+1) == 0)
{
if (IfNormalOp)
DeleteImages(&_images,arg1,_exception);
else
DeleteImages(&_images,""-1"",_exception);
break;
}
if (LocaleCompare(""duplicate"",option+1) == 0)
{
if (IfNormalOp)
{
const char
*p;

size_t
number_duplicates;

if (IsGeometry(arg1) == MagickFalse)
CLIWandExceptArgBreak(OptionError,""InvalidArgument"",option,
arg1);
number_duplicates=(size_t) StringToLong(arg1);
p=strchr(arg1,',');
if (p == (const char *) NULL)
new_images=DuplicateImages(_images,number_duplicates,""-1"",
_exception);
else
new_images=DuplicateImages(_images,number_duplicates,p,
_exception);
}
else
new_images=DuplicateImages(_images,1,""-1"",_exception);
AppendImageToList(&_images, new_images);
new_images=(Image *) NULL;
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'e':
{
if (LocaleCompare(""evaluate-sequence"",option+1) == 0)
{
parse=ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);
if (parse < 0)
CLIWandExceptArgBreak(OptionError,""UnrecognizedEvaluateOperator"",
option,arg1);
new_images=EvaluateImages(_images,(MagickEvaluateOperator) parse,
_exception);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'f':
{
if (LocaleCompare(""fft"",option+1) == 0)
{
new_images=ForwardFourierTransformImage(_images,IsNormalOp,
_exception);
break;
}
if (LocaleCompare(""flatten"",option+1) == 0)
{

(void) CLIListOperatorImages(cli_wand,""-layers"",option+1,NULL);
break;
}
if (LocaleCompare(""fx"",option+1) == 0)
{
new_images=FxImage(_images,arg1,_exception);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'h':
{
if (LocaleCompare(""hald-clut"",option+1) == 0)
{



Image
*hald_image;

new_images=RemoveFirstImageFromList(&_images);
hald_image=RemoveLastImageFromList(&_images);
if (hald_image == (Image *) NULL)
break;
(void) HaldClutImage(new_images,hald_image,_exception);
hald_image=DestroyImage(hald_image);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'i':
{
if (LocaleCompare(""ift"",option+1) == 0)
{
Image
*magnitude_image,
*phase_image;

magnitude_image=RemoveFirstImageFromList(&_images);
phase_image=RemoveFirstImageFromList(&_images);

if (phase_image == (Image *) NULL)
break;
new_images=InverseFourierTransformImage(magnitude_image,phase_image,
IsNormalOp,_exception);
magnitude_image=DestroyImage(magnitude_image);
phase_image=DestroyImage(phase_image);
break;
}
if (LocaleCompare(""insert"",option+1) == 0)
{
Image
*insert_image,
*index_image;

ssize_t
index;

if (IfNormalOp && (IsGeometry(arg1) == MagickFalse))
CLIWandExceptArgBreak(OptionError,""InvalidArgument"",option,arg1);
index=0;
insert_image=RemoveLastImageFromList(&_images);
if (IfNormalOp)
index=(ssize_t) StringToLong(arg1);
index_image=insert_image;
if (index == 0)
PrependImageToList(&_images,insert_image);
else if (index == (ssize_t) GetImageListLength(_images))
AppendImageToList(&_images,insert_image);
else
{
index_image=GetImageFromList(_images,index-1);
if (index_image == (Image *) NULL)
CLIWandExceptArgBreak(OptionError,""NoSuchImage"",option,arg1);
InsertImageInList(&index_image,insert_image);
}
_images=GetFirstImageInList(index_image);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'l':
{
if (LocaleCompare(""layers"",option+1) == 0)
{
parse=ParseCommandOption(MagickLayerOptions,MagickFalse,arg1);
if ( parse < 0 )
CLIWandExceptArgBreak(OptionError,""UnrecognizedLayerMethod"",
option,arg1);
switch ((LayerMethod) parse)
{
case CoalesceLayer:
{
new_images=CoalesceImages(_images,_exception);
break;
}
case CompareAnyLayer:
case CompareClearLayer:
case CompareOverlayLayer:
default:
{
new_images=CompareImagesLayers(_images,(LayerMethod) parse,
_exception);
break;
}
case MergeLayer:
case FlattenLayer:
case MosaicLayer:
case TrimBoundsLayer:
{
new_images=MergeImageLayers(_images,(LayerMethod) parse,
_exception);
break;
}
case DisposeLayer:
{
new_images=DisposeImages(_images,_exception);
break;
}
case OptimizeImageLayer:
{
new_images=OptimizeImageLayers(_images,_exception);
break;
}
case OptimizePlusLayer:
{
new_images=OptimizePlusImageLayers(_images,_exception);
break;
}
case OptimizeTransLayer:
{
OptimizeImageTransparency(_images,_exception);
break;
}
case RemoveDupsLayer:
{
RemoveDuplicateLayers(&_images,_exception);
break;
}
case RemoveZeroLayer:
{
RemoveZeroDelayLayers(&_images,_exception);
break;
}
case OptimizeLayer:
{
new_images=CoalesceImages(_images,_exception);
if (new_images == (Image *) NULL)
break;
_images=DestroyImageList(_images);
_images=OptimizeImageLayers(new_images,_exception);
if (_images == (Image *) NULL)
break;
new_images=DestroyImageList(new_images);
OptimizeImageTransparency(_images,_exception);
(void) RemapImages(_quantize_info,_images,(Image *) NULL,
_exception);
break;
}
case CompositeLayer:
{
Image
*source;

RectangleInfo
geometry;

CompositeOperator
compose;

const char*
value;

value=GetImageOption(_image_info,""compose"");
compose=OverCompositeOp;
if (value != (const char *) NULL)
compose=(CompositeOperator) ParseCommandOption(
MagickComposeOptions,MagickFalse,value);


source=_images;
while (source != (Image *) NULL)
{
source=GetNextImageInList(source);
if ((source != (Image *) NULL) &&
(LocaleCompare(source->magick,""NULL"") == 0))
break;
}
if (source != (Image *) NULL)
{
if ((GetPreviousImageInList(source) == (Image *) NULL) ||
(GetNextImageInList(source) == (Image *) NULL))
source=(Image *) NULL;
else
{
source=SplitImageList(source->previous);
DeleteImageFromList(&source);
}
}
if (source == (Image *) NULL)
{
(void) ThrowMagickException(_exception,GetMagickModule(),
OptionError,""MissingNullSeparator"",""layers Composite"");
break;
}

SetGeometry(_images,&geometry);
(void) ParseAbsoluteGeometry(_images->geometry,&geometry);
geometry.width=source->page.width != 0 ?
source->page.width : source->columns;
geometry.height=source->page.height != 0 ?
source->page.height : source->rows;
GravityAdjustGeometry(_images->page.width != 0 ?
_images->page.width : _images->columns,
_images->page.height != 0 ? _images->page.height :
_images->rows,_images->gravity,&geometry);


CompositeLayers(_images,compose,source,geometry.x,geometry.y,
_exception);
source=DestroyImageList(source);
break;
}
}
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'm':
{
if (LocaleCompare(""map"",option+1) == 0)
{
CLIWandWarnReplaced(""+remap"");
(void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);
break;
}
if (LocaleCompare(""metric"",option+1) == 0)
{
(void) SetImageOption(_image_info,option+1,arg1);
break;
}
if (LocaleCompare(""morph"",option+1) == 0)
{
Image
*morph_image;

if (IsGeometry(arg1) == MagickFalse)
CLIWandExceptArgBreak(OptionError,""InvalidArgument"",option,arg1);
morph_image=MorphImages(_images,StringToUnsignedLong(arg1),
_exception);
if (morph_image == (Image *) NULL)
break;
_images=DestroyImageList(_images);
_images=morph_image;
break;
}
if (LocaleCompare(""mosaic"",option+1) == 0)
{

(void) CLIListOperatorImages(cli_wand,""-layers"",option+1,NULL);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'p':
{
if (LocaleCompare(""poly"",option+1) == 0)
{
double
*args;

ssize_t
count;


args = StringToArrayOfDoubles(arg1,&count,_exception);
if (args == (double *) NULL )
CLIWandExceptArgBreak(OptionError,""InvalidNumberList"",option,arg1);
new_images=PolynomialImage(_images,(size_t) (count >> 1),args,
_exception);
args=(double *) RelinquishMagickMemory(args);
break;
}
if (LocaleCompare(""process"",option+1) == 0)
{

char
**arguments;

int
j,
number_arguments;

arguments=StringToArgv(arg1,&number_arguments);
if (arguments == (char **) NULL)
break;
if (strchr(arguments[1],'=') != (char *) NULL)
{
char
breaker,
quote,
*token;

const char
*arguments;

int
next,
status;

size_t
length;

TokenInfo
*token_info;




assert(arg1 != (const char *) NULL);
length=strlen(arg1);
token=(char *) NULL;
if (~length >= (MagickPathExtent-1))
token=(char *) AcquireQuantumMemory(length+MagickPathExtent,
sizeof(*token));
if (token == (char *) NULL)
break;
next=0;
arguments=arg1;
token_info=AcquireTokenInfo();
status=Tokenizer(token_info,0,token,length,arguments,"""",""="",
""\"""",'\0',&breaker,&next,&quote);
token_info=DestroyTokenInfo(token_info);
if (status == 0)
{
const char
*argv;

argv=(&(arguments[next]));
(void) InvokeDynamicImageFilter(token,&_images,1,&argv,
_exception);
}
token=DestroyString(token);
break;
}
(void) SubstituteString(&arguments[1],""-"","""");
(void) InvokeDynamicImageFilter(arguments[1],&_images,
number_arguments-2,(const char **) arguments+2,_exception);
for (j=0; j < number_arguments; j++)
arguments[j]=DestroyString(arguments[j]);
arguments=(char **) RelinquishMagickMemory(arguments);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 'r':
{
if (LocaleCompare(""remap"",option+1) == 0)
{
(void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);
break;
}
if (LocaleCompare(""reverse"",option+1) == 0)
{
ReverseImageList(&_images);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
case 's':
{
if (LocaleCompare(""smush"",option+1) == 0)
{

ssize_t
offset;

if (IsGeometry(arg1) == MagickFalse)
CLIWandExceptArgBreak(OptionError,""InvalidArgument"",option,arg1);
offset=(ssize_t) StringToLong(arg1);
new_images=SmushImages(_images,IsNormalOp,offset,_exception);
break;
}
if (LocaleCompare(""subimage"",option+1) == 0)
{
Image
*base_image,
*compare_image;

const char
*value;

MetricType
metric;

double
similarity;

RectangleInfo
offset;

base_image=GetImageFromList(_images,0);
compare_image=GetImageFromList(_images,1);


metric=UndefinedErrorMetric;
value=GetImageOption(_image_info,""metric"");
if (value != (const char *) NULL)
metric=(MetricType) ParseCommandOption(MagickMetricOptions,
MagickFalse,value);

new_images=SimilarityImage(base_image,compare_image,metric,0.0,
&offset,&similarity,_exception);

if (new_images != (Image *) NULL)
{
char
result[MagickPathExtent];

(void) FormatLocaleString(result,MagickPathExtent,""%lf"",
similarity);
(void) SetImageProperty(new_images,""subimage:similarity"",result,
_exception);
(void) FormatLocaleString(result,MagickPathExtent,""%+ld"",(long)
offset.x);
(void) SetImageProperty(new_images,""subimage:x"",result,
_exception);
(void) FormatLocaleString(result,MagickPathExtent,""%+ld"",(long)
offset.y);
(void) SetImageProperty(new_images,""subimage:y"",result,
_exception);
(void) FormatLocaleString(result,MagickPathExtent,
""%lux%lu%+ld%+ld"",(unsigned long) offset.width,(unsigned long)
offset.height,(long) offset.x,(long) offset.y);
(void) SetImageProperty(new_images,""subimage:offset"",result,
_exception);
}
break;
}
if (LocaleCompare(""swap"",option+1) == 0)
{
Image
*p,
*q,
*swap;

ssize_t
index,
swap_index;

index=(-1);
swap_index=(-2);
if (IfNormalOp) {
GeometryInfo
geometry_info;

MagickStatusType
flags;

swap_index=(-1);
flags=ParseGeometry(arg1,&geometry_info);
if ((flags & RhoValue) == 0)
CLIWandExceptArgBreak(OptionError,""InvalidArgument"",option,arg1);
index=(ssize_t) geometry_info.rho;
if ((flags & SigmaValue) != 0)
swap_index=(ssize_t) geometry_info.sigma;
}
p=GetImageFromList(_images,index);
q=GetImageFromList(_images,swap_index);
if ((p == (Image *) NULL) || (q == (Image *) NULL)) {
if (IfNormalOp)
CLIWandExceptArgBreak(OptionError,""InvalidImageIndex"",option,arg1)
else
CLIWandExceptionBreak(OptionError,""TwoOrMoreImagesRequired"",option);
}
if (p == q)
CLIWandExceptArgBreak(OptionError,""InvalidImageIndex"",option,arg1);
swap=CloneImage(p,0,0,MagickTrue,_exception);
if (swap == (Image *) NULL)
CLIWandExceptArgBreak(ResourceLimitError,""MemoryAllocationFailed"",
option,GetExceptionMessage(errno));
ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,_exception));
ReplaceImageInList(&q,swap);
_images=GetFirstImageInList(q);
break;
}
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}
default:
CLIWandExceptionBreak(OptionError,""UnrecognizedOption"",option);
}


if (arg1 != arg1n )
arg1=DestroyString((char *)arg1);
if (arg2 != arg2n )
arg2=DestroyString((char *)arg2);


if (new_images == (Image *) NULL)
return(status == 0 ? MagickFalse : MagickTrue);
_images=DestroyImageList(_images);
_images=GetFirstImageInList(new_images);
return(status == 0 ? MagickFalse : MagickTrue);

#undef _image_info
#undef _images
#undef _exception
#undef _draw_info
#undef _quantize_info
#undef IfNormalOp
#undef IfPlusOp
#undef IsNormalOp
}",[453],ImageMagick 7.0.8-50 Q16 has memory leaks at AcquireMagickMemory because of mishandling the NoSuchImage error in CLIListOperatorImages in MagickWand/operation.c.
7886,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const Tensor& filter = context->input(1);
const Tensor& out_backprop = context->input(2);


int stride_rows = 0, stride_cols = 0;
int rate_rows = 0, rate_cols = 0;
int64 pad_top = 0, pad_left = 0;
int64 out_rows = 0, out_cols = 0;
ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,
&rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,
&out_cols);



const int batch = input.dim_size(0);
const int depth = input.dim_size(3);
OP_REQUIRES(context,
batch == out_backprop.dim_size(0) &&
out_rows == out_backprop.dim_size(1) &&
out_cols == out_backprop.dim_size(2) &&
depth == out_backprop.dim_size(3),
errors::InvalidArgument(""out_backprop has incompatible size.""));



Tensor* filter_backprop = nullptr;
OP_REQUIRES_OK(
context, context->allocate_output(0, filter.shape(), &filter_backprop));


if (filter.shape().num_elements() == 0) {
return;
}

functor::DilationBackpropFilter<Device, T>()(
context->eigen_device<Device>(), input.tensor<T, 4>(),
filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,
stride_cols, rate_rows, rate_cols, pad_top, pad_left,
filter_backprop->tensor<T, 3>());
}",[17],"TensorFlow is an end-to-end open source platform for machine learning. An attacker can write outside the bounds of heap allocated arrays by passing invalid arguments to `tf.raw_ops.Dilation2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/afd954e65f15aea4d438d0a219136fc4a63a573d/tensorflow/core/kernels/dilation_ops.cc#L321-L322) does not validate before writing to the output array. The values for `h_out` and `w_out` are guaranteed to be in range for `out_backprop` (as they are loop indices bounded by the size of the array). However, there are no similar guarantees relating `h_in_max`/`w_in_max` and `in_backprop`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
6272,"BOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,
BOOL compressed, UINT16* flags)
{
BYTE bitsPerPixelId;

if (!Stream_EnsureRemainingCapacity(
s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))
return FALSE;

bitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];
*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |
((cache_bitmap_v2->flags << 7) & 0xFF80);

if (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)
{
Stream_Write_UINT32(s, cache_bitmap_v2->key1);
Stream_Write_UINT32(s, cache_bitmap_v2->key2);
}

if (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)
{
if (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth))
return FALSE;
}
else
{
if (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) ||
!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))
return FALSE;
}

if (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)
cache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;

if (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) ||
!update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))
return FALSE;

if (compressed)
{
if (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))
{
Stream_Write_UINT16(
s, cache_bitmap_v2->cbCompFirstRowSize);
Stream_Write_UINT16(
s, cache_bitmap_v2->cbCompMainBodySize);
Stream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth);
Stream_Write_UINT16(
s, cache_bitmap_v2->cbUncompressedSize);
cache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;
}

if (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))
return FALSE;

Stream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);
}
else
{
if (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))
return FALSE;

Stream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);
}

cache_bitmap_v2->compressed = compressed;
return TRUE;
}","[4, 10]","In FreeRDP before version 2.1.2, there is a global OOB read in update_read_cache_bitmap_v3_order. As a workaround, one can disable bitmap cache with -bitmap-cache (default). This is fixed in version 2.1.2."
265,"virtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage) {
if (sMessage.Equals(""DCC "", false, 4) && m_pUser->IsUserAttached()) {

CString sType = sMessage.Token(1);
CString sFile = sMessage.Token(2);
unsigned long uLongIP = sMessage.Token(3).ToULong();
unsigned short uPort = sMessage.Token(4).ToUShort();
unsigned long uFileSize = sMessage.Token(5).ToULong();

if (sType.Equals(""CHAT"")) {
CNick FromNick(Nick.GetNickMask());
unsigned short uBNCPort = CDCCBounce::DCCRequest(FromNick.GetNick(), uLongIP, uPort, """", true, this, CUtils::GetIP(uLongIP));
if (uBNCPort) {
CString sIP = GetLocalDCCIP();
m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pUser->GetNick() + "" :\001DCC CHAT chat "" + CString(CUtils::GetLongIP(sIP)) + "" "" + CString(uBNCPort) + ""\001"");
}
} else if (sType.Equals(""SEND"")) {

unsigned short uBNCPort = CDCCBounce::DCCRequest(Nick.GetNick(), uLongIP, uPort, sFile, false, this, CUtils::GetIP(uLongIP));
if (uBNCPort) {
CString sIP = GetLocalDCCIP();
m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pUser->GetNick() + "" :\001DCC SEND "" + sFile + "" "" + CString(CUtils::GetLongIP(sIP)) + "" "" + CString(uBNCPort) + "" "" + CString(uFileSize) + ""\001"");
}
} else if (sType.Equals(""RESUME"")) {

unsigned short uResumePort = sMessage.Token(3).ToUShort();

set<CSocket*>::const_iterator it;
for (it = BeginSockets(); it != EndSockets(); ++it) {
CDCCBounce* pSock = (CDCCBounce*) *it;

if (pSock->GetLocalPort() == uResumePort) {
m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pClient->GetNick() + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetUserPort()) + "" "" + sMessage.Token(4) + ""\001"");
}
}
} else if (sType.Equals(""ACCEPT"")) {

set<CSocket*>::const_iterator it;
for (it = BeginSockets(); it != EndSockets(); ++it) {
CDCCBounce* pSock = (CDCCBounce*) *it;

if (pSock->GetUserPort() == sMessage.Token(3).ToUShort()) {
m_pUser->PutUser("":"" + Nick.GetNickMask() + "" PRIVMSG "" + m_pClient->GetNick() + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetLocalPort()) + "" "" + sMessage.Token(4) + ""\001"");
}
}
}

return HALTCORE;
}

return CONTINUE;
}","[33, 43]",The CBounceDCCMod::OnPrivCTCP function in bouncedcc.cpp in the bouncedcc module in ZNC 0.200 and 0.202 allows remote attackers to cause a denial of service (crash) via a crafted DCC RESUME request.
204938," void OneClickSigninSyncStarter::UntrustedSigninConfirmed(
      StartSyncMode response) {
    if (response == UNDO_SYNC) {
      CancelSigninAndDelete();
      
      
     if (source_ != SyncPromoUI::SOURCE_UNKNOWN) {
       EnsureBrowser();
       chrome::NavigateParams params(browser_, GURL(chrome::kChromeUINewTabURL),
                                     content::PAGE_TRANSITION_AUTO_TOPLEVEL);
       params.disposition = CURRENT_TAB;
       params.window_action = chrome::NavigateParams::SHOW_WINDOW;
       chrome::Navigate(&params);
     }
    } else {
     if (response == CONFIGURE_SYNC_FIRST)
       start_mode_ = response;
     SigninManager* signin = SigninManagerFactory::GetForProfile(profile_);
     signin->CompletePendingSignin();
   }
 }","[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]","Google Chrome before 28.0.1500.71 does not properly determine the circumstances in which a renderer process can be considered a trusted process for sign-in and subsequent sync operations, which makes it easier for remote attackers to conduct phishing attacks via a crafted web site."
200151," xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
 	int error = 0;
 
 	if (!acl)
 		goto set_acl;
 
 	error = -E2BIG;
 	if (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))
  		return error;
  
  	if (type == ACL_TYPE_ACCESS) {
		umode_t mode = inode->i_mode;
		error = posix_acl_equiv_mode(acl, &mode);
		if (error <= 0) {
			acl = NULL;
			if (error < 0)
				return error;
		}
 		umode_t mode;
  
 		error = posix_acl_update_mode(inode, &mode, &acl);
 		if (error)
 			return error;
  		error = xfs_set_mode(inode, mode);
  		if (error)
  			return error;
 	}
 
  set_acl:
 	return __xfs_set_acl(inode, type, acl);
 }","[20, 22, 23, 24, 13, 14, 15, 16, 17, 18, 19]","The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions."
207700," perform_formatting_test(png_store *volatile ps)
 perform_formatting_test(png_store *ps)
  {
  #ifdef PNG_TIME_RFC1123_SUPPORTED
      
    context(ps, fault);
 
  Try
  {
       png_const_charp correct = ""29 Aug 2079 13:53:60 +0000"";
       png_const_charp result;
 #     if PNG_LIBPNG_VER >= 10600
  char timestring[29];
 #     endif
       png_structp pp;
       png_time pt;
 
       pp = set_store_for_write(ps, NULL, ""libpng formatting test"");
 
  if (pp == NULL)
  Throw ps;
 
 
   
       pt.year = 2079;
       pt.month = 8;
       pt.day = 29;
       pt.hour = 13;
       pt.minute = 53;
       pt.second = 60;  
 
 #     if PNG_LIBPNG_VER < 10600
          result = png_convert_to_rfc1123(pp, &pt);
 #     else
  if (png_convert_to_rfc1123_buffer(timestring, &pt))
             result = timestring;
 
  else
             result = NULL;
 #     endif
 
  if (result == NULL)
          png_error(pp, ""png_convert_to_rfc1123 failed"");
 
  if (strcmp(result, correct) != 0)
  {
  size_t pos = 0;
  char msg[128];
 
          pos = safecat(msg, sizeof msg, pos, ""png_convert_to_rfc1123("");
          pos = safecat(msg, sizeof msg, pos, correct);
          pos = safecat(msg, sizeof msg, pos, "") returned: '"");
          pos = safecat(msg, sizeof msg, pos, result);
          pos = safecat(msg, sizeof msg, pos, ""'"");
 
          png_error(pp, msg);
  }
 
       store_write_reset(ps);
  }
 
  Catch(fault)
  {
       store_write_reset(fault);
  }
 #else
    UNUSED(ps)
 #endif
 }",[2],"Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
200554," _gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,
                int *cs, int *vers, int *fmt, int *ncx, int *ncy,
                t_chunk_info ** chunkIdx)
 {
 	int i;
 	int ch;
 	char id[5];
 	t_chunk_info *cidx;
 	int sidx;
 	int nc;
 
 	GD2_DBG (printf (""Reading gd2 header info\n""));
 
 	for (i = 0; i < 4; i++) {
 		ch = gdGetC (in);
 		if (ch == EOF) {
 			goto fail1;
 		};
 		id[i] = ch;
 	};
 	id[4] = 0;
 
 	GD2_DBG (printf (""Got file code: %s\n"", id));
 
 	 
 	if (strcmp (id, GD2_ID) != 0) {
 		GD2_DBG (printf (""Not a valid gd2 file\n""));
 		goto fail1;
 	};
 
 	 
 	if (gdGetWord (vers, in) != 1) {
 		goto fail1;
 	};
 	GD2_DBG (printf (""Version: %d\n"", *vers));
 
 	if ((*vers != 1) && (*vers != 2)) {
 		GD2_DBG (printf (""Bad version: %d\n"", *vers));
 		goto fail1;
 	};
 
 	 
 	if (!gdGetWord (sx, in)) {
 		GD2_DBG (printf (""Could not get x-size\n""));
 		goto fail1;
 	}
 	if (!gdGetWord (sy, in)) {
 		GD2_DBG (printf (""Could not get y-size\n""));
 		goto fail1;
 	}
 	GD2_DBG (printf (""Image is %dx%d\n"", *sx, *sy));
 
 	 
 	if (gdGetWord (cs, in) != 1) {
 		goto fail1;
 	};
 	GD2_DBG (printf (""ChunkSize: %d\n"", *cs));
 
 	if ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {
 		GD2_DBG (printf (""Bad chunk size: %d\n"", *cs));
 		goto fail1;
 	};
 
 	 
 	if (gdGetWord (fmt, in) != 1) {
 		goto fail1;
 	};
 	GD2_DBG (printf (""Format: %d\n"", *fmt));
 
 	if ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&
 	        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&
 	        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {
 		GD2_DBG (printf (""Bad data format: %d\n"", *fmt));
 		goto fail1;
 	};
 
 
 	 
 	if (gdGetWord (ncx, in) != 1) {
 		goto fail1;
 	};
 	GD2_DBG (printf (""%d Chunks Wide\n"", *ncx));
 
 	 
 	if (gdGetWord (ncy, in) != 1) {
 		goto fail1;
 	};
 	GD2_DBG (printf (""%d Chunks vertically\n"", *ncy));
 
 	if (gd2_compressed (*fmt)) {
 		nc = (*ncx) * (*ncy);
 		GD2_DBG (printf (""Reading %d chunk index entries\n"", nc));
 		sidx = sizeof (t_chunk_info) * nc;
 		cidx = gdCalloc (sidx, 1);
 		if (!cidx) {
 			goto fail1;
 		}
 		for (i = 0; i < nc; i++) {
 			if (gdGetInt (&cidx[i].offset, in) != 1) {
 				goto fail2;
 			};
  			if (gdGetInt (&cidx[i].size, in) != 1) {
  				goto fail2;
  			};
 			if (cidx[i].offset < 0 || cidx[i].size < 0)
 				goto fail2;
  		};
  		*chunkIdx = cidx;
  	};
 
 	GD2_DBG (printf (""gd2 header complete\n""));
 
 	return 1;
 fail2:
 	gdFree(cidx);
 fail1:
 	return 0;
 }","[105, 106]","Integer signedness error in GD Graphics Library 2.1.1 (aka libgd or libgd2) allows remote attackers to cause a denial of service (crash) or potentially execute arbitrary code via crafted compressed gd2 data, which triggers a heap-based buffer overflow."
199098," static int g2m_init_buffers(G2MContext *c)
 {
     int aligned_height;
 
     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {
         c->framebuf_stride = FFALIGN(c->width * 3, 16);
         aligned_height     = FFALIGN(c->height,    16);
         av_free(c->framebuf);
         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);
         if (!c->framebuf)
             return AVERROR(ENOMEM);
     }
      if (!c->synth_tile || !c->jpeg_tile ||
          c->old_tile_w < c->tile_width ||
          c->old_tile_h < c->tile_height) {
        c->tile_stride = FFALIGN(c->tile_width * 3, 16);
         c->tile_stride = FFALIGN(c->tile_width, 16) * 3;
          aligned_height = FFALIGN(c->tile_height,    16);
          av_free(c->synth_tile);
          av_free(c->jpeg_tile);
         av_free(c->kempf_buf);
         av_free(c->kempf_flags);
         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);
         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);
         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height
                                     + FF_INPUT_BUFFER_PADDING_SIZE);
         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);
         if (!c->synth_tile || !c->jpeg_tile ||
             !c->kempf_buf || !c->kempf_flags)
             return AVERROR(ENOMEM);
     }
 
     return 0;
 }","[17, 16]","The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 uses an incorrect ordering of arithmetic operations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data."
206115,"  RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
     : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {
    RouteFunction(
        ""OnDocumentElementCreated"",
        base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                   base::Unretained(this)));
  }","[3, 2]","extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors."
200239," SPL_METHOD(SplFileObject, fread)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long length = 0;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &length) == FAILURE) {
 		return;
 	}
 
 	if (length <= 0) {
  		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be greater than 0"");
  		RETURN_FALSE;
  	}
 	if (length > INT_MAX) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be no more than %d"", INT_MAX);
 		RETURN_FALSE;
 	}
  
  	Z_STRVAL_P(return_value) = emalloc(length + 1);
  	Z_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);
 
 	 
 	Z_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;
 	Z_TYPE_P(return_value) = IS_STRING;
 }","[14, 15, 16, 17]","Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096."
205645,"  void TextTrack::addCue(TextTrackCue* cue) {
    DCHECK(cue);
  
  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||
      cue->startTime() < 0 || cue->endTime() < 0)
   if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()))
      return;
  
 
 
 
   if (TextTrack* cue_track = cue->track())
     cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);
 
   cue->SetTrack(this);
   EnsureTextTrackCueList()->Add(cue);
 
   if (GetCueTimeline() && mode_ != DisabledKeyword())
     GetCueTimeline()->AddCue(this, cue);
 }","[6, 4, 5]","fpdfsdk/src/jsapi/fxjs_v8.cpp in PDFium, as used in Google Chrome before 47.0.2526.73, does not use signatures, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage *type confusion.*"
3976,"static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
{
return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
indx, 0, data, size, 500);
}","[3, 4, 5]","drivers/net/usb/rtl8150.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
200116," m_authenticate(struct Client *client_p, struct Client *source_p,
 	int parc, const char *parv[])
 {
 	struct Client *agent_p = NULL;
 	struct Client *saslserv_p = NULL;
 
 	 
 	if(!IsCapable(source_p, CLICAP_SASL))
 		return 0;
 
 	if (strlen(client_p->id) == 3)
 	{
 		exit_client(client_p, client_p, client_p, ""Mixing client and server protocol"");
  		return 0;
  	}
  
 	if (*parv[1] == ':' || strchr(parv[1], ' '))
 	{
 		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
 		return 0;
 	}
 
  	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
  	if (saslserv_p == NULL || !IsService(saslserv_p))
  	{
 		sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
 		return 0;
 	}
 
 	if(source_p->localClient->sasl_complete)
 	{
 		*source_p->localClient->sasl_agent = '\0';
 		source_p->localClient->sasl_complete = 0;
 	}
 
 	if(strlen(parv[1]) > 400)
 	{
 		sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name);
 		return 0;
 	}
 
 	if(!*source_p->id)
 	{
 		 
 		strcpy(source_p->id, generate_uid());
 		add_to_id_hash(source_p->id, source_p);
 	}
 
 	if(*source_p->localClient->sasl_agent)
 		agent_p = find_id(source_p->localClient->sasl_agent);
 
 	if(agent_p == NULL)
 	{
 		sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"",
 					me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
 					source_p->host, source_p->sockhost);
 
 		if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL)
 			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"",
 						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
 						parv[1], source_p->certfp);
 		else
 			sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"",
 						me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,
 						parv[1]);
 
 		rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);
 	}
 	else
 		sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"",
 				me.id, agent_p->servptr->name, source_p->id, agent_p->id,
 				parv[1]);
 	source_p->localClient->sasl_out++;
 
 	return 0;
 }","[17, 18, 19, 20, 21, 22]",The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.
207770," OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr)
 {
  unsigned int index = 0;
     OMX_U8 *temp_buff ;
 
  if (bufferHdr == NULL || m_inp_mem_ptr == NULL) {
         DEBUG_PRINT_ERROR(""ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]"",
                 bufferHdr, m_inp_mem_ptr);
  return OMX_ErrorBadParameter;
  }
 
     index = bufferHdr - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);
 #ifdef _ANDROID_ICS_
  if (meta_mode_enable) {
  if (index < m_sInPortDef.nBufferCountActual) {
             memset(&meta_buffer_hdr[index], 0, sizeof(meta_buffer_hdr[index]));
             memset(&meta_buffers[index], 0, sizeof(meta_buffers[index]));
  }
  if (!mUseProxyColorFormat)
  return OMX_ErrorNone;
  else {
             c2d_conv.close();
             opaque_buffer_hdr[index] = NULL;
  }
  }
 #endif
  if (index < m_sInPortDef.nBufferCountActual && !mUseProxyColorFormat &&
             dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {
         DEBUG_PRINT_LOW(""ERROR: dev_free_buf() Failed for i/p buf"");
 
      }
  
      if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) {
         auto_lock l(m_lock);
 
          if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) {
              DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case"");
              if(!secure_session) {
             munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
 
              } else {
                  free(m_pInput_pmem[index].buffer);
              }
             m_pInput_pmem[index].buffer = NULL;
              close (m_pInput_pmem[index].fd);
  #ifdef USE_ION
              free_ion_memory(&m_pInput_ion[index]);
 #endif
             m_pInput_pmem[index].fd = -1;
  } else if (m_pInput_pmem[index].fd > 0 && (input_use_buffer == true &&
                     m_use_input_pmem == OMX_FALSE)) {
             DEBUG_PRINT_LOW(""FreeBuffer:: i/p Heap UseBuffer case"");
  if (dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {
 
                  DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf"");
              }
              if(!secure_session) {
            munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
                 munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
                 m_pInput_pmem[index].buffer = NULL;
              }
              close (m_pInput_pmem[index].fd);
  #ifdef USE_ION
             free_ion_memory(&m_pInput_ion[index]);
 #endif
             m_pInput_pmem[index].fd = -1;
  } else {
             DEBUG_PRINT_ERROR(""FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case"");
  }
  }
  return OMX_ErrorNone;
 }","[34, 35, 44, 59, 60, 58]","Use-after-free vulnerability in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27903498."
9918,"int passwd_to_utf16(unsigned char *in_passwd,
int length,
int max_length,
unsigned char *out_passwd)
{
#ifdef WIN32
int ret;
(void)length;
ret = MultiByteToWideChar(
CP_ACP,
0,
(LPCSTR)in_passwd,
-1,
(LPWSTR)out_passwd,
max_length / 2
);
if (ret == 0)
return AESCRYPT_READPWD_ICONV;
return ret * 2;
#else
#ifndef ENABLE_ICONV

int i;
for (i=0;i<length+1;i++) {
out_passwd[i*2] = in_passwd[i];
out_passwd[i*2+1] = 0;
}
return length*2;
#else
unsigned char *ic_outbuf,
*ic_inbuf;
iconv_t condesc;
size_t ic_inbytesleft,
ic_outbytesleft;





max_length *= 2;

ic_inbuf = in_passwd;
ic_inbytesleft = length;
ic_outbytesleft = max_length;
ic_outbuf = out_passwd;


setlocale(LC_CTYPE,"""");

if ((condesc = iconv_open(""UTF-16LE"", nl_langinfo(CODESET))) ==
(iconv_t)(-1))
{
perror(""Error in iconv_open"");
return -1;
}

if (iconv(condesc,
(char ** const) &ic_inbuf,
&ic_inbytesleft,
(char ** const) &ic_outbuf,
&ic_outbytesleft) == (size_t) -1)
{
switch (errno)
{
case E2BIG:
fprintf(stderr, ""Error: password too long\n"");
iconv_close(condesc);
return -1;
break;
default:






perror(""Password conversion error"");
iconv_close(condesc);
return -1;
}
}
iconv_close(condesc);
return (max_length - ic_outbytesleft);
#endif
#endif
}","[6, 9, 10, 12, 14, 15, 24, 25, 26, 28]","AES Crypt is a file encryption software for multiple platforms. AES Crypt for Linux built using the source on GitHub and having the version number 3.11 has a vulnerability with respect to reading user-provided passwords and confirmations via command-line prompts. Passwords lengths were not checked before being read. This vulnerability may lead to buffer overruns. This does _not_ affect source code found on aescrypt.com, nor is the vulnerability present when providing a password or a key via the `-p` or `-k` command-line options. The problem was fixed via in commit 68761851b and will be included in release 3.16. Users are advised to upgrade. Users unable to upgrade should us the `-p` or `-k` options to provide a password or key."
199209," static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
 			    struct msghdr *msg, size_t len, int noblock,
 			    int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;
 	size_t copied = 0;
 	int err = -EOPNOTSUPP;
 	struct sk_buff *skb;
 
 	if (flags & MSG_OOB)
 		goto out;
 
 	if (addr_len)
 		*addr_len = sizeof(*lsa);
 
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len);
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;
 
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
 		copied = len;
 	}
 
 	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 	if (err)
 		goto done;
 
 	sock_recv_timestamp(msg, sk, skb);
 
 	 
 	if (lsa) {
 		lsa->l2tp_family = AF_INET6;
 		lsa->l2tp_unused = 0;
  		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
  		lsa->l2tp_flowinfo = 0;
  		lsa->l2tp_scope_id = 0;
 		lsa->l2tp_conn_id = 0;
  		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
  			lsa->l2tp_scope_id = IP6CB(skb)->iif;
  	}
 
 	if (np->rxopt.all)
 		ip6_datagram_recv_ctl(sk, msg, skb);
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
 done:
 	skb_free_datagram(sk, skb);
 out:
 	return err ? err : copied;
 }",[43],"The l2tp_ip6_recvmsg function in net/l2tp/l2tp_ip6.c in the Linux kernel before 3.9-rc7 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
207138," CSSStyleSheet* CSSStyleSheet::CreateInline(Node& owner_node,
                                            const KURL& base_url,
                                            const TextPosition& start_position,
                                             const WTF::TextEncoding& encoding) {
    CSSParserContext* parser_context = CSSParserContext::Create(
        owner_node.GetDocument(), owner_node.GetDocument().BaseURL(),
       false  ,
        owner_node.GetDocument().GetReferrerPolicy(), encoding);
    StyleSheetContents* sheet =
        StyleSheetContents::Create(base_url.GetString(), parser_context);
   return new CSSStyleSheet(sheet, owner_node, true, start_position);
 }",[7],Insufficient origin checks for CSS content in Blink in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
200319," netscreen_seek_read(wtap *wth, gint64 seek_off,
  	struct wtap_pkthdr *phdr, Buffer *buf,
  	int *err, gchar **err_info)
  {
	int		pkt_len;
  	char		line[NETSCREEN_LINE_LENGTH];
	char		cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];
	gboolean	cap_dir;
	char		cap_dst[13];
  
  	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {
  		return FALSE;
 	}
 
 	if (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {
 		*err = file_error(wth->random_fh, err_info);
 		if (*err == 0) {
 			*err = WTAP_ERR_SHORT_READ;
 		}
  		return FALSE;
  	}
  
	pkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,
	    cap_dst, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	if (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,
	    cap_dst, phdr, buf, err, err_info))
		return FALSE;
	return TRUE;
 	return parse_netscreen_packet(wth->random_fh, phdr, buf, line,
 	    err, err_info);
  }","[31, 32, 5, 7, 8, 9, 23, 24, 25, 26, 27, 28, 29, 30]","wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
8985,"codegen(codegen_scope *s, node *tree, int val)
{
int nt;
int rlev = s->rlev;

if (!tree) {
if (val) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
return;
}

s->rlev++;
if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {
codegen_error(s, ""too complex expression"");
}
if (s->irep && s->filename_index != tree->filename_index) {
mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);
const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);

mrb_debug_info_append_file(s->mrb, s->irep->debug_info,
filename, s->lines, s->debug_start_pos, s->pc);
s->debug_start_pos = s->pc;
s->filename_index = tree->filename_index;
s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);
}

nt = nint(tree->car);
s->lineno = tree->lineno;
tree = tree->cdr;
switch (nt) {
case NODE_BEGIN:
if (val && !tree) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
while (tree) {
codegen(s, tree->car, tree->cdr ? NOVAL : val);
tree = tree->cdr;
}
break;

case NODE_RESCUE:
{
int noexc;
uint32_t exend, pos1, pos2, tmp;
struct loopinfo *lp;
int catch_entry, begin, end;

if (tree->car == NULL) goto exit;
lp = loop_push(s, LOOP_BEGIN);
lp->pc0 = new_label(s);
catch_entry = catch_handler_new(s);
begin = s->pc;
codegen(s, tree->car, VAL);
pop();
lp->type = LOOP_RESCUE;
end = s->pc;
noexc = genjmp_0(s, OP_JMP);
catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);
tree = tree->cdr;
exend = JMPLINK_START;
pos1 = JMPLINK_START;
if (tree->car) {
node *n2 = tree->car;
int exc = cursp();

genop_1(s, OP_EXCEPT, exc);
push();
while (n2) {
node *n3 = n2->car;
node *n4 = n3->car;

dispatch(s, pos1);
pos2 = JMPLINK_START;
do {
if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {
codegen(s, n4->car, VAL);
gen_move(s, cursp(), exc, 0);
push_n(2); pop_n(2);
pop();
genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);
}
else {
if (n4) {
codegen(s, n4->car, VAL);
}
else {
genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));
push();
}
pop();
genop_2(s, OP_RESCUE, exc, cursp());
}
tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);
pos2 = tmp;
if (n4) {
n4 = n4->cdr;
}
} while (n4);
pos1 = genjmp_0(s, OP_JMP);
dispatch_linked(s, pos2);

pop();
if (n3->cdr->car) {
gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);
}
if (n3->cdr->cdr->car) {
codegen(s, n3->cdr->cdr->car, val);
if (val) pop();
}
tmp = genjmp(s, OP_JMP, exend);
exend = tmp;
n2 = n2->cdr;
push();
}
if (pos1 != JMPLINK_START) {
dispatch(s, pos1);
genop_1(s, OP_RAISEIF, exc);
}
}
pop();
tree = tree->cdr;
dispatch(s, noexc);
if (tree->car) {
codegen(s, tree->car, val);
}
else if (val) {
push();
}
dispatch_linked(s, exend);
loop_pop(s, NOVAL);
}
break;

case NODE_ENSURE:
if (!tree->cdr || !tree->cdr->cdr ||
(nint(tree->cdr->cdr->car) == NODE_BEGIN &&
tree->cdr->cdr->cdr)) {
int catch_entry, begin, end, target;
int idx;

catch_entry = catch_handler_new(s);
begin = s->pc;
codegen(s, tree->car, val);
end = target = s->pc;
push();
idx = cursp();
genop_1(s, OP_EXCEPT, idx);
push();
codegen(s, tree->cdr->cdr, NOVAL);
pop();
genop_1(s, OP_RAISEIF, idx);
pop();
catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);
}
else {
codegen(s, tree->car, val);
}
break;

case NODE_LAMBDA:
if (val) {
int idx = lambda_body(s, tree, 1);

genop_2(s, OP_LAMBDA, cursp(), idx);
push();
}
break;

case NODE_BLOCK:
if (val) {
int idx = lambda_body(s, tree, 1);

genop_2(s, OP_BLOCK, cursp(), idx);
push();
}
break;

case NODE_IF:
{
uint32_t pos1, pos2;
mrb_bool nil_p = FALSE;
node *elsepart = tree->cdr->cdr->car;

if (!tree->car) {
codegen(s, elsepart, val);
goto exit;
}
if (true_always(tree->car)) {
codegen(s, tree->cdr->car, val);
goto exit;
}
if (false_always(tree->car)) {
codegen(s, elsepart, val);
goto exit;
}
if (nint(tree->car->car) == NODE_CALL) {
node *n = tree->car->cdr;
mrb_sym mid = nsym(n->cdr->car);
mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);
if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {
nil_p = TRUE;
codegen(s, n->car, VAL);
}
}
if (!nil_p) {
codegen(s, tree->car, VAL);
}
pop();
if (val || tree->cdr->car) {
if (nil_p) {
pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);
pos1 = genjmp_0(s, OP_JMP);
dispatch(s, pos2);
}
else {
pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);
}
codegen(s, tree->cdr->car, val);
if (val) pop();
if (elsepart || val) {
pos2 = genjmp_0(s, OP_JMP);
dispatch(s, pos1);
codegen(s, elsepart, val);
dispatch(s, pos2);
}
else {
dispatch(s, pos1);
}
}
else {
if (elsepart) {
if (nil_p) {
pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);
}
else {
pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);
}
codegen(s, elsepart, val);
dispatch(s, pos1);
}
else if (val && !nil_p) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
}
}
break;

case NODE_AND:
{
uint32_t pos;

if (true_always(tree->car)) {
codegen(s, tree->cdr, val);
goto exit;
}
if (false_always(tree->car)) {
codegen(s, tree->car, val);
goto exit;
}
codegen(s, tree->car, VAL);
pop();
pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);
codegen(s, tree->cdr, val);
dispatch(s, pos);
}
break;

case NODE_OR:
{
uint32_t pos;

if (true_always(tree->car)) {
codegen(s, tree->car, val);
goto exit;
}
if (false_always(tree->car)) {
codegen(s, tree->cdr, val);
goto exit;
}
codegen(s, tree->car, VAL);
pop();
pos = genjmp2_0(s, OP_JMPIF, cursp(), val);
codegen(s, tree->cdr, val);
dispatch(s, pos);
}
break;

case NODE_WHILE:
case NODE_UNTIL:
{
if (true_always(tree->car)) {
if (nt == NODE_UNTIL) {
if (val) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
goto exit;
}
}
else if (false_always(tree->car)) {
if (nt == NODE_WHILE) {
if (val) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
goto exit;
}
}

uint32_t pos = JMPLINK_START;
struct loopinfo *lp = loop_push(s, LOOP_NORMAL);

if (!val) lp->reg = -1;
lp->pc0 = new_label(s);
codegen(s, tree->car, VAL);
pop();
if (nt == NODE_WHILE) {
pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);
}
else {
pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);
}
lp->pc1 = new_label(s);
codegen(s, tree->cdr, NOVAL);
genjmp(s, OP_JMP, lp->pc0);
dispatch(s, pos);
loop_pop(s, val);
}
break;

case NODE_FOR:
for_body(s, tree);
if (val) push();
break;

case NODE_CASE:
{
int head = 0;
uint32_t pos1, pos2, pos3, tmp;
node *n;

pos3 = JMPLINK_START;
if (tree->car) {
head = cursp();
codegen(s, tree->car, VAL);
}
tree = tree->cdr;
while (tree) {
n = tree->car->car;
pos1 = pos2 = JMPLINK_START;
while (n) {
codegen(s, n->car, VAL);
if (head) {
gen_move(s, cursp(), head, 0);
push(); push(); pop(); pop(); pop();
if (nint(n->car->car) == NODE_SPLAT) {
genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);
}
else {
genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);
}
}
else {
pop();
}
tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);
pos2 = tmp;
n = n->cdr;
}
if (tree->car->car) {
pos1 = genjmp_0(s, OP_JMP);
dispatch_linked(s, pos2);
}
codegen(s, tree->car->cdr, val);
if (val) pop();
tmp = genjmp(s, OP_JMP, pos3);
pos3 = tmp;
dispatch(s, pos1);
tree = tree->cdr;
}
if (val) {
uint32_t pos = cursp();
genop_1(s, OP_LOADNIL, cursp());
if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);
if (head) pop();
if (cursp() != pos) {
gen_move(s, cursp(), pos, 0);
}
push();
}
else {
if (pos3 != JMPLINK_START) {
dispatch_linked(s, pos3);
}
if (head) {
pop();
}
}
}
break;

case NODE_SCOPE:
scope_body(s, tree, NOVAL);
break;

case NODE_FCALL:
case NODE_CALL:
gen_call(s, tree, val, 0);
break;
case NODE_SCALL:
gen_call(s, tree, val, 1);
break;

case NODE_DOT2:
codegen(s, tree->car, val);
codegen(s, tree->cdr, val);
if (val) {
pop(); pop();
genop_1(s, OP_RANGE_INC, cursp());
push();
}
break;

case NODE_DOT3:
codegen(s, tree->car, val);
codegen(s, tree->cdr, val);
if (val) {
pop(); pop();
genop_1(s, OP_RANGE_EXC, cursp());
push();
}
break;

case NODE_COLON2:
{
int sym = new_sym(s, nsym(tree->cdr));

codegen(s, tree->car, VAL);
pop();
genop_2(s, OP_GETMCNST, cursp(), sym);
if (val) push();
}
break;

case NODE_COLON3:
{
int sym = new_sym(s, nsym(tree));

genop_1(s, OP_OCLASS, cursp());
genop_2(s, OP_GETMCNST, cursp(), sym);
if (val) push();
}
break;

case NODE_ARRAY:
{
int n;

n = gen_values(s, tree, val, 0);
if (val) {
if (n >= 0) {
pop_n(n);
genop_2(s, OP_ARRAY, cursp(), n);
}
push();
}
}
break;

case NODE_HASH:
case NODE_KW_HASH:
{
int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);
if (val && nk >= 0) {
pop_n(nk*2);
genop_2(s, OP_HASH, cursp(), nk);
push();
}
}
break;

case NODE_SPLAT:
codegen(s, tree, val);
break;

case NODE_ASGN:
gen_assignment(s, tree->car, tree->cdr, 0, val);
break;

case NODE_MASGN:
{
int len = 0, n = 0, post = 0;
node *t = tree->cdr, *p;
int rhs = cursp();

if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {

t = t->cdr;
while (t) {
codegen(s, t->car, VAL);
len++;
t = t->cdr;
}
tree = tree->car;
if (tree->car) {
t = tree->car;
n = 0;
while (t) {
if (n < len) {
gen_assignment(s, t->car, NULL, rhs+n, NOVAL);
n++;
}
else {
genop_1(s, OP_LOADNIL, rhs+n);
gen_assignment(s, t->car, NULL, rhs+n, NOVAL);
}
t = t->cdr;
}
}
t = tree->cdr;
if (t) {
if (t->cdr) {
p = t->cdr->car;
while (p) {
post++;
p = p->cdr;
}
}
if (t->car) {
int rn;

if (len < post + n) {
rn = 0;
}
else {
rn = len - post - n;
}
genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);
gen_assignment(s, t->car, NULL, cursp(), NOVAL);
n += rn;
}
if (t->cdr && t->cdr->car) {
t = t->cdr->car;
while (n<len) {
gen_assignment(s, t->car, NULL, rhs+n, NOVAL);
t = t->cdr;
n++;
}
}
}
pop_n(len);
if (val) {
genop_2(s, OP_ARRAY, rhs, len);
push();
}
}
else {

codegen(s, t, VAL);
gen_vmassignment(s, tree->car, rhs, val);
if (!val) {
pop();
}
}
}
break;

case NODE_OP_ASGN:
{
mrb_sym sym = nsym(tree->cdr->car);
mrb_int len;
const char *name = mrb_sym_name_len(s->mrb, sym, &len);
int idx, callargs = -1, vsp = -1;

if ((len == 2 && name[0] == '|' && name[1] == '|') &&
(nint(tree->car->car) == NODE_CONST ||
nint(tree->car->car) == NODE_CVAR)) {
int catch_entry, begin, end;
int noexc, exc;
struct loopinfo *lp;

lp = loop_push(s, LOOP_BEGIN);
lp->pc0 = new_label(s);
catch_entry = catch_handler_new(s);
begin = s->pc;
exc = cursp();
codegen(s, tree->car, VAL);
end = s->pc;
noexc = genjmp_0(s, OP_JMP);
lp->type = LOOP_RESCUE;
catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);
genop_1(s, OP_EXCEPT, exc);
genop_1(s, OP_LOADF, exc);
dispatch(s, noexc);
loop_pop(s, NOVAL);
}
else if (nint(tree->car->car) == NODE_CALL) {
node *n = tree->car->cdr;
int base, i, nargs = 0;
callargs = 0;

if (val) {
vsp = cursp();
push();
}
codegen(s, n->car, VAL);
idx = new_sym(s, nsym(n->cdr->car));
base = cursp()-1;
if (n->cdr->cdr->car) {
nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);
if (nargs >= 0) {
callargs = nargs;
}
else {
push();
nargs = 1;
callargs = CALL_MAXARGS;
}
}

gen_move(s, cursp(), base, 1);
for (i=0; i<nargs; i++) {
gen_move(s, cursp()+i+1, base+i+1, 1);
}
push_n(nargs+2);pop_n(nargs+2);
genop_3(s, OP_SEND, cursp(), idx, callargs);
push();
}
else {
codegen(s, tree->car, VAL);
}
if (len == 2 &&
((name[0] == '|' && name[1] == '|') ||
(name[0] == '&' && name[1] == '&'))) {
uint32_t pos;

pop();
if (val) {
if (vsp >= 0) {
gen_move(s, vsp, cursp(), 1);
}
pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);
}
else {
pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);
}
codegen(s, tree->cdr->cdr->car, VAL);
pop();
if (val && vsp >= 0) {
gen_move(s, vsp, cursp(), 1);
}
if (nint(tree->car->car) == NODE_CALL) {
if (callargs == CALL_MAXARGS) {
pop();
genop_2(s, OP_ARYPUSH, cursp(), 1);
}
else {
pop_n(callargs);
callargs++;
}
pop();
idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));
genop_3(s, OP_SEND, cursp(), idx, callargs);
}
else {
gen_assignment(s, tree->car, NULL, cursp(), val);
}
dispatch(s, pos);
goto exit;
}
codegen(s, tree->cdr->cdr->car, VAL);
push(); pop();
pop(); pop();

if (len == 1 && name[0] == '+')  {
gen_addsub(s, OP_ADD, cursp());
}
else if (len == 1 && name[0] == '-')  {
gen_addsub(s, OP_SUB, cursp());
}
else if (len == 1 && name[0] == '*')  {
genop_1(s, OP_MUL, cursp());
}
else if (len == 1 && name[0] == '/')  {
genop_1(s, OP_DIV, cursp());
}
else if (len == 1 && name[0] == '<')  {
genop_1(s, OP_LT, cursp());
}
else if (len == 2 && name[0] == '<' && name[1] == '=')  {
genop_1(s, OP_LE, cursp());
}
else if (len == 1 && name[0] == '>')  {
genop_1(s, OP_GT, cursp());
}
else if (len == 2 && name[0] == '>' && name[1] == '=')  {
genop_1(s, OP_GE, cursp());
}
else {
idx = new_sym(s, sym);
genop_3(s, OP_SEND, cursp(), idx, 1);
}
if (callargs < 0) {
gen_assignment(s, tree->car, NULL, cursp(), val);
}
else {
if (val && vsp >= 0) {
gen_move(s, vsp, cursp(), 0);
}
if (callargs == CALL_MAXARGS) {
pop();
genop_2(s, OP_ARYPUSH, cursp(), 1);
}
else {
pop_n(callargs);
callargs++;
}
pop();
idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));
genop_3(s, OP_SEND, cursp(), idx, callargs);
}
}
break;

case NODE_SUPER:
{
codegen_scope *s2 = s;
int lv = 0;
int n = 0, nk = 0, st = 0;

push();
while (!s2->mscope) {
lv++;
s2 = s2->prev;
if (!s2) break;
}
if (tree) {
node *args = tree->car;
if (args) {
st = n = gen_values(s, args, VAL, 14);
if (n < 0) {
st = 1; n = 15;
push();
}
}

if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {
nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);
if (nk < 0) {st++; nk = 15;}
else st += nk*2;
n |= nk<<4;
}

if (tree->cdr->cdr) {
codegen(s, tree->cdr->cdr, VAL);
}
else if (!s2) {
push();
}
else {
gen_blkmove(s, s2->ainfo, lv);
}
st++;
}
else {
if (!s2) push();
else gen_blkmove(s, s2->ainfo, lv);
st++;
}
pop_n(st+1);
genop_2(s, OP_SUPER, cursp(), n);
if (val) push();
}
break;

case NODE_ZSUPER:
{
codegen_scope *s2 = s;
int lv = 0;
uint16_t ainfo = 0;
int n = CALL_MAXARGS;
int sp = cursp();

push();
while (!s2->mscope) {
lv++;
s2 = s2->prev;
if (!s2) break;
}
if (s2 && s2->ainfo > 0) {
ainfo = s2->ainfo;
}
if (ainfo > 0) {
genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));
push(); push(); push();
pop(); pop(); pop();

if (ainfo & 0x1) {
n |= CALL_MAXARGS<<4;
push();
}

if (tree && tree->cdr && tree->cdr->cdr) {
push();
codegen(s, tree->cdr->cdr, VAL);
}
}
else {

if (tree && tree->cdr && tree->cdr->cdr) {
codegen(s, tree->cdr->cdr, VAL);
}
else {
gen_blkmove(s, 0, lv);
}
n = 0;
}
s->sp = sp;
genop_2(s, OP_SUPER, cursp(), n);
if (val) push();
}
break;

case NODE_RETURN:
if (tree) {
gen_retval(s, tree);
}
else {
genop_1(s, OP_LOADNIL, cursp());
}
if (s->loop) {
gen_return(s, OP_RETURN_BLK, cursp());
}
else {
gen_return(s, OP_RETURN, cursp());
}
if (val) push();
break;

case NODE_YIELD:
{
codegen_scope *s2 = s;
int lv = 0, ainfo = -1;
int n = 0, sendv = 0;

while (!s2->mscope) {
lv++;
s2 = s2->prev;
if (!s2) break;
}
if (s2) {
ainfo = (int)s2->ainfo;
}
if (ainfo < 0) codegen_error(s, ""invalid yield (SyntaxError)"");
push();
if (tree) {
n = gen_values(s, tree, VAL, 14);
if (n < 0) {
n = sendv = 1;
push();
}
}
push();pop();
pop_n(n+1);
genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));
if (sendv) n = CALL_MAXARGS;
genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);
if (val) push();
}
break;

case NODE_BREAK:
loop_break(s, tree);
if (val) push();
break;

case NODE_NEXT:
if (!s->loop) {
raise_error(s, ""unexpected next"");
}
else if (s->loop->type == LOOP_NORMAL) {
codegen(s, tree, NOVAL);
genjmp(s, OP_JMPUW, s->loop->pc0);
}
else {
if (tree) {
codegen(s, tree, VAL);
pop();
}
else {
genop_1(s, OP_LOADNIL, cursp());
}
gen_return(s, OP_RETURN, cursp());
}
if (val) push();
break;

case NODE_REDO:
if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {
raise_error(s, ""unexpected redo"");
}
else {
genjmp(s, OP_JMPUW, s->loop->pc1);
}
if (val) push();
break;

case NODE_RETRY:
{
const char *msg = ""unexpected retry"";
const struct loopinfo *lp = s->loop;

while (lp && lp->type != LOOP_RESCUE) {
lp = lp->prev;
}
if (!lp) {
raise_error(s, msg);
}
else {
genjmp(s, OP_JMPUW, lp->pc0);
}
if (val) push();
}
break;

case NODE_LVAR:
if (val) {
int idx = lv_idx(s, nsym(tree));

if (idx > 0) {
gen_move(s, cursp(), idx, val);
}
else {
gen_getupvar(s, cursp(), nsym(tree));
}
push();
}
break;

case NODE_NVAR:
if (val) {
int idx = nint(tree);

gen_move(s, cursp(), idx, val);

push();
}
break;

case NODE_GVAR:
{
int sym = new_sym(s, nsym(tree));

genop_2(s, OP_GETGV, cursp(), sym);
if (val) push();
}
break;

case NODE_IVAR:
{
int sym = new_sym(s, nsym(tree));

genop_2(s, OP_GETIV, cursp(), sym);
if (val) push();
}
break;

case NODE_CVAR:
{
int sym = new_sym(s, nsym(tree));

genop_2(s, OP_GETCV, cursp(), sym);
if (val) push();
}
break;

case NODE_CONST:
{
int sym = new_sym(s, nsym(tree));

genop_2(s, OP_GETCONST, cursp(), sym);
if (val) push();
}
break;

case NODE_BACK_REF:
if (val) {
char buf[] = {'$', nchar(tree)};
int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));

genop_2(s, OP_GETGV, cursp(), sym);
push();
}
break;

case NODE_NTH_REF:
if (val) {
mrb_state *mrb = s->mrb;
mrb_value str;
int sym;

str = mrb_format(mrb, ""$%d"", nint(tree));
sym = new_sym(s, mrb_intern_str(mrb, str));
genop_2(s, OP_GETGV, cursp(), sym);
push();
}
break;

case NODE_ARG:

break;

case NODE_BLOCK_ARG:
if (!tree) {
int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));

if (idx == 0) {
codegen_error(s, ""no anonymous block argument"");
}
gen_move(s, cursp(), idx, val);
}
else {
codegen(s, tree, val);
}
break;

case NODE_INT:
if (val) {
char *p = (char*)tree->car;
int base = nint(tree->cdr->car);
mrb_int i;
mrb_bool overflow;

i = readint(s, p, base, FALSE, &overflow);
if (overflow) {
int off = new_litbn(s, p, base, FALSE);
genop_2(s, OP_LOADL, cursp(), off);
}
else {
gen_int(s, cursp(), i);
}
push();
}
break;

#ifndef MRB_NO_FLOAT
case NODE_FLOAT:
if (val) {
char *p = (char*)tree;
mrb_float f = mrb_float_read(p, NULL);
int off = new_lit(s, mrb_float_value(s->mrb, f));

genop_2(s, OP_LOADL, cursp(), off);
push();
}
break;
#endif

case NODE_NEGATE:
{
nt = nint(tree->car);
switch (nt) {
#ifndef MRB_NO_FLOAT
case NODE_FLOAT:
if (val) {
char *p = (char*)tree->cdr;
mrb_float f = mrb_float_read(p, NULL);
int off = new_lit(s, mrb_float_value(s->mrb, -f));

genop_2(s, OP_LOADL, cursp(), off);
push();
}
break;
#endif

case NODE_INT:
if (val) {
char *p = (char*)tree->cdr->car;
int base = nint(tree->cdr->cdr->car);
mrb_int i;
mrb_bool overflow;

i = readint(s, p, base, TRUE, &overflow);
if (overflow) {
int off = new_litbn(s, p, base, TRUE);
genop_2(s, OP_LOADL, cursp(), off);
}
else {
gen_int(s, cursp(), i);
}
push();
}
break;

default:
if (val) {
codegen(s, tree, VAL);
pop();
push_n(2);pop_n(2);
mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);
if (!gen_uniop(s, minus, cursp())) {
genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);
}
push();
}
else {
codegen(s, tree, NOVAL);
}
break;
}
}
break;

case NODE_STR:
if (val) {
char *p = (char*)tree->car;
size_t len = (intptr_t)tree->cdr;
int ai = mrb_gc_arena_save(s->mrb);
int off = new_lit(s, mrb_str_new(s->mrb, p, len));

mrb_gc_arena_restore(s->mrb, ai);
genop_2(s, OP_STRING, cursp(), off);
push();
}
break;

case NODE_HEREDOC:
tree = ((struct mrb_parser_heredoc_info *)tree)->doc;

case NODE_DSTR:
if (val) {
node *n = tree;

if (!n) {
genop_1(s, OP_LOADNIL, cursp());
push();
break;
}
codegen(s, n->car, VAL);
n = n->cdr;
while (n) {
codegen(s, n->car, VAL);
pop(); pop();
genop_1(s, OP_STRCAT, cursp());
push();
n = n->cdr;
}
}
else {
node *n = tree;

while (n) {
if (nint(n->car->car) != NODE_STR) {
codegen(s, n->car, NOVAL);
}
n = n->cdr;
}
}
break;

case NODE_WORDS:
gen_literal_array(s, tree, FALSE, val);
break;

case NODE_SYMBOLS:
gen_literal_array(s, tree, TRUE, val);
break;

case NODE_DXSTR:
{
node *n;
int ai = mrb_gc_arena_save(s->mrb);
int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));

genop_1(s, OP_LOADSELF, cursp());
push();
codegen(s, tree->car, VAL);
n = tree->cdr;
while (n) {
if (nint(n->car->car) == NODE_XSTR) {
n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;
mrb_assert(!n->cdr);
}
codegen(s, n->car, VAL);
pop(); pop();
genop_1(s, OP_STRCAT, cursp());
push();
n = n->cdr;
}
push();
pop_n(3);
sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick));
genop_3(s, OP_SEND, cursp(), sym, 1);
if (val) push();
mrb_gc_arena_restore(s->mrb, ai);
}
break;

case NODE_XSTR:
{
char *p = (char*)tree->car;
size_t len = (intptr_t)tree->cdr;
int ai = mrb_gc_arena_save(s->mrb);
int off = new_lit(s, mrb_str_new(s->mrb, p, len));
int sym;

genop_1(s, OP_LOADSELF, cursp());
push();
genop_2(s, OP_STRING, cursp(), off);
push(); push();
pop_n(3);
sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick));
genop_3(s, OP_SEND, cursp(), sym, 1);
if (val) push();
mrb_gc_arena_restore(s->mrb, ai);
}
break;

case NODE_REGX:
if (val) {
char *p1 = (char*)tree->car;
char *p2 = (char*)tree->cdr->car;
char *p3 = (char*)tree->cdr->cdr;
int ai = mrb_gc_arena_save(s->mrb);
int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));
int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));
int argc = 1;

genop_1(s, OP_OCLASS, cursp());
genop_2(s, OP_GETMCNST, cursp(), sym);
push();
genop_2(s, OP_STRING, cursp(), off);
push();
if (p2 || p3) {
if (p2) {
off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));
genop_2(s, OP_STRING, cursp(), off);
}
else {
genop_1(s, OP_LOADNIL, cursp());
}
push();
argc++;
if (p3) {
off = new_lit(s, mrb_str_new(s->mrb, p3, 1));
genop_2(s, OP_STRING, cursp(), off);
push();
argc++;
}
}
push();
pop_n(argc+2);
sym = new_sym(s, MRB_SYM_2(s->mrb, compile));
genop_3(s, OP_SEND, cursp(), sym, argc);
mrb_gc_arena_restore(s->mrb, ai);
push();
}
break;

case NODE_DREGX:
if (val) {
node *n = tree->car;
int ai = mrb_gc_arena_save(s->mrb);
int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));
int argc = 1;
int off;
char *p;

genop_1(s, OP_OCLASS, cursp());
genop_2(s, OP_GETMCNST, cursp(), sym);
push();
codegen(s, n->car, VAL);
n = n->cdr;
while (n) {
codegen(s, n->car, VAL);
pop(); pop();
genop_1(s, OP_STRCAT, cursp());
push();
n = n->cdr;
}
n = tree->cdr->cdr;
if (n->car) {
p = (char*)n->car;
off = new_lit(s, mrb_str_new_cstr(s->mrb, p));
codegen(s, tree->car, VAL);
genop_2(s, OP_STRING, cursp(), off);
pop();
genop_1(s, OP_STRCAT, cursp());
push();
}
if (n->cdr->car) {
char *p2 = (char*)n->cdr->car;
off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));
genop_2(s, OP_STRING, cursp(), off);
push();
argc++;
}
if (n->cdr->cdr) {
char *p2 = (char*)n->cdr->cdr;
off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));
genop_2(s, OP_STRING, cursp(), off);
push();
argc++;
}
push();
pop_n(argc+2);
sym = new_sym(s, MRB_SYM_2(s->mrb, compile));
genop_3(s, OP_SEND, cursp(), sym, argc);
mrb_gc_arena_restore(s->mrb, ai);
push();
}
else {
node *n = tree->car;

while (n) {
if (nint(n->car->car) != NODE_STR) {
codegen(s, n->car, NOVAL);
}
n = n->cdr;
}
}
break;

case NODE_SYM:
if (val) {
int sym = new_sym(s, nsym(tree));

genop_2(s, OP_LOADSYM, cursp(), sym);
push();
}
break;

case NODE_DSYM:
codegen(s, tree, val);
if (val) {
gen_intern(s);
}
break;

case NODE_SELF:
if (val) {
genop_1(s, OP_LOADSELF, cursp());
push();
}
break;

case NODE_NIL:
if (val) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
break;

case NODE_TRUE:
if (val) {
genop_1(s, OP_LOADT, cursp());
push();
}
break;

case NODE_FALSE:
if (val) {
genop_1(s, OP_LOADF, cursp());
push();
}
break;

case NODE_ALIAS:
{
int a = new_sym(s, nsym(tree->car));
int b = new_sym(s, nsym(tree->cdr));

genop_2(s, OP_ALIAS, a, b);
if (val) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
}
break;

case NODE_UNDEF:
{
node *t = tree;

while (t) {
int symbol = new_sym(s, nsym(t->car));
genop_1(s, OP_UNDEF, symbol);
t = t->cdr;
}
if (val) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
}
break;

case NODE_CLASS:
{
int idx;
node *body;

if (tree->car->car == (node*)0) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
else if (tree->car->car == (node*)1) {
genop_1(s, OP_OCLASS, cursp());
push();
}
else {
codegen(s, tree->car->car, VAL);
}
if (tree->cdr->car) {
codegen(s, tree->cdr->car, VAL);
}
else {
genop_1(s, OP_LOADNIL, cursp());
push();
}
pop(); pop();
idx = new_sym(s, nsym(tree->car->cdr));
genop_2(s, OP_CLASS, cursp(), idx);
body = tree->cdr->cdr->car;
if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {
genop_1(s, OP_LOADNIL, cursp());
}
else {
idx = scope_body(s, body, val);
genop_2(s, OP_EXEC, cursp(), idx);
}
if (val) {
push();
}
}
break;

case NODE_MODULE:
{
int idx;

if (tree->car->car == (node*)0) {
genop_1(s, OP_LOADNIL, cursp());
push();
}
else if (tree->car->car == (node*)1) {
genop_1(s, OP_OCLASS, cursp());
push();
}
else {
codegen(s, tree->car->car, VAL);
}
pop();
idx = new_sym(s, nsym(tree->car->cdr));
genop_2(s, OP_MODULE, cursp(), idx);
if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&
tree->cdr->car->cdr->cdr == NULL) {
genop_1(s, OP_LOADNIL, cursp());
}
else {
idx = scope_body(s, tree->cdr->car, val);
genop_2(s, OP_EXEC, cursp(), idx);
}
if (val) {
push();
}
}
break;

case NODE_SCLASS:
{
int idx;

codegen(s, tree->car, VAL);
pop();
genop_1(s, OP_SCLASS, cursp());
if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&
tree->cdr->car->cdr->cdr == NULL) {
genop_1(s, OP_LOADNIL, cursp());
}
else {
idx = scope_body(s, tree->cdr->car, val);
genop_2(s, OP_EXEC, cursp(), idx);
}
if (val) {
push();
}
}
break;

case NODE_DEF:
{
int sym = new_sym(s, nsym(tree->car));
int idx = lambda_body(s, tree->cdr, 0);

genop_1(s, OP_TCLASS, cursp());
push();
genop_2(s, OP_METHOD, cursp(), idx);
push(); pop();
pop();
genop_2(s, OP_DEF, cursp(), sym);
if (val) push();
}
break;

case NODE_SDEF:
{
node *recv = tree->car;
int sym = new_sym(s, nsym(tree->cdr->car));
int idx = lambda_body(s, tree->cdr->cdr, 0);

codegen(s, recv, VAL);
pop();
genop_1(s, OP_SCLASS, cursp());
push();
genop_2(s, OP_METHOD, cursp(), idx);
pop();
genop_2(s, OP_DEF, cursp(), sym);
if (val) push();
}
break;

case NODE_POSTEXE:
codegen(s, tree, NOVAL);
break;

default:
break;
}
exit:
s->rlev = rlev;
}","[761, 762, 765, 767, 770, 771, 772, 774, 1026]",NULL Pointer Dereference in Homebrew mruby prior to 3.2.
201146," static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
   Image *image)
 {
   ExceptionInfo
     *exception;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     currentOffset,
     offset,
     scene;
 
   MagickSizeType
     cc;
 
   PixelPacket
     transpix;
 
   QuantizeInfo
     *quantize_info;
 
   register IndexPacket
     *indexes;
 
   register ssize_t
     x;
 
   register PixelPacket
     *p;
 
   ssize_t
     y;
 
   size_t
     count,
     bits_per_pixel,
     bytes_per_row,
     nextDepthOffset,
     one;
 
   unsigned char
      bit,
      byte,
      color,
    *lastrow,
     *last_row,
      *one_row,
      *ptr,
      version;
 
   unsigned int
     transparentIndex;
 
   unsigned short
     color16,
     flags;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   exception=AcquireExceptionInfo();
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(status);
   quantize_info=AcquireQuantizeInfo(image_info);
   flags=0;
   currentOffset=0;
   transparentIndex=0;
   transpix.red=0;
   transpix.green=0;
   transpix.blue=0;
   transpix.opacity=0;
   one=1;
   version=0;
   scene=0;
   do
   {
     (void) TransformImageColorspace(image,sRGBColorspace);
     count=GetNumberColors(image,NULL,exception);
     for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;
     if (bits_per_pixel > 16)
       bits_per_pixel=16;
     else
       if (bits_per_pixel < 16)
         (void) TransformImageColorspace(image,image->colorspace);
     if (bits_per_pixel < 8)
       {
         (void) TransformImageColorspace(image,GRAYColorspace);
         (void) SetImageType(image,PaletteType);
         (void) SortColormapByIntensity(image);
       }
     if ((image->storage_class == PseudoClass) && (image->colors > 256))
       (void) SetImageStorageClass(image,DirectClass);
     if (image->storage_class == PseudoClass)
       flags|=PALM_HAS_COLORMAP_FLAG;
     else
       flags|=PALM_IS_DIRECT_COLOR;
     (void) WriteBlobMSBShort(image,(unsigned short) image->columns);  
     (void) WriteBlobMSBShort(image,(unsigned short) image->rows);   
     bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/
       bits_per_pixel))*2;
     (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);
     if ((image_info->compression == RLECompression) ||
         (image_info->compression == FaxCompression))
       flags|=PALM_IS_COMPRESSED_FLAG;
     (void) WriteBlobMSBShort(image, flags);
     (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);
     if (bits_per_pixel > 1)
       version=1;
     if ((image_info->compression == RLECompression) ||
         (image_info->compression == FaxCompression))
       version=2;
     (void) WriteBlobByte(image,version);
     (void) WriteBlobMSBShort(image,0);   
     (void) WriteBlobByte(image,(unsigned char) transparentIndex);
     if (image_info->compression == RLECompression)
       (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);
     else
       if (image_info->compression == FaxCompression)
         (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);
       else
         (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);
     (void) WriteBlobMSBShort(image,0);   
     offset=16;
     if (bits_per_pixel == 16)
       {
         (void) WriteBlobByte(image,5);   
         (void) WriteBlobByte(image,6);   
         (void) WriteBlobByte(image,5);   
         (void) WriteBlobByte(image,0);   
         (void) WriteBlobMSBLong(image,0);   
         offset+=8;
       }
     if (bits_per_pixel == 8)
       {
         if (flags & PALM_HAS_COLORMAP_FLAG)   
           {
             quantize_info->dither=IsPaletteImage(image,&image->exception);
             quantize_info->number_colors=image->colors;
             (void) QuantizeImage(quantize_info,image);
             (void) WriteBlobMSBShort(image,(unsigned short) image->colors);
             for (count = 0; count < image->colors; count++)
             {
               (void) WriteBlobByte(image,(unsigned char) count);
               (void) WriteBlobByte(image,ScaleQuantumToChar(
                 image->colormap[count].red));
               (void) WriteBlobByte(image,
                 ScaleQuantumToChar(image->colormap[count].green));
               (void) WriteBlobByte(image,
                 ScaleQuantumToChar(image->colormap[count].blue));
             }
             offset+=2+count*4;
           }
       else   
         {
           Image
             *affinity_image;
 
           affinity_image=ConstituteImage(256,1,""RGB"",CharPixel,&PalmPalette,
             exception);
           (void) TransformImageColorspace(affinity_image,
             affinity_image->colorspace);
           (void) RemapImage(quantize_info,image,affinity_image);
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
             indexes=GetAuthenticIndexQueue(image);
             for (x=0; x < (ssize_t) image->columns; x++)
               SetPixelIndex(indexes+x,FindColor(&image->colormap[
                 (ssize_t) GetPixelIndex(indexes+x)]));
           }
           affinity_image=DestroyImage(affinity_image);
         }
        }
      if (flags & PALM_IS_COMPRESSED_FLAG)
        (void) WriteBlobMSBShort(image,0);   
    lastrow=(unsigned char *) NULL;
     last_row=(unsigned char *) NULL;
      if (image_info->compression == FaxCompression)
      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,
        sizeof(*lastrow));
       
       {
         last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,
           sizeof(*last_row));
         if (last_row == (unsigned char *) NULL)
           {
             quantize_info=DestroyQuantizeInfo(quantize_info);
             ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
           }
       }
      one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,
        sizeof(*one_row));
      if (one_row == (unsigned char *) NULL)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
       {
         quantize_info=DestroyQuantizeInfo(quantize_info);
         ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
       }
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        ptr=one_row;
       (void) ResetMagickMemory(ptr,0,bytes_per_row);
       p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
       if (p == (PixelPacket *) NULL)
         break;
       indexes=GetAuthenticIndexQueue(image);
       if (bits_per_pixel == 16)
         {
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             color16=(unsigned short) ((((31*(size_t) GetPixelRed(p))/
               (size_t) QuantumRange) << 11) |
               (((63*(size_t) GetPixelGreen(p))/(size_t) QuantumRange) << 5) |
               ((31*(size_t) GetPixelBlue(p))/(size_t) QuantumRange));
             if (GetPixelOpacity(p) == (Quantum) TransparentOpacity)
               {
                 transpix.red=GetPixelRed(p);
                 transpix.green=GetPixelGreen(p);
                 transpix.blue=GetPixelBlue(p);
                 transpix.opacity=GetPixelOpacity(p);
                 flags|=PALM_HAS_TRANSPARENCY_FLAG;
               }
             *ptr++=(unsigned char) ((color16 >> 8) & 0xff);
             *ptr++=(unsigned char) (color16 & 0xff);
             p++;
           }
         }
       else
         {
           byte=0x00;
           bit=(unsigned char) (8-bits_per_pixel);
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             if (bits_per_pixel >= 8)
               color=(unsigned char) GetPixelIndex(indexes+x);
             else
               color=(unsigned char) (GetPixelIndex(indexes+x)*
                 ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));
             byte|=color << bit;
             if (bit != 0)
               bit-=(unsigned char) bits_per_pixel;
             else
               {
                 *ptr++=byte;
                 byte=0x00;
                 bit=(unsigned char) (8-bits_per_pixel);
               }
           }
           if ((image->columns % (8/bits_per_pixel)) != 0)
             *ptr++=byte;
         }
       if (image_info->compression == RLECompression)
         {
           x=0;
           while (x < (ssize_t) bytes_per_row)
           {
             byte=one_row[x];
             count=1;
             while ((one_row[++x] == byte) && (count < 255) &&
                    (x < (ssize_t) bytes_per_row))
               count++;
             (void) WriteBlobByte(image,(unsigned char) count);
             (void) WriteBlobByte(image,(unsigned char) byte);
           }
         }
       else
         if (image_info->compression == FaxCompression)
           {
             char
               tmpbuf[8],
               *tptr;
 
             for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)
             {
                tptr = tmpbuf;
                for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)
                {
                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))
                 if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))
                    {
                      byte |= (1 << (7 - bit));
                      *tptr++ = (char) one_row[x + bit];
                   }
               }
                (void) WriteBlobByte(image, byte);
                (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);
              }
            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);
             (void) CopyMagickMemory(last_row,one_row,bytes_per_row);
            }
          else
            (void) WriteBlob(image,bytes_per_row,one_row);
       }
     if (flags & PALM_HAS_TRANSPARENCY_FLAG)
       {
         offset=SeekBlob(image,currentOffset+6,SEEK_SET);
         (void) WriteBlobMSBShort(image,flags);
         offset=SeekBlob(image,currentOffset+12,SEEK_SET);
         (void) WriteBlobByte(image,(unsigned char) transparentIndex);   
       }
     if (bits_per_pixel == 16)
        {
          offset=SeekBlob(image,currentOffset+20,SEEK_SET);
          (void) WriteBlobByte(image,0);   
        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));
        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));
        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));
         (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/
           QuantumRange));
         (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/
           QuantumRange));
         (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/
           QuantumRange));
        }
      if (flags & PALM_IS_COMPRESSED_FLAG)   
        {
         offset=SeekBlob(image,currentOffset+offset,SEEK_SET);
         (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-
           currentOffset-offset));
        }
      if (one_row != (unsigned char *) NULL)
        one_row=(unsigned char *) RelinquishMagickMemory(one_row);
    if (lastrow != (unsigned char *) NULL)
      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);
     if (last_row != (unsigned char *) NULL)
       last_row=(unsigned char *) RelinquishMagickMemory(last_row);
      if (GetNextImageInList(image) == (Image *) NULL)
        break;
       
     for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)
       (void) WriteBlobByte(image,0);
      
     (void) SeekBlob(image,currentOffset+10,SEEK_SET);
     nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);
     (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);
     currentOffset=(MagickOffsetType) GetBlobSize(image);
     (void) SeekBlob(image,currentOffset,SEEK_SET);
     image=SyncNextImageInList(image);
     status=SetImageProgress(image,SaveImagesTag,scene++,
       GetImageListLength(image));
     if (status == MagickFalse)
       break;
   } while (image_info->adjoin != MagickFalse);
   quantize_info=DestroyQuantizeInfo(quantize_info);
   (void) CloseBlob(image);
   (void) DestroyExceptionInfo(exception);
   return(MagickTrue);
 }","[48, 184, 189, 190, 191, 192, 193, 194, 195, 196, 197, 202, 203, 204, 205, 286, 296, 315, 316, 317, 318, 319, 320, 332, 333, 47, 183, 186, 187, 188, 201, 285, 295, 312, 313, 314, 330, 331]",ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c.
198794," static int xfrm6_tunnel_rcv(struct sk_buff *skb)
 {
 	struct ipv6hdr *iph = ipv6_hdr(skb);
  	__be32 spi;
  
  	spi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);
	return xfrm6_rcv_spi(skb, spi);
 	return xfrm6_rcv_spi(skb, spi) > 0 ? : 0;
  }","[8, 7]","Double free vulnerability in the xfrm6_tunnel_rcv function in net/ipv6/xfrm6_tunnel.c in the Linux kernel before 2.6.22, when the xfrm6_tunnel module is enabled, allows remote attackers to cause a denial of service (panic) via crafted IPv6 packets."
201620," static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
  				   u16 selector, int seg)
  {
  	u8 cpl = ctxt->ops->cpl(ctxt);
 
 	 
 	if (seg == VCPU_SREG_SS && selector == 3 &&
 	    ctxt->mode == X86EMUL_MODE_PROT64)
 		return emulate_exception(ctxt, GP_VECTOR, 0, true);
 
  	return __load_segment_descriptor(ctxt, selector, seg, cpl,
  					 X86_TRANSFER_NONE, NULL);
  }","[5, 6, 7, 8, 9, 10]","The load_segment_descriptor implementation in arch/x86/kvm/emulate.c in the Linux kernel before 4.9.5 improperly emulates a *MOV SS, NULL selector* instruction, which allows guest OS users to cause a denial of service (guest OS crash) or gain guest OS privileges via a crafted application."
199599," PHP_FUNCTION(imagecrop)
 {
 	zval *IM;
 	gdImagePtr im;
 	gdImagePtr im_crop;
 	gdRect rect;
 	zval *z_rect;
 	zval **tmp;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &z_rect) == FAILURE)  {
 		return;
 	}
 
  	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
  
  	if (zend_hash_find(HASH_OF(z_rect), ""x"", sizeof(""x""), (void **)&tmp) != FAILURE) {
		rect.x = Z_LVAL_PP(tmp);
 		if (Z_TYPE_PP(tmp) != IS_LONG) {
 			zval lval;
 			lval = **tmp;
 			zval_copy_ctor(&lval);
 			convert_to_long(&lval);
 			rect.x = Z_LVAL(lval);
 		} else {
 			rect.x = Z_LVAL_PP(tmp);
 		}
  	} else {
  		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing x position"");
  		RETURN_FALSE;
  	}
  
  	if (zend_hash_find(HASH_OF(z_rect), ""y"", sizeof(""x""), (void **)&tmp) != FAILURE) {
		rect.y = Z_LVAL_PP(tmp);
 		if (Z_TYPE_PP(tmp) != IS_LONG) {
 			zval lval;
 			lval = **tmp;
 			zval_copy_ctor(&lval);
 			convert_to_long(&lval);
 			rect.y = Z_LVAL(lval);
 		} else {
 			rect.y = Z_LVAL_PP(tmp);
 		}
  	} else {
  		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
  		RETURN_FALSE;
  	}
  
  	if (zend_hash_find(HASH_OF(z_rect), ""width"", sizeof(""width""), (void **)&tmp) != FAILURE) {
		rect.width = Z_LVAL_PP(tmp);
 		if (Z_TYPE_PP(tmp) != IS_LONG) {
 			zval lval;
 			lval = **tmp;
 			zval_copy_ctor(&lval);
 			convert_to_long(&lval);
 			rect.width = Z_LVAL(lval);
 		} else {
 			rect.width = Z_LVAL_PP(tmp);
 		}
  	} else {
  		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing width"");
  		RETURN_FALSE;
  	}
  
  	if (zend_hash_find(HASH_OF(z_rect), ""height"", sizeof(""height""), (void **)&tmp) != FAILURE) {
		rect.height = Z_LVAL_PP(tmp);
 		if (Z_TYPE_PP(tmp) != IS_LONG) {
 			zval lval;
 			lval = **tmp;
 			zval_copy_ctor(&lval);
 			convert_to_long(&lval);
 			rect.height = Z_LVAL(lval);
 		} else {
 			rect.height = Z_LVAL_PP(tmp);
 		}
  	} else {
  		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing height"");
  		RETURN_FALSE;
 	}
 
 	im_crop = gdImageCrop(im, &rect);
 
 	if (im_crop == NULL) {
 		RETURN_FALSE;
 	} else {
 		ZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);
 	}
 }","[18, 19, 20, 21, 22, 23, 24, 25, 26, 34, 35, 36, 37, 38, 39, 40, 41, 42, 50, 51, 52, 53, 54, 55, 56, 57, 58, 66, 67, 68, 69, 70, 71, 72, 73, 74, 17, 33, 49, 65]","ext/gd/gd.c in PHP 5.5.x before 5.5.9 does not check data types, which might allow remote attackers to obtain sensitive information by using a (1) string or (2) array data type in place of a numeric data type, as demonstrated by an imagecrop function call with a string for the x dimension value, a different vulnerability than CVE-2013-7226."
6088,"proc_wizkit_line(buf)
char *buf;
{
struct obj *otmp = readobjnam(buf, (struct obj *) 0);

if (otmp) {
if (otmp != &zeroobj)
wizkit_addinv(otmp);
} else {

config_error_add(""Bad wizkit item: \""%.60s\"""", buf);
return FALSE;
}
return TRUE;
}",[4],"NetHack 3.6.x before 3.6.4 is prone to a buffer overflow vulnerability when reading very long lines from configuration files. This affects systems that have NetHack installed suid/sgid, and shared systems that allow users to upload their own configuration files."
205238,"    void TestPlaybackRate(double playback_rate) {
    static const int kDefaultBufferSize = kSamplesPerSecond / 10;
    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;
     const int kDefaultBufferSize = algorithm_.samples_per_second() / 10;
     const int kDefaultFramesRequested = 2 * algorithm_.samples_per_second();
  
      TestPlaybackRate(playback_rate, kDefaultBufferSize,
                       kDefaultFramesRequested);
   }","[4, 5, 2, 3]",Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service (out-of-bounds read) via vectors involving seek operations on video data.
206189,"    void CloseTabsAndExpectNotifications(
        TabStripModel* tab_strip_model,
        std::vector<LifecycleUnit*> lifecycle_units) {
    std::vector<std::unique_ptr<testing::StrictMock<MockLifecycleUnitObserver>>>
     std::vector<
         std::unique_ptr<::testing::StrictMock<MockLifecycleUnitObserver>>>
          observers;
      for (LifecycleUnit* lifecycle_unit : lifecycle_units) {
        observers.emplace_back(
          std::make_unique<testing::StrictMock<MockLifecycleUnitObserver>>());
           std::make_unique<::testing::StrictMock<MockLifecycleUnitObserver>>());
        lifecycle_unit->AddObserver(observers.back().get());
        EXPECT_CALL(*observers.back().get(),
                    OnLifecycleUnitDestroyed(lifecycle_unit));
     }
     tab_strip_model->CloseAllTabs();
   }","[5, 6, 11, 4, 10]","Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects."
2758,"static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
int64_t scale           ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second, result;
bc_init_num(&first);
bc_init_num(&second);
bc_init_num(&result);
php_str2num(&first, (char*)left.data());
php_str2num(&second, (char*)right.data());
bc_add(first, second, &result, scale);
if (result->n_scale > scale) {
result->n_scale = scale;
}
String ret(bc_num2str(result), AttachString);
bc_free_num(&first);
bc_free_num(&second);
bc_free_num(&result);
return ret;
}",[3],"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow."
5773,"static void GTextFieldSave(GTextField *gt,int utf8) {
unichar_t *ret;
char *cret;
FILE *file;
unichar_t *pt;

if ( _ggadget_use_gettext ) {
char *temp = GWidgetOpenFile8(_(""Save""),NULL,""*.{txt,py}"",NULL,NULL);
ret = utf82u_copy(temp);
free(temp);
} else
ret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,
txt,NULL,NULL);

if ( ret==NULL )
return;
cret = u2def_copy(ret);
free(ret);
file = fopen(cret,""w"");
if ( file==NULL ) {
if ( _ggadget_use_gettext )
GWidgetError8(_(""Could not open file""), _(""Could not open %.100s""),cret);
else
GWidgetError(errort,error,cret);
free(cret);
return;
}
free(cret);

if ( utf8 ) {
putc(0xef,file);
putc(0xbb,file);
putc(0xbf,file);
for ( pt = gt->text ; *pt; ++pt ) {
if ( *pt<0x80 )
putc(*pt,file);
else if ( *pt<0x800 ) {
putc(0xc0 | (*pt>>6), file);
putc(0x80 | (*pt&0x3f), file);
} else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {
int u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);
putc( 0xf0 | (u>>2),file );
putc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );
putc( 0x80 | y,file );
putc( 0x80 | (pt[1]&0x3f),file );
} else {
putc( 0xe0 | (*pt>>12),file );
putc( 0x80 | ((*pt>>6)&0x3f),file );
putc( 0x80 | (*pt&0x3f),file );
}
}
} else {
putc(0xfeff>>8,file);
putc(0xfeff&0xff,file);
for ( pt = gt->text ; *pt; ++pt ) {
putc(*pt>>8,file);
putc(*pt&0xff,file);
}
}
fclose(file);
}",[57],FontForge 20190813 through 20190820 has a buffer overflow in PrefsUI_LoadPrefs in prefs.c.
207104,"  void ChromeContentBrowserClient::OpenURL(
    content::BrowserContext* browser_context,
     content::SiteInstance* site_instance,
      const content::OpenURLParams& params,
    const base::Callback<void(content::WebContents*)>& callback) {
     const base::RepeatingCallback<void(content::WebContents*)>& callback) {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(ShouldAllowOpenURL(site_instance, params.url));
 
   content::BrowserContext* browser_context = site_instance->GetBrowserContext();
  
  #if defined(OS_ANDROID)
    ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,
                                                callback);
 #else
   NavigateParams nav_params(Profile::FromBrowserContext(browser_context),
                             params.url, params.transition);
   nav_params.FillNavigateParamsFromOpenURLParams(params);
   nav_params.user_gesture = params.user_gesture;
 
   Navigate(&nav_params);
   callback.Run(nav_params.navigated_or_inserted_contents);
 #endif
 }","[3, 6, 8, 9, 10, 2, 5]",Insufficient policy validation in ServiceWorker in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to bypass navigation restrictions via a crafted HTML page.
198196," void DelayedExecutor::delayedExecute(const QString &udi)
 {
     Solid::Device device(udi);
  
      QString exec = m_service.exec();
      MacroExpander mx(device);
    mx.expandMacros(exec);
     mx.expandMacrosShellQuote(exec);
  
      KRun::runCommand(exec, QString(), m_service.icon(), 0);
      deleteLater();
 }","[8, 7]","An issue was discovered in soliduiserver/deviceserviceaction.cpp in KDE Plasma Workspace before 5.12.0. When a vfat thumbdrive that contains `` or $() in its volume label is plugged in and mounted through the device notifier, it's interpreted as a shell command, leading to a possibility of arbitrary command execution. An example of an offending volume label is ""$(touch b)"" -- this will create a file called b in the home folder."
8386,"enum sctp_disposition sctp_sf_discard_chunk(struct net *net,
const struct sctp_endpoint *ep,
const struct sctp_association *asoc,
const union sctp_subtype type,
void *arg,
struct sctp_cmd_seq *commands)
{
struct sctp_chunk *chunk = arg;





if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))
return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
commands);

pr_debug(""%s: chunk:%d is discarded\n"", __func__, type.chunk);

return SCTP_DISPOSITION_DISCARD;
}",[14],A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses.
198463," PHP_METHOD(Phar, __construct)
 {
 #if !HAVE_SPL
 	zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Cannot instantiate Phar object without SPL extension"");
 #else
 	char *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;
 	int fname_len, alias_len = 0, arch_len, entry_len, is_data;
 #if PHP_VERSION_ID < 50300
 	long flags = 0;
 #else
 	long flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;
 #endif
 	long format = 0;
 	phar_archive_object *phar_obj;
 	phar_archive_data   *phar_data;
 	zval *zobj = getThis(), arg1, arg2;
 
 	phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 
 	is_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data TSRMLS_CC);
 
 	if (is_data) {
 		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|ls!l"", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {
 			return;
 		}
 	} else {
 		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|ls!"", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {
 			return;
 		}
 	}
 
 	if (phar_obj->arc.archive) {
 		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Cannot call constructor twice"");
 		return;
 	}
 
 	save_fname = fname;
 	if (SUCCESS == phar_split_fname(fname, fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2 TSRMLS_CC)) {
 		 
 		 
 #ifdef PHP_WIN32
 		phar_unixify_path_separators(arch, arch_len);
 #endif
 		fname = arch;
 		fname_len = arch_len;
 #ifdef PHP_WIN32
 	} else {
 		arch = estrndup(fname, fname_len);
 		arch_len = fname_len;
 		fname = arch;
 		phar_unixify_path_separators(arch, arch_len);
 #endif
 	}
 
 	if (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error TSRMLS_CC) == FAILURE) {
 
 		if (fname == arch && fname != save_fname) {
 			efree(arch);
 			fname = save_fname;
 		}
 
 		if (entry) {
 			efree(entry);
 		}
 
 		if (error) {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""%s"", error);
 			efree(error);
 		} else {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""Phar creation or opening failed"");
 		}
 
 		return;
 	}
 
 	if (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {
 		phar_data->is_zip = 1;
 		phar_data->is_tar = 0;
 	}
 
 	if (fname == arch) {
 		efree(arch);
 		fname = save_fname;
 	}
 
 	if ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {
 		if (is_data) {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""PharData class can only be used for non-executable tar and zip archives"");
 		} else {
 			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
 				""Phar class can only be used for executable tar and zip archives"");
 		}
 		efree(entry);
 		return;
 	}
 
 	is_data = phar_data->is_data;
 
 	if (!phar_data->is_persistent) {
 		++(phar_data->refcount);
 	}
 
 	phar_obj->arc.archive = phar_data;
 	phar_obj->spl.oth_handler = &phar_spl_foreign_handler;
 
 	if (entry) {
 		fname_len = spprintf(&fname, 0, ""phar:%s%s"", phar_data->fname, entry);
 		efree(entry);
 	} else {
 		fname_len = spprintf(&fname, 0, ""phar:%s"", phar_data->fname);
 	}
 
 	INIT_PZVAL(&arg1);
 	ZVAL_STRINGL(&arg1, fname, fname_len, 0);
         INIT_PZVAL(&arg2);
         ZVAL_LONG(&arg2, flags);
  
       zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj), 
        zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj),
                 &spl_ce_RecursiveDirectoryIterator->constructor, ""__construct"", NULL, &arg1, &arg2);
  
         if (!phar_data->is_persistent) {
 		phar_obj->arc.archive->is_data = is_data;
 	} else if (!EG(exception)) {
 		 
 		zend_hash_add(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive), (void *) &phar_obj, sizeof(phar_archive_object **), NULL);
 	}
 
 	phar_obj->spl.info_class = phar_ce_entry;
 	efree(fname);
 #endif  
 }","[122, 121]","The phar_convert_to_other function in ext/phar/phar_object.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 does not validate a file pointer before a close operation, which allows remote attackers to cause a denial of service (segmentation fault) or possibly have unspecified other impact via a crafted TAR archive that is mishandled in a Phar::convertToData call."
207873," long Track::ParseContentEncodingsEntry(long long start, long long size) {
  IMkvReader* const pReader = m_pSegment->m_pReader;
   assert(pReader);
 
  long long pos = start;
  const long long stop = start + size;
 
  int count = 0;
  while (pos < stop) {
  long long id, size;
  const long status = ParseElementHeader(pReader, pos, stop, id, size);
  if (status < 0)  
  return status;
 
  if (id == 0x2240)  
 
        ++count;
  
      pos += size;   
    assert(pos <= stop);
     if (pos > stop)
       return E_FILE_FORMAT_INVALID;
    }
  
    if (count <= 0)
      return -1;
  
  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];
   content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];
    if (!content_encoding_entries_)
      return -1;
  
   content_encoding_entries_end_ = content_encoding_entries_;
 
   pos = start;
  while (pos < stop) {
  long long id, size;
  long status = ParseElementHeader(pReader, pos, stop, id, size);
  if (status < 0)  
  return status;
 
  if (id == 0x2240) {  
  ContentEncoding* const content_encoding =
  new (std::nothrow) ContentEncoding();
  if (!content_encoding)
  return -1;
 
       status = content_encoding->ParseContentEncodingEntry(pos, size, pReader);
  if (status) {
  delete content_encoding;
  return status;
  }
 
  *content_encoding_entries_end_++ = content_encoding;
 
      }
  
      pos += size;   
    assert(pos <= stop);
     if (pos > stop)
       return E_FILE_FORMAT_INVALID;
    }
  
  assert(pos == stop);
   if (pos != stop)
     return E_FILE_FORMAT_INVALID;
  
    return 0;
  }","[21, 22, 29, 60, 61, 65, 66, 20, 28, 59, 64]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
8380,"enum sctp_disposition sctp_sf_do_9_1_abort(
struct net *net,
const struct sctp_endpoint *ep,
const struct sctp_association *asoc,
const union sctp_subtype type,
void *arg,
struct sctp_cmd_seq *commands)
{
struct sctp_chunk *chunk = arg;

if (!sctp_vtag_verify_either(chunk, asoc))
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);











if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);






if (SCTP_ADDR_DEL ==
sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))
return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);

if (!sctp_err_chunk_valid(chunk))
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);

return __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);
}",[34],A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses.
206187," bool TabLifecycleUnitSource::TabLifecycleUnit::CanFreeze(
     DecisionDetails* decision_details) const {
   DCHECK(decision_details->reasons().empty());
 
 
   if (!IsValidStateChange(GetState(), LifecycleUnitState::PENDING_FREEZE,
                           StateChangeReason::BROWSER_INITIATED)) {
     return false;
   }
 
   if (TabLoadTracker::Get()->GetLoadingState(GetWebContents()) !=
       TabLoadTracker::LoadingState::LOADED) {
      return false;
    }
  
 
   if (GetWebContents()->GetVisibility() == content::Visibility::VISIBLE)
     decision_details->AddReason(DecisionFailureReason::LIVE_STATE_VISIBLE);
 
    IsMediaTabImpl(decision_details);
  
    
    
    
   CheckIfTabCanCommunicateWithUserWhileInBackground(GetWebContents(),
                                                     decision_details);
 
    if (decision_details->reasons().empty()) {
      decision_details->AddReason(
          DecisionSuccessReason::HEURISTIC_OBSERVED_TO_BE_SAFE);
    DCHECK(decision_details->IsPositive());
    }
 
    return decision_details->IsPositive();
  }","[22, 23, 24, 25, 26, 27, 33, 31]","Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects."
202582," int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int status = 0, size_change;
 	int inode_locked = 0;
 	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	struct ocfs2_super *osb = OCFS2_SB(sb);
 	struct buffer_head *bh = NULL;
 	handle_t *handle = NULL;
 	struct dquot *transfer_to[MAXQUOTAS] = { };
 	int qtype;
 	int had_lock;
 	struct ocfs2_lock_holder oh;
 
 	trace_ocfs2_setattr(inode, dentry,
 			    (unsigned long long)OCFS2_I(inode)->ip_blkno,
 			    dentry->d_name.len, dentry->d_name.name,
 			    attr->ia_valid, attr->ia_mode,
 			    from_kuid(&init_user_ns, attr->ia_uid),
 			    from_kgid(&init_user_ns, attr->ia_gid));
 
 	 
 	if (S_ISLNK(inode->i_mode))
 		attr->ia_valid &= ~ATTR_SIZE;
 
 #define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \
 			   | ATTR_GID | ATTR_UID | ATTR_MODE)
 	if (!(attr->ia_valid & OCFS2_VALID_ATTRS))
 		return 0;
 
 	status = setattr_prepare(dentry, attr);
 	if (status)
 		return status;
 
 	if (is_quota_modification(inode, attr)) {
 		status = dquot_initialize(inode);
 		if (status)
 			return status;
  	}
  	size_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;
  	if (size_change) {
 		 
 		inode_dio_wait(inode);
 
  		status = ocfs2_rw_lock(inode, 1);
  		if (status < 0) {
  			mlog_errno(status);
 			goto bail;
 		}
 	}
 
 	had_lock = ocfs2_inode_lock_tracker(inode, &bh, 1, &oh);
 	if (had_lock < 0) {
 		status = had_lock;
 		goto bail_unlock_rw;
 	} else if (had_lock) {
 		 
 		mlog(ML_ERROR, ""Another case of recursive locking:\n"");
 		dump_stack();
 	}
 	inode_locked = 1;
 
 	if (size_change) {
 		status = inode_newsize_ok(inode, attr->ia_size);
  		if (status)
  			goto bail_unlock;
  
		inode_dio_wait(inode);
  		if (i_size_read(inode) >= attr->ia_size) {
  			if (ocfs2_should_order_data(inode)) {
  				status = ocfs2_begin_ordered_truncate(inode,
 								      attr->ia_size);
 				if (status)
 					goto bail_unlock;
 			}
 			status = ocfs2_truncate_file(inode, bh, attr->ia_size);
 		} else
 			status = ocfs2_extend_file(inode, bh, attr->ia_size);
 		if (status < 0) {
 			if (status != -ENOSPC)
 				mlog_errno(status);
 			status = -ENOSPC;
 			goto bail_unlock;
 		}
 	}
 
 	if ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||
 	    (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {
 		 
 		if (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)
 		    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,
 		    OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {
 			transfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid));
 			if (IS_ERR(transfer_to[USRQUOTA])) {
 				status = PTR_ERR(transfer_to[USRQUOTA]);
 				goto bail_unlock;
 			}
 		}
 		if (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid)
 		    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,
 		    OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {
 			transfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid));
 			if (IS_ERR(transfer_to[GRPQUOTA])) {
 				status = PTR_ERR(transfer_to[GRPQUOTA]);
 				goto bail_unlock;
 			}
 		}
 		handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS +
 					   2 * ocfs2_quota_trans_credits(sb));
 		if (IS_ERR(handle)) {
 			status = PTR_ERR(handle);
 			mlog_errno(status);
 			goto bail_unlock;
 		}
 		status = __dquot_transfer(inode, transfer_to);
 		if (status < 0)
 			goto bail_commit;
 	} else {
 		handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);
 		if (IS_ERR(handle)) {
 			status = PTR_ERR(handle);
 			mlog_errno(status);
 			goto bail_unlock;
 		}
 	}
 
 	setattr_copy(inode, attr);
 	mark_inode_dirty(inode);
 
 	status = ocfs2_mark_inode_dirty(handle, inode, bh);
 	if (status < 0)
 		mlog_errno(status);
 
 bail_commit:
 	ocfs2_commit_trans(osb, handle);
 bail_unlock:
 	if (status && inode_locked) {
 		ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);
 		inode_locked = 0;
 	}
 bail_unlock_rw:
 	if (size_change)
 		ocfs2_rw_unlock(inode, 1);
 bail:
 
 	 
 	for (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++)
 		dqput(transfer_to[qtype]);
 
 	if (!status && attr->ia_valid & ATTR_MODE) {
 		status = ocfs2_acl_chmod(inode, bh);
 		if (status < 0)
 			mlog_errno(status);
 	}
 	if (inode_locked)
 		ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);
 
 	brelse(bh);
 	return status;
 }","[42, 43, 44, 68]",The ocfs2_setattr function in fs/ocfs2/file.c in the Linux kernel before 4.14.2 allows local users to cause a denial of service (deadlock) via DIO requests.
9518,"llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,
ValueRange shapes, Location loc,
OpBuilder* builder) {

SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;
size_t maxRank = 0;
for (const auto &shape : llvm::enumerate(shapes)) {
auto found_shape = analysis.GetValueInfo(shape.value());
if (!found_shape) return {};
shapes_found.push_back(*found_shape);
maxRank = std::max(maxRank, found_shape->size());
}

SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(
maxRank);
SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);
for (const auto &shape : llvm::enumerate(shapes_found)) {
for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {

if (dim.value().isConstant(1)) continue;


auto index = maxRank - dim.index() - 1;
if (!joined_dimensions[index]) {
joined_dimensions[index] = &dim.value();
shape_and_rank_for_dim[index] =
std::make_pair(shapes[shape.index()], shape.value().size());
continue;
}

if (*joined_dimensions[index] != dim.value()) return {};
}
}

if (llvm::is_splat(shape_and_rank_for_dim) &&
shape_and_rank_for_dim[0].first) {
return shape_and_rank_for_dim[0].first;
}

SmallVector<Value> elements;
for (int i = 0; i != maxRank; ++i) {

if (!shape_and_rank_for_dim[i].first) {
auto one = builder->getIntegerAttr(
shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);
elements.push_back(builder->create<ConstantOp>(loc, one));
continue;
}


Value index = builder->create<ConstantIndexOp>(
loc, i - maxRank + shape_and_rank_for_dim[i].second);
elements.push_back(builder->create<tensor::ExtractOp>(
loc, shape_and_rank_for_dim[i].first, index));
}
return Value(builder->create<tensor::FromElementsOp>(loc, elements));
}",[14],"Tensorflow is an Open Source Machine Learning Framework. The `simplifyBroadcast` function in the MLIR-TFRT infrastructure in TensorFlow is vulnerable to a segfault (hence, denial of service), if called with scalar shapes. If all shapes are scalar, then `maxRank` is 0, so we build an empty `SmallVector`. The fix will be included in TensorFlow 2.8.0. This is the only affected version."
198701," int __ref online_pages(unsigned long pfn, unsigned long nr_pages)
 {
 	unsigned long onlined_pages = 0;
 	struct zone *zone;
 	int need_zonelists_rebuild = 0;
 	int nid;
 	int ret;
 	struct memory_notify arg;
 
 	lock_memory_hotplug();
 	arg.start_pfn = pfn;
 	arg.nr_pages = nr_pages;
 	arg.status_change_nid = -1;
 
 	nid = page_to_nid(pfn_to_page(pfn));
 	if (node_present_pages(nid) == 0)
 		arg.status_change_nid = nid;
 
 	ret = memory_notify(MEM_GOING_ONLINE, &arg);
 	ret = notifier_to_errno(ret);
 	if (ret) {
 		memory_notify(MEM_CANCEL_ONLINE, &arg);
 		unlock_memory_hotplug();
 		return ret;
 	}
 	 
 	zone = page_zone(pfn_to_page(pfn));
 	 
 	mutex_lock(&zonelists_mutex);
 	if (!populated_zone(zone))
 		need_zonelists_rebuild = 1;
 
 	ret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,
 		online_pages_range);
 	if (ret) {
 		mutex_unlock(&zonelists_mutex);
 		printk(KERN_DEBUG ""online_pages [mem %#010llx-%#010llx] failed\n"",
 		       (unsigned long long) pfn << PAGE_SHIFT,
 		       (((unsigned long long) pfn + nr_pages)
 			    << PAGE_SHIFT) - 1);
 		memory_notify(MEM_CANCEL_ONLINE, &arg);
 		unlock_memory_hotplug();
 		return ret;
 	}
  
  	zone->present_pages += onlined_pages;
  	zone->zone_pgdat->node_present_pages += onlined_pages;
	if (need_zonelists_rebuild)
		build_all_zonelists(NULL, zone);
	else
		zone_pcp_update(zone);
 	if (onlined_pages) {
 		node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);
 		if (need_zonelists_rebuild)
 			build_all_zonelists(NULL, zone);
 		else
 			zone_pcp_update(zone);
 	}
  
  	mutex_unlock(&zonelists_mutex);
  
  	init_per_zone_wmark_min();
  
	if (onlined_pages) {
 	if (onlined_pages)
  		kswapd_run(zone_to_nid(zone));
		node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);
	}
  
  	vm_total_pages = nr_free_pagecache_pages();
  
 	writeback_set_ratelimit();
 
 	if (onlined_pages)
 		memory_notify(MEM_ONLINE, &arg);
 	unlock_memory_hotplug();
 
 	return 0;
 }","[52, 53, 54, 55, 56, 57, 58, 65, 48, 49, 50, 51, 64, 67, 68]",The online_pages function in mm/memory_hotplug.c in the Linux kernel before 3.6 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact in opportunistic circumstances by using memory that was hot-added by an administrator.
205966,"   void ProcessControlLaunched() {
   void ProcessControlLaunched(base::OnceClosure on_done) {
      base::ScopedAllowBlockingForTesting allow_blocking;
      base::ProcessId service_pid;
      EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
     EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
 #if defined(OS_WIN)
     service_process_ =
         base::Process::OpenWithAccess(service_pid,
                                       SYNCHRONIZE | PROCESS_QUERY_INFORMATION);
 #else
      service_process_ = base::Process::Open(service_pid);
  #endif
      EXPECT_TRUE(service_process_.IsValid());
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
     std::move(on_done).Run();
    }","[2, 17, 15, 16]","The extensions subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux relies on an IFRAME source URL to identify an associated extension, which allows remote attackers to conduct extension-bindings injection attacks by leveraging script access to a resource that initially has the about:blank URL."
199482," acc_ctx_cont(OM_uint32 *minstat,
 	     gss_buffer_t buf,
 	     gss_ctx_id_t *ctx,
 	     gss_buffer_t *responseToken,
 	     gss_buffer_t *mechListMIC,
 	     OM_uint32 *negState,
 	     send_token_flag *return_token)
 {
 	OM_uint32 ret, tmpmin;
 	gss_OID supportedMech;
 	spnego_gss_ctx_id_t sc;
 	unsigned int len;
 	unsigned char *ptr, *bufstart;
 
 	sc = (spnego_gss_ctx_id_t)*ctx;
 	ret = GSS_S_DEFECTIVE_TOKEN;
 	*negState = REJECT;
 	*minstat = 0;
 	supportedMech = GSS_C_NO_OID;
 	*return_token = ERROR_TOKEN_SEND;
 	*responseToken = *mechListMIC = GSS_C_NO_BUFFER;
  
  	ptr = bufstart = buf->value;
  #define REMAIN (buf->length - (ptr - bufstart))
	if (REMAIN > INT_MAX)
 	if (REMAIN == 0 || REMAIN > INT_MAX)
  		return GSS_S_DEFECTIVE_TOKEN;
  
  	 
 	if (*ptr == HEADER_ID) {
 		ret = g_verify_token_header(gss_mech_spnego,
 					    &len, &ptr, 0, REMAIN);
 		if (ret) {
 			*minstat = ret;
 			return GSS_S_DEFECTIVE_TOKEN;
 		}
 	}
 	if (*ptr != (CONTEXT | 0x01)) {
 		return GSS_S_DEFECTIVE_TOKEN;
 	}
 	ret = get_negTokenResp(minstat, ptr, REMAIN,
 			       negState, &supportedMech,
 			       responseToken, mechListMIC);
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
 	if (*responseToken == GSS_C_NO_BUFFER &&
 	    *mechListMIC == GSS_C_NO_BUFFER) {
 
 		ret = GSS_S_DEFECTIVE_TOKEN;
 		goto cleanup;
 	}
 	if (supportedMech != GSS_C_NO_OID) {
 		ret = GSS_S_DEFECTIVE_TOKEN;
 		goto cleanup;
 	}
 	sc->firstpass = 0;
 	*negState = ACCEPT_INCOMPLETE;
 	*return_token = CONT_TOKEN_SEND;
 cleanup:
 	if (supportedMech != GSS_C_NO_OID) {
 		generic_gss_release_oid(&tmpmin, &supportedMech);
 	}
 	return ret;
 #undef REMAIN
 }","[26, 25]",The acc_ctx_cont function in the SPNEGO acceptor in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.5.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty continuation token at a certain point during a SPNEGO negotiation.
201958," static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
 static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)
  {
    MagickBooleanType
      status;
 
   int
     bit;
 
   register const PixelPacket
     *p;
 
   register ssize_t
     x;
 
   ssize_t
     y;
 
   unsigned char
     byte;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
    assert(image->signature == MagickSignature);
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
    if (status == MagickFalse)
      return(status);
    (void) TransformImageColorspace(image,sRGBColorspace);
   if((image->columns > 255L) || (image->rows > 255L))
     ThrowWriterException(ImageError,""Dimensions must be less than 255x255"");
    
   (void) WriteBlobByte(image,image->columns & 0xff);
   (void) WriteBlobByte(image,image->rows & 0xff);
    
   (void) SetImageType(image,BilevelType);
   x=0;
    y=0;
    for (y=0; y < (ssize_t) image->rows; y++)
    {
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (const PixelPacket *) NULL)
        break;
      bit=0;
     byte=0;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       byte>>=1;
       if (GetPixelLuma(image,p) < (QuantumRange/2.0))
         byte|=0x80;
       bit++;
       if (bit == 8)
         {
            
        	  (void) WriteBlobByte(image,byte);
           bit=0;
           byte=0;
         }
       p++;
     }
     if (bit != 0)
       (void) WriteBlobByte(image,byte);
     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
       image->rows);
     if (status == MagickFalse)
       break;
   }
   (void) CloseBlob(image);
   return(MagickTrue);
 }","[3, 33, 49, 2, 30, 31, 32, 48]",coders/rgf.c in ImageMagick before 6.9.4-10 allows remote attackers to cause a denial of service (assertion failure) by converting an image to rgf format.
207444," static int a2dp_command(struct a2dp_stream_common *common, char cmd)
 {
  char ack;
 
 
      DEBUG(""A2DP COMMAND %s"", dump_a2dp_ctrl_event(cmd));
  
       
    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)
     if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)
      {
          ERROR(""cmd failed (%s)"", strerror(errno));
          skt_disconnect(common->ctrl_fd);
         common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
  return -1;
  }
 
   
  if (a2dp_ctrl_receive(common, &ack, 1) < 0)
  return -1;
 
     DEBUG(""A2DP COMMAND %s DONE STATUS %d"", dump_a2dp_ctrl_event(cmd), ack);
 
  if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)
  return ack;
  if (ack != A2DP_CTRL_ACK_SUCCESS)
  return -1;
 
  return 0;
 }","[10, 9]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
202469," static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)
 {
 	BYTE c;
 	BYTE flags;
 	UINT32 extra = 0;
 	int opIndex;
 	int haveBits;
 	int inPrefix;
  	UINT32 count;
  	UINT32 distance;
  	BYTE* pbSegment;
	size_t cbSegment = segmentSize - 1;
 	size_t cbSegment;
  
	if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))
 	if (!zgfx || !stream)
 		return FALSE;
 
 	cbSegment = segmentSize - 1;
 
 	if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||
 	    (segmentSize > UINT32_MAX))
  		return FALSE;
  
  	Stream_Read_UINT8(stream, flags);  
 	zgfx->OutputCount = 0;
 	pbSegment = Stream_Pointer(stream);
 	Stream_Seek(stream, cbSegment);
 
  	if (!(flags & PACKET_COMPRESSED))
  	{
  		zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);
 
 		if (cbSegment > sizeof(zgfx->OutputBuffer))
 			return FALSE;
 
  		CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);
  		zgfx->OutputCount = cbSegment;
  		return TRUE;
 	}
 
 	zgfx->pbInputCurrent = pbSegment;
 	zgfx->pbInputEnd = &pbSegment[cbSegment - 1];
 	 
 	zgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;
 	zgfx->cBitsCurrent = 0;
 	zgfx->BitsCurrent = 0;
 
 	while (zgfx->cBitsRemaining)
 	{
 		haveBits = 0;
 		inPrefix = 0;
 
 		for (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)
 		{
 			while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)
 			{
 				zgfx_GetBits(zgfx, 1);
 				inPrefix = (inPrefix << 1) + zgfx->bits;
 				haveBits++;
 			}
 
 			if (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)
 			{
 				if (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)
 				{
 					 
 					zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);
 					c = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);
 					zgfx->HistoryBuffer[zgfx->HistoryIndex] = c;
 
  					if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)
  						zgfx->HistoryIndex = 0;
  
 					if (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))
 						return FALSE;
 
  					zgfx->OutputBuffer[zgfx->OutputCount++] = c;
  				}
  				else
 				{
 					zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);
 					distance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;
 
 					if (distance != 0)
 					{
 						 
 						zgfx_GetBits(zgfx, 1);
 
 						if (zgfx->bits == 0)
 						{
 							count = 3;
 						}
 						else
 						{
 							count = 4;
 							extra = 2;
 							zgfx_GetBits(zgfx, 1);
 
 							while (zgfx->bits == 1)
 							{
 								count *= 2;
 								extra++;
 								zgfx_GetBits(zgfx, 1);
 							}
 
 							zgfx_GetBits(zgfx, extra);
  							count += zgfx->bits;
  						}
  
 						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
 							return FALSE;
 
  						zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
  						zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
  						zgfx->OutputCount += count;
 					}
 					else
 					{
 						 
 						zgfx_GetBits(zgfx, 15);
 						count = zgfx->bits;
  						zgfx->cBitsRemaining -= zgfx->cBitsCurrent;
  						zgfx->cBitsCurrent = 0;
  						zgfx->BitsCurrent = 0;
 
 						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
 							return FALSE;
 
  						CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);
  						zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);
  						zgfx->pbInputCurrent += count;
 						zgfx->cBitsRemaining -= (8 * count);
 						zgfx->OutputCount += count;
 					}
 				}
 
 				break;
 			}
 		}
 	}
 
 	return TRUE;
 }","[13, 16, 17, 18, 19, 20, 21, 22, 33, 34, 35, 36, 75, 76, 77, 111, 112, 113, 126, 127, 128, 129, 12, 15]",FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress_segment() that results in a memory corruption and probably even a remote code execution.
202880," GF_Err gf_bin128_parse(const char *string, bin128 value)
 {
 	u32 len;
 	u32	i=0;
 	if (!strnicmp(string, ""0x"", 2)) string += 2;
 	len = (u32) strlen(string);
 	if (len >= 32) {
 		u32 j;
 		for (j=0; j<len; j+=2) {
 			u32 v;
 			char szV[5];
 
 			while (string[j] && !isalnum(string[j]))
 				j++;
 			if (!string[j])
 				break;
 			sprintf(szV, ""%c%c"", string[j], string[j+1]);
  			sscanf(szV, ""%x"", &v);
  			value[i] = v;
  			i++;
 			if (i > 15) {
 				 
 				i++;
 				break;
 			}
  		}
  	}
  	if (i != 16) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
 		return GF_BAD_PARAM;
 	}
 	return GF_OK;
 }","[21, 22, 23, 24, 25]",gf_bin128_parse in utils/os_divers.c in GPAC 0.7.1 has a buffer overflow issue for the crypt feature when encountering a crafted_drm_file.xml file.
204431," bool PrintWebViewHelper::UpdatePrintSettings(
     WebKit::WebFrame* frame, const WebKit::WebNode& node,
     const DictionaryValue& passed_job_settings) {
   DCHECK(is_preview_enabled_);
   const DictionaryValue* job_settings = &passed_job_settings;
   DictionaryValue modified_job_settings;
   if (job_settings->empty()) {
     if (!print_for_preview_)
       print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
     return false;
   }
 
   bool source_is_html = true;
   if (print_for_preview_) {
     if (!job_settings->GetBoolean(printing::kSettingPreviewModifiable,
                                   &source_is_html)) {
       NOTREACHED();
     }
   } else {
     source_is_html = !PrintingNodeOrPdfFrame(frame, node);
   }
 
   if (print_for_preview_ || !source_is_html) {
     modified_job_settings.MergeDictionary(job_settings);
     modified_job_settings.SetBoolean(printing::kSettingHeaderFooterEnabled,
                                      false);
     modified_job_settings.SetInteger(printing::kSettingMarginsType,
                                      printing::NO_MARGINS);
     job_settings = &modified_job_settings;
   }
 
   int cookie = print_pages_params_.get() ?
       print_pages_params_->params.document_cookie : 0;
   PrintMsg_PrintPages_Params settings;
   Send(new PrintHostMsg_UpdatePrintSettings(routing_id(),
       cookie, *job_settings, &settings));
   print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));
 
   if (!PrintMsg_Print_Params_IsValid(settings.params)) {
     if (!print_for_preview_) {
       print_preview_context_.set_error(PREVIEW_ERROR_INVALID_PRINTER_SETTINGS);
     } else {
       WebKit::WebFrame* print_frame = NULL;
       GetPrintFrame(&print_frame);
       if (print_frame) {
         render_view()->RunModalAlertDialog(
             print_frame,
             l10n_util::GetStringUTF16(
                 IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS));
       }
     }
     return false;
   }
 
   if (settings.params.dpi < kMinDpi || !settings.params.document_cookie) {
     print_preview_context_.set_error(PREVIEW_ERROR_UPDATING_PRINT_SETTINGS);
     return false;
   }
  
    if (!print_for_preview_) {
    if (!job_settings->GetString(printing::kPreviewUIAddr,
                                 &(settings.params.preview_ui_addr)) ||
     if (!job_settings->GetInteger(printing::kPreviewUIID,
                                   &(settings.params.preview_ui_id)) ||
          !job_settings->GetInteger(printing::kPreviewRequestID,
                                    &(settings.params.preview_request_id)) ||
          !job_settings->GetBoolean(printing::kIsFirstRequest,
                                   &(settings.params.is_first_request))) {
       NOTREACHED();
       print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);
       return false;
     }
 
     settings.params.print_to_pdf = IsPrintToPdfRequested(*job_settings);
     UpdateFrameMarginsCssInfo(*job_settings);
     settings.params.print_scaling_option = GetPrintScalingOption(
         source_is_html, *job_settings, settings.params);
 
     if (settings.params.display_header_footer) {
       header_footer_info_.reset(new DictionaryValue());
       header_footer_info_->SetString(printing::kSettingHeaderFooterDate,
                                      settings.params.date);
       header_footer_info_->SetString(printing::kSettingHeaderFooterURL,
                                      settings.params.url);
       header_footer_info_->SetString(printing::kSettingHeaderFooterTitle,
                                      settings.params.title);
     }
   }
 
   print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));
   Send(new PrintHostMsg_DidGetDocumentCookie(routing_id(),
                                              settings.params.document_cookie));
   return true;
 }","[63, 64, 61, 62]",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
201594," int ssl3_get_record(SSL *s)
 {
     int ssl_major, ssl_minor, al;
     int enc_err, n, i, ret = -1;
     SSL3_RECORD *rr;
     SSL3_BUFFER *rbuf;
     SSL_SESSION *sess;
     unsigned char *p;
     unsigned char md[EVP_MAX_MD_SIZE];
     short version;
     unsigned mac_size;
     unsigned int num_recs = 0;
     unsigned int max_recs;
     unsigned int j;
 
     rr = RECORD_LAYER_get_rrec(&s->rlayer);
     rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);
     max_recs = s->max_pipelines;
     if (max_recs == 0)
         max_recs = 1;
     sess = s->session;
 
     do {
          
         if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||
             (RECORD_LAYER_get_packet_length(&s->rlayer)
              < SSL3_RT_HEADER_LENGTH)) {
             n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,
                             SSL3_BUFFER_get_len(rbuf), 0,
                             num_recs == 0 ? 1 : 0);
             if (n <= 0)
                 return (n);      
             RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);
 
             p = RECORD_LAYER_get_packet(&s->rlayer);
 
              
             if (s->server && RECORD_LAYER_is_first_record(&s->rlayer)
                 && (p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {
                  
                 rr[num_recs].type = SSL3_RT_HANDSHAKE;
                 rr[num_recs].rec_version = SSL2_VERSION;
 
                 rr[num_recs].length = ((p[0] & 0x7f) << 8) | p[1];
 
                 if (rr[num_recs].length > SSL3_BUFFER_get_len(rbuf)
                     - SSL2_RT_HEADER_LENGTH) {
                     al = SSL_AD_RECORD_OVERFLOW;
                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);
                     goto f_err;
                 }
 
                 if (rr[num_recs].length < MIN_SSL2_RECORD_LEN) {
                     al = SSL_AD_HANDSHAKE_FAILURE;
                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
                     goto f_err;
                 }
             } else {
                  
                 if (s->msg_callback)
                     s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,
                                     s->msg_callback_arg);
 
                  
                 rr[num_recs].type = *(p++);
                 ssl_major = *(p++);
                 ssl_minor = *(p++);
                 version = (ssl_major << 8) | ssl_minor;
                 rr[num_recs].rec_version = version;
                 n2s(p, rr[num_recs].length);
 
                  
                 if (!s->first_packet && version != s->version) {
                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);
                     if ((s->version & 0xFF00) == (version & 0xFF00)
                         && !s->enc_write_ctx && !s->write_hash) {
                         if (rr->type == SSL3_RT_ALERT) {
                              
                             goto err;
                         }
                          
                         s->version = (unsigned short)version;
                     }
                     al = SSL_AD_PROTOCOL_VERSION;
                     goto f_err;
                 }
 
                 if ((version >> 8) != SSL3_VERSION_MAJOR) {
                     if (RECORD_LAYER_is_first_record(&s->rlayer)) {
                          
                         p = RECORD_LAYER_get_packet(&s->rlayer);
                         if (strncmp((char *)p, ""GET "", 4) == 0 ||
                             strncmp((char *)p, ""POST "", 5) == 0 ||
                             strncmp((char *)p, ""HEAD "", 5) == 0 ||
                             strncmp((char *)p, ""PUT "", 4) == 0) {
                             SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST);
                             goto err;
                         } else if (strncmp((char *)p, ""CONNE"", 5) == 0) {
                             SSLerr(SSL_F_SSL3_GET_RECORD,
                                    SSL_R_HTTPS_PROXY_REQUEST);
                             goto err;
                         }
 
                          
                         SSLerr(SSL_F_SSL3_GET_RECORD,
                                SSL_R_WRONG_VERSION_NUMBER);
                         goto err;
                     } else {
                         SSLerr(SSL_F_SSL3_GET_RECORD,
                                SSL_R_WRONG_VERSION_NUMBER);
                         al = SSL_AD_PROTOCOL_VERSION;
                         goto f_err;
                     }
                 }
 
                 if (rr[num_recs].length >
                     SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {
                     al = SSL_AD_RECORD_OVERFLOW;
                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);
                     goto f_err;
                 }
             }
 
              
         }
 
          
         if (rr[num_recs].rec_version == SSL2_VERSION) {
             i = rr[num_recs].length + SSL2_RT_HEADER_LENGTH
                 - SSL3_RT_HEADER_LENGTH;
         } else {
             i = rr[num_recs].length;
         }
         if (i > 0) {
              
 
             n = ssl3_read_n(s, i, i, 1, 0);
             if (n <= 0)
                 return (n);      
         }
 
          
         RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);
 
          
         if (rr[num_recs].rec_version == SSL2_VERSION) {
             rr[num_recs].input =
                 &(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]);
         } else {
             rr[num_recs].input =
                 &(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]);
         }
 
          
 
          
 
          
         if (rr[num_recs].length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
             al = SSL_AD_RECORD_OVERFLOW;
             SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
             goto f_err;
         }
 
          
         rr[num_recs].data = rr[num_recs].input;
         rr[num_recs].orig_len = rr[num_recs].length;
 
          
         rr[num_recs].read = 0;
 
         num_recs++;
 
          
         RECORD_LAYER_reset_packet_length(&s->rlayer);
         RECORD_LAYER_clear_first_record(&s->rlayer);
     } while (num_recs < max_recs
              && rr[num_recs - 1].type == SSL3_RT_APPLICATION_DATA
              && SSL_USE_EXPLICIT_IV(s)
              && s->enc_read_ctx != NULL
              && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))
                  & EVP_CIPH_FLAG_PIPELINE)
              && ssl3_record_app_data_waiting(s));
 
      
    if (SSL_USE_ETM(s) && s->read_hash) {
     if (SSL_READ_ETM(s) && s->read_hash) {
          unsigned char *mac;
          mac_size = EVP_MD_CTX_size(s->read_hash);
          OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
         for (j = 0; j < num_recs; j++) {
             if (rr[j].length < mac_size) {
                 al = SSL_AD_DECODE_ERROR;
                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
                 goto f_err;
             }
             rr[j].length -= mac_size;
             mac = rr[j].data + rr[j].length;
             i = s->method->ssl3_enc->mac(s, &rr[j], md, 0   );
             if (i < 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {
                 al = SSL_AD_BAD_RECORD_MAC;
                 SSLerr(SSL_F_SSL3_GET_RECORD,
                        SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
                 goto f_err;
             }
         }
     }
 
     enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0);
      
     if (enc_err == 0) {
         al = SSL_AD_DECRYPTION_FAILED;
         SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
         goto f_err;
     }
 #ifdef SSL_DEBUG
     printf(""dec %d\n"", rr->length);
     {
         unsigned int z;
         for (z = 0; z < rr->length; z++)
             printf(""%02X%c"", rr->data[z], ((z + 1) % 16) ? ' ' : '\n');
     }
     printf(""\n"");
 #endif
 
       
      if ((sess != NULL) &&
          (s->enc_read_ctx != NULL) &&
        (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {
         (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {
           
          unsigned char *mac = NULL;
          unsigned char mac_tmp[EVP_MAX_MD_SIZE];
 
         mac_size = EVP_MD_CTX_size(s->read_hash);
         OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
 
         for (j = 0; j < num_recs; j++) {
              
             if (rr[j].orig_len < mac_size ||
                  
                 (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
                  rr[j].orig_len < mac_size + 1)) {
                 al = SSL_AD_DECODE_ERROR;
                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
                 goto f_err;
             }
 
             if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
                  
                 mac = mac_tmp;
                 ssl3_cbc_copy_mac(mac_tmp, &rr[j], mac_size);
                 rr[j].length -= mac_size;
             } else {
                  
                 rr[j].length -= mac_size;
                 mac = &rr[j].data[rr[j].length];
             }
 
             i = s->method->ssl3_enc->mac(s, &rr[j], md, 0   );
             if (i < 0 || mac == NULL
                 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
                 enc_err = -1;
             if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)
                 enc_err = -1;
         }
     }
 
     if (enc_err < 0) {
          
         al = SSL_AD_BAD_RECORD_MAC;
         SSLerr(SSL_F_SSL3_GET_RECORD,
                SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
         goto f_err;
     }
 
     for (j = 0; j < num_recs; j++) {
          
         if (s->expand != NULL) {
             if (rr[j].length > SSL3_RT_MAX_COMPRESSED_LENGTH) {
                 al = SSL_AD_RECORD_OVERFLOW;
                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);
                 goto f_err;
             }
             if (!ssl3_do_uncompress(s, &rr[j])) {
                 al = SSL_AD_DECOMPRESSION_FAILURE;
                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);
                 goto f_err;
             }
         }
 
         if (rr[j].length > SSL3_RT_MAX_PLAIN_LENGTH) {
             al = SSL_AD_RECORD_OVERFLOW;
             SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
             goto f_err;
         }
 
         rr[j].off = 0;
          
 
          
         if (rr[j].length == 0) {
             RECORD_LAYER_inc_empty_record_count(&s->rlayer);
             if (RECORD_LAYER_get_empty_record_count(&s->rlayer)
                 > MAX_EMPTY_RECORDS) {
                 al = SSL_AD_UNEXPECTED_MESSAGE;
                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);
                 goto f_err;
             }
         } else {
             RECORD_LAYER_reset_empty_record_count(&s->rlayer);
         }
     }
 
     RECORD_LAYER_set_numrpipes(&s->rlayer, num_recs);
     return 1;
 
  f_err:
     ssl3_send_alert(s, SSL3_AL_FATAL, al);
  err:
     return ret;
 }","[187, 230, 186, 229]",During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected.
201858,"  static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	if (jas_iccgetuint(in, 4, &tmp))
  		return -1;
  	*val = tmp;
 	return 0;
 }","[4, 3]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
204885,"  void DelegatedFrameHost::CopyFromCompositingSurface(
      const gfx::Rect& src_subrect,
    const gfx::Size& dst_size,
     const gfx::Size& output_size,
      const base::Callback<void(bool, const SkBitmap&)>& callback,
      const SkColorType color_type) {
   bool format_support = ((color_type == kRGB_565_SkColorType) ||
                          (color_type == kN32_SkColorType));
   DCHECK(format_support);
   if (!CanCopyToBitmap()) {
     callback.Run(false, SkBitmap());
      return;
    }
  
  const gfx::Size& dst_size_in_pixel =
      client_->ConvertViewSizeToPixel(dst_size);
    scoped_ptr<cc::CopyOutputRequest> request =
        cc::CopyOutputRequest::CreateRequest(base::Bind(
            &DelegatedFrameHost::CopyFromCompositingSurfaceHasResult,
          dst_size_in_pixel,
           output_size,
            color_type,
            callback));
  gfx::Rect src_subrect_in_pixel =
      ConvertRectToPixel(client_->CurrentDeviceScaleFactor(), src_subrect);
  request->set_area(src_subrect_in_pixel);
   request->set_area(src_subrect);
    client_->RequestCopyOfOutput(request.Pass());
  }","[4, 21, 27, 3, 15, 16, 20, 24, 25, 26]","Double free vulnerability in the ResourceFetcher::didLoadResource function in core/fetch/ResourceFetcher.cpp in the resource loader in Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering certain callback processing during the reporting of a resource entry."
207553," status_t OMXNodeInstance::updateGraphicBufferInMeta(
 
          OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
          OMX::buffer_id buffer) {
      Mutex::Autolock autoLock(mLock);
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);
      return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header);
  }","[7, 6]","omx/OMXNodeInstance.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 does not validate the buffer port, which allows attackers to gain privileges via a crafted application, aka internal bug 28816827."
199926," psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
  {	sf_count_t total = 0 ;
  	ssize_t	count ;
  
 	if (bytes == 0 || items == 0)
 		return 0 ;
 
  	if (psf->virtual_io)
  		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;
  
 	items *= bytes ;
 
 	 
 	if (items <= 0)
 		return 0 ;
 
 	while (items > 0)
 	{	 
 		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;
 
 		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;
 
 		if (count == -1)
 		{	if (errno == EINTR)
 				continue ;
 
 			psf_log_syserr (psf, errno) ;
 			break ;
 			} ;
 
 		if (count == 0)
 			break ;
 
 		total += count ;
 		items -= count ;
 		} ;
 
 	if (psf->is_pipe)
 		psf->pipeoffset += total ;
 
 	return total / bytes ;
 }  ","[5, 6, 7]",The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.
203931,"  void DisconnectWindowLinux::Show(remoting::ChromotingHost* host,
                                   const std::string& username) {
  NOTIMPLEMENTED();
   host_ = host;
   CreateWindow();
   gtk_label_set_text(GTK_LABEL(user_label_), username.c_str());
   gtk_window_present(GTK_WINDOW(disconnect_window_));
  }","[4, 5, 6, 7, 3]",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to display box rendering.
198422," int BN_hex2bn(BIGNUM **bn, const char *a)
 {
     BIGNUM *ret = NULL;
     BN_ULONG l = 0;
     int neg = 0, h, m, i, j, k, c;
     int num;
 
     if ((a == NULL) || (*a == '\0'))
         return (0);
 
     if (*a == '-') {
         neg = 1;
         a++;
          a++;
      }
  
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
     for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)
         continue;
 
     if (i > INT_MAX/4)
         goto err;
  
      num = i + neg;
      if (bn == NULL)
             return (0);
     } else {
         ret = *bn;
         BN_zero(ret);
     }","[18, 19, 20, 21, 22, 17]","Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c."
207484,"  int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)
 {
  if(h < 0 || h >= MAX_THREAD)
  {
         APPL_TRACE_ERROR(""invalid bt thread handle:%d"", h);
  return FALSE;
  }
  if(ts[h].cmd_fdw == -1)
  {
         APPL_TRACE_ERROR(""cmd socket is not created. socket thread may not initialized"");
  return FALSE;
  }
  sock_cmd_t cmd = {CMD_USER_PRIVATE, 0, type, size, user_id};
     APPL_TRACE_DEBUG(""post cmd type:%d, size:%d, h:%d, "", type, size, h);
  sock_cmd_t* cmd_send = &cmd;
  int size_send = sizeof(cmd);
  if(data && size)
  {
         size_send = sizeof(cmd) + size;
         cmd_send = (sock_cmd_t*)alloca(size_send);
  if(cmd_send)
  {
  *cmd_send = cmd;
             memcpy(cmd_send + 1, data, size);
  }
  else
  {
             APPL_TRACE_ERROR(""alloca failed at h:%d, cmd type:%d, size:%d"", h, type, size_send);
 
              return FALSE;
          }
      }
    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;
     return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, cmd_send, size_send, 0)) == size_send;
  }","[34, 33]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
5934,"int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,
struct nlattr **attrs)
{
struct net *net = sock_net(in_skb->sk);
struct crypto_user_alg *p = nlmsg_data(in_nlh);
struct crypto_alg *alg;
struct sk_buff *skb;
struct crypto_dump_info info;
int err;

if (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))
return -EINVAL;

alg = crypto_alg_match(p, 0);
if (!alg)
return -ENOENT;

err = -ENOMEM;
skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);
if (!skb)
goto drop_alg;

info.in_skb = in_skb;
info.out_skb = skb;
info.nlmsg_seq = in_nlh->nlmsg_seq;
info.nlmsg_flags = 0;

err = crypto_reportstat_alg(alg, &info);

drop_alg:
crypto_mod_put(alg);

if (err)
return err;

return nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);
}","[33, 36]","A memory leak in the crypto_reportstat() function in crypto/crypto_user_stat.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering crypto_reportstat_alg() failures, aka CID-c03b04dcdba1."
204405,"   bool Get(const std::string& addr, int* out_value) {
    
    
   bool Get(int32 preview_id, int* out_value) {
      base::AutoLock lock(lock_);
    PrintPreviewRequestIdMap::const_iterator it = map_.find(addr);
     PrintPreviewRequestIdMap::const_iterator it = map_.find(preview_id);
      if (it == map_.end())
        return false;
      *out_value = it->second;
      return true;
    }","[2, 3, 4, 7, 6]",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
200857,"  void uwbd_start(struct uwb_rc *rc)
  {
	rc->uwbd.task = kthread_run(uwbd, rc, ""uwbd"");
	if (rc->uwbd.task == NULL)
 	struct task_struct *task = kthread_run(uwbd, rc, ""uwbd"");
 	if (IS_ERR(task)) {
 		rc->uwbd.task = NULL;
  		printk(KERN_ERR ""UWB: Cannot start management daemon; ""
  		       ""UWB won't work\n"");
	else
 	} else {
 		rc->uwbd.task = task;
  		rc->uwbd.pid = rc->uwbd.task->pid;
 	}
  }","[5, 6, 7, 11, 12, 14, 3, 4, 10]",drivers/uwb/uwbd.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (general protection fault and system crash) or possibly have unspecified other impact via a crafted USB device.
3339,"QPDFObjectHandle::parseContentStream_internal(PointerHolder<Buffer> stream_data,
std::string const& description,
ParserCallbacks* callbacks)
{
size_t length = stream_data->getSize();
PointerHolder<InputSource> input =
new BufferInputSource(description, stream_data.getPointer());
QPDFTokenizer tokenizer;
tokenizer.allowEOF();
bool empty = false;
while (static_cast<size_t>(input->tell()) < length)
{
QPDFObjectHandle obj =
parseInternal(input, ""content"", tokenizer, empty,
0, 0, false, false, true);
if (! obj.isInitialized())
{

break;
}

callbacks->handleObject(obj);
if (obj.isOperator() && (obj.getOperatorValue() == ""ID""))
{


char ch;
input->read(&ch, 1);
char buf[4];
memset(buf, '\0', sizeof(buf));
bool done = false;
std::string inline_image;
while (! done)
{
if (input->read(&ch, 1) == 0)
{
QTC::TC(""qpdf"", ""QPDFObjectHandle EOF in inline image"");
throw QPDFExc(qpdf_e_damaged_pdf, input->getName(),
""stream data"", input->tell(),
""EOF found while reading inline image"");
}
inline_image += ch;
memmove(buf, buf + 1, sizeof(buf) - 1);
buf[sizeof(buf) - 1] = ch;
if (strchr("" \t\n\v\f\r"", buf[0]) &&
(buf[1] == 'E') &&
(buf[2] == 'I') &&
strchr("" \t\n\v\f\r"", buf[3]))
{

done = true;
input->seek(-3, SEEK_CUR);
for (int i = 0; i < 4; ++i)
{
if (inline_image.length() > 0)
{
inline_image.erase(inline_image.length() - 1);
}
}
}
}
QTC::TC(""qpdf"", ""QPDFObjectHandle inline image token"");
callbacks->handleObject(
QPDFObjectHandle::newInlineImage(inline_image));
}
}
}","[14, 15]","The tokenizer in QPDF 6.0.0 and 7.0.b1 is recursive for arrays and dictionaries, which allows remote attackers to cause a denial of service (stack consumption and segmentation fault) or possibly have unspecified other impact via a PDF document with a deep data structure, as demonstrated by a crash in QPDFObjectHandle::parseInternal in libqpdf/QPDFObjectHandle.cc."
207348," xsltElement(xsltTransformContextPtr ctxt, xmlNodePtr node,
 	    xmlNodePtr inst, xsltStylePreCompPtr castedComp) {
 #ifdef XSLT_REFACTORED
     xsltStyleItemElementPtr comp = (xsltStyleItemElementPtr) castedComp;
 #else
     xsltStylePreCompPtr comp = castedComp;
 #endif
     xmlChar *prop = NULL;
     const xmlChar *name, *prefix = NULL, *nsName = NULL;
     xmlNodePtr copy;
     xmlNodePtr oldInsert;
 
     if (ctxt->insert == NULL)
 	return;
 
      
     if (!comp->has_name)
         return;
 
      
     oldInsert = ctxt->insert;
 
     if (comp->name == NULL) {
 	 
         prop = xsltEvalAttrValueTemplate(ctxt, inst,
 	    (const xmlChar *) ""name"", XSLT_NAMESPACE);
         if (prop == NULL) {
             xsltTransformError(ctxt, NULL, inst,
 		""xsl:element: The attribute 'name' is missing.\n"");
             goto error;
         }
 	if (xmlValidateQName(prop, 0)) {
 	    xsltTransformError(ctxt, NULL, inst,
 		""xsl:element: The effective name '%s' is not a ""
 		""valid QName.\n"", prop);
 	     
 	}
 	name = xsltSplitQName(ctxt->dict, prop, &prefix);
 	xmlFree(prop);
     } else {
 	 
 #ifdef XSLT_REFACTORED
 	prefix = comp->nsPrefix;
 	name = comp->name;
 #else
 	name = xsltSplitQName(ctxt->dict, comp->name, &prefix);
 #endif
     }
 
      
     if (ctxt->output->dict == ctxt->dict) {
 	copy = xmlNewDocNodeEatName(ctxt->output, NULL, (xmlChar *)name, NULL);
     } else {
 	copy = xmlNewDocNode(ctxt->output, NULL, (xmlChar *)name, NULL);
     }
     if (copy == NULL) {
 	xsltTransformError(ctxt, NULL, inst,
 	    ""xsl:element : creation of %s failed\n"", name);
  	return;
      }
      copy = xsltAddChild(ctxt->insert, copy);
     if (copy == NULL) {
         xsltTransformError(ctxt, NULL, inst,
             ""xsl:element : xsltAddChild failed\n"");
         return;
     }
  
       
     if (comp->has_ns) {
 	if (comp->ns != NULL) {
 	     
 	    if (comp->ns[0] != 0)
 		nsName = comp->ns;
 	} else {
 	    xmlChar *tmpNsName;
 	     
 	     
 	    tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,
 		(const xmlChar *) ""namespace"", XSLT_NAMESPACE);
 	     
 	    if ((tmpNsName != NULL) && (tmpNsName[0] != 0))
 		nsName = xmlDictLookup(ctxt->dict, BAD_CAST tmpNsName, -1);
 	    xmlFree(tmpNsName);
 	}
 
         if (xmlStrEqual(nsName, BAD_CAST ""http:www.w3.org/2000/xmlns/"")) {
             xsltTransformError(ctxt, NULL, inst,
                 ""xsl:attribute: Namespace http:www.w3.org/2000/xmlns/ ""
                 ""forbidden.\n"");
             goto error;
         }
         if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {
             prefix = BAD_CAST ""xml"";
         } else if (xmlStrEqual(prefix, BAD_CAST ""xml"")) {
             prefix = NULL;
         }
     } else {
 	xmlNsPtr ns;
 	 
 	ns = xmlSearchNs(inst->doc, inst, prefix);
 	if (ns == NULL) {
 	     
             if (prefix != NULL) {
                 xsltTransformError(ctxt, NULL, inst,
                     ""xsl:element: The QName '%s:%s' has no ""
                     ""namespace binding in scope in the stylesheet; ""
                     ""this is an error, since the namespace was not ""
                     ""specified by the instruction itself.\n"", prefix, name);
             }
 	} else
 	    nsName = ns->href;
     }
      
     if (nsName != NULL) {
 	if (xmlStrEqual(prefix, BAD_CAST ""xmlns"")) {
              
 	    xmlChar *pref = xmlStrdup(BAD_CAST ""ns_1"");
 
 	    copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, copy);
 
 	    xmlFree(pref);
 	} else {
 	    copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,
 		copy);
 	}
     } else if ((copy->parent != NULL) &&
 	(copy->parent->type == XML_ELEMENT_NODE) &&
 	(copy->parent->ns != NULL))
     {
 	 
 	xsltGetSpecialNamespace(ctxt, inst, NULL, NULL, copy);
     }
 
     ctxt->insert = copy;
 
     if (comp->has_use) {
 	if (comp->use != NULL) {
 	    xsltApplyAttributeSet(ctxt, node, inst, comp->use);
 	} else {
 	    xmlChar *attrSets = NULL;
 	     
 	    attrSets = xsltEvalAttrValueTemplate(ctxt, inst,
 		(const xmlChar *)""use-attribute-sets"", NULL);
 	    if (attrSets != NULL) {
 		xsltApplyAttributeSet(ctxt, node, inst, attrSets);
 		xmlFree(attrSets);
 	    }
 	}
     }
      
     if (inst->children != NULL)
 	xsltApplySequenceConstructor(ctxt, ctxt->node, inst->children,
 	    NULL);
 
 error:
     ctxt->insert = oldInsert;
     return;
 }","[62, 63, 64, 65, 66]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
8779,"static void cstm(JF, js_Ast *stm)
{
js_Ast *target;
int loop, cont, then, end;

emitline(J, F, stm);

switch (stm->type) {
case AST_FUNDEC:
break;

case STM_BLOCK:
cstmlist(J, F, stm->a);
break;

case STM_EMPTY:
if (F->script) {
emitline(J, F, stm);
emit(J, F, OP_POP);
emit(J, F, OP_UNDEF);
}
break;

case STM_VAR:
cvarinit(J, F, stm->a);
break;

case STM_IF:
if (stm->c) {
cexp(J, F, stm->a);
emitline(J, F, stm);
then = emitjump(J, F, OP_JTRUE);
cstm(J, F, stm->c);
emitline(J, F, stm);
end = emitjump(J, F, OP_JUMP);
label(J, F, then);
cstm(J, F, stm->b);
label(J, F, end);
} else {
cexp(J, F, stm->a);
emitline(J, F, stm);
end = emitjump(J, F, OP_JFALSE);
cstm(J, F, stm->b);
label(J, F, end);
}
break;

case STM_DO:
loop = here(J, F);
cstm(J, F, stm->a);
cont = here(J, F);
cexp(J, F, stm->b);
emitline(J, F, stm);
emitjumpto(J, F, OP_JTRUE, loop);
labeljumps(J, F, stm->jumps, here(J,F), cont);
break;

case STM_WHILE:
loop = here(J, F);
cexp(J, F, stm->a);
emitline(J, F, stm);
end = emitjump(J, F, OP_JFALSE);
cstm(J, F, stm->b);
emitline(J, F, stm);
emitjumpto(J, F, OP_JUMP, loop);
label(J, F, end);
labeljumps(J, F, stm->jumps, here(J,F), loop);
break;

case STM_FOR:
case STM_FOR_VAR:
if (stm->type == STM_FOR_VAR) {
cvarinit(J, F, stm->a);
} else {
if (stm->a) {
cexp(J, F, stm->a);
emit(J, F, OP_POP);
}
}
loop = here(J, F);
if (stm->b) {
cexp(J, F, stm->b);
emitline(J, F, stm);
end = emitjump(J, F, OP_JFALSE);
} else {
end = 0;
}
cstm(J, F, stm->d);
cont = here(J, F);
if (stm->c) {
cexp(J, F, stm->c);
emit(J, F, OP_POP);
}
emitline(J, F, stm);
emitjumpto(J, F, OP_JUMP, loop);
if (end)
label(J, F, end);
labeljumps(J, F, stm->jumps, here(J,F), cont);
break;

case STM_FOR_IN:
case STM_FOR_IN_VAR:
cexp(J, F, stm->b);
emitline(J, F, stm);
emit(J, F, OP_ITERATOR);
loop = here(J, F);
{
emitline(J, F, stm);
emit(J, F, OP_NEXTITER);
end = emitjump(J, F, OP_JFALSE);
cassignforin(J, F, stm);
if (F->script) {
emit(J, F, OP_ROT2);
cstm(J, F, stm->c);
emit(J, F, OP_ROT2);
} else {
cstm(J, F, stm->c);
}
emitline(J, F, stm);
emitjumpto(J, F, OP_JUMP, loop);
}
label(J, F, end);
labeljumps(J, F, stm->jumps, here(J,F), loop);
break;

case STM_SWITCH:
cswitch(J, F, stm->a, stm->b);
labeljumps(J, F, stm->jumps, here(J,F), 0);
break;

case STM_LABEL:
cstm(J, F, stm->b);

while (stm->type == STM_LABEL)
stm = stm->b;

if (!isloop(stm->type) && stm->type != STM_SWITCH)
labeljumps(J, F, stm->jumps, here(J,F), 0);
break;

case STM_BREAK:
if (stm->a) {
checkfutureword(J, F, stm->a);
target = breaktarget(J, F, stm->parent, stm->a->string);
if (!target)
jsC_error(J, stm, ""break label '%s' not found"", stm->a->string);
} else {
target = breaktarget(J, F, stm->parent, NULL);
if (!target)
jsC_error(J, stm, ""unlabelled break must be inside loop or switch"");
}
cexit(J, F, STM_BREAK, stm, target);
emitline(J, F, stm);
addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));
break;

case STM_CONTINUE:
if (stm->a) {
checkfutureword(J, F, stm->a);
target = continuetarget(J, F, stm->parent, stm->a->string);
if (!target)
jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string);
} else {
target = continuetarget(J, F, stm->parent, NULL);
if (!target)
jsC_error(J, stm, ""continue must be inside loop"");
}
cexit(J, F, STM_CONTINUE, stm, target);
emitline(J, F, stm);
addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));
break;

case STM_RETURN:
if (stm->a)
cexp(J, F, stm->a);
else
emit(J, F, OP_UNDEF);
target = returntarget(J, F, stm->parent);
if (!target)
jsC_error(J, stm, ""return not in function"");
cexit(J, F, STM_RETURN, stm, target);
emitline(J, F, stm);
emit(J, F, OP_RETURN);
break;

case STM_THROW:
cexp(J, F, stm->a);
emitline(J, F, stm);
emit(J, F, OP_THROW);
break;

case STM_WITH:
F->lightweight = 0;
if (F->strict)
jsC_error(J, stm->a, ""'with' statements are not allowed in strict mode"");
cexp(J, F, stm->a);
emitline(J, F, stm);
emit(J, F, OP_WITH);
cstm(J, F, stm->b);
emitline(J, F, stm);
emit(J, F, OP_ENDWITH);
break;

case STM_TRY:
emitline(J, F, stm);
if (stm->b && stm->c) {
F->lightweight = 0;
if (stm->d)
ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);
else
ctrycatch(J, F, stm->a, stm->b, stm->c);
} else {
ctryfinally(J, F, stm->a, stm->d);
}
break;

case STM_DEBUGGER:
emitline(J, F, stm);
emit(J, F, OP_DEBUGGER);
break;

default:
if (F->script) {
emitline(J, F, stm);
emit(J, F, OP_POP);
cexp(J, F, stm);
} else {
cexp(J, F, stm);
emitline(J, F, stm);
emit(J, F, OP_POP);
}
break;
}
}","[55, 67, 98, 123, 128, 138]",Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which is caused by conflicting JumpList of nested try/finally statements.
7574,"static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
{
#ifndef PB_ENABLE_MALLOC
PB_UNUSED(wire_type);
PB_UNUSED(iter);
PB_RETURN_ERROR(stream, ""no malloc support"");
#else
pb_type_t type;
pb_decoder_t func;

type = iter->pos->type;
func = PB_DECODERS[PB_LTYPE(type)];

switch (PB_HTYPE(type))
{
case PB_HTYPE_REQUIRED:
case PB_HTYPE_OPTIONAL:
case PB_HTYPE_ONEOF:
if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&
*(void**)iter->pData != NULL)
{

pb_release_single_field(iter);
}

if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
{
*(pb_size_t*)iter->pSize = iter->pos->tag;
}

if (PB_LTYPE(type) == PB_LTYPE_STRING ||
PB_LTYPE(type) == PB_LTYPE_BYTES)
{
return func(stream, iter->pos, iter->pData);
}
else
{
if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))
return false;

initialize_pointer_field(*(void**)iter->pData, iter);
return func(stream, iter->pos, *(void**)iter->pData);
}

case PB_HTYPE_REPEATED:
if (wire_type == PB_WT_STRING
&& PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)
{

bool status = true;
pb_size_t *size = (pb_size_t*)iter->pSize;
size_t allocated_size = *size;
void *pItem;
pb_istream_t substream;

if (!pb_make_string_substream(stream, &substream))
return false;

while (substream.bytes_left)
{
if ((size_t)*size + 1 > allocated_size)
{



allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;

if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))
{
status = false;
break;
}
}


pItem = *(char**)iter->pData + iter->pos->data_size * (*size);
initialize_pointer_field(pItem, iter);
if (!func(&substream, iter->pos, pItem))
{
status = false;
break;
}

if (*size == PB_SIZE_MAX)
{
#ifndef PB_NO_ERRMSG
stream->errmsg = ""too many array entries"";
#endif
status = false;
break;
}

(*size)++;
}
if (!pb_close_string_substream(stream, &substream))
return false;

return status;
}
else
{

pb_size_t *size = (pb_size_t*)iter->pSize;
void *pItem;

if (*size == PB_SIZE_MAX)
PB_RETURN_ERROR(stream, ""too many array entries"");

(*size)++;
if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))
return false;

pItem = *(char**)iter->pData + iter->pos->data_size * (*size - 1);
initialize_pointer_field(pItem, iter);
return func(stream, iter->pos, pItem);
}

default:
PB_RETURN_ERROR(stream, ""invalid field type"");
}
#endif
}","[109, 110, 113]","There is a potentially exploitable out of memory condition In Nanopb before 0.4.1, 0.3.9.5, and 0.2.9.4. When nanopb is compiled with PB_ENABLE_MALLOC, the message to be decoded contains a repeated string, bytes or message field and realloc() runs out of memory when expanding the array nanopb can end up calling `free()` on a pointer value that comes from uninitialized memory. Depending on platform this can result in a crash or further memory corruption, which may be exploitable in some cases. This problem is fixed in nanopb-0.4.1, nanopb-0.3.9.5, nanopb-0.2.9.4."
1203,"static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)
{
struct sk_buff *skb = (struct sk_buff *)(long) ctx;
struct nlattr *nla;

if (skb_is_nonlinear(skb))
return 0;

if (A > skb->len - sizeof(struct nlattr))
return 0;

nla = (struct nlattr *) &skb->data[A];
if (nla->nla_len > A - skb->len)
return 0;

nla = nla_find_nested(nla, X);
if (nla)
return (void *) nla - (void *) skb->data;

return 0;
}","[9, 13]","The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced."
6384,"SetFormatAndEncodings(rfbClient* client)
{
rfbSetPixelFormatMsg spf;
char buf[sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4];

rfbSetEncodingsMsg *se = (rfbSetEncodingsMsg *)buf;
uint32_t *encs = (uint32_t *)(&buf[sz_rfbSetEncodingsMsg]);
int len = 0;
rfbBool requestCompressLevel = FALSE;
rfbBool requestQualityLevel = FALSE;
rfbBool requestLastRectEncoding = FALSE;
rfbClientProtocolExtension* e;

if (!SupportsClient2Server(client, rfbSetPixelFormat)) return TRUE;

spf.type = rfbSetPixelFormat;
spf.pad1 = 0;
spf.pad2 = 0;
spf.format = client->format;
spf.format.redMax = rfbClientSwap16IfLE(spf.format.redMax);
spf.format.greenMax = rfbClientSwap16IfLE(spf.format.greenMax);
spf.format.blueMax = rfbClientSwap16IfLE(spf.format.blueMax);

if (!WriteToRFBServer(client, (char *)&spf, sz_rfbSetPixelFormatMsg))
return FALSE;


if (!SupportsClient2Server(client, rfbSetEncodings)) return TRUE;

se->type = rfbSetEncodings;
se->pad = 0;
se->nEncodings = 0;

if (client->appData.encodingsString) {
const char *encStr = client->appData.encodingsString;
int encStrLen;
do {
const char *nextEncStr = strchr(encStr, ' ');
if (nextEncStr) {
encStrLen = nextEncStr - encStr;
nextEncStr++;
} else {
encStrLen = strlen(encStr);
}

if (strncasecmp(encStr,""raw"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);
} else if (strncasecmp(encStr,""copyrect"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);
#ifdef LIBVNCSERVER_HAVE_LIBZ
#ifdef LIBVNCSERVER_HAVE_LIBJPEG
} else if (strncasecmp(encStr,""tight"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);
requestLastRectEncoding = TRUE;
if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)
requestCompressLevel = TRUE;
if (client->appData.enableJPEG)
requestQualityLevel = TRUE;
#endif
#endif
} else if (strncasecmp(encStr,""hextile"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);
#ifdef LIBVNCSERVER_HAVE_LIBZ
} else if (strncasecmp(encStr,""zlib"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);
if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)
requestCompressLevel = TRUE;
} else if (strncasecmp(encStr,""zlibhex"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlibHex);
if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)
requestCompressLevel = TRUE;
} else if (strncasecmp(encStr,""trle"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTRLE);
} else if (strncasecmp(encStr,""zrle"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);
} else if (strncasecmp(encStr,""zywrle"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);
requestQualityLevel = TRUE;
#endif
} else if ((strncasecmp(encStr,""ultra"",encStrLen) == 0) || (strncasecmp(encStr,""ultrazip"",encStrLen) == 0)) {

encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);
} else if (strncasecmp(encStr,""corre"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);
} else if (strncasecmp(encStr,""rre"",encStrLen) == 0) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);
} else {
rfbClientLog(""Unknown encoding '%.*s'\n"",encStrLen,encStr);
}

encStr = nextEncStr;
} while (encStr && se->nEncodings < MAX_ENCODINGS);

if (se->nEncodings < MAX_ENCODINGS && requestCompressLevel) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +
rfbEncodingCompressLevel0);
}

if (se->nEncodings < MAX_ENCODINGS && requestQualityLevel) {
if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)
client->appData.qualityLevel = 5;
encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +
rfbEncodingQualityLevel0);
}
}
else {
if (SameMachine(client->sock)) {



rfbClientLog(""Same machine: preferring raw encoding\n"");
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);





}

encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);
#ifdef LIBVNCSERVER_HAVE_LIBZ
#ifdef LIBVNCSERVER_HAVE_LIBJPEG
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);
requestLastRectEncoding = TRUE;
#endif
#endif
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);
#ifdef LIBVNCSERVER_HAVE_LIBZ
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);
#endif
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);

if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9) {
encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +
rfbEncodingCompressLevel0);
} else                             {




encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCompressLevel1);
}

if (client->appData.enableJPEG) {
if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)
client->appData.qualityLevel = 5;
encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +
rfbEncodingQualityLevel0);
}
}




if (client->appData.useRemoteCursor) {
if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXCursor);
if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRichCursor);
if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingPointerPos);
}


if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingKeyboardLedState);


if (se->nEncodings < MAX_ENCODINGS && client->canHandleNewFBSize)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingNewFBSize);


if (se->nEncodings < MAX_ENCODINGS && requestLastRectEncoding)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingLastRect);


if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedMessages);
if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedEncodings);
if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingServerIdentity);


if (se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXvp);


for(e = rfbClientExtensions; e; e = e->next)
if(e->encodings) {
int* enc;
for(enc = e->encodings; *enc; enc++)
if(se->nEncodings < MAX_ENCODINGS)
encs[se->nEncodings++] = rfbClientSwap32IfLE(*enc);
}

len = sz_rfbSetEncodingsMsg + se->nEncodings * 4;

se->nEncodings = rfbClientSwap16IfLE(se->nEncodings);

if (!WriteToRFBServer(client, buf, len)) return FALSE;

return TRUE;
}","[4, 6, 7, 207]","** DISPUTED ** An issue was discovered in LibVNCServer before 0.9.13. Byte-aligned data is accessed through uint32_t pointers in libvncclient/rfbproto.c. NOTE: there is reportedly ""no trust boundary crossed."""
198403," xps_parse_path(xps_document *doc, const fz_matrix *ctm, char *base_uri, xps_resource *dict, fz_xml *root)
 {
 	fz_xml *node;
 
 	char *fill_uri;
 	char *stroke_uri;
 	char *opacity_mask_uri;
 
 	char *transform_att;
 	char *clip_att;
 	char *data_att;
 	char *fill_att;
 	char *stroke_att;
 	char *opacity_att;
 	char *opacity_mask_att;
 
 	fz_xml *transform_tag = NULL;
 	fz_xml *clip_tag = NULL;
 	fz_xml *data_tag = NULL;
 	fz_xml *fill_tag = NULL;
 	fz_xml *stroke_tag = NULL;
 	fz_xml *opacity_mask_tag = NULL;
 
 	char *fill_opacity_att = NULL;
 	char *stroke_opacity_att = NULL;
 
 	char *stroke_dash_array_att;
 	char *stroke_dash_cap_att;
 	char *stroke_dash_offset_att;
 	char *stroke_end_line_cap_att;
 	char *stroke_start_line_cap_att;
 	char *stroke_line_join_att;
 	char *stroke_miter_limit_att;
 	char *stroke_thickness_att;
 	char *navigate_uri_att;
  
         fz_stroke_state *stroke = NULL;
         fz_matrix transform;
       float samples[32];
        float samples[FZ_MAX_COLORS];
         fz_colorspace *colorspace;
         fz_path *path = NULL;
         fz_path *stroke_path = NULL;
 	fz_rect area;
 	int fill_rule;
 	int dash_len = 0;
 	fz_matrix local_ctm;
 
 	 
 
 	transform_att = fz_xml_att(root, ""RenderTransform"");
 	clip_att = fz_xml_att(root, ""Clip"");
 	data_att = fz_xml_att(root, ""Data"");
 	fill_att = fz_xml_att(root, ""Fill"");
 	stroke_att = fz_xml_att(root, ""Stroke"");
 	opacity_att = fz_xml_att(root, ""Opacity"");
 	opacity_mask_att = fz_xml_att(root, ""OpacityMask"");
 
 	stroke_dash_array_att = fz_xml_att(root, ""StrokeDashArray"");
 	stroke_dash_cap_att = fz_xml_att(root, ""StrokeDashCap"");
 	stroke_dash_offset_att = fz_xml_att(root, ""StrokeDashOffset"");
 	stroke_end_line_cap_att = fz_xml_att(root, ""StrokeEndLineCap"");
 	stroke_start_line_cap_att = fz_xml_att(root, ""StrokeStartLineCap"");
 	stroke_line_join_att = fz_xml_att(root, ""StrokeLineJoin"");
 	stroke_miter_limit_att = fz_xml_att(root, ""StrokeMiterLimit"");
 	stroke_thickness_att = fz_xml_att(root, ""StrokeThickness"");
 	navigate_uri_att = fz_xml_att(root, ""FixedPage.NavigateUri"");
 
 	for (node = fz_xml_down(root); node; node = fz_xml_next(node))
 	{
 		if (!strcmp(fz_xml_tag(node), ""Path.RenderTransform""))
 			transform_tag = fz_xml_down(node);
 		if (!strcmp(fz_xml_tag(node), ""Path.OpacityMask""))
 			opacity_mask_tag = fz_xml_down(node);
 		if (!strcmp(fz_xml_tag(node), ""Path.Clip""))
 			clip_tag = fz_xml_down(node);
 		if (!strcmp(fz_xml_tag(node), ""Path.Fill""))
 			fill_tag = fz_xml_down(node);
 		if (!strcmp(fz_xml_tag(node), ""Path.Stroke""))
 			stroke_tag = fz_xml_down(node);
 		if (!strcmp(fz_xml_tag(node), ""Path.Data""))
 			data_tag = fz_xml_down(node);
 	}
 
 	fill_uri = base_uri;
 	stroke_uri = base_uri;
 	opacity_mask_uri = base_uri;
 
 	xps_resolve_resource_reference(doc, dict, &data_att, &data_tag, NULL);
 	xps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);
 	xps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);
 	xps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);
 	xps_resolve_resource_reference(doc, dict, &stroke_att, &stroke_tag, &stroke_uri);
 	xps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);
 
 	 
 
 	if (!data_att && !data_tag)
 		return;
 
 	if (fill_tag && !strcmp(fz_xml_tag(fill_tag), ""SolidColorBrush""))
 	{
 		fill_opacity_att = fz_xml_att(fill_tag, ""Opacity"");
 		fill_att = fz_xml_att(fill_tag, ""Color"");
 		fill_tag = NULL;
 	}
 
 	if (stroke_tag && !strcmp(fz_xml_tag(stroke_tag), ""SolidColorBrush""))
 	{
 		stroke_opacity_att = fz_xml_att(stroke_tag, ""Opacity"");
 		stroke_att = fz_xml_att(stroke_tag, ""Color"");
 		stroke_tag = NULL;
 	}
 
 	if (stroke_att || stroke_tag)
 	{
 		if (stroke_dash_array_att)
 		{
 			char *s = stroke_dash_array_att;
 
 			while (*s)
 			{
 				while (*s == ' ')
 					s++;
 				if (*s)  
 					dash_len++;
 
 				while (*s && *s != ' ')
 					s++;
 			}
 		}
 		stroke = fz_new_stroke_state_with_dash_len(doc->ctx, dash_len);
 		stroke->start_cap = xps_parse_line_cap(stroke_start_line_cap_att);
 		stroke->dash_cap = xps_parse_line_cap(stroke_dash_cap_att);
 		stroke->end_cap = xps_parse_line_cap(stroke_end_line_cap_att);
 
 		stroke->linejoin = FZ_LINEJOIN_MITER_XPS;
 		if (stroke_line_join_att)
 		{
 			if (!strcmp(stroke_line_join_att, ""Miter"")) stroke->linejoin = FZ_LINEJOIN_MITER_XPS;
 			if (!strcmp(stroke_line_join_att, ""Round"")) stroke->linejoin = FZ_LINEJOIN_ROUND;
 			if (!strcmp(stroke_line_join_att, ""Bevel"")) stroke->linejoin = FZ_LINEJOIN_BEVEL;
 		}
 
 		stroke->miterlimit = 10;
 		if (stroke_miter_limit_att)
 			stroke->miterlimit = fz_atof(stroke_miter_limit_att);
 
 		stroke->linewidth = 1;
 		if (stroke_thickness_att)
 			stroke->linewidth = fz_atof(stroke_thickness_att);
 
 		stroke->dash_phase = 0;
 		stroke->dash_len = 0;
 		if (stroke_dash_array_att)
 		{
 			char *s = stroke_dash_array_att;
 
 			if (stroke_dash_offset_att)
 				stroke->dash_phase = fz_atof(stroke_dash_offset_att) * stroke->linewidth;
 
 			while (*s)
 			{
 				while (*s == ' ')
 					s++;
 				if (*s)  
 					stroke->dash_list[stroke->dash_len++] = fz_atof(s) * stroke->linewidth;
 				while (*s && *s != ' ')
 					s++;
 			}
 			stroke->dash_len = dash_len;
 		}
 	}
 
 	transform = fz_identity;
 	if (transform_att)
 		xps_parse_render_transform(doc, transform_att, &transform);
 	if (transform_tag)
 		xps_parse_matrix_transform(doc, transform_tag, &transform);
 	fz_concat(&local_ctm, &transform, ctm);
 
 	if (clip_att || clip_tag)
 		xps_clip(doc, &local_ctm, dict, clip_att, clip_tag);
 
 	fill_rule = 0;
 	if (data_att)
 		path = xps_parse_abbreviated_geometry(doc, data_att, &fill_rule);
 	else if (data_tag)
 	{
 		path = xps_parse_path_geometry(doc, dict, data_tag, 0, &fill_rule);
 		if (stroke_att || stroke_tag)
 			stroke_path = xps_parse_path_geometry(doc, dict, data_tag, 1, &fill_rule);
 	}
 	if (!stroke_path)
 		stroke_path = path;
 
 	if (stroke_att || stroke_tag)
 	{
 		fz_bound_path(doc->ctx, stroke_path, stroke, &local_ctm, &area);
 		if (stroke_path != path && (fill_att || fill_tag)) {
 			fz_rect bounds;
 			fz_bound_path(doc->ctx, path, NULL, &local_ctm, &bounds);
 			fz_union_rect(&area, &bounds);
 		}
 	}
 	else
 		fz_bound_path(doc->ctx, path, NULL, &local_ctm, &area);
 
 	if (navigate_uri_att)
 		xps_add_link(doc, &area, base_uri, navigate_uri_att);
 
 	xps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);
 
 	if (fill_att)
 	{
 		xps_parse_color(doc, base_uri, fill_att, &colorspace, samples);
 		if (fill_opacity_att)
 			samples[0] *= fz_atof(fill_opacity_att);
 		xps_set_color(doc, colorspace, samples);
 
 		fz_fill_path(doc->dev, path, fill_rule == 0, &local_ctm,
 			doc->colorspace, doc->color, doc->alpha);
 	}
 
 	if (fill_tag)
 	{
 		fz_clip_path(doc->dev, path, &area, fill_rule == 0, &local_ctm);
 		xps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);
 		fz_pop_clip(doc->dev);
 	}
 
 	if (stroke_att)
 	{
 		xps_parse_color(doc, base_uri, stroke_att, &colorspace, samples);
 		if (stroke_opacity_att)
 			samples[0] *= fz_atof(stroke_opacity_att);
 		xps_set_color(doc, colorspace, samples);
 
 		fz_stroke_path(doc->dev, stroke_path, stroke, &local_ctm,
 			doc->colorspace, doc->color, doc->alpha);
 	}
 
 	if (stroke_tag)
 	{
 		fz_clip_stroke_path(doc->dev, stroke_path, &area, stroke, &local_ctm);
 		xps_parse_brush(doc, &local_ctm, &area, stroke_uri, dict, stroke_tag);
 		fz_pop_clip(doc->dev);
 	}
 
 	xps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);
 
 	if (stroke_path != path)
 		fz_free_path(doc->ctx, stroke_path);
 	fz_free_path(doc->ctx, path);
 	path = NULL;
 	fz_drop_stroke_state(doc->ctx, stroke);
 
 	if (clip_att || clip_tag)
 		fz_pop_clip(doc->dev);
 }","[40, 39]",Stack-based buffer overflow in the xps_parse_color function in xps/xps-common.c in MuPDF 1.3 and earlier allows remote attackers to execute arbitrary code via a large number of entries in the ContextColor value of the Fill attribute in a Path element.
199346," static int xen_netbk_get_extras(struct xenvif *vif,
 				struct xen_netif_extra_info *extras,
 				int work_to_do)
 {
 	struct xen_netif_extra_info extra;
 	RING_IDX cons = vif->tx.req_cons;
  
  	do {
  		if (unlikely(work_to_do-- <= 0)) {
			netdev_dbg(vif->dev, ""Missing extra info\n"");
 			netdev_err(vif->dev, ""Missing extra info\n"");
 			netbk_fatal_tx_err(vif);
  			return -EBADR;
  		}
  
 		memcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),
 		       sizeof(extra));
  		if (unlikely(!extra.type ||
  			     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {
  			vif->tx.req_cons = ++cons;
			netdev_dbg(vif->dev,
 			netdev_err(vif->dev,
  				   ""Invalid extra type: %d\n"", extra.type);
 			netbk_fatal_tx_err(vif);
  			return -EINVAL;
  		}
  
 		memcpy(&extras[extra.type - 1], &extra, sizeof(extra));
 		vif->tx.req_cons = ++cons;
 	} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);
 
 	return work_to_do;
 }","[11, 12, 22, 24, 10, 21]",The Xen netback functionality in the Linux kernel before 3.7.8 allows guest OS users to cause a denial of service (loop) by triggering ring pointer corruption.
1153,"pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,
const std::vector<int> &desired,
const char *cwd,
const std::vector<std::string> &env) {
int id = GetId();
Lock lock(g_procs[id].m_procMutex);
always_assert(Available());
always_assert(created.size() == desired.size());

if (fprintf(g_procs[id].m_fout, ""proc_open\n%s\n%s\n"", cmd, cwd) <= 0) {
Logger::Error(""Failed to send command proc_open"");
return -1;
}
fprintf(g_procs[id].m_fout, ""%d\n"", (int)env.size());
for (unsigned int i = 0; i < env.size(); i++) {
fprintf(g_procs[id].m_fout, ""%s\n"", env[i].c_str());
}

fprintf(g_procs[id].m_fout, ""%d\n"", (int)created.size());

for (unsigned int i = 0; i < desired.size(); i++) {
fprintf(g_procs[id].m_fout, ""%d\n"", desired[i]);
}
fflush(g_procs[id].m_fout);
bool error_send = false;
int save_errno = 0;
for (unsigned int i = 0; i < created.size(); i++) {
if (!send_fd(g_procs[id].m_afdt_fd, created[i])) {
error_send = true;
save_errno = errno;
break;
}
}

char buf[BUFFER_SIZE];
read_buf(g_procs[id].m_fin, buf);
if (strncmp(buf, ""error"", 5) == 0) {
read_buf(g_procs[id].m_fin, buf);
sscanf(buf, ""%d"", &errno);
if (error_send) {


errno = save_errno;
}
return -1;
}
int64_t pid = -1;
sscanf(buf, ""%"" PRId64, &pid);
assert(pid);
return (pid_t)pid;
}","[10, 11, 12, 14, 16, 19, 22, 24, 35, 36, 37, 38, 39, 47, 48, 49]",CRLF injection vulnerability in the LightProcess protocol implementation in hphp/util/light-process.cpp in Facebook HipHop Virtual Machine (HHVM) before 2.4.2 allows remote attackers to execute arbitrary commands by entering a \n (newline) character before the end of a string.
207775," omx_vdec::omx_vdec(): m_error_propogated(false),
     m_state(OMX_StateInvalid),
     m_app_data(NULL),
     m_inp_mem_ptr(NULL),
     m_out_mem_ptr(NULL),
     input_flush_progress (false),
     output_flush_progress (false),
     input_use_buffer (false),
     output_use_buffer (false),
     ouput_egl_buffers(false),
     m_use_output_pmem(OMX_FALSE),
     m_out_mem_region_smi(OMX_FALSE),
     m_out_pvt_entry_pmem(OMX_FALSE),
     pending_input_buffers(0),
     pending_output_buffers(0),
     m_out_bm_count(0),
     m_inp_bm_count(0),
     m_inp_bPopulated(OMX_FALSE),
     m_out_bPopulated(OMX_FALSE),
     m_flags(0),
 #ifdef _ANDROID_
     m_heap_ptr(NULL),
 #endif
     m_inp_bEnabled(OMX_TRUE),
     m_out_bEnabled(OMX_TRUE),
     m_in_alloc_cnt(0),
     m_platform_list(NULL),
     m_platform_entry(NULL),
     m_pmem_info(NULL),
     h264_parser(NULL),
     arbitrary_bytes (true),
     psource_frame (NULL),
     pdest_frame (NULL),
     m_inp_heap_ptr (NULL),
     m_phdr_pmem_ptr(NULL),
     m_heap_inp_bm_count (0),
     codec_type_parse ((codec_type)0),
     first_frame_meta (true),
     frame_count (0),
     nal_count (0),
     nal_length(0),
     look_ahead_nal (false),
     first_frame(0),
     first_buffer(NULL),
     first_frame_size (0),
     m_device_file_ptr(NULL),
     m_vc1_profile((vc1_profile_type)0),
     h264_last_au_ts(LLONG_MAX),
     h264_last_au_flags(0),
     m_disp_hor_size(0),
     m_disp_vert_size(0),
     prev_ts(LLONG_MAX),
     rst_prev_ts(true),
     frm_int(0),
     in_reconfig(false),
     m_display_id(NULL),
     client_extradata(0),
     m_reject_avc_1080p_mp (0),
 #ifdef _ANDROID_
     m_enable_android_native_buffers(OMX_FALSE),
     m_use_android_native_buffers(OMX_FALSE),
     iDivXDrmDecrypt(NULL),
 #endif
     m_desc_buffer_ptr(NULL),
     secure_mode(false),
     m_other_extradata(NULL),
     m_profile(0),
     client_set_fps(false),
     m_last_rendered_TS(-1),
     m_queued_codec_config_count(0),
     secure_scaling_to_non_secure_opb(false)
 {
   
     DEBUG_PRINT_HIGH(""In %u bit OMX vdec Constructor"", (unsigned int)sizeof(long) * 8);
     memset(&m_debug,0,sizeof(m_debug));
 #ifdef _ANDROID_
  char property_value[PROPERTY_VALUE_MAX] = {0};
     property_get(""vidc.debug.level"", property_value, ""1"");
     debug_level = atoi(property_value);
     property_value[0] = '\0';
 
     DEBUG_PRINT_HIGH(""In OMX vdec Constructor"");
 
     property_get(""vidc.dec.debug.perf"", property_value, ""0"");
     perf_flag = atoi(property_value);
  if (perf_flag) {
         DEBUG_PRINT_HIGH(""vidc.dec.debug.perf is %d"", perf_flag);
         dec_time.start();
         proc_frms = latency = 0;
  }
     prev_n_filled_len = 0;
     property_value[0] = '\0';
     property_get(""vidc.dec.debug.ts"", property_value, ""0"");
     m_debug_timestamp = atoi(property_value);
     DEBUG_PRINT_HIGH(""vidc.dec.debug.ts value is %d"",m_debug_timestamp);
  if (m_debug_timestamp) {
         time_stamp_dts.set_timestamp_reorder_mode(true);
         time_stamp_dts.enable_debug_print(true);
  }
 
     property_value[0] = '\0';
     property_get(""vidc.dec.debug.concealedmb"", property_value, ""0"");
     m_debug_concealedmb = atoi(property_value);
     DEBUG_PRINT_HIGH(""vidc.dec.debug.concealedmb value is %d"",m_debug_concealedmb);
 
     property_value[0] = '\0';
     property_get(""vidc.dec.profile.check"", property_value, ""0"");
     m_reject_avc_1080p_mp = atoi(property_value);
     DEBUG_PRINT_HIGH(""vidc.dec.profile.check value is %d"",m_reject_avc_1080p_mp);
 
     property_value[0] = '\0';
     property_get(""vidc.dec.log.in"", property_value, ""0"");
     m_debug.in_buffer_log = atoi(property_value);
 
     property_value[0] = '\0';
     property_get(""vidc.dec.log.out"", property_value, ""0"");
     m_debug.out_buffer_log = atoi(property_value);
     sprintf(m_debug.log_loc, ""%s"", BUFFER_LOG_LOC);
 
     property_value[0] = '\0';
     property_get(""vidc.log.loc"", property_value, """");
  if (*property_value)
         strlcpy(m_debug.log_loc, property_value, PROPERTY_VALUE_MAX);
 
     property_value[0] = '\0';
     property_get(""vidc.dec.120fps.enabled"", property_value, ""0"");
 
  if(atoi(property_value)) {
         DEBUG_PRINT_LOW(""feature 120 FPS decode enabled"");
         m_last_rendered_TS = 0;
  }
 
     property_value[0] = '\0';
     property_get(""vidc.dec.debug.dyn.disabled"", property_value, ""0"");
     m_disable_dynamic_buf_mode = atoi(property_value);
     DEBUG_PRINT_HIGH(""vidc.dec.debug.dyn.disabled value is %d"",m_disable_dynamic_buf_mode);
 
 #endif
     memset(&m_cmp,0,sizeof(m_cmp));
     memset(&m_cb,0,sizeof(m_cb));
     memset (&drv_ctx,0,sizeof(drv_ctx));
     memset (&h264_scratch,0,sizeof (OMX_BUFFERHEADERTYPE));
     memset (m_hwdevice_name,0,sizeof(m_hwdevice_name));
     memset(m_demux_offsets, 0, ( sizeof(OMX_U32) * 8192) );
     memset(&m_custom_buffersize, 0, sizeof(m_custom_buffersize));
     m_demux_entries = 0;
     msg_thread_id = 0;
     async_thread_id = 0;
     msg_thread_created = false;
     async_thread_created = false;
 #ifdef _ANDROID_ICS_
     memset(&native_buffer, 0 ,(sizeof(struct nativebuffer) * MAX_NUM_INPUT_OUTPUT_BUFFERS));
 #endif
     memset(&drv_ctx.extradata_info, 0, sizeof(drv_ctx.extradata_info));
 
   
     memset(&m_frame_pack_arrangement, 0, sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT));
     m_frame_pack_arrangement.cancel_flag = 1;
 
     drv_ctx.timestamp_adjust = false;
     drv_ctx.video_driver_fd = -1;
 
      m_vendor_config.pData = NULL;
      pthread_mutex_init(&m_lock, NULL);
      pthread_mutex_init(&c_lock, NULL);
     pthread_mutex_init(&buf_lock, NULL);
      sem_init(&m_cmd_lock,0,0);
      sem_init(&m_safe_flush, 0, 0);
      streaming[CAPTURE_PORT] =
         streaming[OUTPUT_PORT] = false;
 #ifdef _ANDROID_
  char extradata_value[PROPERTY_VALUE_MAX] = {0};
     property_get(""vidc.dec.debug.extradata"", extradata_value, ""0"");
     m_debug_extradata = atoi(extradata_value);
     DEBUG_PRINT_HIGH(""vidc.dec.debug.extradata value is %d"",m_debug_extradata);
 #endif
     m_fill_output_msg = OMX_COMPONENT_GENERATE_FTB;
     client_buffers.set_vdec_client(this);
     dynamic_buf_mode = false;
     out_dynamic_list = NULL;
     is_down_scalar_enabled = false;
     m_smoothstreaming_mode = false;
     m_smoothstreaming_width = 0;
     m_smoothstreaming_height = 0;
     is_q6_platform = false;
 }",[166],"Use-after-free vulnerability in the mm-video-v4l2 vdec component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27890802."
208590,"   virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
  #if WRITE_COMPRESSED_STREAM
   virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
      ++out_frames_;
  
  if (pkt->data.frame.pts == 0)
       write_ivf_file_header(&cfg_, 0, outfile_);
 
 
      write_ivf_frame_header(pkt, outfile_);
      (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);
#endif
    }","[3, 12]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
206480," DevToolsClient::DevToolsClient(
     RenderFrame* main_render_frame,
     const std::string& compatibility_script)
     : RenderFrameObserver(main_render_frame),
        compatibility_script_(compatibility_script),
        web_tools_frontend_(
            WebDevToolsFrontend::create(main_render_frame->GetWebFrame(), this)) {
   compatibility_script_ += ""\n# sourceURL=devtools_compatibility.js"";
  }",[8],"Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android insufficiently sanitized DevTools URLs, which allowed a remote attacker to read local files via a crafted HTML page."
207013," void DragController::PerformDrag(DragData* drag_data, LocalFrame& local_root) {
   DCHECK(drag_data);
   document_under_mouse_ =
       local_root.DocumentAtPoint(LayoutPoint(drag_data->ClientPosition()));
   std::unique_ptr<UserGestureIndicator> gesture = Frame::NotifyUserActivation(
       document_under_mouse_ ? document_under_mouse_->GetFrame() : nullptr,
       UserGestureToken::kNewGesture);
   if ((drag_destination_action_ & kDragDestinationActionDHTML) &&
       document_is_handling_drag_) {
     bool prevented_default = false;
     if (local_root.View()) {
       DataTransfer* data_transfer =
           CreateDraggingDataTransfer(kDataTransferReadable, drag_data);
       data_transfer->SetSourceOperation(
           drag_data->DraggingSourceOperationMask());
       EventHandler& event_handler = local_root.GetEventHandler();
       prevented_default = event_handler.PerformDragAndDrop(
                               CreateMouseEvent(drag_data), data_transfer) !=
                           WebInputEventResult::kNotHandled;
       if (!prevented_default) {
         const LayoutPoint point = local_root.View()->RootFrameToContents(
             LayoutPoint(drag_data->ClientPosition()));
         const HitTestResult result = event_handler.HitTestResultAtPoint(point);
         prevented_default |=
             IsHTMLPlugInElement(*result.InnerNode()) &&
             ToHTMLPlugInElement(result.InnerNode())->CanProcessDrag();
       }
 
       data_transfer->SetAccessPolicy(kDataTransferNumb);
     }
     if (prevented_default) {
       document_under_mouse_ = nullptr;
       CancelDrag();
       return;
     }
   }
 
   if ((drag_destination_action_ & kDragDestinationActionEdit) &&
       ConcludeEditDrag(drag_data)) {
     document_under_mouse_ = nullptr;
     return;
   }
 
   document_under_mouse_ = nullptr;
 
   if (OperationForLoad(drag_data, local_root) != kDragOperationNone) {
     if (page_->GetSettings().GetNavigateOnDragDrop()) {
       ResourceRequest resource_request(drag_data->AsURL());
        resource_request.SetRequestorOrigin(
            SecurityOrigin::Create(KURL(drag_data->AsURL())));
       resource_request.SetHasUserGesture(Frame::HasTransientUserActivation(
           document_under_mouse_ ? document_under_mouse_->GetFrame() : nullptr));
        page_->MainFrame()->Navigate(FrameLoadRequest(nullptr, resource_request));
      }
  
     local_root.GetEventHandler().ClearDragState();
   }
 }","[51, 52]",An integer overflow leading to an incorrect capacity of a buffer in JavaScript in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.
202352," void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)
 {
 	const struct k_clock *kc = timr->kclock;
 	ktime_t now, remaining, iv;
 	struct timespec64 ts64;
 	bool sig_none;
 
 	sig_none = timr->it_sigev_notify == SIGEV_NONE;
 	iv = timr->it_interval;
 
 	 
 	if (iv) {
 		cur_setting->it_interval = ktime_to_timespec64(iv);
 	} else if (!timr->it_active) {
 		 
 		if (!sig_none)
 			return;
 	}
 
 	 
 	kc->clock_get(timr->it_clock, &ts64);
 	now = timespec64_to_ktime(ts64);
 
 	 
  	if (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))
		timr->it_overrun += (int)kc->timer_forward(timr, now);
 		timr->it_overrun += kc->timer_forward(timr, now);
  
  	remaining = kc->timer_remaining(timr, now);
  	 
 	if (remaining <= 0) {
 		 
 		if (!sig_none)
 			cur_setting->it_value.tv_nsec = 1;
 	} else {
 		cur_setting->it_value = ktime_to_timespec64(remaining);
 	}
 }","[27, 26]","An issue was discovered in the Linux kernel through 4.17.3. An Integer Overflow in kernel/time/posix-timers.c in the POSIX timer code is caused by the way the overrun accounting works. Depending on interval and expiry time values, the overrun can be larger than INT_MAX, but the accounting is int based. This basically makes the accounting values, which are visible to user space via timer_getoverrun(2) and siginfo::si_overrun, random. For example, a local user can cause a denial of service (signed integer overflow) via crafted mmap, futex, timer_create, and timer_settime system calls."
202607," create_watching_parent (void)
 {
   pid_t child;
   sigset_t ourset;
   struct sigaction oldact[3];
   int status = 0;
   int retval;
 
   retval = pam_open_session (pamh, 0);
   if (is_pam_failure(retval))
     {
       cleanup_pam (retval);
       errx (EXIT_FAILURE, _(""cannot open session: %s""),
 	     pam_strerror (pamh, retval));
     }
   else
     _pam_session_opened = 1;
 
   memset(oldact, 0, sizeof(oldact));
 
   child = fork ();
   if (child == (pid_t) -1)
     {
       cleanup_pam (PAM_ABORT);
       err (EXIT_FAILURE, _(""cannot create child process""));
     }
 
    
   if (child == 0)
     return;
 
    
 
    
   if (chdir (""/"") != 0)
     warn (_(""cannot change directory to %s""), ""/"");
 
   sigfillset (&ourset);
   if (sigprocmask (SIG_BLOCK, &ourset, NULL))
     {
       warn (_(""cannot block signals""));
       caught_signal = true;
     }
   if (!caught_signal)
     {
       struct sigaction action;
       action.sa_handler = su_catch_sig;
       sigemptyset (&action.sa_mask);
       action.sa_flags = 0;
       sigemptyset (&ourset);
     if (!same_session)
       {
         if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))
           {
             warn (_(""cannot set signal handler""));
             caught_signal = true;
           }
       }
     if (!caught_signal && (sigaddset(&ourset, SIGTERM)
                     || sigaddset(&ourset, SIGALRM)
                     || sigaction(SIGTERM, &action, &oldact[0])
                     || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {
 	  warn (_(""cannot set signal handler""));
 	  caught_signal = true;
 	}
     if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])
                                      || sigaction(SIGQUIT, &action, &oldact[2])))
       {
         warn (_(""cannot set signal handler""));
         caught_signal = true;
       }
     }
   if (!caught_signal)
     {
       pid_t pid;
       for (;;)
 	{
 	  pid = waitpid (child, &status, WUNTRACED);
 
 	  if (pid != (pid_t)-1 && WIFSTOPPED (status))
 	    {
 	      kill (getpid (), SIGSTOP);
 	       
 	      kill (pid, SIGCONT);
 	    }
 	  else
 	    break;
 	}
       if (pid != (pid_t)-1)
         {
           if (WIFSIGNALED (status))
             {
               fprintf (stderr, ""%s%s\n"", strsignal (WTERMSIG (status)),
                        WCOREDUMP (status) ? _("" (core dumped)"") : """");
               status = WTERMSIG (status) + 128;
              }
            else
              status = WEXITSTATUS (status);
 
 	   
 	  child = (pid_t) -1;
          }
        else if (caught_signal)
          status = caught_signal + 128;
       else
         status = 1;
     }
    else
      status = 1;
  
  if (caught_signal)
   if (caught_signal && child != (pid_t)-1)
      {
        fprintf (stderr, _(""\nSession terminated, killing shell...""));
        kill (child, SIGTERM);
     }
 
   cleanup_pam (PAM_SUCCESS);
  
    if (caught_signal)
      {
      sleep (2);
      kill (child, SIGKILL);
      fprintf (stderr, _("" ...killed.\n""));
       if (child != (pid_t)-1)
 	{
 	  sleep (2);
 	  kill (child, SIGKILL);
 	  fprintf (stderr, _("" ...killed.\n""));
 	}
  
         
       switch (caught_signal) {
         case SIGTERM:
           sigaction(SIGTERM, &oldact[0], NULL);
           break;
         case SIGINT:
           sigaction(SIGINT, &oldact[1], NULL);
           break;
         case SIGQUIT:
           sigaction(SIGQUIT, &oldact[2], NULL);
           break;
         default:
 	   
           caught_signal = SIGKILL;
           break;
       }
       kill(getpid(), caught_signal);
     }
   exit (status);
 }","[99, 100, 101, 112, 125, 126, 127, 128, 129, 130, 111, 122, 123, 124]",A race condition was found in util-linux before 2.32.1 in the way su handled the management of child processes. A local authenticated attacker could use this flaw to kill other processes with root privileges under specific conditions.
206775,"  VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::CreateVP8Picture() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
    scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();
    if (!va_surface)
      return nullptr;
 
   return new VaapiVP8Picture(std::move(va_surface));
 }",[2],A race in the handling of SharedArrayBuffers in WebAssembly in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
5033,"int ZLIB_INTERNAL _tr_tally (s, dist, lc)
deflate_state *s;
unsigned dist;
unsigned lc;
{
s->d_buf[s->last_lit] = (ush)dist;
s->l_buf[s->last_lit++] = (uch)lc;
if (dist == 0) {

s->dyn_ltree[lc].Freq++;
} else {
s->matches++;

dist--;
Assert((ush)dist < (ush)MAX_DIST(s) &&
(ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
(ush)d_code(dist) < (ush)D_CODES,  ""_tr_tally: bad match"");

s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
s->dyn_dtree[d_code(dist)].Freq++;
}

#ifdef TRUNCATE_BLOCK

if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {

ulg out_length = (ulg)s->last_lit*8L;
ulg in_length = (ulg)((long)s->strstart - s->block_start);
int dcode;
for (dcode = 0; dcode < D_CODES; dcode++) {
out_length += (ulg)s->dyn_dtree[dcode].Freq *
(5L+extra_dbits[dcode]);
}
out_length >>= 3;
Tracev((stderr,""\nlast_lit %u, in %ld, out ~%ld(%ld%%) "",
s->last_lit, in_length, out_length,
100L - out_length*100L/in_length));
if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
}
#endif
return (s->last_lit == s->lit_bufsize-1);




}","[6, 7, 23, 25, 27, 28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 40, 41]","zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches."
3485,"static int read_header(FFV1Context *f)
{
uint8_t state[CONTEXT_SIZE];
int i, j, context_count = -1;
RangeCoder *const c = &f->slice_context[0]->c;

memset(state, 128, sizeof(state));

if (f->version < 2) {
int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;
unsigned v= get_symbol(c, state, 0);
if (v >= 2) {
av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
return AVERROR_INVALIDDATA;
}
f->version = v;
f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);
if (f->ac > 1) {
for (i = 1; i < 256; i++)
f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
}

colorspace          = get_symbol(c, state, 0);
bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;
chroma_planes       = get_rac(c, state);
chroma_h_shift      = get_symbol(c, state, 0);
chroma_v_shift      = get_symbol(c, state, 0);
transparency        = get_rac(c, state);

if (f->plane_count) {
if (colorspace          != f->colorspace                 ||
bits_per_raw_sample != f->avctx->bits_per_raw_sample ||
chroma_planes       != f->chroma_planes              ||
chroma_h_shift      != f->chroma_h_shift             ||
chroma_v_shift      != f->chroma_v_shift             ||
transparency        != f->transparency) {
av_log(f->avctx, AV_LOG_ERROR, ""Invalid change of global parameters\n"");
return AVERROR_INVALIDDATA;
}
}

if (chroma_h_shift > 4U || chroma_v_shift > 4U) {
av_log(f->avctx, AV_LOG_ERROR, ""chroma shift parameters %d %d are invalid\n"",
chroma_h_shift, chroma_v_shift);
return AVERROR_INVALIDDATA;
}

f->colorspace                 = colorspace;
f->avctx->bits_per_raw_sample = bits_per_raw_sample;
f->chroma_planes              = chroma_planes;
f->chroma_h_shift             = chroma_h_shift;
f->chroma_v_shift             = chroma_v_shift;
f->transparency               = transparency;

f->plane_count    = 2 + f->transparency;
}

if (f->colorspace == 0) {
if (f->avctx->skip_alpha) f->transparency = 0;
if (!f->transparency && !f->chroma_planes) {
if (f->avctx->bits_per_raw_sample <= 8)
f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;
else
f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;
} else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;
case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;
case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;
case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;
}
} else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {
switch(16*f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;
}
} else if (f->avctx->bits_per_raw_sample == 9 && !f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;
}
} else if (f->avctx->bits_per_raw_sample == 9 && f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P9; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P9; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P9; break;
}
} else if (f->avctx->bits_per_raw_sample == 10 && !f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;
}
} else if (f->avctx->bits_per_raw_sample == 10 && f->transparency) {
f->packed_at_lsb = 1;
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P10; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P10; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P10; break;
}
} else if (f->avctx->bits_per_raw_sample == 16 && !f->transparency){
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;
}
} else if (f->avctx->bits_per_raw_sample == 16 && f->transparency){
switch(16 * f->chroma_h_shift + f->chroma_v_shift) {
case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P16; break;
case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P16; break;
case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P16; break;
}
}
} else if (f->colorspace == 1) {
if (f->chroma_h_shift || f->chroma_v_shift) {
av_log(f->avctx, AV_LOG_ERROR,
""chroma subsampling not supported in this colorspace\n"");
return AVERROR(ENOSYS);
}
if (     f->avctx->bits_per_raw_sample ==  9)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;
else if (f->avctx->bits_per_raw_sample == 10)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;
else if (f->avctx->bits_per_raw_sample == 12)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;
else if (f->avctx->bits_per_raw_sample == 14)
f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;
else
if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;
else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;
} else {
av_log(f->avctx, AV_LOG_ERROR, ""colorspace not supported\n"");
return AVERROR(ENOSYS);
}
if (f->avctx->pix_fmt == AV_PIX_FMT_NONE) {
av_log(f->avctx, AV_LOG_ERROR, ""format not supported\n"");
return AVERROR(ENOSYS);
}

av_dlog(f->avctx, ""%d %d %d\n"",
f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);
if (f->version < 2) {
context_count = read_quant_tables(c, f->quant_table);
if (context_count < 0) {
av_log(f->avctx, AV_LOG_ERROR, ""read_quant_table error\n"");
return AVERROR_INVALIDDATA;
}
f->slice_count = f->max_slice_count;
} else if (f->version < 3) {
f->slice_count = get_symbol(c, state, 0);
} else {
const uint8_t *p = c->bytestream_end;
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) {
int trailer = 3 + 5*!!f->ec;
int size = AV_RB24(p-trailer);
if (size + trailer > p - c->bytestream_start)
break;
p -= size + trailer;
}
}
if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0 || f->slice_count > f->max_slice_count) {
av_log(f->avctx, AV_LOG_ERROR, ""slice count %d is invalid (max=%d)\n"", f->slice_count, f->max_slice_count);
return AVERROR_INVALIDDATA;
}

for (j = 0; j < f->slice_count; j++) {
FFV1Context *fs = f->slice_context[j];
fs->ac            = f->ac;
fs->packed_at_lsb = f->packed_at_lsb;

fs->slice_damaged = 0;

if (f->version == 2) {
fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;
fs->slice_y      =  get_symbol(c, state, 0)      * f->height;
fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;
fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;

fs->slice_x     /= f->num_h_slices;
fs->slice_y     /= f->num_v_slices;
fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;
fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;
if ((unsigned)fs->slice_width  > f->width ||
(unsigned)fs->slice_height > f->height)
return AVERROR_INVALIDDATA;
if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width
|| (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)
return AVERROR_INVALIDDATA;
}

for (i = 0; i < f->plane_count; i++) {
PlaneContext *const p = &fs->plane[i];

if (f->version == 2) {
int idx = get_symbol(c, state, 0);
if (idx > (unsigned)f->quant_table_count) {
av_log(f->avctx, AV_LOG_ERROR,
""quant_table_index out of range\n"");
return AVERROR_INVALIDDATA;
}
p->quant_table_index = idx;
memcpy(p->quant_table, f->quant_tables[idx],
sizeof(p->quant_table));
context_count = f->context_count[idx];
} else {
memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
}

if (f->version <= 2) {
av_assert0(context_count >= 0);
if (p->context_count < context_count) {
av_freep(&p->state);
av_freep(&p->vlc_state);
}
p->context_count = context_count;
}
}
}
return 0;
}",[161],"The read_header function in libavcodec/ffv1dec.c in FFmpeg 2.4 and 3.3.4 and possibly earlier allows remote attackers to have unspecified impact via a crafted MP4 file, which triggers an out-of-bounds read."
200670," static ssize_t fuse_fill_write_pages(struct fuse_req *req,
 			       struct address_space *mapping,
 			       struct iov_iter *ii, loff_t pos)
 {
 	struct fuse_conn *fc = get_fuse_conn(mapping->host);
 	unsigned offset = pos & (PAGE_CACHE_SIZE - 1);
 	size_t count = 0;
 	int err;
 
 	req->in.argpages = 1;
 	req->page_descs[0].offset = offset;
 
 	do {
 		size_t tmp;
 		struct page *page;
 		pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 		size_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,
 				     iov_iter_count(ii));
 
 		bytes = min_t(size_t, bytes, fc->max_write - count);
 
  again:
 		err = -EFAULT;
 		if (iov_iter_fault_in_readable(ii, bytes))
 			break;
 
 		err = -ENOMEM;
 		page = grab_cache_page_write_begin(mapping, index, 0);
 		if (!page)
 			break;
 
 		if (mapping_writably_mapped(mapping))
 			flush_dcache_page(page);
 
  		tmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);
  		flush_dcache_page(page);
  
 		iov_iter_advance(ii, tmp);
  		if (!tmp) {
  			unlock_page(page);
  			page_cache_release(page);
 			bytes = min(bytes, iov_iter_single_seg_count(ii));
 			goto again;
 		}
 
 		err = 0;
 		req->pages[req->num_pages] = page;
  		req->page_descs[req->num_pages].length = tmp;
  		req->num_pages++;
  
		iov_iter_advance(ii, tmp);
  		count += tmp;
  		pos += tmp;
  		offset += tmp;
 		if (offset == PAGE_CACHE_SIZE)
 			offset = 0;
 
 		if (!fc->big_writes)
 			break;
 	} while (iov_iter_count(ii) && count < fc->max_write &&
 		 req->num_pages < req->max_pages && offset == 0);
 
 	return count > 0 ? count : err;
 }","[38, 51]",The fuse_fill_write_pages function in fs/fuse/file.c in the Linux kernel before 4.4 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers a zero length for the first segment of an iov.
204299," bool NaClProcessHost::OnMessageReceived(const IPC::Message& msg) {
   bool handled = true;
   IPC_BEGIN_MESSAGE_MAP(NaClProcessHost, msg)
     IPC_MESSAGE_HANDLER(NaClProcessMsg_QueryKnownToValidate,
                         OnQueryKnownToValidate)
     IPC_MESSAGE_HANDLER(NaClProcessMsg_SetKnownToValidate,
                         OnSetKnownToValidate)
 #if defined(OS_WIN)
      IPC_MESSAGE_HANDLER_DELAY_REPLY(NaClProcessMsg_AttachDebugExceptionHandler,
                                      OnAttachDebugExceptionHandler)
  #endif
    IPC_MESSAGE_HANDLER(NaClProcessHostMsg_PpapiChannelCreated,
                        OnPpapiChannelCreated)
      IPC_MESSAGE_UNHANDLED(handled = false)
    IPC_END_MESSAGE_MAP()
    return handled;
 }","[12, 13]",Use-after-free vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG text references.
203069," static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
 	struct bt_security sec;
 	int len, err = 0;
 
 	BT_DBG(""sk %p"", sk);
 
 	if (level == SOL_RFCOMM)
 		return rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);
 
 	if (level != SOL_BLUETOOTH)
 		return -ENOPROTOOPT;
 
 	if (get_user(len, optlen))
 		return -EFAULT;
 
 	lock_sock(sk);
 
 	switch (optname) {
 	case BT_SECURITY:
 		if (sk->sk_type != SOCK_STREAM) {
 			err = -EINVAL;
 			break;
  		}
  
  		sec.level = rfcomm_pi(sk)->sec_level;
 		sec.key_size = 0;
  
  		len = min_t(unsigned int, len, sizeof(sec));
  		if (copy_to_user(optval, (char *) &sec, len))
 			err = -EFAULT;
 
 		break;
 
 	case BT_DEFER_SETUP:
 		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {
 			err = -EINVAL;
 			break;
 		}
 
 		if (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),
 			     (u32 __user *) optval))
 			err = -EFAULT;
 
 		break;
 
 	default:
 		err = -ENOPROTOOPT;
 		break;
 	}
 
 	release_sock(sk);
 	return err;
 }",[28],"The Bluetooth RFCOMM implementation in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application."
7603,"static int may_create_in_sticky(struct dentry * const dir,
struct inode * const inode)
{
if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||
(!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||
likely(!(dir->d_inode->i_mode & S_ISVTX)) ||
uid_eq(inode->i_uid, dir->d_inode->i_uid) ||
uid_eq(current_fsuid(), inode->i_uid))
return 0;

if (likely(dir->d_inode->i_mode & 0002) ||
(dir->d_inode->i_mode & 0020 &&
((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||
(sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {
const char *operation = S_ISFIFO(inode->i_mode) ?
""sticky_create_fifo"" :
""sticky_create_regular"";
audit_log_path_denied(AUDIT_ANOM_CREAT, operation);
return -EACCES;
}
return 0;
}","[6, 7, 11, 12]","fs/namei.c in the Linux kernel before 5.5 has a may_create_in_sticky use-after-free, which allows local users to cause a denial of service (OOPS) or possibly obtain sensitive information from kernel memory, aka CID-d0cb50185ae9. One attack vector may be an open system call for a UNIX domain socket, if the socket is being moved to a new parent directory and its old parent directory is being removed."
203242,"  static int get_default_root(pool *p, int allow_symlinks, char **root) {
    config_rec *c = NULL;
    char *dir = NULL;
   int res;
 
   c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
   while (c) {
     pr_signals_handle();
 
      
     if (c->argc < 2) {
       dir = c->argv[0];
       break;
     }
 
     res = pr_expr_eval_group_and(((char **) c->argv)+1);
     if (res) {
       dir = c->argv[0];
       break;
     }
 
     c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
   }
 
   if (dir) {
     char *new_dir;
 
      
     new_dir = path_subst_uservar(p, &dir);
     if (new_dir != NULL) {
       dir = new_dir;
     }
 
     if (strncmp(dir, ""/"", 2) == 0) {
       dir = NULL;
 
     } else {
       char *realdir;
       int xerrno = 0;
  
        if (allow_symlinks == FALSE) {
          char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
          size_t pathlen;
  
           
 
         path = dir;
         if (*path != '/') {
           if (*path == '~') {
             if (pr_fs_interpolate(dir, target_path,
                 sizeof(target_path)-1) < 0) {
               return -1;
             }
 
             path = target_path;
           }
         }
 
          
         pathlen = strlen(path);
         if (pathlen > 1 &&
             path[pathlen-1] == '/') {
            path[pathlen-1] = '\0';
          }
  
        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
         res = is_symlink_path(p, path, pathlen);
          if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
           if (errno == EPERM) {
             pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
               ""(denied by AllowChrootSymlinks config)"", path);
           }
  
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
            errno = EPERM;
            return -1;
          }
       }
 
        
 
       PRIVS_USER
       realdir = dir_realpath(p, dir);
       xerrno = errno;
       PRIVS_RELINQUISH
 
       if (realdir) {
         dir = realdir;
 
       } else {
          
         char interp_dir[PR_TUNABLE_PATH_MAX + 1];
 
         memset(interp_dir, '\0', sizeof(interp_dir));
         (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 
 
         pr_log_pri(PR_LOG_NOTICE,
           ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
           dir, interp_dir, strerror(xerrno));
 
         errno = xerrno;
       }
     }
   }
 
   *root = dir;
   return 0;
 }","[69, 77, 78, 79, 80, 43, 67, 68, 71, 72, 73, 74, 75, 76, 82, 83, 84, 85]","ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user."
8285,"void DoCompute(OpKernelContext* c) {
core::RefCountPtr<Var> v;
OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));
Tensor* params = v->tensor();
const Tensor& indices = c->input(1);
const Tensor& updates = c->input(2);


OP_REQUIRES(c,
updates.dims() == 0 ||
updates.dims() == indices.dims() + params->dims() - 1,
errors::InvalidArgument(
""Must have updates.shape = indices.shape + ""
""params.shape[1:] or updates.shape = [], got "",
""updates.shape "", updates.shape().DebugString(),
"", indices.shape "", indices.shape().DebugString(),
"", params.shape "", params->shape().DebugString()));


const int64_t N_big = indices.NumElements();
OP_REQUIRES(
c, N_big <= std::numeric_limits<Index>::max(),
errors::InvalidArgument(""indices has too many elements for "",
DataTypeString(DataTypeToEnum<Index>::v()),
"" indexing: "", N_big, "" > "",
std::numeric_limits<Index>::max()));
const Index N = static_cast<Index>(N_big);
OP_REQUIRES(
c, params->dim_size(0) <= std::numeric_limits<Index>::max(),
errors::InvalidArgument(""params.shape[0] too large for "",
DataTypeString(DataTypeToEnum<Index>::v()),
"" indexing: "", params->dim_size(0), "" > "",
std::numeric_limits<Index>::max()));

if (N > 0) {
auto indices_flat = indices.flat<Index>();
auto params_flat = params->flat_outer_dims<T>();
if (TensorShapeUtils::IsScalar(updates.shape())) {
const auto update = updates.scalar<T>();

functor::ScatterScalarFunctor<Device, T, Index, op> functor;
const Index bad_i = functor(c, c->template eigen_device<Device>(),
params_flat, update, indices_flat);
OP_REQUIRES(c, bad_i < 0,
errors::InvalidArgument(
""indices"", SliceDebugString(indices.shape(), bad_i),
"" = "", indices_flat(bad_i), "" is not in [0, "",
params->dim_size(0), "")""));
} else {
int64_t num_updates = updates.NumElements();
OP_REQUIRES(
c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),
errors::InvalidArgument(
""The shape of indices ("", indices.shape().DebugString(),
"") must be a prefix of the shape of updates ("",
updates.shape().DebugString(), "")""));
auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});

functor::ScatterFunctor<Device, T, Index, op> functor;
const Index bad_i = functor(c, c->template eigen_device<Device>(),
params_flat, updates_flat, indices_flat);
OP_REQUIRES(c, bad_i < 0,
errors::InvalidArgument(
""indices"", SliceDebugString(indices.shape(), bad_i),
"" = "", indices_flat(bad_i), "" is not in [0, "",
params->dim_size(0), "")""));
}
}
}",[35],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
198886," static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)
 {
 	__be32 *p;
   
  	RESERVE_SPACE(8);
  	WRITE32(OP_OPEN);
  	WRITE32(arg->seqid->sequence->counter);
	encode_share_access(xdr, arg->open_flags);
 	encode_share_access(xdr, arg->fmode);
  	RESERVE_SPACE(28);
  	WRITE64(arg->clientid);
  	WRITE32(16);
 	WRITEMEM(""open id:"", 8);
 	WRITE64(arg->id);
 }","[9, 8]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
208510," static void encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         int flags,
                         VpxVideoWriter *writer) {
 static int encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         int flags,
                         VpxVideoWriter *writer) {
   int got_pkts = 0;
    vpx_codec_iter_t iter = NULL;
    const vpx_codec_cx_pkt_t *pkt = NULL;
    const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,
                                                flags, VPX_DL_GOOD_QUALITY);
  if (res != VPX_CODEC_OK)
 
      die_codec(codec, ""Failed to encode frame"");
  
    while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {
     got_pkts = 1;
 
      if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
        const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
        if (!vpx_video_writer_write_frame(writer,
                                         pkt->data.frame.buf,
                                         pkt->data.frame.sz,
 
                                          pkt->data.frame.pts)) {
          die_codec(codec, ""Failed to write compressed frame"");
        }
        printf(keyframe ? ""K"" : ""."");
        fflush(stdout);
      }
    }
 
   return got_pkts;
  }","[6, 7, 8, 9, 10, 11, 21, 22, 36, 37, 2, 3, 4, 5]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
207860,"  long Chapters::Parse() {
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  long long pos = m_start;  
  const long long stop = pos + m_size;  
 
  while (pos < stop) {
  long long id, size;
 
  long status = ParseElementHeader(pReader, pos, stop, id, size);
 
  if (status < 0)  
  return status;
 
  if (size == 0)  
  continue;
 
  if (id == 0x05B9) {  
       status = ParseEdition(pos, size);
 
  if (status < 0)  
  return status;
 
      }
  
      pos += size;
    assert(pos <= stop);
     if (pos > stop)
       return E_FILE_FORMAT_INVALID;
    }
  
  assert(pos == stop);
   if (pos != stop)
     return E_FILE_FORMAT_INVALID;
    return 0;
  }","[28, 29, 33, 34, 27, 32]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
5802,"parse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,
ScanEnv* env, int group_head)
{
int r, len, group = 0;
Node* qn;
Node** tp;

*np = NULL;
if (tok->type == (enum TokenSyms )term)
goto end_of_token;

switch (tok->type) {
case TK_ALT:
case TK_EOT:
end_of_token:
*np = node_new_empty();
CHECK_NULL_RETURN_MEMERR(*np);
return tok->type;
break;

case TK_SUBEXP_OPEN:
r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);
if (r < 0) return r;
if (r == 1) {
if (group_head == 0)
group = 1;
else {
Node* target = *np;
*np = node_new_group(target);
if (IS_NULL(*np)) {
onig_node_free(target);
return ONIGERR_MEMORY;
}
group = 2;
}
}
else if (r == 2) {
Node* target;
OnigOptionType prev = env->options;

env->options = BAG_(*np)->o.options;
r = fetch_token(tok, src, end, env);
if (r < 0) return r;
r = parse_subexp(&target, tok, term, src, end, env, 0);
env->options = prev;
if (r < 0) {
onig_node_free(target);
return r;
}
NODE_BODY(*np) = target;
return tok->type;
}
break;

case TK_SUBEXP_CLOSE:
if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))
return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;

if (tok->escaped) goto tk_raw_byte;
else goto tk_byte;
break;

case TK_STRING:
tk_byte:
{
*np = node_new_str(tok->backp, *src);
CHECK_NULL_RETURN_MEMERR(*np);

while (1) {
r = fetch_token(tok, src, end, env);
if (r < 0) return r;
if (r != TK_STRING) break;

r = onig_node_str_cat(*np, tok->backp, *src);
if (r < 0) return r;
}

string_end:
tp = np;
goto repeat;
}
break;

case TK_RAW_BYTE:
tk_raw_byte:
{
*np = node_new_str_raw_char((UChar )tok->u.c);
CHECK_NULL_RETURN_MEMERR(*np);
len = 1;
while (1) {
if (len >= ONIGENC_MBC_MINLEN(env->enc)) {
if (len == enclen(env->enc, STR_(*np)->s)) {
r = fetch_token(tok, src, end, env);
goto tk_raw_byte_end;
}
}

r = fetch_token(tok, src, end, env);
if (r < 0) return r;
if (r != TK_RAW_BYTE)
return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;

r = node_str_cat_char(*np, (UChar )tok->u.c);
if (r < 0) return r;

len++;
}

tk_raw_byte_end:
if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))
return ONIGERR_INVALID_WIDE_CHAR_VALUE;

NODE_STRING_CLEAR_RAW(*np);
goto string_end;
}
break;

case TK_CODE_POINT:
{
UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];
len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);
if (len < 0) return len;
#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG
*np = node_new_str_raw(buf, buf + len);
#else
*np = node_new_str(buf, buf + len);
#endif
CHECK_NULL_RETURN_MEMERR(*np);
}
break;

case TK_QUOTE_OPEN:
{
OnigCodePoint end_op[2];
UChar *qstart, *qend, *nextp;

end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);
end_op[1] = (OnigCodePoint )'E';
qstart = *src;
qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);
if (IS_NULL(qend)) {
nextp = qend = end;
}
*np = node_new_str(qstart, qend);
CHECK_NULL_RETURN_MEMERR(*np);
*src = nextp;
}
break;

case TK_CHAR_TYPE:
{
switch (tok->u.prop.ctype) {
case ONIGENC_CTYPE_WORD:
*np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);
CHECK_NULL_RETURN_MEMERR(*np);
break;

case ONIGENC_CTYPE_SPACE:
case ONIGENC_CTYPE_DIGIT:
case ONIGENC_CTYPE_XDIGIT:
{
CClassNode* cc;

*np = node_new_cclass();
CHECK_NULL_RETURN_MEMERR(*np);
cc = CCLASS_(*np);
add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);
if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);
}
break;

default:
return ONIGERR_PARSER_BUG;
break;
}
}
break;

case TK_CHAR_PROPERTY:
r = parse_char_property(np, tok, src, end, env);
if (r != 0) return r;
break;

case TK_CC_OPEN:
{
CClassNode* cc;

r = parse_char_class(np, tok, src, end, env);
if (r != 0) return r;

cc = CCLASS_(*np);
if (IS_IGNORECASE(env->options)) {
IApplyCaseFoldArg iarg;

iarg.env      = env;
iarg.cc       = cc;
iarg.alt_root = NULL_NODE;
iarg.ptail    = &(iarg.alt_root);

r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,
i_apply_case_fold, &iarg);
if (r != 0) {
onig_node_free(iarg.alt_root);
return r;
}
if (IS_NOT_NULL(iarg.alt_root)) {
Node* work = onig_node_new_alt(*np, iarg.alt_root);
if (IS_NULL(work)) {
onig_node_free(iarg.alt_root);
return ONIGERR_MEMORY;
}
*np = work;
}
}
}
break;

case TK_ANYCHAR:
*np = node_new_anychar();
CHECK_NULL_RETURN_MEMERR(*np);
break;

case TK_ANYCHAR_ANYTIME:
*np = node_new_anychar();
CHECK_NULL_RETURN_MEMERR(*np);
qn = node_new_quantifier(0, INFINITE_REPEAT, 0);
CHECK_NULL_RETURN_MEMERR(qn);
NODE_BODY(qn) = *np;
*np = qn;
break;

case TK_BACKREF:
len = tok->u.backref.num;
*np = node_new_backref(len,
(len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),
tok->u.backref.by_name,
#ifdef USE_BACKREF_WITH_LEVEL
tok->u.backref.exist_level,
tok->u.backref.level,
#endif
env);
CHECK_NULL_RETURN_MEMERR(*np);
break;

#ifdef USE_CALL
case TK_CALL:
{
int gnum = tok->u.call.gnum;

*np = node_new_call(tok->u.call.name, tok->u.call.name_end,
gnum, tok->u.call.by_number);
CHECK_NULL_RETURN_MEMERR(*np);
env->num_call++;
if (tok->u.call.by_number != 0 && gnum == 0) {
env->has_call_zero = 1;
}
}
break;
#endif

case TK_ANCHOR:
{
int ascii_mode =
IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;
*np = onig_node_new_anchor(tok->u.anchor, ascii_mode);
CHECK_NULL_RETURN_MEMERR(*np);
}
break;

case TK_REPEAT:
case TK_INTERVAL:
if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {
if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))
return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;
else {
*np = node_new_empty();
CHECK_NULL_RETURN_MEMERR(*np);
}
}
else {
goto tk_byte;
}
break;

case TK_KEEP:
r = node_new_keep(np, env);
if (r < 0) return r;
break;

case TK_GENERAL_NEWLINE:
r = node_new_general_newline(np, env);
if (r < 0) return r;
break;

case TK_NO_NEWLINE:
r = node_new_no_newline(np, env);
if (r < 0) return r;
break;

case TK_TRUE_ANYCHAR:
r = node_new_true_anychar(np, env);
if (r < 0) return r;
break;

case TK_TEXT_SEGMENT:
r = make_text_segment(np, env);
if (r < 0) return r;
break;

default:
return ONIGERR_PARSER_BUG;
break;
}

{
tp = np;

re_entry:
r = fetch_token(tok, src, end, env);
if (r < 0) return r;

repeat:
if (r == TK_REPEAT || r == TK_INTERVAL) {
Node* target;

if (is_invalid_quantifier_target(*tp))
return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;

qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,
r == TK_INTERVAL);
CHECK_NULL_RETURN_MEMERR(qn);
QUANT_(qn)->greedy = tok->u.repeat.greedy;
if (group == 2) {
target = node_drop_group(*tp);
*tp = NULL_NODE;
}
else {
target = *tp;
}
r = set_quantifier(qn, target, group, env);
if (r < 0) {
onig_node_free(qn);
return r;
}

if (tok->u.repeat.possessive != 0) {
Node* en;
en = node_new_bag(BAG_STOP_BACKTRACK);
if (IS_NULL(en)) {
onig_node_free(qn);
return ONIGERR_MEMORY;
}
NODE_BODY(en) = qn;
qn = en;
}

if (r == 0) {
*tp = qn;
}
else if (r == 1) {
onig_node_free(qn);
*tp = target;
}
else if (r == 2) {
Node *tmp;

*tp = node_new_list(*tp, NULL);
if (IS_NULL(*tp)) {
onig_node_free(qn);
return ONIGERR_MEMORY;
}
tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);
if (IS_NULL(tmp)) {
onig_node_free(qn);
return ONIGERR_MEMORY;
}
tp = &(NODE_CAR(tmp));
}
group = 0;
goto re_entry;
}
}

return r;
}","[4, 8, 8, 12, 329]",Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c.
206874," PrintMsg_Print_Params::PrintMsg_Print_Params()
     : page_size(),
       content_size(),
       printable_area(),
       margin_top(0),
       margin_left(0),
       dpi(0),
       scale_factor(1.0f),
       rasterize_pdf(false),
       document_cookie(0),
       selection_only(false),
       supports_alpha_blend(false),
       preview_ui_id(-1),
       preview_request_id(0),
       is_first_request(false),
       print_scaling_option(blink::kWebPrintScalingOptionSourceSize),
       print_to_pdf(false),
        display_header_footer(false),
        title(),
        url(),
       header_template(),
       footer_template(),
        should_print_backgrounds(false),
        printed_doc_type(printing::SkiaDocumentType::PDF) {}","[21, 22]",Failure to apply Mark-of-the-Web in Downloads in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to bypass OS level controls via a crafted HTML page.
201787," static Image *ReadUYVYImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   Image
     *image;
 
   MagickBooleanType
     status;
 
   register ssize_t
     x;
 
   register PixelPacket
     *q;
 
   ssize_t
     y;
 
   unsigned char
     u,
     v,
     y1,
     y2;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   if ((image->columns == 0) || (image->rows == 0))
     ThrowReaderException(OptionError,""MustSpecifyImageSize"");
   if ((image->columns % 2) != 0)
     image->columns++;
   (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     return((Image *) NULL);
   if (DiscardBlobBytes(image,image->offset) == MagickFalse)
     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
       image->filename);
   image->depth=8;
   if (image_info->ping != MagickFalse)
     {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
     
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
     if (q == (PixelPacket *) NULL)
       break;
     for (x=0; x < (ssize_t) (image->columns >> 1); x++)
     {
       u=(unsigned char) ReadBlobByte(image);
       y1=(unsigned char) ReadBlobByte(image);
       v=(unsigned char) ReadBlobByte(image);
       y2=(unsigned char) ReadBlobByte(image);
       SetPixelRed(q,ScaleCharToQuantum(y1));
       SetPixelGreen(q,ScaleCharToQuantum(u));
       SetPixelBlue(q,ScaleCharToQuantum(v));
       q++;
       SetPixelRed(q,ScaleCharToQuantum(y2));
       SetPixelGreen(q,ScaleCharToQuantum(u));
       SetPixelBlue(q,ScaleCharToQuantum(v));
       q++;
     }
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
     status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
       image->rows);
     if (status == MagickFalse)
       break;
   }
   SetImageColorspace(image,YCbCrColorspace);
   if (EOFBlob(image) != MagickFalse)
     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
       image->filename);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[51, 52, 53, 54, 55, 56]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
6278,"static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)
{
UINT16 AvLen;

Data_Read_UINT16(&pAvPair->AvLen, AvLen);

return AvLen;
}","[5, 7]","In FreeRDP before version 2.1.2, an out of bounds read occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2."
207889," long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,
                                  long long size_, char*& str) {
 long UnserializeString(IMkvReader* pReader, long long pos, long long size,
                        char*& str) {
    delete[] str;
    str = NULL;
  
  if (size_ >= LONG_MAX)   
   if (size >= LONG_MAX || size < 0)
      return E_FILE_FORMAT_INVALID;
  
  const long size = static_cast<long>(size_);
    
   const long required_size = static_cast<long>(size) + 1;
  
  str = new (std::nothrow) char[size + 1];
   str = SafeArrayAlloc<char>(1, required_size);
    if (str == NULL)
    return -1;
     return E_FILE_FORMAT_INVALID;
  
    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
  
  const long status = pReader->Read(pos, size, buf);
 
  if (status) {
  delete[] str;
     str = NULL;
 
 
      return status;
    }
  
  str[size] = '\0';
  return 0;   
   str[required_size - 1] = '\0';
   return 0;
  }","[3, 4, 9, 13, 14, 17, 20, 36, 37, 2, 8, 12, 16, 19, 34, 35]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
199141," void exit_sem(struct task_struct *tsk)
 {
 	struct sem_undo_list *ulp;
 
 	ulp = tsk->sysvsem.undo_list;
 	if (!ulp)
 		return;
 	tsk->sysvsem.undo_list = NULL;
 
 	if (!atomic_dec_and_test(&ulp->refcnt))
 		return;
 
 	for (;;) {
  		struct sem_array *sma;
  		struct sem_undo *un;
  		struct list_head tasks;
		int semid;
		int i;
 		int semid, i;
  
  		rcu_read_lock();
  		un = list_entry_rcu(ulp->list_proc.next,
 				    struct sem_undo, list_proc);
 		if (&un->list_proc == &ulp->list_proc)
  			semid = -1;
  		 else
  			semid = un->semid;
		rcu_read_unlock();
  
		if (semid == -1)
 		if (semid == -1) {
 			rcu_read_unlock();
  			break;
 		}
  
		sma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);
 		sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);
  		 
		if (IS_ERR(sma))
 		if (IS_ERR(sma)) {
 			rcu_read_unlock();
  			continue;
 		}
  
 		sem_lock(sma, NULL, -1);
  		un = __lookup_undo(ulp, semid);
  		if (un == NULL) {
  			 
			sem_unlock(sma);
 			sem_unlock(sma, -1);
  			continue;
  		}
  
 		 
 		assert_spin_locked(&sma->sem_perm.lock);
 		list_del(&un->list_id);
 
 		spin_lock(&ulp->lock);
 		list_del_rcu(&un->list_proc);
 		spin_unlock(&ulp->lock);
 
 		 
 		for (i = 0; i < sma->sem_nsems; i++) {
 			struct sem * semaphore = &sma->sem_base[i];
 			if (un->semadj[i]) {
 				semaphore->semval += un->semadj[i];
 				 
 				if (semaphore->semval < 0)
 					semaphore->semval = 0;
 				if (semaphore->semval > SEMVMX)
 					semaphore->semval = SEMVMX;
 				semaphore->sempid = task_tgid_vnr(current);
 			}
 		}
  		 
  		INIT_LIST_HEAD(&tasks);
  		do_smart_update(sma, NULL, 0, 1, &tasks);
		sem_unlock(sma);
 		sem_unlock(sma, -1);
  		wake_up_sem_queue_do(&tasks);
  
  		kfree_rcu(un, rcu);
 	}
 	kfree(ulp);
 }","[19, 31, 32, 34, 37, 40, 41, 43, 45, 50, 79, 17, 18, 28, 30, 36, 39, 49, 78]","The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application."
206418," static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                        String scriptClassName,
                                                        const char* source,
                                                        size_t size) {
   v8::Isolate* isolate = scriptState->isolate();
   v8::TryCatch block(isolate);
   String sourceString(source, size);
   String fileName = scriptClassName + "".js"";
  
    v8::Local<v8::Context> context = scriptState->context();
    v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
   v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
 
   if (global->HasOwnProperty(context, key).ToChecked()) {
     v8::Local<v8::Value> privateScriptController =
         global->Get(context, key).ToLocalChecked();
     CHECK(privateScriptController->IsObject());
      v8::Local<v8::Object> privateScriptControllerObject =
          privateScriptController.As<v8::Object>();
      v8::Local<v8::Value> importFunctionValue =
         privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
             .ToLocalChecked();
     if (importFunctionValue->IsUndefined()) {
       v8::Local<v8::Function> function;
       if (!v8::FunctionTemplate::New(isolate, importFunction)
                ->GetFunction(context)
                .ToLocal(&function) ||
           !v8CallBoolean(privateScriptControllerObject->Set(
               context, v8String(isolate, ""import""), function))) {
         dumpV8Message(context, block.Message());
         LOG(FATAL)
             << ""Private script error: Setting import function failed. (Class ""
                ""name = ""
             << scriptClassName.utf8().data() << "")"";
       }
     }
   }
 
   v8::Local<v8::Script> script;
   if (!v8Call(V8ScriptRunner::compileScript(
                   v8String(isolate, sourceString), fileName, String(),
                   TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                   nullptr, NotSharableCrossOrigin),
               script, block)) {
     dumpV8Message(context, block.Message());
     LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
                << scriptClassName.utf8().data() << "")"";
   }
 
   v8::Local<v8::Value> result;
   if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
               result, block)) {
     dumpV8Message(context, block.Message());
     LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
                << scriptClassName.utf8().data() << "")"";
   }
   return result;
 }","[18, 19, 20, 21, 22, 23, 12, 13, 14, 15, 16, 17]","Blink in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed attacker controlled JavaScript to be run during the invocation of a private script method, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page."
198501," static int ec_mul_consttime(const EC_GROUP *group, EC_POINT *r,
                             const BIGNUM *scalar, const EC_POINT *point,
                             BN_CTX *ctx)
 {
     int i, cardinality_bits, group_top, kbit, pbit, Z_is_one;
     EC_POINT *s = NULL;
     BIGNUM *k = NULL;
     BIGNUM *lambda = NULL;
     BIGNUM *cardinality = NULL;
     BN_CTX *new_ctx = NULL;
     int ret = 0;
 
     if (ctx == NULL && (ctx = new_ctx = BN_CTX_secure_new()) == NULL)
         return 0;
 
     BN_CTX_start(ctx);
 
     s = EC_POINT_new(group);
     if (s == NULL)
         goto err;
 
     if (point == NULL) {
         if (!EC_POINT_copy(s, group->generator))
             goto err;
     } else {
         if (!EC_POINT_copy(s, point))
             goto err;
     }
 
     EC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);
 
     cardinality = BN_CTX_get(ctx);
     lambda = BN_CTX_get(ctx);
     k = BN_CTX_get(ctx);
     if (k == NULL || !BN_mul(cardinality, group->order, group->cofactor, ctx))
         goto err;
 
      
      cardinality_bits = BN_num_bits(cardinality);
      group_top = bn_get_top(cardinality);
    if ((bn_wexpand(k, group_top + 1) == NULL)
        || (bn_wexpand(lambda, group_top + 1) == NULL))
     if ((bn_wexpand(k, group_top + 2) == NULL)
         || (bn_wexpand(lambda, group_top + 2) == NULL)) {
          goto err;
  
      if (!BN_copy(k, scalar))
         goto err;
 
     BN_set_flags(k, BN_FLG_CONSTTIME);
 
     if ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {
          
         if (!BN_nnmod(k, k, cardinality, ctx))
             goto err;
     }
 
     if (!BN_add(lambda, k, cardinality))
         goto err;
     BN_set_flags(lambda, BN_FLG_CONSTTIME);
     if (!BN_add(k, lambda, cardinality))
         goto err;
      
      kbit = BN_is_bit_set(lambda, cardinality_bits);
    BN_consttime_swap(kbit, k, lambda, group_top + 1);
     BN_consttime_swap(kbit, k, lambda, group_top + 2);
  
      group_top = bn_get_top(group->field);
      if ((bn_wexpand(s->X, group_top) == NULL)
         || (bn_wexpand(s->Y, group_top) == NULL)
         || (bn_wexpand(s->Z, group_top) == NULL)
         || (bn_wexpand(r->X, group_top) == NULL)
         || (bn_wexpand(r->Y, group_top) == NULL)
         || (bn_wexpand(r->Z, group_top) == NULL))
         goto err;
 
      
     if (!ec_point_blind_coordinates(group, s, ctx))
         goto err;
 
      
     if (!EC_POINT_copy(r, s))
         goto err;
 
     EC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);
 
     if (!EC_POINT_dbl(group, s, s, ctx))
         goto err;
 
     pbit = 0;
 
 #define EC_POINT_CSWAP(c, a, b, w, t) do {         \
         BN_consttime_swap(c, (a)->X, (b)->X, w);   \
         BN_consttime_swap(c, (a)->Y, (b)->Y, w);   \
         BN_consttime_swap(c, (a)->Z, (b)->Z, w);   \
         t = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \
         (a)->Z_is_one ^= (t);                      \
         (b)->Z_is_one ^= (t);                      \
 } while(0)
 
      
 
     for (i = cardinality_bits - 1; i >= 0; i--) {
         kbit = BN_is_bit_set(k, i) ^ pbit;
         EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);
         if (!EC_POINT_add(group, s, r, s, ctx))
             goto err;
         if (!EC_POINT_dbl(group, r, r, ctx))
             goto err;
          
         pbit ^= kbit;
     }
      
     EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);
 #undef EC_POINT_CSWAP
 
     ret = 1;
 
  err:
     EC_POINT_free(s);
     BN_CTX_end(ctx);
     BN_CTX_free(new_ctx);
 
     return ret;
 }","[43, 44, 66, 41, 42, 65]",The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.1.1a (Affected 1.1.1).
207191," void AutofillManager::OnQueryFormFieldAutofillImpl(
     int query_id,
     const FormData& form,
     const FormFieldData& field,
     const gfx::RectF& transformed_box,
     bool autoselect_first_suggestion) {
   external_delegate_->OnQuery(query_id, form, field, transformed_box);
 
   std::vector<Suggestion> suggestions;
   SuggestionsContext context;
   GetAvailableSuggestions(form, field, &suggestions, &context);
 
   if (context.is_autofill_available) {
     switch (context.suppress_reason) {
       case SuppressReason::kNotSuppressed:
         break;
 
       case SuppressReason::kCreditCardsAblation:
         enable_ablation_logging_ = true;
         autocomplete_history_manager_->CancelPendingQuery();
         external_delegate_->OnSuggestionsReturned(query_id, suggestions,
                                                   autoselect_first_suggestion);
         return;
 
       case SuppressReason::kAutocompleteOff:
         return;
     }
 
     if (!suggestions.empty()) {
       if (context.is_filling_credit_card) {
         AutofillMetrics::LogIsQueriedCreditCardFormSecure(
             context.is_context_secure);
       }
 
      if (!has_logged_address_suggestions_count_ &&
          !context.section_has_autofilled_field) {
       if (!has_logged_address_suggestions_count_) {
          AutofillMetrics::LogAddressSuggestionsCount(suggestions.size());
          has_logged_address_suggestions_count_ = true;
        }
     }
   }
 
   if (suggestions.empty() && !ShouldShowCreditCardSigninPromo(form, field) &&
       field.should_autocomplete &&
       !(context.focused_field &&
         (IsCreditCardExpirationType(
              context.focused_field->Type().GetStorableType()) ||
          context.focused_field->Type().html_type() == HTML_TYPE_UNRECOGNIZED ||
          context.focused_field->Type().GetStorableType() ==
              CREDIT_CARD_NUMBER ||
          context.focused_field->Type().GetStorableType() ==
              CREDIT_CARD_VERIFICATION_CODE))) {
     autocomplete_history_manager_->OnGetAutocompleteSuggestions(
         query_id, field.name, field.value, field.form_control_type);
     return;
   }
 
   autocomplete_history_manager_->CancelPendingQuery();
   external_delegate_->OnSuggestionsReturned(query_id, suggestions,
                                             autoselect_first_suggestion,
                                             context.is_all_server_suggestions);
 }","[37, 35, 36]",Unsafe handling of credit card details in Autofill in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.
10033,"Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) {
if (t.shape() == TensorShape({})) {
if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) ||
(t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) {
*out = PartialTensorShape();
return OkStatus();
}
return errors::InvalidArgument(
""The only valid scalar shape tensor is the fully unknown shape ""
""specified as -1."");
}
if (t.dtype() == DT_INT32) {
return PartialTensorShape::MakePartialShape(t.vec<int32>().data(),
t.NumElements(), out);
} else if (t.dtype() == DT_INT64) {
return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(),
t.NumElements(), out);
}
return errors::InvalidArgument(
""Expected an int32 or int64 shape tensor; found "",
DataTypeString(t.dtype()));
}",[12],"TensorFlow is an open source platform for machine learning. If `EmptyTensorList` receives an input `element_shape` with more than one dimension, it gives a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit c8ba76d48567aed347508e0552a257641931024d. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
199956," sd2_parse_rsrc_fork (SF_PRIVATE *psf)
 {	SD2_RSRC rsrc ;
 	int k, marker, error = 0 ;
 
 	psf_use_rsrc (psf, SF_TRUE) ;
 
 	memset (&rsrc, 0, sizeof (rsrc)) ;
 
 	rsrc.rsrc_len = psf_get_filelen (psf) ;
 	psf_log_printf (psf, ""Resource length : %d (0x%04X)\n"", rsrc.rsrc_len, rsrc.rsrc_len) ;
 
 	if (rsrc.rsrc_len > SIGNED_SIZEOF (psf->header))
 	{	rsrc.rsrc_data = calloc (1, rsrc.rsrc_len) ;
 		rsrc.need_to_free_rsrc_data = SF_TRUE ;
 		}
 	else
 	{
 		rsrc.rsrc_data = psf->header ;
 		rsrc.need_to_free_rsrc_data = SF_FALSE ;
 		} ;
 
 	 
 	psf_fread (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;
 
 	 
 	psf->headindex = psf->headend = rsrc.rsrc_len ;
 
 	rsrc.data_offset = read_rsrc_int (&rsrc, 0) ;
 	rsrc.map_offset = read_rsrc_int (&rsrc, 4) ;
 	rsrc.data_length = read_rsrc_int (&rsrc, 8) ;
 	rsrc.map_length = read_rsrc_int (&rsrc, 12) ;
 
 	if (rsrc.data_offset == 0x51607 && rsrc.map_offset == 0x20000)
 	{	psf_log_printf (psf, ""Trying offset of 0x52 bytes.\n"") ;
 		rsrc.data_offset = read_rsrc_int (&rsrc, 0x52 + 0) + 0x52 ;
 		rsrc.map_offset = read_rsrc_int (&rsrc, 0x52 + 4) + 0x52 ;
 		rsrc.data_length = read_rsrc_int (&rsrc, 0x52 + 8) ;
 		rsrc.map_length = read_rsrc_int (&rsrc, 0x52 + 12) ;
 		} ;
 
 	psf_log_printf (psf, ""  data offset : 0x%04X\n  map  offset : 0x%04X\n""
 				""  data length : 0x%04X\n  map  length : 0x%04X\n"",
 				rsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length) ;
 
 	if (rsrc.data_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.data_offset (%d, 0x%x) > len\n"", rsrc.data_offset, rsrc.data_offset) ;
 		error = SFE_SD2_BAD_DATA_OFFSET ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
 	if (rsrc.map_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.map_offset > len\n"") ;
 		error = SFE_SD2_BAD_MAP_OFFSET ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
 	if (rsrc.data_length > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.data_length > len\n"") ;
 		error = SFE_SD2_BAD_DATA_LENGTH ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
 	if (rsrc.map_length > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : rsrc.map_length > len\n"") ;
 		error = SFE_SD2_BAD_MAP_LENGTH ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
 	if (rsrc.data_offset + rsrc.data_length != rsrc.map_offset || rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Error : This does not look like a MacOSX resource fork.\n"") ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
 	if (rsrc.map_offset + 28 >= rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad map offset (%d + 28 > %d).\n"", rsrc.map_offset, rsrc.rsrc_len) ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
 	rsrc.string_offset = rsrc.map_offset + read_rsrc_short (&rsrc, rsrc.map_offset + 26) ;
 	if (rsrc.string_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad string offset (%d).\n"", rsrc.string_offset) ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
  
  	rsrc.type_offset = rsrc.map_offset + 30 ;
  
 	if (rsrc.map_offset + 28 > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad map offset.\n"") ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
  	rsrc.type_count = read_rsrc_short (&rsrc, rsrc.map_offset + 28) + 1 ;
  	if (rsrc.type_count < 1)
  	{	psf_log_printf (psf, ""Bad type count.\n"") ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
 
 	rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;
 	if (rsrc.item_offset < 0 || rsrc.item_offset > rsrc.rsrc_len)
 	{	psf_log_printf (psf, ""Bad item offset (%d).\n"", rsrc.item_offset) ;
 		error = SFE_SD2_BAD_RSRC ;
 		goto parse_rsrc_fork_cleanup ;
 		} ;
  
  	rsrc.str_index = -1 ;
  	for (k = 0 ; k < rsrc.type_count ; k ++)
	{	marker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;
 	{	if (rsrc.type_offset + k * 8 > rsrc.rsrc_len)
 		{	psf_log_printf (psf, ""Bad rsrc marker.\n"") ;
 			goto parse_rsrc_fork_cleanup ;
 			} ;
 
 		marker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;
  
  		if (marker == STR_MARKER)
  		{	rsrc.str_index = k ;
 			rsrc.str_count = read_rsrc_short (&rsrc, rsrc.type_offset + k * 8 + 4) + 1 ;
 			error = parse_str_rsrc (psf, &rsrc) ;
 			goto parse_rsrc_fork_cleanup ;
 			} ;
 		} ;
 
 	psf_log_printf (psf, ""No 'STR ' resource.\n"") ;
 	error = SFE_SD2_BAD_RSRC ;
 
 parse_rsrc_fork_cleanup :
 
 	psf_use_rsrc (psf, SF_FALSE) ;
 
 	if (rsrc.need_to_free_rsrc_data)
 		free (rsrc.rsrc_data) ;
 
 	return error ;
 }  ","[90, 91, 92, 93, 94, 112, 113, 114, 115, 116, 117, 111]","The sd2_parse_rsrc_fork function in sd2.c in libsndfile allows attackers to have unspecified impact via vectors related to a (1) map offset or (2) rsrc marker, which triggers an out-of-bounds read."
206853," media::mojom::VideoFrameDataPtr MakeVideoFrameData(
     const scoped_refptr<media::VideoFrame>& input) {
   if (input->metadata()->IsTrue(media::VideoFrameMetadata::END_OF_STREAM)) {
     return media::mojom::VideoFrameData::NewEosData(
         media::mojom::EosVideoFrameData::New());
   }
 
   if (input->storage_type() == media::VideoFrame::STORAGE_MOJO_SHARED_BUFFER) {
      media::MojoSharedBufferVideoFrame* mojo_frame =
          static_cast<media::MojoSharedBufferVideoFrame*>(input.get());
  
      
      
      
      mojo::ScopedSharedBufferHandle dup = mojo_frame->Handle().Clone(
        mojo::SharedBufferHandle::AccessMode::READ_ONLY);
         mojo::SharedBufferHandle::AccessMode::READ_WRITE);
      DCHECK(dup.is_valid());
  
      return media::mojom::VideoFrameData::NewSharedBufferData(
         media::mojom::SharedBufferVideoFrameData::New(
             std::move(dup), mojo_frame->MappedSize(),
             mojo_frame->stride(media::VideoFrame::kYPlane),
             mojo_frame->stride(media::VideoFrame::kUPlane),
             mojo_frame->stride(media::VideoFrame::kVPlane),
             mojo_frame->PlaneOffset(media::VideoFrame::kYPlane),
             mojo_frame->PlaneOffset(media::VideoFrame::kUPlane),
             mojo_frame->PlaneOffset(media::VideoFrame::kVPlane)));
   }
 
   if (input->HasTextures()) {
     std::vector<gpu::MailboxHolder> mailbox_holder(
         media::VideoFrame::kMaxPlanes);
     size_t num_planes = media::VideoFrame::NumPlanes(input->format());
     for (size_t i = 0; i < num_planes; i++)
       mailbox_holder[i] = input->mailbox_holder(i);
     return media::mojom::VideoFrameData::NewMailboxData(
         media::mojom::MailboxVideoFrameData::New(std::move(mailbox_holder)));
   }
 
   NOTREACHED() << ""Unsupported VideoFrame conversion"";
   return nullptr;
 }","[12, 13, 14, 17, 16]",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
207518," static void uipc_check_interrupt_locked(void)
 {
  if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))
 
      {
          char sig_recv = 0;
        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
         TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
      }
  }","[8, 7]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
200982," static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   Image *image, *image2=NULL,
    *rotated_image;
   register Quantum *q;
 
   unsigned int status;
   MATHeader MATLAB_HDR;
   size_t size;
   size_t CellType;
   QuantumInfo *quantum_info;
   ImageInfo *clone_info;
   int i;
   ssize_t ldblk;
   unsigned char *BImgBuff = NULL;
   double MinVal, MaxVal;
   unsigned z, z2;
   unsigned Frames;
   int logging;
   int sample_size;
   MagickOffsetType filepos=0x80;
   BlobInfo *blob;
   size_t one;
 
   unsigned int (*ReadBlobXXXLong)(Image *image);
   unsigned short (*ReadBlobXXXShort)(Image *image);
   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
 
 
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
 
    
   image = AcquireImage(image_info,exception);
 
   status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   clone_info=CloneImageInfo(image_info);
   if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
     {
       image2=ReadMATImageV4(image_info,image,exception);
       if (image2  == NULL)
         goto MATLAB_KO;
       image=image2;
       goto END_OF_READING;
     }
   MATLAB_HDR.Version = ReadBlobLSBShort(image);
   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   if (logging)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
       MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
   if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
   {
     ReadBlobXXXLong = ReadBlobLSBLong;
     ReadBlobXXXShort = ReadBlobLSBShort;
     ReadBlobDoublesXXX = ReadBlobDoublesLSB;
     ReadBlobFloatsXXX = ReadBlobFloatsLSB;
     image->endian = LSBEndian;
   }
   else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
   {
     ReadBlobXXXLong = ReadBlobMSBLong;
     ReadBlobXXXShort = ReadBlobMSBShort;
     ReadBlobDoublesXXX = ReadBlobDoublesMSB;
     ReadBlobFloatsXXX = ReadBlobFloatsMSB;
     image->endian = MSBEndian;
   }
   else
     goto MATLAB_KO;     
 
   if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
 MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   filepos = TellBlob(image);
   while(!EOFBlob(image))  
   {
     Frames = 1;
     (void) SeekBlob(image,filepos,SEEK_SET);
      
 
     MATLAB_HDR.DataType = ReadBlobXXXLong(image);
     if(EOFBlob(image)) break;
     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
     if(EOFBlob(image)) break;
     filepos += MATLAB_HDR.ObjectSize + 4 + 4;
 
     image2 = image;
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
     if(MATLAB_HDR.DataType == miCOMPRESSED)
     {
       image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
       if(image2==NULL) continue;
       MATLAB_HDR.DataType = ReadBlobXXXLong(image2);  
     }
 #endif
 
     if(MATLAB_HDR.DataType!=miMATRIX) continue;   
 
     MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
 
     MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
 
     MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
     if(image!=image2)
       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);   
     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
 
 
     switch(MATLAB_HDR.DimFlag)
     {
       case  8: z2=z=1; break;       
       case 12: z2=z = ReadBlobXXXLong(image2);   
            (void) ReadBlobXXXLong(image2);
          if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
          break;
       case 16: z2=z = ReadBlobXXXLong(image2);   
          if(z!=3 && z!=1)
             ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
          Frames = ReadBlobXXXLong(image2);
          if (Frames == 0)
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
          break;
       default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
     }
 
     MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
 
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
           ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
         MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&     
         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT8_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT16_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT32_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT64_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT64_CLASS)     
       ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
 
     switch (MATLAB_HDR.NameFlag)
     {
       case 0:
         size = ReadBlobXXXLong(image2);   
         size = 4 * (ssize_t) ((size + 3 + 1) / 4);
         (void) SeekBlob(image2, size, SEEK_CUR);
         break;
       case 1:
       case 2:
       case 3:
       case 4:
         (void) ReadBlob(image2, 4, (unsigned char *) &size);  
         break;
       default:
         goto MATLAB_KO;
     }
 
     CellType = ReadBlobXXXLong(image2);     
     if (logging)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""MATLAB_HDR.CellType: %.20g"",(double) CellType);
 
     (void) ReadBlob(image2, 4, (unsigned char *) &size);      
 
     NEXT_FRAME:
     switch (CellType)
     {
       case miINT8:
       case miUINT8:
         sample_size = 8;
         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
           image->depth = 1;
         else
           image->depth = 8;          
         ldblk = (ssize_t) MATLAB_HDR.SizeX;
         break;
       case miINT16:
       case miUINT16:
         sample_size = 16;
         image->depth = 16;         
         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
         break;
       case miINT32:
       case miUINT32:
         sample_size = 32;
         image->depth = 32;         
         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
         break;
       case miINT64:
       case miUINT64:
         sample_size = 64;
         image->depth = 64;         
         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
         break;
       case miSINGLE:
         sample_size = 32;
         image->depth = 32;         
         (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
   {               
   }
         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
         break;
       case miDOUBLE:
         sample_size = 64;
         image->depth = 64;         
         (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
 DisableMSCWarning(4127)
         if (sizeof(double) != 8)
 RestoreMSCWarning
           ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
   {                          
   }
         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
         break;
       default:
         ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
     }
     (void) sample_size;
     image->columns = MATLAB_HDR.SizeX;
     image->rows = MATLAB_HDR.SizeY;
     quantum_info=AcquireQuantumInfo(clone_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     one=1;
     image->colors = one << image->depth;
     if (image->columns == 0 || image->rows == 0)
       goto MATLAB_KO;
      
     if ((MATLAB_HDR.DimFlag == 8) &&
         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
       {
         image->type=GrayscaleType;
         SetImageColorspace(image,GRAYColorspace,exception);
       }
 
 
      
     if (image_info->ping)
     {
       size_t temp = image->columns;
       image->columns = image->rows;
       image->rows = temp;
       goto done_reading;  
     }
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
 
    
      BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));     
      if (BImgBuff == NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
  
      MinVal = 0;
      MaxVal = 0;
     if (CellType==miDOUBLE || CellType==miSINGLE)         
     {
       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
     }
 
      
     if(z==1) z=0;  
      
     do
     {
       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
       {
         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
         if (q == (Quantum *) NULL)
   {
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
     goto done_reading;     
   }
         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
   {
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
     goto ExitLoop;
   }
         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
         {
           FixLogical((unsigned char *)BImgBuff,ldblk);
           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
     {
 ImportQuantumPixelsFailed:
       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
       break;
     }
         }
         else
         {
           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
       goto ImportQuantumPixelsFailed;
 
 
           if (z<=1 &&        
           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
       FixSignedValues(image,q,MATLAB_HDR.SizeX);
         }
 
         if (!SyncAuthenticPixels(image,exception))
   {
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
     goto ExitLoop;
   }
       }
     } while(z-- >= 2);
     quantum_info=DestroyQuantumInfo(quantum_info);
 ExitLoop:
 
 
      
     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
     {         
       CellType = ReadBlobXXXLong(image2);     
       i = ReadBlobXXXLong(image2);            
 
       if (CellType==miDOUBLE || CellType==miSINGLE)
       {
         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
       }
 
       if (CellType==miDOUBLE)
         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
   {
           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
           InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
             exception);
   }
 
       if (CellType==miSINGLE)
         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
   {
           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
           InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
             exception);
   }
     }
 
        
     if ((MATLAB_HDR.DimFlag == 8) &&
         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
       image->type=GrayscaleType;
     if (image->depth == 1)
       image->type=BilevelType;
 
     if(image2==image)
         image2 = NULL;     
 
        
     rotated_image = RotateImage(image, 90.0, exception);
     if (rotated_image != (Image *) NULL)
     {
          
       rotated_image->page.x=0;
       rotated_image->page.y=0;
 
       blob = rotated_image->blob;
       rotated_image->blob = image->blob;
       rotated_image->colors = image->colors;
       image->blob = blob;
       AppendImageToList(&image,rotated_image);
       DeleteImageFromList(&image);
     }
 
 done_reading:
 
     if(image2!=NULL)
       if(image2!=image)
       {
         DeleteImageFromList(&image2);
   if(clone_info)
   {
           if(clone_info->file)
     {
             fclose(clone_info->file);
             clone_info->file = NULL;
             (void) remove_utf8(clone_info->filename);
     }
         }
       }
 
        
     AcquireNextImage(image_info,image,exception);
     if (image->next == (Image *) NULL) break;
     image=SyncNextImageInList(image);
     image->columns=image->rows=0;
     image->colors=0;
 
        
     RelinquishMagickMemory(BImgBuff);
     BImgBuff = NULL;
 
     if(--Frames>0)
     {
       z = z2;
       if(image2==NULL) image2 = image;
       goto NEXT_FRAME;
     }
     if ((image2!=NULL) && (image2!=image))    
       {
  
         DeleteImageFromList(&image2);
         if(clone_info)
         {
           if(clone_info->file)
           {
             fclose(clone_info->file);
             clone_info->file = NULL;
             (void) remove_utf8(clone_info->filename);
           }
         }
         }
   }
 
   RelinquishMagickMemory(BImgBuff);
 END_OF_READING:
   clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
   {
     Image *p;
     ssize_t scene=0;
 
      
     p=image;
     image=NULL;
     while (p != (Image *) NULL)
       {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
           p=p->previous;
         }
       }
 
      
     for (p=image; p != (Image *) NULL; p=p->next)
       p->scene=scene++;
   }
 
   if(clone_info != NULL)   
   {
     if(clone_info->file)
     {
       fclose(clone_info->file);
       clone_info->file = NULL;
       (void) remove_utf8(clone_info->filename);
     }
     DestroyImageInfo(clone_info);
     clone_info = NULL;
   }
   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
   if(image==NULL)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   return (image);
 }",[277],"In ImageMagick before 6.9.7-6 and 7.x before 7.0.4-6, the ReadMATImage function in coders/mat.c uses uninitialized data, which might allow remote attackers to obtain sensitive information from process memory."
201563,"  static int atusb_get_and_show_revision(struct atusb *atusb)
  {
  	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
 	unsigned char *buffer;
  	int ret;
  
 	buffer = kmalloc(3, GFP_KERNEL);
 	if (!buffer)
 		return -ENOMEM;
 
  	 
  	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
  				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
 				buffer, 3, 1000);
 	if (ret >= 0) {
 		atusb->fw_ver_maj = buffer[0];
 		atusb->fw_ver_min = buffer[1];
 		atusb->fw_hw_type = buffer[2];
 
 		dev_info(&usb_dev->dev,
 			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
 			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
 	}
 	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
 		dev_info(&usb_dev->dev,
 			 ""Firmware version (%u.%u) predates our first public release."",
 			 atusb->fw_ver_maj, atusb->fw_ver_min);
  		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
  	}
  
 	kfree(buffer);
  	return ret;
  }","[5, 8, 9, 10, 11, 32, 4]","drivers/net/ieee802154/atusb.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
5770,"rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)
{
rfbClientPtr cl;
rfbServerCutTextMsg sct;
rfbClientIteratorPtr iterator;

iterator = rfbGetClientIterator(rfbScreen);
while ((cl = rfbClientIteratorNext(iterator)) != NULL) {
sct.type = rfbServerCutText;
sct.length = Swap32IfLE(len);
LOCK(cl->sendMutex);
if (rfbWriteExact(cl, (char *)&sct,
sz_rfbServerCutTextMsg) < 0) {
rfbLogPerror(""rfbSendServerCutText: write"");
rfbCloseClient(cl);
UNLOCK(cl->sendMutex);
continue;
}
if (rfbWriteExact(cl, str, len) < 0) {
rfbLogPerror(""rfbSendServerCutText: write"");
rfbCloseClient(cl);
}
UNLOCK(cl->sendMutex);
rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);
}
rfbReleaseClientIterator(iterator);
}",[7],"LibVNC commit before d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a contains a memory leak (CWE-655) in VNC server code, which allow an attacker to read stack memory and can be abused for information disclosure. Combined with another vulnerability, it can be used to leak stack memory and bypass ASLR. This attack appear to be exploitable via network connectivity. These vulnerabilities have been fixed in commit d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a."
202982,"  sec_decrypt(uint8 * data, int length)
  {
 	if (length <= 0)
 		return;
 
  	if (g_sec_decrypt_use_count == 4096)
  	{
  		sec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);
 		rdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);
 		g_sec_decrypt_use_count = 0;
 	}
 
 	rdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);
 	g_sec_decrypt_use_count++;
 }","[3, 4, 5]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.
207473," int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
 {
  struct uinput_event event;
     BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
         type, code, value);
     memset(&event, 0, sizeof(event));
     event.type  = type;
 
      event.code  = code;
      event.value = value;
  
    return write(fd, &event, sizeof(event));
     return TEMP_FAILURE_RETRY(write(fd, &event, sizeof(event)));
  }","[13, 12]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
46,"ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)
{
MonoClass *klass = array->obj.vtable->klass;
guint32 size = mono_array_element_size (klass);
MonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);
int align;
const char *field_data;

if (MONO_TYPE_IS_REFERENCE (type) ||
(type->type == MONO_TYPE_VALUETYPE &&
(!mono_type_get_class (type) ||
mono_type_get_class (type)->has_references))) {
MonoException *exc = mono_get_exception_argument(""array"",
""Cannot initialize array containing references"");
mono_raise_exception (exc);
}

if (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {
MonoException *exc = mono_get_exception_argument(""field_handle"",
""Field doesn't have an RVA"");
mono_raise_exception (exc);
}

size *= array->max_length;
field_data = mono_field_get_data (field_handle);

if (size > mono_type_size (field_handle->type, &align)) {
MonoException *exc = mono_get_exception_argument(""field_handle"",
""Field not large enough to fill array"");
mono_raise_exception (exc);
}

#if G_BYTE_ORDER != G_LITTLE_ENDIAN
#define SWAP(n) {\
	guint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \
	guint ## n *src = (guint ## n *) field_data; \
	guint ## n *end = (guint ## n *)((char*)src + size); \
\
	for (; src < end; data++, src++) { \
		*data = read ## n (src); \
	} \
}



switch (type->type) {
case MONO_TYPE_CHAR:
case MONO_TYPE_I2:
case MONO_TYPE_U2:
SWAP (16);
break;
case MONO_TYPE_I4:
case MONO_TYPE_U4:
case MONO_TYPE_R4:
SWAP (32);
break;
case MONO_TYPE_I8:
case MONO_TYPE_U8:
case MONO_TYPE_R8:
SWAP (64);
break;
default:
memcpy (mono_array_addr (array, char, 0), field_data, size);
break;
}
#else
memcpy (mono_array_addr (array, char, 0), field_data, size);
#ifdef ARM_FPU_FPA
if (klass->element_class->byval_arg.type == MONO_TYPE_R8) {
gint i;
double tmp;
double *data = (double*)mono_array_addr (array, double, 0);

for (i = 0; i < size; i++, data++) {
readr8 (data, &tmp);
*data = tmp;
}
}
#endif
#endif
}","[9, 10, 11, 12, 14]","The RuntimeHelpers.InitializeArray method in metadata/icall.c in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, does not properly restrict data types, which allows remote attackers to modify internal read-only data structures, and cause a denial of service (plugin crash) or corrupt the internal state of the security manager, via a crafted media file, as demonstrated by modifying a C# struct."
203377," static PixelChannels **AcquirePixelThreadSet(const Image *image)
 static PixelChannels **AcquirePixelThreadSet(const Image *images)
  {
   const Image
     *next;
 
    PixelChannels
      **pixels;
  
    register ssize_t
      i;
  
    size_t
     columns,
      number_threads;
  
    number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
   pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,
     sizeof(*pixels));
    if (pixels == (PixelChannels **) NULL)
      return((PixelChannels **) NULL);
    (void) memset(pixels,0,number_threads*sizeof(*pixels));
   columns=images->columns;
   for (next=images; next != (Image *) NULL; next=next->next)
     columns=MagickMax(next->columns,columns);
    for (i=0; i < (ssize_t) number_threads; i++)
    {
      register ssize_t
        j;
  
    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,
      sizeof(**pixels));
     pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));
      if (pixels[i] == (PixelChannels *) NULL)
        return(DestroyPixelThreadSet(pixels));
    for (j=0; j < (ssize_t) image->columns; j++)
     for (j=0; j < (ssize_t) columns; j++)
      {
        register ssize_t
          k;
 
       for (k=0; k < MaxPixelChannels; k++)
         pixels[i][j].channel[k]=0.0;
     }
   }
   return(pixels);
 }","[2, 4, 5, 6, 14, 23, 24, 25, 33, 37, 31, 32, 36]",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling columns.
198553," produce_output()
 {
 	char	*str;
 	FILE	*mailer;
 	MyString subject,szTmp;
 	subject.sprintf(""condor_preen results %s: %d old file%s found"", 
 		my_full_hostname(), BadFiles->number(), 
 		(BadFiles->number() > 1)?""s"":"""");
 
 	if( MailFlag ) {
 		if( (mailer=email_open(PreenAdmin, subject.Value())) == NULL ) {
 			EXCEPT( ""Can't do email_open(\""%s\"", \""%s\"")\n"",PreenAdmin,subject.Value());
 		}
 	} else {
 		mailer = stdout;
         }
  
         szTmp.sprintf(""The condor_preen process has found the following stale condor files on <%s>:\n\n"",  get_local_hostname().Value());
       dprintf(D_ALWAYS, szTmp.Value()); 
        dprintf(D_ALWAYS, ""%s"", szTmp.Value()); 
                 
         if( MailFlag ) {
                 fprintf( mailer, ""\n"" );
               fprintf( mailer, szTmp.Value());
                fprintf( mailer, ""%s"", szTmp.Value());
         }
  
         for( BadFiles->rewind(); (str = BadFiles->next()); ) {
                 szTmp.sprintf(""  %s\n"", str);
               dprintf(D_ALWAYS, szTmp.Value() );
               fprintf( mailer, szTmp.Value() );
                dprintf(D_ALWAYS, ""%s"", szTmp.Value() );
                fprintf( mailer, ""%s"", szTmp.Value() );
         }
  
         if( MailFlag ) {
 		const char *explanation = ""\n\nWhat is condor_preen?\n\n""
 ""The condor_preen tool examines the directories belonging to Condor, and\n""
 ""removes extraneous files and directories which may be left over from Condor\n""
 ""processes which terminated abnormally either due to internal errors or a\n""
 ""system crash.  The directories checked are the LOG, EXECUTE, and SPOOL\n""
 ""directories as defined in the Condor configuration files.  The condor_preen\n""
 ""tool is intended to be run as user root (or user condor) periodically as a\n""
 ""backup method to ensure reasonable file system cleanliness in the face of\n""
 ""errors. This is done automatically by default by the condor_master daemon.\n""
 ""It may also be explicitly invoked on an as needed basis.\n\n""
 ""See the Condor manual section on condor_preen for more details.\n"";
 
 		fprintf( mailer, ""%s\n"", explanation );
 		email_close( mailer );
 	}
 }","[20, 25, 32, 33, 19, 24, 30, 31]","Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors."
206205," bool CSPSource::schemeMatches(const KURL& url) const
  {
      if (m_scheme.isEmpty())
          return m_policy->protocolMatchesSelf(url);
     if (equalIgnoringCase(m_scheme, ""http""))
         return equalIgnoringCase(url.protocol(), ""http"") || equalIgnoringCase(url.protocol(), ""https"");
     if (equalIgnoringCase(m_scheme, ""ws""))
         return equalIgnoringCase(url.protocol(), ""ws"") || equalIgnoringCase(url.protocol(), ""wss"");
      return equalIgnoringCase(url.protocol(), m_scheme);
  }","[5, 6, 7, 8]","The CSPSource::schemeMatches function in WebKit/Source/core/frame/csp/CSPSource.cpp in the Content Security Policy (CSP) implementation in Blink, as used in Google Chrome before 48.0.2564.82, does not apply http policies to https URLs and does not apply ws policies to wss URLs, which makes it easier for remote attackers to determine whether a specific HSTS web site has been visited by reading a CSP report."
207482," int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)
 {
  if(h < 0 || h >= MAX_THREAD)
  {
         APPL_TRACE_ERROR(""invalid bt thread handle:%d"", h);
  return FALSE;
  }
  if(ts[h].cmd_fdw == -1)
  {
         APPL_TRACE_ERROR(""cmd socket is not created. socket thread may not initialized"");
  return FALSE;
  }
  if(flags & SOCK_THREAD_ADD_FD_SYNC)
  {
  if(ts[h].thread_id == pthread_self())
  {
             flags &= ~SOCK_THREAD_ADD_FD_SYNC;
             add_poll(h, fd, type, flags, user_id);
  return TRUE;
  }
         APPL_TRACE_DEBUG(""THREAD_ADD_FD_SYNC is not called in poll thread, fallback to async"");
 
      }
      sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};
      APPL_TRACE_DEBUG(""adding fd:%d, flags:0x%x"", fd, flags);
    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
     return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);
  }","[27, 26]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
203288," static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   Image
     *image;
 
   MagickBooleanType
     has_merged_image,
     skip_layers;
 
   MagickOffsetType
     offset;
 
   MagickSizeType
     length;
 
   MagickBooleanType
     status;
 
   PSDInfo
     psd_info;
 
   register ssize_t
     i;
 
   ssize_t
     count;
 
   unsigned char
     *data;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
 
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   image->endian=MSBEndian;
   count=ReadBlob(image,4,(unsigned char *) psd_info.signature);
   psd_info.version=ReadBlobMSBShort(image);
   if ((count == 0) || (LocaleNCompare(psd_info.signature,""8BPS"",4) != 0) ||
       ((psd_info.version != 1) && (psd_info.version != 2)))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   (void) ReadBlob(image,6,psd_info.reserved);
   psd_info.channels=ReadBlobMSBShort(image);
   if (psd_info.channels > MaxPSDChannels)
     ThrowReaderException(CorruptImageError,""MaximumChannelsExceeded"");
   psd_info.rows=ReadBlobMSBLong(image);
   psd_info.columns=ReadBlobMSBLong(image);
   if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||
       (psd_info.columns > 30000)))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   psd_info.depth=ReadBlobMSBShort(image);
   if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   psd_info.mode=ReadBlobMSBShort(image);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s"",
       (double) psd_info.columns,(double) psd_info.rows,(double)
       psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)
       psd_info.mode));
    
   image->depth=psd_info.depth;
   image->columns=psd_info.columns;
   image->rows=psd_info.rows;
   status=SetImageExtent(image,image->columns,image->rows,exception);
   if (status == MagickFalse)
     return(DestroyImageList(image));
   if (SetImageBackgroundColor(image,exception) == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   if (psd_info.mode == LabMode)
     SetImageColorspace(image,LabColorspace,exception);
   if (psd_info.mode == CMYKMode)
     {
       SetImageColorspace(image,CMYKColorspace,exception);
       image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :
         UndefinedPixelTrait;
     }
   else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||
       (psd_info.mode == DuotoneMode))
     {
       status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,
         exception);
       if (status == MagickFalse)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  Image colormap allocated"");
       SetImageColorspace(image,GRAYColorspace,exception);
       image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :
         UndefinedPixelTrait;
     }
   else
     image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :
       UndefinedPixelTrait;
    
   length=ReadBlobMSBLong(image);
   if (length != 0)
     {
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  reading colormap"");
       if (psd_info.mode == DuotoneMode)
         {
            
           data=(unsigned char *) AcquireQuantumMemory((size_t) length,
             sizeof(*data));
           if (data == (unsigned char *) NULL)
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           (void) ReadBlob(image,(size_t) length,data);
           data=(unsigned char *) RelinquishMagickMemory(data);
         }
       else
         {
           size_t
             number_colors;
 
            
           number_colors=length/3;
           if (number_colors > 65536)
             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           for (i=0; i < (ssize_t) image->colors; i++)
             image->colormap[i].red=ScaleCharToQuantum((unsigned char)
               ReadBlobByte(image));
           for (i=0; i < (ssize_t) image->colors; i++)
             image->colormap[i].green=ScaleCharToQuantum((unsigned char)
               ReadBlobByte(image));
           for (i=0; i < (ssize_t) image->colors; i++)
             image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
               ReadBlobByte(image));
            image->alpha_trait=UndefinedPixelTrait;
          }
      }
   if ((image->depth == 1) && (image->storage_class != PseudoClass))
     ThrowReaderException(CorruptImageError, ""ImproperImageHeader"");
    has_merged_image=MagickTrue;
    length=ReadBlobMSBLong(image);
    if (length != 0)
     {
       unsigned char
         *blocks;
 
        
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  reading image resource blocks - %.20g bytes"",(double)
           ((MagickOffsetType) length));
       blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,
         sizeof(*blocks));
       if (blocks == (unsigned char *) NULL)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       count=ReadBlob(image,(size_t) length,blocks);
       if ((count != (ssize_t) length) ||
           (LocaleNCompare((char *) blocks,""8BIM"",4) != 0))
         {
           blocks=(unsigned char *) RelinquishMagickMemory(blocks);
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         }
       ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,
         exception);
       blocks=(unsigned char *) RelinquishMagickMemory(blocks);
     }
    
   length=GetPSDSize(&psd_info,image);
   if (length == 8)
     {
       length=ReadBlobMSBLong(image);
       length=ReadBlobMSBLong(image);
     }
   offset=TellBlob(image);
   skip_layers=MagickFalse;
   if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&
       (has_merged_image != MagickFalse))
     {
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  read composite only"");
       skip_layers=MagickTrue;
     }
   if (length == 0)
     {
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  image has no layers"");
     }
   else
     {
       if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=
           MagickTrue)
         {
           (void) CloseBlob(image);
           image=DestroyImageList(image);
           return((Image *) NULL);
         }
 
        
       SeekBlob(image,offset+length,SEEK_SET);
     }
    
   if (image_info->ping != MagickFalse)
     {
       (void) CloseBlob(image);
       return(GetFirstImageInList(image));
     }
    
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""  reading the precombined layer"");
   if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))
     has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,
       &psd_info,exception);
   if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&
       (length != 0))
     {
       SeekBlob(image,offset,SEEK_SET);
       status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);
       if (status != MagickTrue)
         {
           (void) CloseBlob(image);
           image=DestroyImageList(image);
           return((Image *) NULL);
         }
     }
   if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))
     {
       Image
         *merged;
 
       SetImageAlphaChannel(image,TransparentAlphaChannel,exception);
       image->background_color.alpha=TransparentAlpha;
       image->background_color.alpha_trait=BlendPixelTrait;
       merged=MergeImageLayers(image,FlattenLayer,exception);
       ReplaceImageInList(&image,merged);
     }
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[150, 151]",The ReadPSDChannelPixels function in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
201377," static target_ulong disas_insn(CPUX86State *env, DisasContext *s,
                                target_ulong pc_start)
 {
     int b, prefixes;
     int shift;
     TCGMemOp ot, aflag, dflag;
     int modrm, reg, rm, mod, op, opreg, val;
     target_ulong next_eip, tval;
     int rex_w, rex_r;
 
     s->pc_start = s->pc = pc_start;
     prefixes = 0;
     s->override = -1;
     rex_w = -1;
     rex_r = 0;
 #ifdef TARGET_X86_64
     s->rex_x = 0;
     s->rex_b = 0;
     x86_64_hregs = 0;
 #endif
     s->rip_offset = 0;  
      s->vex_l = 0;
      s->vex_v = 0;
   next_byte:
      
     if (s->pc - pc_start > 14) {
         goto illegal_op;
     }
      b = cpu_ldub_code(env, s->pc);
      s->pc++;
       
     switch (b) {
     case 0xf3:
         prefixes |= PREFIX_REPZ;
         goto next_byte;
     case 0xf2:
         prefixes |= PREFIX_REPNZ;
         goto next_byte;
     case 0xf0:
         prefixes |= PREFIX_LOCK;
         goto next_byte;
     case 0x2e:
         s->override = R_CS;
         goto next_byte;
     case 0x36:
         s->override = R_SS;
         goto next_byte;
     case 0x3e:
         s->override = R_DS;
         goto next_byte;
     case 0x26:
         s->override = R_ES;
         goto next_byte;
     case 0x64:
         s->override = R_FS;
         goto next_byte;
     case 0x65:
         s->override = R_GS;
         goto next_byte;
     case 0x66:
         prefixes |= PREFIX_DATA;
         goto next_byte;
     case 0x67:
         prefixes |= PREFIX_ADR;
         goto next_byte;
 #ifdef TARGET_X86_64
     case 0x40 ... 0x4f:
         if (CODE64(s)) {
              
             rex_w = (b >> 3) & 1;
             rex_r = (b & 0x4) << 1;
             s->rex_x = (b & 0x2) << 2;
             REX_B(s) = (b & 0x1) << 3;
             x86_64_hregs = 1;  
             goto next_byte;
         }
         break;
 #endif
     case 0xc5:  
     case 0xc4:  
          
         if (s->code32 && !s->vm86) {
             static const int pp_prefix[4] = {
                 0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ
             };
             int vex3, vex2 = cpu_ldub_code(env, s->pc);
 
             if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {
                  
                 break;
             }
             s->pc++;
 
              
             if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ
                             | PREFIX_LOCK | PREFIX_DATA)) {
                 goto illegal_op;
             }
 #ifdef TARGET_X86_64
             if (x86_64_hregs) {
                 goto illegal_op;
             }
 #endif
             rex_r = (~vex2 >> 4) & 8;
             if (b == 0xc5) {
                 vex3 = vex2;
                 b = cpu_ldub_code(env, s->pc++);
             } else {
 #ifdef TARGET_X86_64
                 s->rex_x = (~vex2 >> 3) & 8;
                 s->rex_b = (~vex2 >> 2) & 8;
 #endif
                 vex3 = cpu_ldub_code(env, s->pc++);
                 rex_w = (vex3 >> 7) & 1;
                 switch (vex2 & 0x1f) {
                 case 0x01:  
                     b = cpu_ldub_code(env, s->pc++) | 0x100;
                     break;
                 case 0x02:  
                     b = 0x138;
                     break;
                 case 0x03:  
                     b = 0x13a;
                     break;
                 default:    
                     goto unknown_op;
                 }
             }
             s->vex_v = (~vex3 >> 3) & 0xf;
             s->vex_l = (vex3 >> 2) & 1;
             prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;
         }
         break;
     }
 
      
     if (CODE64(s)) {
          
         dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);
          
         aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);
     } else {
          
         if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {
             dflag = MO_32;
         } else {
             dflag = MO_16;
         }
          
         if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {
             aflag = MO_32;
         }  else {
             aflag = MO_16;
         }
     }
 
     s->prefix = prefixes;
     s->aflag = aflag;
     s->dflag = dflag;
 
      
  reswitch:
     switch(b) {
     case 0x0f:
          
          
         b = cpu_ldub_code(env, s->pc++) | 0x100;
         goto reswitch;
 
          
          
     case 0x00 ... 0x05:
     case 0x08 ... 0x0d:
     case 0x10 ... 0x15:
     case 0x18 ... 0x1d:
     case 0x20 ... 0x25:
     case 0x28 ... 0x2d:
     case 0x30 ... 0x35:
     case 0x38 ... 0x3d:
         {
             int op, f, val;
             op = (b >> 3) & 7;
             f = (b >> 1) & 3;
 
             ot = mo_b_d(b, dflag);
 
             switch(f) {
             case 0:  
                 modrm = cpu_ldub_code(env, s->pc++);
                 reg = ((modrm >> 3) & 7) | rex_r;
                 mod = (modrm >> 6) & 3;
                 rm = (modrm & 7) | REX_B(s);
                 if (mod != 3) {
                     gen_lea_modrm(env, s, modrm);
                     opreg = OR_TMP0;
                 } else if (op == OP_XORL && rm == reg) {
                 xor_zero:
                      
                     set_cc_op(s, CC_OP_CLR);
                     tcg_gen_movi_tl(cpu_T0, 0);
                     gen_op_mov_reg_v(ot, reg, cpu_T0);
                     break;
                 } else {
                     opreg = rm;
                 }
                 gen_op_mov_v_reg(ot, cpu_T1, reg);
                 gen_op(s, op, ot, opreg);
                 break;
             case 1:  
                 modrm = cpu_ldub_code(env, s->pc++);
                 mod = (modrm >> 6) & 3;
                 reg = ((modrm >> 3) & 7) | rex_r;
                 rm = (modrm & 7) | REX_B(s);
                 if (mod != 3) {
                     gen_lea_modrm(env, s, modrm);
                     gen_op_ld_v(s, ot, cpu_T1, cpu_A0);
                 } else if (op == OP_XORL && rm == reg) {
                     goto xor_zero;
                 } else {
                     gen_op_mov_v_reg(ot, cpu_T1, rm);
                 }
                 gen_op(s, op, ot, reg);
                 break;
             case 2:  
                 val = insn_get(env, s, ot);
                 tcg_gen_movi_tl(cpu_T1, val);
                 gen_op(s, op, ot, OR_EAX);
                 break;
             }
         }
         break;
 
     case 0x82:
         if (CODE64(s))
             goto illegal_op;
     case 0x80:  
     case 0x81:
     case 0x83:
         {
             int val;
 
             ot = mo_b_d(b, dflag);
 
             modrm = cpu_ldub_code(env, s->pc++);
             mod = (modrm >> 6) & 3;
             rm = (modrm & 7) | REX_B(s);
             op = (modrm >> 3) & 7;
 
             if (mod != 3) {
                 if (b == 0x83)
                     s->rip_offset = 1;
                 else
                     s->rip_offset = insn_const_size(ot);
                 gen_lea_modrm(env, s, modrm);
                 opreg = OR_TMP0;
             } else {
                 opreg = rm;
             }
 
             switch(b) {
             default:
             case 0x80:
             case 0x81:
             case 0x82:
                 val = insn_get(env, s, ot);
                 break;
             case 0x83:
                 val = (int8_t)insn_get(env, s, MO_8);
                 break;
             }
             tcg_gen_movi_tl(cpu_T1, val);
             gen_op(s, op, ot, opreg);
         }
         break;
 
          
          
     case 0x40 ... 0x47:  
         ot = dflag;
         gen_inc(s, ot, OR_EAX + (b & 7), 1);
         break;
     case 0x48 ... 0x4f:  
         ot = dflag;
         gen_inc(s, ot, OR_EAX + (b & 7), -1);
         break;
     case 0xf6:  
     case 0xf7:
         ot = mo_b_d(b, dflag);
 
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         rm = (modrm & 7) | REX_B(s);
         op = (modrm >> 3) & 7;
         if (mod != 3) {
             if (op == 0) {
                 s->rip_offset = insn_const_size(ot);
             }
             gen_lea_modrm(env, s, modrm);
              
             if (!(s->prefix & PREFIX_LOCK)
                 || op != 2) {
                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);
             }
         } else {
             gen_op_mov_v_reg(ot, cpu_T0, rm);
         }
 
         switch(op) {
         case 0:  
             val = insn_get(env, s, ot);
             tcg_gen_movi_tl(cpu_T1, val);
             gen_op_testl_T0_T1_cc();
             set_cc_op(s, CC_OP_LOGICB + ot);
             break;
         case 2:  
             if (s->prefix & PREFIX_LOCK) {
                 if (mod == 3) {
                     goto illegal_op;
                 }
                 tcg_gen_movi_tl(cpu_T0, ~0);
                 tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,
                                             s->mem_index, ot | MO_LE);
             } else {
                 tcg_gen_not_tl(cpu_T0, cpu_T0);
                 if (mod != 3) {
                     gen_op_st_v(s, ot, cpu_T0, cpu_A0);
                 } else {
                     gen_op_mov_reg_v(ot, rm, cpu_T0);
                 }
             }
             break;
         case 3:  
             if (s->prefix & PREFIX_LOCK) {
                 TCGLabel *label1;
                 TCGv a0, t0, t1, t2;
 
                 if (mod == 3) {
                     goto illegal_op;
                 }
                 a0 = tcg_temp_local_new();
                 t0 = tcg_temp_local_new();
                 label1 = gen_new_label();
 
                 tcg_gen_mov_tl(a0, cpu_A0);
                 tcg_gen_mov_tl(t0, cpu_T0);
 
                 gen_set_label(label1);
                 t1 = tcg_temp_new();
                 t2 = tcg_temp_new();
                 tcg_gen_mov_tl(t2, t0);
                 tcg_gen_neg_tl(t1, t0);
                 tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,
                                           s->mem_index, ot | MO_LE);
                 tcg_temp_free(t1);
                 tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);
 
                 tcg_temp_free(t2);
                 tcg_temp_free(a0);
                 tcg_gen_mov_tl(cpu_T0, t0);
                 tcg_temp_free(t0);
             } else {
                 tcg_gen_neg_tl(cpu_T0, cpu_T0);
                 if (mod != 3) {
                     gen_op_st_v(s, ot, cpu_T0, cpu_A0);
                 } else {
                     gen_op_mov_reg_v(ot, rm, cpu_T0);
                 }
             }
             gen_op_update_neg_cc();
             set_cc_op(s, CC_OP_SUBB + ot);
             break;
         case 4:  
             switch(ot) {
             case MO_8:
                 gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);
                 tcg_gen_ext8u_tl(cpu_T0, cpu_T0);
                 tcg_gen_ext8u_tl(cpu_T1, cpu_T1);
                  
                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);
                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);
                 tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);
                 set_cc_op(s, CC_OP_MULB);
                 break;
             case MO_16:
                 gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);
                 tcg_gen_ext16u_tl(cpu_T0, cpu_T0);
                 tcg_gen_ext16u_tl(cpu_T1, cpu_T1);
                  
                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);
                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);
                 tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);
                 gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);
                 tcg_gen_mov_tl(cpu_cc_src, cpu_T0);
                 set_cc_op(s, CC_OP_MULW);
                 break;
             default:
             case MO_32:
                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
                 tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);
                 tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,
                                   cpu_tmp2_i32, cpu_tmp3_i32);
                 tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);
                 tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);
                 tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);
                 set_cc_op(s, CC_OP_MULL);
                 break;
 #ifdef TARGET_X86_64
             case MO_64:
                 tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],
                                   cpu_T0, cpu_regs[R_EAX]);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);
                 tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);
                 set_cc_op(s, CC_OP_MULQ);
                 break;
 #endif
             }
             break;
         case 5:  
             switch(ot) {
             case MO_8:
                 gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);
                 tcg_gen_ext8s_tl(cpu_T0, cpu_T0);
                 tcg_gen_ext8s_tl(cpu_T1, cpu_T1);
                  
                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);
                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);
                 tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);
                 tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);
                 set_cc_op(s, CC_OP_MULB);
                 break;
             case MO_16:
                 gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);
                 tcg_gen_ext16s_tl(cpu_T0, cpu_T0);
                 tcg_gen_ext16s_tl(cpu_T1, cpu_T1);
                  
                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);
                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);
                 tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);
                 tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);
                 tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);
                 gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);
                 set_cc_op(s, CC_OP_MULW);
                 break;
             default:
             case MO_32:
                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
                 tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);
                 tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,
                                   cpu_tmp2_i32, cpu_tmp3_i32);
                 tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);
                 tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);
                 tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);
                 tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);
                 tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);
                 set_cc_op(s, CC_OP_MULL);
                 break;
 #ifdef TARGET_X86_64
             case MO_64:
                 tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],
                                   cpu_T0, cpu_regs[R_EAX]);
                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);
                 tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);
                 tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);
                 set_cc_op(s, CC_OP_MULQ);
                 break;
 #endif
             }
             break;
         case 6:  
             switch(ot) {
             case MO_8:
                 gen_helper_divb_AL(cpu_env, cpu_T0);
                 break;
             case MO_16:
                 gen_helper_divw_AX(cpu_env, cpu_T0);
                 break;
             default:
             case MO_32:
                 gen_helper_divl_EAX(cpu_env, cpu_T0);
                 break;
 #ifdef TARGET_X86_64
             case MO_64:
                 gen_helper_divq_EAX(cpu_env, cpu_T0);
                 break;
 #endif
             }
             break;
         case 7:  
             switch(ot) {
             case MO_8:
                 gen_helper_idivb_AL(cpu_env, cpu_T0);
                 break;
             case MO_16:
                 gen_helper_idivw_AX(cpu_env, cpu_T0);
                 break;
             default:
             case MO_32:
                 gen_helper_idivl_EAX(cpu_env, cpu_T0);
                 break;
 #ifdef TARGET_X86_64
             case MO_64:
                 gen_helper_idivq_EAX(cpu_env, cpu_T0);
                 break;
 #endif
             }
             break;
         default:
             goto unknown_op;
         }
         break;
 
     case 0xfe:  
     case 0xff:  
         ot = mo_b_d(b, dflag);
 
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         rm = (modrm & 7) | REX_B(s);
         op = (modrm >> 3) & 7;
         if (op >= 2 && b == 0xfe) {
             goto unknown_op;
         }
         if (CODE64(s)) {
             if (op == 2 || op == 4) {
                  
                 ot = MO_64;
             } else if (op == 3 || op == 5) {
                 ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;
             } else if (op == 6) {
                  
                 ot = mo_pushpop(s, dflag);
             }
         }
         if (mod != 3) {
             gen_lea_modrm(env, s, modrm);
             if (op >= 2 && op != 3 && op != 5)
                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);
         } else {
             gen_op_mov_v_reg(ot, cpu_T0, rm);
         }
 
         switch(op) {
         case 0:  
             if (mod != 3)
                 opreg = OR_TMP0;
             else
                 opreg = rm;
             gen_inc(s, ot, opreg, 1);
             break;
         case 1:  
             if (mod != 3)
                 opreg = OR_TMP0;
             else
                 opreg = rm;
             gen_inc(s, ot, opreg, -1);
             break;
         case 2:  
              
             if (dflag == MO_16) {
                 tcg_gen_ext16u_tl(cpu_T0, cpu_T0);
             }
             next_eip = s->pc - s->cs_base;
             tcg_gen_movi_tl(cpu_T1, next_eip);
             gen_push_v(s, cpu_T1);
             gen_op_jmp_v(cpu_T0);
             gen_bnd_jmp(s);
             gen_eob(s);
             break;
         case 3:  
             gen_op_ld_v(s, ot, cpu_T1, cpu_A0);
             gen_add_A0_im(s, 1 << ot);
             gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);
         do_lcall:
             if (s->pe && !s->vm86) {
                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
                 gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,
                                            tcg_const_i32(dflag - 1),
                                            tcg_const_tl(s->pc - s->cs_base));
             } else {
                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
                 gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,
                                       tcg_const_i32(dflag - 1),
                                       tcg_const_i32(s->pc - s->cs_base));
             }
             gen_eob(s);
             break;
         case 4:  
             if (dflag == MO_16) {
                 tcg_gen_ext16u_tl(cpu_T0, cpu_T0);
             }
             gen_op_jmp_v(cpu_T0);
             gen_bnd_jmp(s);
             gen_eob(s);
             break;
         case 5:  
             gen_op_ld_v(s, ot, cpu_T1, cpu_A0);
             gen_add_A0_im(s, 1 << ot);
             gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);
         do_ljmp:
             if (s->pe && !s->vm86) {
                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
                 gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,
                                           tcg_const_tl(s->pc - s->cs_base));
             } else {
                 gen_op_movl_seg_T0_vm(R_CS);
                 gen_op_jmp_v(cpu_T1);
             }
             gen_eob(s);
             break;
         case 6:  
             gen_push_v(s, cpu_T0);
             break;
         default:
             goto unknown_op;
         }
         break;
 
     case 0x84:  
     case 0x85:
         ot = mo_b_d(b, dflag);
 
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
 
         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);
         gen_op_mov_v_reg(ot, cpu_T1, reg);
         gen_op_testl_T0_T1_cc();
         set_cc_op(s, CC_OP_LOGICB + ot);
         break;
 
     case 0xa8:  
     case 0xa9:
         ot = mo_b_d(b, dflag);
         val = insn_get(env, s, ot);
 
         gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);
         tcg_gen_movi_tl(cpu_T1, val);
         gen_op_testl_T0_T1_cc();
         set_cc_op(s, CC_OP_LOGICB + ot);
         break;
 
     case 0x98:  
         switch (dflag) {
 #ifdef TARGET_X86_64
         case MO_64:
             gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);
             tcg_gen_ext32s_tl(cpu_T0, cpu_T0);
             gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);
             break;
 #endif
         case MO_32:
             gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);
             tcg_gen_ext16s_tl(cpu_T0, cpu_T0);
             gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);
             break;
         case MO_16:
             gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);
             tcg_gen_ext8s_tl(cpu_T0, cpu_T0);
             gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);
             break;
         default:
             tcg_abort();
         }
         break;
     case 0x99:  
         switch (dflag) {
 #ifdef TARGET_X86_64
         case MO_64:
             gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);
             tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);
             gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);
             break;
 #endif
         case MO_32:
             gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);
             tcg_gen_ext32s_tl(cpu_T0, cpu_T0);
             tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);
             gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);
             break;
         case MO_16:
             gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);
             tcg_gen_ext16s_tl(cpu_T0, cpu_T0);
             tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);
             gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);
             break;
         default:
             tcg_abort();
         }
         break;
     case 0x1af:  
     case 0x69:  
     case 0x6b:
         ot = dflag;
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
         if (b == 0x69)
             s->rip_offset = insn_const_size(ot);
         else if (b == 0x6b)
             s->rip_offset = 1;
         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);
         if (b == 0x69) {
             val = insn_get(env, s, ot);
             tcg_gen_movi_tl(cpu_T1, val);
         } else if (b == 0x6b) {
             val = (int8_t)insn_get(env, s, MO_8);
             tcg_gen_movi_tl(cpu_T1, val);
         } else {
             gen_op_mov_v_reg(ot, cpu_T1, reg);
         }
         switch (ot) {
 #ifdef TARGET_X86_64
         case MO_64:
             tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);
             tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);
             tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);
             tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);
             break;
 #endif
         case MO_32:
             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
             tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);
             tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,
                               cpu_tmp2_i32, cpu_tmp3_i32);
             tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);
             tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);
             tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);
             tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);
             tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);
             break;
         default:
             tcg_gen_ext16s_tl(cpu_T0, cpu_T0);
             tcg_gen_ext16s_tl(cpu_T1, cpu_T1);
              
             tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);
             tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);
             tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);
             tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);
             gen_op_mov_reg_v(ot, reg, cpu_T0);
             break;
         }
         set_cc_op(s, CC_OP_MULB + ot);
         break;
     case 0x1c0:
     case 0x1c1:  
         ot = mo_b_d(b, dflag);
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
         mod = (modrm >> 6) & 3;
         gen_op_mov_v_reg(ot, cpu_T0, reg);
         if (mod == 3) {
             rm = (modrm & 7) | REX_B(s);
             gen_op_mov_v_reg(ot, cpu_T1, rm);
             tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);
             gen_op_mov_reg_v(ot, reg, cpu_T1);
             gen_op_mov_reg_v(ot, rm, cpu_T0);
         } else {
             gen_lea_modrm(env, s, modrm);
             if (s->prefix & PREFIX_LOCK) {
                 tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,
                                             s->mem_index, ot | MO_LE);
                 tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);
             } else {
                 gen_op_ld_v(s, ot, cpu_T1, cpu_A0);
                 tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);
                 gen_op_st_v(s, ot, cpu_T0, cpu_A0);
             }
             gen_op_mov_reg_v(ot, reg, cpu_T1);
         }
         gen_op_update2_cc();
         set_cc_op(s, CC_OP_ADDB + ot);
         break;
     case 0x1b0:
     case 0x1b1:  
         {
             TCGv oldv, newv, cmpv;
 
             ot = mo_b_d(b, dflag);
             modrm = cpu_ldub_code(env, s->pc++);
             reg = ((modrm >> 3) & 7) | rex_r;
             mod = (modrm >> 6) & 3;
             oldv = tcg_temp_new();
             newv = tcg_temp_new();
             cmpv = tcg_temp_new();
             gen_op_mov_v_reg(ot, newv, reg);
             tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);
 
             if (s->prefix & PREFIX_LOCK) {
                 if (mod == 3) {
                     goto illegal_op;
                 }
                 gen_lea_modrm(env, s, modrm);
                 tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,
                                           s->mem_index, ot | MO_LE);
                 gen_op_mov_reg_v(ot, R_EAX, oldv);
             } else {
                 if (mod == 3) {
                     rm = (modrm & 7) | REX_B(s);
                     gen_op_mov_v_reg(ot, oldv, rm);
                 } else {
                     gen_lea_modrm(env, s, modrm);
                     gen_op_ld_v(s, ot, oldv, cpu_A0);
                     rm = 0;  
                 }
                 gen_extu(ot, oldv);
                 gen_extu(ot, cmpv);
                  
                 tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);
                 if (mod == 3) {
                     gen_op_mov_reg_v(ot, R_EAX, oldv);
                     gen_op_mov_reg_v(ot, rm, newv);
                 } else {
                      
                     gen_op_st_v(s, ot, newv, cpu_A0);
                     gen_op_mov_reg_v(ot, R_EAX, oldv);
                 }
             }
             tcg_gen_mov_tl(cpu_cc_src, oldv);
             tcg_gen_mov_tl(cpu_cc_srcT, cmpv);
             tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);
             set_cc_op(s, CC_OP_SUBB + ot);
             tcg_temp_free(oldv);
             tcg_temp_free(newv);
             tcg_temp_free(cmpv);
         }
         break;
     case 0x1c7:  
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         if ((mod == 3) || ((modrm & 0x38) != 0x8))
             goto illegal_op;
 #ifdef TARGET_X86_64
         if (dflag == MO_64) {
             if (!(s->cpuid_ext_features & CPUID_EXT_CX16))
                 goto illegal_op;
             gen_lea_modrm(env, s, modrm);
             if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {
                 gen_helper_cmpxchg16b(cpu_env, cpu_A0);
             } else {
                 gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);
             }
         } else
 #endif        
         {
             if (!(s->cpuid_features & CPUID_CX8))
                 goto illegal_op;
             gen_lea_modrm(env, s, modrm);
             if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {
                 gen_helper_cmpxchg8b(cpu_env, cpu_A0);
             } else {
                 gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);
             }
         }
         set_cc_op(s, CC_OP_EFLAGS);
         break;
 
          
          
     case 0x50 ... 0x57:  
         gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));
         gen_push_v(s, cpu_T0);
         break;
     case 0x58 ... 0x5f:  
         ot = gen_pop_T0(s);
          
         gen_pop_update(s, ot);
         gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);
         break;
     case 0x60:  
         if (CODE64(s))
             goto illegal_op;
         gen_pusha(s);
         break;
     case 0x61:  
         if (CODE64(s))
             goto illegal_op;
         gen_popa(s);
         break;
     case 0x68:  
     case 0x6a:
         ot = mo_pushpop(s, dflag);
         if (b == 0x68)
             val = insn_get(env, s, ot);
         else
             val = (int8_t)insn_get(env, s, MO_8);
         tcg_gen_movi_tl(cpu_T0, val);
         gen_push_v(s, cpu_T0);
         break;
     case 0x8f:  
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         ot = gen_pop_T0(s);
         if (mod == 3) {
              
             gen_pop_update(s, ot);
             rm = (modrm & 7) | REX_B(s);
             gen_op_mov_reg_v(ot, rm, cpu_T0);
         } else {
              
             s->popl_esp_hack = 1 << ot;
             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);
             s->popl_esp_hack = 0;
             gen_pop_update(s, ot);
         }
         break;
     case 0xc8:  
         {
             int level;
             val = cpu_lduw_code(env, s->pc);
             s->pc += 2;
             level = cpu_ldub_code(env, s->pc++);
             gen_enter(s, val, level);
         }
         break;
     case 0xc9:  
         gen_leave(s);
         break;
     case 0x06:  
     case 0x0e:  
     case 0x16:  
     case 0x1e:  
         if (CODE64(s))
             goto illegal_op;
         gen_op_movl_T0_seg(b >> 3);
         gen_push_v(s, cpu_T0);
         break;
     case 0x1a0:  
     case 0x1a8:  
         gen_op_movl_T0_seg((b >> 3) & 7);
         gen_push_v(s, cpu_T0);
         break;
     case 0x07:  
     case 0x17:  
     case 0x1f:  
         if (CODE64(s))
             goto illegal_op;
         reg = b >> 3;
         ot = gen_pop_T0(s);
         gen_movl_seg_T0(s, reg);
         gen_pop_update(s, ot);
          
         if (s->is_jmp) {
             gen_jmp_im(s->pc - s->cs_base);
             if (reg == R_SS) {
                 s->tf = 0;
                 gen_eob_inhibit_irq(s, true);
             } else {
                 gen_eob(s);
             }
         }
         break;
     case 0x1a1:  
     case 0x1a9:  
         ot = gen_pop_T0(s);
         gen_movl_seg_T0(s, (b >> 3) & 7);
         gen_pop_update(s, ot);
         if (s->is_jmp) {
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
         }
         break;
 
          
          
     case 0x88:
     case 0x89:  
         ot = mo_b_d(b, dflag);
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
 
          
         gen_ldst_modrm(env, s, modrm, ot, reg, 1);
         break;
     case 0xc6:
     case 0xc7:  
         ot = mo_b_d(b, dflag);
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         if (mod != 3) {
             s->rip_offset = insn_const_size(ot);
             gen_lea_modrm(env, s, modrm);
         }
         val = insn_get(env, s, ot);
         tcg_gen_movi_tl(cpu_T0, val);
         if (mod != 3) {
             gen_op_st_v(s, ot, cpu_T0, cpu_A0);
         } else {
             gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);
         }
         break;
     case 0x8a:
     case 0x8b:  
         ot = mo_b_d(b, dflag);
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
 
         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);
         gen_op_mov_reg_v(ot, reg, cpu_T0);
         break;
     case 0x8e:  
         modrm = cpu_ldub_code(env, s->pc++);
         reg = (modrm >> 3) & 7;
         if (reg >= 6 || reg == R_CS)
             goto illegal_op;
         gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);
         gen_movl_seg_T0(s, reg);
          
         if (s->is_jmp) {
             gen_jmp_im(s->pc - s->cs_base);
             if (reg == R_SS) {
                 s->tf = 0;
                 gen_eob_inhibit_irq(s, true);
             } else {
                 gen_eob(s);
             }
         }
         break;
     case 0x8c:  
         modrm = cpu_ldub_code(env, s->pc++);
         reg = (modrm >> 3) & 7;
         mod = (modrm >> 6) & 3;
         if (reg >= 6)
             goto illegal_op;
         gen_op_movl_T0_seg(reg);
         ot = mod == 3 ? dflag : MO_16;
         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);
         break;
 
     case 0x1b6:  
     case 0x1b7:  
     case 0x1be:  
     case 0x1bf:  
         {
             TCGMemOp d_ot;
             TCGMemOp s_ot;
 
              
             d_ot = dflag;
              
             ot = (b & 1) + MO_8;
              
             s_ot = b & 8 ? MO_SIGN | ot : ot;
 
             modrm = cpu_ldub_code(env, s->pc++);
             reg = ((modrm >> 3) & 7) | rex_r;
             mod = (modrm >> 6) & 3;
             rm = (modrm & 7) | REX_B(s);
 
             if (mod == 3) {
                 if (s_ot == MO_SB && byte_reg_is_xH(rm)) {
                     tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);
                 } else {
                     gen_op_mov_v_reg(ot, cpu_T0, rm);
                     switch (s_ot) {
                     case MO_UB:
                         tcg_gen_ext8u_tl(cpu_T0, cpu_T0);
                         break;
                     case MO_SB:
                         tcg_gen_ext8s_tl(cpu_T0, cpu_T0);
                         break;
                     case MO_UW:
                         tcg_gen_ext16u_tl(cpu_T0, cpu_T0);
                         break;
                     default:
                     case MO_SW:
                         tcg_gen_ext16s_tl(cpu_T0, cpu_T0);
                         break;
                     }
                 }
                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);
             } else {
                 gen_lea_modrm(env, s, modrm);
                 gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);
                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);
             }
         }
         break;
 
     case 0x8d:  
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         if (mod == 3)
             goto illegal_op;
         reg = ((modrm >> 3) & 7) | rex_r;
         {
             AddressParts a = gen_lea_modrm_0(env, s, modrm);
             TCGv ea = gen_lea_modrm_1(a);
             gen_lea_v_seg(s, s->aflag, ea, -1, -1);
             gen_op_mov_reg_v(dflag, reg, cpu_A0);
         }
         break;
 
     case 0xa0:  
     case 0xa1:
     case 0xa2:  
     case 0xa3:
         {
             target_ulong offset_addr;
 
             ot = mo_b_d(b, dflag);
             switch (s->aflag) {
 #ifdef TARGET_X86_64
             case MO_64:
                 offset_addr = cpu_ldq_code(env, s->pc);
                 s->pc += 8;
                 break;
 #endif
             default:
                 offset_addr = insn_get(env, s, s->aflag);
                 break;
             }
             tcg_gen_movi_tl(cpu_A0, offset_addr);
             gen_add_A0_ds_seg(s);
             if ((b & 2) == 0) {
                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);
                 gen_op_mov_reg_v(ot, R_EAX, cpu_T0);
             } else {
                 gen_op_mov_v_reg(ot, cpu_T0, R_EAX);
                 gen_op_st_v(s, ot, cpu_T0, cpu_A0);
             }
         }
         break;
     case 0xd7:  
         tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);
         tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);
         tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);
         gen_extu(s->aflag, cpu_A0);
         gen_add_A0_ds_seg(s);
         gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);
         gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);
         break;
     case 0xb0 ... 0xb7:  
         val = insn_get(env, s, MO_8);
         tcg_gen_movi_tl(cpu_T0, val);
         gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);
         break;
     case 0xb8 ... 0xbf:  
 #ifdef TARGET_X86_64
         if (dflag == MO_64) {
             uint64_t tmp;
              
             tmp = cpu_ldq_code(env, s->pc);
             s->pc += 8;
             reg = (b & 7) | REX_B(s);
             tcg_gen_movi_tl(cpu_T0, tmp);
             gen_op_mov_reg_v(MO_64, reg, cpu_T0);
         } else
 #endif
         {
             ot = dflag;
             val = insn_get(env, s, ot);
             reg = (b & 7) | REX_B(s);
             tcg_gen_movi_tl(cpu_T0, val);
             gen_op_mov_reg_v(ot, reg, cpu_T0);
         }
         break;
 
     case 0x91 ... 0x97:  
     do_xchg_reg_eax:
         ot = dflag;
         reg = (b & 7) | REX_B(s);
         rm = R_EAX;
         goto do_xchg_reg;
     case 0x86:
     case 0x87:  
         ot = mo_b_d(b, dflag);
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
         mod = (modrm >> 6) & 3;
         if (mod == 3) {
             rm = (modrm & 7) | REX_B(s);
         do_xchg_reg:
             gen_op_mov_v_reg(ot, cpu_T0, reg);
             gen_op_mov_v_reg(ot, cpu_T1, rm);
             gen_op_mov_reg_v(ot, rm, cpu_T0);
             gen_op_mov_reg_v(ot, reg, cpu_T1);
         } else {
             gen_lea_modrm(env, s, modrm);
             gen_op_mov_v_reg(ot, cpu_T0, reg);
              
             tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,
                                    s->mem_index, ot | MO_LE);
             gen_op_mov_reg_v(ot, reg, cpu_T1);
         }
         break;
     case 0xc4:  
          
         op = R_ES;
         goto do_lxx;
     case 0xc5:  
          
         op = R_DS;
         goto do_lxx;
     case 0x1b2:  
         op = R_SS;
         goto do_lxx;
     case 0x1b4:  
         op = R_FS;
         goto do_lxx;
     case 0x1b5:  
         op = R_GS;
     do_lxx:
         ot = dflag != MO_16 ? MO_32 : MO_16;
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
         mod = (modrm >> 6) & 3;
         if (mod == 3)
             goto illegal_op;
         gen_lea_modrm(env, s, modrm);
         gen_op_ld_v(s, ot, cpu_T1, cpu_A0);
         gen_add_A0_im(s, 1 << ot);
          
         gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);
         gen_movl_seg_T0(s, op);
          
         gen_op_mov_reg_v(ot, reg, cpu_T1);
         if (s->is_jmp) {
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
         }
         break;
 
          
          
     case 0xc0:
     case 0xc1:
          
         shift = 2;
     grp2:
         {
             ot = mo_b_d(b, dflag);
             modrm = cpu_ldub_code(env, s->pc++);
             mod = (modrm >> 6) & 3;
             op = (modrm >> 3) & 7;
 
             if (mod != 3) {
                 if (shift == 2) {
                     s->rip_offset = 1;
                 }
                 gen_lea_modrm(env, s, modrm);
                 opreg = OR_TMP0;
             } else {
                 opreg = (modrm & 7) | REX_B(s);
             }
 
              
             if (shift == 0) {
                 gen_shift(s, op, ot, opreg, OR_ECX);
             } else {
                 if (shift == 2) {
                     shift = cpu_ldub_code(env, s->pc++);
                 }
                 gen_shifti(s, op, ot, opreg, shift);
             }
         }
         break;
     case 0xd0:
     case 0xd1:
          
         shift = 1;
         goto grp2;
     case 0xd2:
     case 0xd3:
          
         shift = 0;
         goto grp2;
 
     case 0x1a4:  
         op = 0;
         shift = 1;
         goto do_shiftd;
     case 0x1a5:  
         op = 0;
         shift = 0;
         goto do_shiftd;
     case 0x1ac:  
         op = 1;
         shift = 1;
         goto do_shiftd;
     case 0x1ad:  
         op = 1;
         shift = 0;
     do_shiftd:
         ot = dflag;
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         rm = (modrm & 7) | REX_B(s);
         reg = ((modrm >> 3) & 7) | rex_r;
         if (mod != 3) {
             gen_lea_modrm(env, s, modrm);
             opreg = OR_TMP0;
         } else {
             opreg = rm;
         }
         gen_op_mov_v_reg(ot, cpu_T1, reg);
 
         if (shift) {
             TCGv imm = tcg_const_tl(cpu_ldub_code(env, s->pc++));
             gen_shiftd_rm_T1(s, ot, opreg, op, imm);
             tcg_temp_free(imm);
         } else {
             gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);
         }
         break;
 
          
          
     case 0xd8 ... 0xdf:
         if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {
              
              
             gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);
             break;
         }
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         rm = modrm & 7;
         op = ((b & 7) << 3) | ((modrm >> 3) & 7);
         if (mod != 3) {
              
             gen_lea_modrm(env, s, modrm);
             switch(op) {
             case 0x00 ... 0x07:  
             case 0x10 ... 0x17:  
             case 0x20 ... 0x27:  
             case 0x30 ... 0x37:  
                 {
                     int op1;
                     op1 = op & 7;
 
                     switch(op >> 4) {
                     case 0:
                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUL);
                         gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);
                         break;
                     case 1:
                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUL);
                         gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);
                         break;
                     case 2:
                         tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,
                                             s->mem_index, MO_LEQ);
                         gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);
                         break;
                     case 3:
                     default:
                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LESW);
                         gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);
                         break;
                     }
 
                     gen_helper_fp_arith_ST0_FT0(op1);
                     if (op1 == 3) {
                          
                         gen_helper_fpop(cpu_env);
                     }
                 }
                 break;
             case 0x08:  
             case 0x0a:  
             case 0x0b:  
             case 0x18 ... 0x1b:  
             case 0x28 ... 0x2b:  
             case 0x38 ... 0x3b:  
                 switch(op & 7) {
                 case 0:
                     switch(op >> 4) {
                     case 0:
                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUL);
                         gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);
                         break;
                     case 1:
                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUL);
                         gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);
                         break;
                     case 2:
                         tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,
                                             s->mem_index, MO_LEQ);
                         gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);
                         break;
                     case 3:
                     default:
                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LESW);
                         gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);
                         break;
                     }
                     break;
                 case 1:
                      
                     switch(op >> 4) {
                     case 1:
                         gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);
                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUL);
                         break;
                     case 2:
                         gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);
                         tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,
                                             s->mem_index, MO_LEQ);
                         break;
                     case 3:
                     default:
                         gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);
                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUW);
                         break;
                     }
                     gen_helper_fpop(cpu_env);
                     break;
                 default:
                     switch(op >> 4) {
                     case 0:
                         gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);
                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUL);
                         break;
                     case 1:
                         gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);
                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUL);
                         break;
                     case 2:
                         gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);
                         tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,
                                             s->mem_index, MO_LEQ);
                         break;
                     case 3:
                     default:
                         gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);
                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,
                                             s->mem_index, MO_LEUW);
                         break;
                     }
                     if ((op & 7) == 3)
                         gen_helper_fpop(cpu_env);
                     break;
                 }
                 break;
             case 0x0c:  
                 gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));
                 break;
             case 0x0d:  
                 tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,
                                     s->mem_index, MO_LEUW);
                 gen_helper_fldcw(cpu_env, cpu_tmp2_i32);
                 break;
             case 0x0e:  
                 gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));
                 break;
             case 0x0f:  
                 gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);
                 tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,
                                     s->mem_index, MO_LEUW);
                 break;
             case 0x1d:  
                 gen_helper_fldt_ST0(cpu_env, cpu_A0);
                 break;
             case 0x1f:  
                 gen_helper_fstt_ST0(cpu_env, cpu_A0);
                 gen_helper_fpop(cpu_env);
                 break;
             case 0x2c:  
                 gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));
                 break;
             case 0x2e:  
                 gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));
                 break;
             case 0x2f:  
                 gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);
                 tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,
                                     s->mem_index, MO_LEUW);
                 break;
             case 0x3c:  
                 gen_helper_fbld_ST0(cpu_env, cpu_A0);
                 break;
             case 0x3e:  
                 gen_helper_fbst_ST0(cpu_env, cpu_A0);
                 gen_helper_fpop(cpu_env);
                 break;
             case 0x3d:  
                 tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);
                 gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);
                 break;
             case 0x3f:  
                 gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);
                 tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);
                 gen_helper_fpop(cpu_env);
                 break;
             default:
                 goto unknown_op;
             }
         } else {
              
             opreg = rm;
 
             switch(op) {
             case 0x08:  
                 gen_helper_fpush(cpu_env);
                 gen_helper_fmov_ST0_STN(cpu_env,
                                         tcg_const_i32((opreg + 1) & 7));
                 break;
             case 0x09:  
             case 0x29:  
             case 0x39:  
                 gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));
                 break;
             case 0x0a:  
                 switch(rm) {
                 case 0:  
                      
                     gen_helper_fwait(cpu_env);
                     break;
                 default:
                     goto unknown_op;
                 }
                 break;
             case 0x0c:  
                 switch(rm) {
                 case 0:  
                     gen_helper_fchs_ST0(cpu_env);
                     break;
                 case 1:  
                     gen_helper_fabs_ST0(cpu_env);
                     break;
                 case 4:  
                     gen_helper_fldz_FT0(cpu_env);
                     gen_helper_fcom_ST0_FT0(cpu_env);
                     break;
                 case 5:  
                     gen_helper_fxam_ST0(cpu_env);
                     break;
                 default:
                     goto unknown_op;
                 }
                 break;
             case 0x0d:  
                 {
                     switch(rm) {
                     case 0:
                         gen_helper_fpush(cpu_env);
                         gen_helper_fld1_ST0(cpu_env);
                         break;
                     case 1:
                         gen_helper_fpush(cpu_env);
                         gen_helper_fldl2t_ST0(cpu_env);
                         break;
                     case 2:
                         gen_helper_fpush(cpu_env);
                         gen_helper_fldl2e_ST0(cpu_env);
                         break;
                     case 3:
                         gen_helper_fpush(cpu_env);
                         gen_helper_fldpi_ST0(cpu_env);
                         break;
                     case 4:
                         gen_helper_fpush(cpu_env);
                         gen_helper_fldlg2_ST0(cpu_env);
                         break;
                     case 5:
                         gen_helper_fpush(cpu_env);
                         gen_helper_fldln2_ST0(cpu_env);
                         break;
                     case 6:
                         gen_helper_fpush(cpu_env);
                         gen_helper_fldz_ST0(cpu_env);
                         break;
                     default:
                         goto unknown_op;
                     }
                 }
                 break;
             case 0x0e:  
                 switch(rm) {
                 case 0:  
                     gen_helper_f2xm1(cpu_env);
                     break;
                 case 1:  
                     gen_helper_fyl2x(cpu_env);
                     break;
                 case 2:  
                     gen_helper_fptan(cpu_env);
                     break;
                 case 3:  
                     gen_helper_fpatan(cpu_env);
                     break;
                 case 4:  
                     gen_helper_fxtract(cpu_env);
                     break;
                 case 5:  
                     gen_helper_fprem1(cpu_env);
                     break;
                 case 6:  
                     gen_helper_fdecstp(cpu_env);
                     break;
                 default:
                 case 7:  
                     gen_helper_fincstp(cpu_env);
                     break;
                 }
                 break;
             case 0x0f:  
                 switch(rm) {
                 case 0:  
                     gen_helper_fprem(cpu_env);
                     break;
                 case 1:  
                     gen_helper_fyl2xp1(cpu_env);
                     break;
                 case 2:  
                     gen_helper_fsqrt(cpu_env);
                     break;
                 case 3:  
                     gen_helper_fsincos(cpu_env);
                     break;
                 case 5:  
                     gen_helper_fscale(cpu_env);
                     break;
                 case 4:  
                     gen_helper_frndint(cpu_env);
                     break;
                 case 6:  
                     gen_helper_fsin(cpu_env);
                     break;
                 default:
                 case 7:  
                     gen_helper_fcos(cpu_env);
                     break;
                 }
                 break;
             case 0x00: case 0x01: case 0x04 ... 0x07:  
             case 0x20: case 0x21: case 0x24 ... 0x27:  
             case 0x30: case 0x31: case 0x34 ... 0x37:  
                 {
                     int op1;
 
                     op1 = op & 7;
                     if (op >= 0x20) {
                         gen_helper_fp_arith_STN_ST0(op1, opreg);
                         if (op >= 0x30)
                             gen_helper_fpop(cpu_env);
                     } else {
                         gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                         gen_helper_fp_arith_ST0_FT0(op1);
                     }
                 }
                 break;
             case 0x02:  
             case 0x22:  
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fcom_ST0_FT0(cpu_env);
                 break;
             case 0x03:  
             case 0x23:  
             case 0x32:  
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fcom_ST0_FT0(cpu_env);
                 gen_helper_fpop(cpu_env);
                 break;
             case 0x15:  
                 switch(rm) {
                 case 1:  
                     gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));
                     gen_helper_fucom_ST0_FT0(cpu_env);
                     gen_helper_fpop(cpu_env);
                     gen_helper_fpop(cpu_env);
                     break;
                 default:
                     goto unknown_op;
                 }
                 break;
             case 0x1c:
                 switch(rm) {
                 case 0:  
                     break;
                 case 1:  
                     break;
                 case 2:  
                     gen_helper_fclex(cpu_env);
                     break;
                 case 3:  
                     gen_helper_fninit(cpu_env);
                     break;
                 case 4:  
                     break;
                 default:
                     goto unknown_op;
                 }
                 break;
             case 0x1d:  
                 if (!(s->cpuid_features & CPUID_CMOV)) {
                     goto illegal_op;
                 }
                 gen_update_cc_op(s);
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fucomi_ST0_FT0(cpu_env);
                 set_cc_op(s, CC_OP_EFLAGS);
                 break;
             case 0x1e:  
                 if (!(s->cpuid_features & CPUID_CMOV)) {
                     goto illegal_op;
                 }
                 gen_update_cc_op(s);
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fcomi_ST0_FT0(cpu_env);
                 set_cc_op(s, CC_OP_EFLAGS);
                 break;
             case 0x28:  
                 gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));
                 break;
             case 0x2a:  
                 gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));
                 break;
             case 0x2b:  
             case 0x0b:  
             case 0x3a:  
             case 0x3b:  
                 gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fpop(cpu_env);
                 break;
             case 0x2c:  
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fucom_ST0_FT0(cpu_env);
                 break;
             case 0x2d:  
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fucom_ST0_FT0(cpu_env);
                 gen_helper_fpop(cpu_env);
                 break;
             case 0x33:  
                 switch(rm) {
                 case 1:  
                     gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));
                     gen_helper_fcom_ST0_FT0(cpu_env);
                     gen_helper_fpop(cpu_env);
                     gen_helper_fpop(cpu_env);
                     break;
                 default:
                     goto unknown_op;
                 }
                 break;
             case 0x38:  
                 gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fpop(cpu_env);
                 break;
             case 0x3c:  
                 switch(rm) {
                 case 0:
                     gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);
                     tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);
                     gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);
                     break;
                 default:
                     goto unknown_op;
                 }
                 break;
             case 0x3d:  
                 if (!(s->cpuid_features & CPUID_CMOV)) {
                     goto illegal_op;
                 }
                 gen_update_cc_op(s);
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fucomi_ST0_FT0(cpu_env);
                 gen_helper_fpop(cpu_env);
                 set_cc_op(s, CC_OP_EFLAGS);
                 break;
             case 0x3e:  
                 if (!(s->cpuid_features & CPUID_CMOV)) {
                     goto illegal_op;
                 }
                 gen_update_cc_op(s);
                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));
                 gen_helper_fcomi_ST0_FT0(cpu_env);
                 gen_helper_fpop(cpu_env);
                 set_cc_op(s, CC_OP_EFLAGS);
                 break;
             case 0x10 ... 0x13:  
             case 0x18 ... 0x1b:
                 {
                     int op1;
                     TCGLabel *l1;
                     static const uint8_t fcmov_cc[8] = {
                         (JCC_B << 1),
                         (JCC_Z << 1),
                         (JCC_BE << 1),
                         (JCC_P << 1),
                     };
 
                     if (!(s->cpuid_features & CPUID_CMOV)) {
                         goto illegal_op;
                     }
                     op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);
                     l1 = gen_new_label();
                     gen_jcc1_noeob(s, op1, l1);
                     gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));
                     gen_set_label(l1);
                 }
                 break;
             default:
                 goto unknown_op;
             }
         }
         break;
          
          
 
     case 0xa4:  
     case 0xa5:
         ot = mo_b_d(b, dflag);
         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {
             gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);
         } else {
             gen_movs(s, ot);
         }
         break;
 
     case 0xaa:  
     case 0xab:
         ot = mo_b_d(b, dflag);
         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {
             gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);
         } else {
             gen_stos(s, ot);
         }
         break;
     case 0xac:  
     case 0xad:
         ot = mo_b_d(b, dflag);
         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {
             gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);
         } else {
             gen_lods(s, ot);
         }
         break;
     case 0xae:  
     case 0xaf:
         ot = mo_b_d(b, dflag);
         if (prefixes & PREFIX_REPNZ) {
             gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);
         } else if (prefixes & PREFIX_REPZ) {
             gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);
         } else {
             gen_scas(s, ot);
         }
         break;
 
     case 0xa6:  
     case 0xa7:
         ot = mo_b_d(b, dflag);
         if (prefixes & PREFIX_REPNZ) {
             gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);
         } else if (prefixes & PREFIX_REPZ) {
             gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);
         } else {
             gen_cmps(s, ot);
         }
         break;
     case 0x6c:  
     case 0x6d:
         ot = mo_b_d32(b, dflag);
         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);
         gen_check_io(s, ot, pc_start - s->cs_base, 
                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);
         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {
             gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);
         } else {
             gen_ins(s, ot);
             if (s->tb->cflags & CF_USE_ICOUNT) {
                 gen_jmp(s, s->pc - s->cs_base);
             }
         }
         break;
     case 0x6e:  
     case 0x6f:
         ot = mo_b_d32(b, dflag);
         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);
         gen_check_io(s, ot, pc_start - s->cs_base,
                      svm_is_rep(prefixes) | 4);
         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {
             gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);
         } else {
             gen_outs(s, ot);
             if (s->tb->cflags & CF_USE_ICOUNT) {
                 gen_jmp(s, s->pc - s->cs_base);
             }
         }
         break;
 
          
          
 
     case 0xe4:
     case 0xe5:
         ot = mo_b_d32(b, dflag);
         val = cpu_ldub_code(env, s->pc++);
         tcg_gen_movi_tl(cpu_T0, val);
         gen_check_io(s, ot, pc_start - s->cs_base,
                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_start();
 	}
         tcg_gen_movi_i32(cpu_tmp2_i32, val);
         gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);
         gen_op_mov_reg_v(ot, R_EAX, cpu_T1);
         gen_bpt_io(s, cpu_tmp2_i32, ot);
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_end();
             gen_jmp(s, s->pc - s->cs_base);
         }
         break;
     case 0xe6:
     case 0xe7:
         ot = mo_b_d32(b, dflag);
         val = cpu_ldub_code(env, s->pc++);
         tcg_gen_movi_tl(cpu_T0, val);
         gen_check_io(s, ot, pc_start - s->cs_base,
                      svm_is_rep(prefixes));
         gen_op_mov_v_reg(ot, cpu_T1, R_EAX);
 
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_start();
 	}
         tcg_gen_movi_i32(cpu_tmp2_i32, val);
         tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);
         gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
         gen_bpt_io(s, cpu_tmp2_i32, ot);
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_end();
             gen_jmp(s, s->pc - s->cs_base);
         }
         break;
     case 0xec:
     case 0xed:
         ot = mo_b_d32(b, dflag);
         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);
         gen_check_io(s, ot, pc_start - s->cs_base,
                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_start();
 	}
         tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
         gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);
         gen_op_mov_reg_v(ot, R_EAX, cpu_T1);
         gen_bpt_io(s, cpu_tmp2_i32, ot);
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_end();
             gen_jmp(s, s->pc - s->cs_base);
         }
         break;
     case 0xee:
     case 0xef:
         ot = mo_b_d32(b, dflag);
         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);
         gen_check_io(s, ot, pc_start - s->cs_base,
                      svm_is_rep(prefixes));
         gen_op_mov_v_reg(ot, cpu_T1, R_EAX);
 
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_start();
 	}
         tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
         tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);
         gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
         gen_bpt_io(s, cpu_tmp2_i32, ot);
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_end();
             gen_jmp(s, s->pc - s->cs_base);
         }
         break;
 
          
          
     case 0xc2:  
         val = cpu_ldsw_code(env, s->pc);
         s->pc += 2;
         ot = gen_pop_T0(s);
         gen_stack_update(s, val + (1 << ot));
          
         gen_op_jmp_v(cpu_T0);
         gen_bnd_jmp(s);
         gen_eob(s);
         break;
     case 0xc3:  
         ot = gen_pop_T0(s);
         gen_pop_update(s, ot);
          
         gen_op_jmp_v(cpu_T0);
         gen_bnd_jmp(s);
         gen_eob(s);
         break;
     case 0xca:  
         val = cpu_ldsw_code(env, s->pc);
         s->pc += 2;
     do_lret:
         if (s->pe && !s->vm86) {
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),
                                       tcg_const_i32(val));
         } else {
             gen_stack_A0(s);
              
             gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);
              
             gen_op_jmp_v(cpu_T0);
              
             gen_add_A0_im(s, 1 << dflag);
             gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);
             gen_op_movl_seg_T0_vm(R_CS);
              
             gen_stack_update(s, val + (2 << dflag));
         }
         gen_eob(s);
         break;
     case 0xcb:  
         val = 0;
         goto do_lret;
     case 0xcf:  
         gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);
         if (!s->pe) {
              
             gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));
             set_cc_op(s, CC_OP_EFLAGS);
         } else if (s->vm86) {
             if (s->iopl != 3) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
             } else {
                 gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));
                 set_cc_op(s, CC_OP_EFLAGS);
             }
         } else {
             gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),
                                       tcg_const_i32(s->pc - s->cs_base));
             set_cc_op(s, CC_OP_EFLAGS);
         }
         gen_eob(s);
         break;
     case 0xe8:  
         {
             if (dflag != MO_16) {
                 tval = (int32_t)insn_get(env, s, MO_32);
             } else {
                 tval = (int16_t)insn_get(env, s, MO_16);
             }
             next_eip = s->pc - s->cs_base;
             tval += next_eip;
             if (dflag == MO_16) {
                 tval &= 0xffff;
             } else if (!CODE64(s)) {
                 tval &= 0xffffffff;
             }
             tcg_gen_movi_tl(cpu_T0, next_eip);
             gen_push_v(s, cpu_T0);
             gen_bnd_jmp(s);
             gen_jmp(s, tval);
         }
         break;
     case 0x9a:  
         {
             unsigned int selector, offset;
 
             if (CODE64(s))
                 goto illegal_op;
             ot = dflag;
             offset = insn_get(env, s, ot);
             selector = insn_get(env, s, MO_16);
 
             tcg_gen_movi_tl(cpu_T0, selector);
             tcg_gen_movi_tl(cpu_T1, offset);
         }
         goto do_lcall;
     case 0xe9:  
         if (dflag != MO_16) {
             tval = (int32_t)insn_get(env, s, MO_32);
         } else {
             tval = (int16_t)insn_get(env, s, MO_16);
         }
         tval += s->pc - s->cs_base;
         if (dflag == MO_16) {
             tval &= 0xffff;
         } else if (!CODE64(s)) {
             tval &= 0xffffffff;
         }
         gen_bnd_jmp(s);
         gen_jmp(s, tval);
         break;
     case 0xea:  
         {
             unsigned int selector, offset;
 
             if (CODE64(s))
                 goto illegal_op;
             ot = dflag;
             offset = insn_get(env, s, ot);
             selector = insn_get(env, s, MO_16);
 
             tcg_gen_movi_tl(cpu_T0, selector);
             tcg_gen_movi_tl(cpu_T1, offset);
         }
         goto do_ljmp;
     case 0xeb:  
         tval = (int8_t)insn_get(env, s, MO_8);
         tval += s->pc - s->cs_base;
         if (dflag == MO_16) {
             tval &= 0xffff;
         }
         gen_jmp(s, tval);
         break;
     case 0x70 ... 0x7f:  
         tval = (int8_t)insn_get(env, s, MO_8);
         goto do_jcc;
     case 0x180 ... 0x18f:  
         if (dflag != MO_16) {
             tval = (int32_t)insn_get(env, s, MO_32);
         } else {
             tval = (int16_t)insn_get(env, s, MO_16);
         }
     do_jcc:
         next_eip = s->pc - s->cs_base;
         tval += next_eip;
         if (dflag == MO_16) {
             tval &= 0xffff;
         }
         gen_bnd_jmp(s);
         gen_jcc(s, b, tval, next_eip);
         break;
 
     case 0x190 ... 0x19f:  
         modrm = cpu_ldub_code(env, s->pc++);
         gen_setcc1(s, b, cpu_T0);
         gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);
         break;
     case 0x140 ... 0x14f:  
         if (!(s->cpuid_features & CPUID_CMOV)) {
             goto illegal_op;
         }
         ot = dflag;
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
         gen_cmovcc1(env, s, ot, b, modrm, reg);
         break;
 
          
          
     case 0x9c:  
         gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);
         if (s->vm86 && s->iopl != 3) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_update_cc_op(s);
             gen_helper_read_eflags(cpu_T0, cpu_env);
             gen_push_v(s, cpu_T0);
         }
         break;
     case 0x9d:  
         gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);
         if (s->vm86 && s->iopl != 3) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             ot = gen_pop_T0(s);
             if (s->cpl == 0) {
                 if (dflag != MO_16) {
                     gen_helper_write_eflags(cpu_env, cpu_T0,
                                             tcg_const_i32((TF_MASK | AC_MASK |
                                                            ID_MASK | NT_MASK |
                                                            IF_MASK |
                                                            IOPL_MASK)));
                 } else {
                     gen_helper_write_eflags(cpu_env, cpu_T0,
                                             tcg_const_i32((TF_MASK | AC_MASK |
                                                            ID_MASK | NT_MASK |
                                                            IF_MASK | IOPL_MASK)
                                                           & 0xffff));
                 }
             } else {
                 if (s->cpl <= s->iopl) {
                     if (dflag != MO_16) {
                         gen_helper_write_eflags(cpu_env, cpu_T0,
                                                 tcg_const_i32((TF_MASK |
                                                                AC_MASK |
                                                                ID_MASK |
                                                                NT_MASK |
                                                                IF_MASK)));
                     } else {
                         gen_helper_write_eflags(cpu_env, cpu_T0,
                                                 tcg_const_i32((TF_MASK |
                                                                AC_MASK |
                                                                ID_MASK |
                                                                NT_MASK |
                                                                IF_MASK)
                                                               & 0xffff));
                     }
                 } else {
                     if (dflag != MO_16) {
                         gen_helper_write_eflags(cpu_env, cpu_T0,
                                            tcg_const_i32((TF_MASK | AC_MASK |
                                                           ID_MASK | NT_MASK)));
                     } else {
                         gen_helper_write_eflags(cpu_env, cpu_T0,
                                            tcg_const_i32((TF_MASK | AC_MASK |
                                                           ID_MASK | NT_MASK)
                                                          & 0xffff));
                     }
                 }
             }
             gen_pop_update(s, ot);
             set_cc_op(s, CC_OP_EFLAGS);
              
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
         }
         break;
     case 0x9e:  
         if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))
             goto illegal_op;
         gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);
         gen_compute_eflags(s);
         tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);
         tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);
         tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);
         break;
     case 0x9f:  
         if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))
             goto illegal_op;
         gen_compute_eflags(s);
          
         tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);
         gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);
         break;
     case 0xf5:  
         gen_compute_eflags(s);
         tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);
         break;
     case 0xf8:  
         gen_compute_eflags(s);
         tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);
         break;
     case 0xf9:  
         gen_compute_eflags(s);
         tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);
         break;
     case 0xfc:  
         tcg_gen_movi_i32(cpu_tmp2_i32, 1);
         tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));
         break;
     case 0xfd:  
         tcg_gen_movi_i32(cpu_tmp2_i32, -1);
         tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));
         break;
 
          
          
     case 0x1ba:  
         ot = dflag;
         modrm = cpu_ldub_code(env, s->pc++);
         op = (modrm >> 3) & 7;
         mod = (modrm >> 6) & 3;
         rm = (modrm & 7) | REX_B(s);
         if (mod != 3) {
             s->rip_offset = 1;
             gen_lea_modrm(env, s, modrm);
             if (!(s->prefix & PREFIX_LOCK)) {
                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);
             }
         } else {
             gen_op_mov_v_reg(ot, cpu_T0, rm);
         }
          
         val = cpu_ldub_code(env, s->pc++);
         tcg_gen_movi_tl(cpu_T1, val);
         if (op < 4)
             goto unknown_op;
         op -= 4;
         goto bt_op;
     case 0x1a3:  
         op = 0;
         goto do_btx;
     case 0x1ab:  
         op = 1;
         goto do_btx;
     case 0x1b3:  
         op = 2;
         goto do_btx;
     case 0x1bb:  
         op = 3;
     do_btx:
         ot = dflag;
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
         mod = (modrm >> 6) & 3;
         rm = (modrm & 7) | REX_B(s);
         gen_op_mov_v_reg(MO_32, cpu_T1, reg);
         if (mod != 3) {
             AddressParts a = gen_lea_modrm_0(env, s, modrm);
              
             gen_exts(ot, cpu_T1);
             tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);
             tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);
             tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);
             gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);
             if (!(s->prefix & PREFIX_LOCK)) {
                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);
             }
         } else {
             gen_op_mov_v_reg(ot, cpu_T0, rm);
         }
     bt_op:
         tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);
         tcg_gen_movi_tl(cpu_tmp0, 1);
         tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);
         if (s->prefix & PREFIX_LOCK) {
             switch (op) {
             case 0:  
                  
                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);
                 break;
             case 1:  
                 tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,
                                            s->mem_index, ot | MO_LE);
                 break;
             case 2:  
                 tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);
                 tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,
                                             s->mem_index, ot | MO_LE);
                 break;
             default:
             case 3:  
                 tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,
                                             s->mem_index, ot | MO_LE);
                 break;
             }
             tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);
         } else {
             tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);
             switch (op) {
             case 0:  
                  
                 break;
             case 1:  
                 tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);
                 break;
             case 2:  
                 tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);
                 break;
             default:
             case 3:  
                 tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);
                 break;
             }
             if (op != 0) {
                 if (mod != 3) {
                     gen_op_st_v(s, ot, cpu_T0, cpu_A0);
                 } else {
                     gen_op_mov_reg_v(ot, rm, cpu_T0);
                 }
             }
         }
 
          
         switch (s->cc_op) {
         case CC_OP_MULB ... CC_OP_MULQ:
         case CC_OP_ADDB ... CC_OP_ADDQ:
         case CC_OP_ADCB ... CC_OP_ADCQ:
         case CC_OP_SUBB ... CC_OP_SUBQ:
         case CC_OP_SBBB ... CC_OP_SBBQ:
         case CC_OP_LOGICB ... CC_OP_LOGICQ:
         case CC_OP_INCB ... CC_OP_INCQ:
         case CC_OP_DECB ... CC_OP_DECQ:
         case CC_OP_SHLB ... CC_OP_SHLQ:
         case CC_OP_SARB ... CC_OP_SARQ:
         case CC_OP_BMILGB ... CC_OP_BMILGQ:
              
             tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);
             set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);
             break;
         default:
              
             gen_compute_eflags(s);
             tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,
                                ctz32(CC_C), 1);
             break;
         }
         break;
     case 0x1bc:  
     case 0x1bd:  
         ot = dflag;
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);
         gen_extu(ot, cpu_T0);
 
          
         if ((prefixes & PREFIX_REPZ)
             && (b & 1
                 ? s->cpuid_ext3_features & CPUID_EXT3_ABM
                 : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {
             int size = 8 << ot;
              
             tcg_gen_mov_tl(cpu_cc_src, cpu_T0);
             if (b & 1) {
                  
                 tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);
                 tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);
             } else {
                  
                 tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);
             }
              
             gen_op_update1_cc();
             set_cc_op(s, CC_OP_BMILGB + ot);
         } else {
              
             tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);
             set_cc_op(s, CC_OP_LOGICB + ot);
 
              
             if (b & 1) {
                  
                 tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);
                 tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);
                 tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);
             } else {
                 tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);
             }
         }
         gen_op_mov_reg_v(ot, reg, cpu_T0);
         break;
          
          
     case 0x27:  
         if (CODE64(s))
             goto illegal_op;
         gen_update_cc_op(s);
         gen_helper_daa(cpu_env);
         set_cc_op(s, CC_OP_EFLAGS);
         break;
     case 0x2f:  
         if (CODE64(s))
             goto illegal_op;
         gen_update_cc_op(s);
         gen_helper_das(cpu_env);
         set_cc_op(s, CC_OP_EFLAGS);
         break;
     case 0x37:  
         if (CODE64(s))
             goto illegal_op;
         gen_update_cc_op(s);
         gen_helper_aaa(cpu_env);
         set_cc_op(s, CC_OP_EFLAGS);
         break;
     case 0x3f:  
         if (CODE64(s))
             goto illegal_op;
         gen_update_cc_op(s);
         gen_helper_aas(cpu_env);
         set_cc_op(s, CC_OP_EFLAGS);
         break;
     case 0xd4:  
         if (CODE64(s))
             goto illegal_op;
         val = cpu_ldub_code(env, s->pc++);
         if (val == 0) {
             gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);
         } else {
             gen_helper_aam(cpu_env, tcg_const_i32(val));
             set_cc_op(s, CC_OP_LOGICB);
         }
         break;
     case 0xd5:  
         if (CODE64(s))
             goto illegal_op;
         val = cpu_ldub_code(env, s->pc++);
         gen_helper_aad(cpu_env, tcg_const_i32(val));
         set_cc_op(s, CC_OP_LOGICB);
         break;
          
          
     case 0x90:  
          
         if (prefixes & PREFIX_LOCK) {
             goto illegal_op;
         }
          
         if (REX_B(s)) {
             goto do_xchg_reg_eax;
         }
         if (prefixes & PREFIX_REPZ) {
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));
             s->is_jmp = DISAS_TB_JUMP;
         }
         break;
     case 0x9b:  
         if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==
             (HF_MP_MASK | HF_TS_MASK)) {
             gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);
         } else {
             gen_helper_fwait(cpu_env);
         }
         break;
     case 0xcc:  
         gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);
         break;
     case 0xcd:  
         val = cpu_ldub_code(env, s->pc++);
         if (s->vm86 && s->iopl != 3) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);
         }
         break;
     case 0xce:  
         if (CODE64(s))
             goto illegal_op;
         gen_update_cc_op(s);
         gen_jmp_im(pc_start - s->cs_base);
         gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));
         break;
 #ifdef WANT_ICEBP
     case 0xf1:  
         gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);
 #if 1
         gen_debug(s, pc_start - s->cs_base);
 #else
          
         tb_flush(CPU(x86_env_get_cpu(env)));
         qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);
 #endif
         break;
 #endif
     case 0xfa:  
         if (!s->vm86) {
             if (s->cpl <= s->iopl) {
                 gen_helper_cli(cpu_env);
             } else {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
             }
         } else {
             if (s->iopl == 3) {
                 gen_helper_cli(cpu_env);
             } else {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
             }
         }
         break;
     case 0xfb:  
         if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {
             gen_helper_sti(cpu_env);
              
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob_inhibit_irq(s, true);
         } else {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         }
         break;
     case 0x62:  
         if (CODE64(s))
             goto illegal_op;
         ot = dflag;
         modrm = cpu_ldub_code(env, s->pc++);
         reg = (modrm >> 3) & 7;
         mod = (modrm >> 6) & 3;
         if (mod == 3)
             goto illegal_op;
         gen_op_mov_v_reg(ot, cpu_T0, reg);
         gen_lea_modrm(env, s, modrm);
         tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
         if (ot == MO_16) {
             gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);
         } else {
             gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);
         }
         break;
     case 0x1c8 ... 0x1cf:  
         reg = (b & 7) | REX_B(s);
 #ifdef TARGET_X86_64
         if (dflag == MO_64) {
             gen_op_mov_v_reg(MO_64, cpu_T0, reg);
             tcg_gen_bswap64_i64(cpu_T0, cpu_T0);
             gen_op_mov_reg_v(MO_64, reg, cpu_T0);
         } else
 #endif
         {
             gen_op_mov_v_reg(MO_32, cpu_T0, reg);
             tcg_gen_ext32u_tl(cpu_T0, cpu_T0);
             tcg_gen_bswap32_tl(cpu_T0, cpu_T0);
             gen_op_mov_reg_v(MO_32, reg, cpu_T0);
         }
         break;
     case 0xd6:  
         if (CODE64(s))
             goto illegal_op;
         gen_compute_eflags_c(s, cpu_T0);
         tcg_gen_neg_tl(cpu_T0, cpu_T0);
         gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);
         break;
     case 0xe0:  
     case 0xe1:  
     case 0xe2:  
     case 0xe3:  
         {
             TCGLabel *l1, *l2, *l3;
 
             tval = (int8_t)insn_get(env, s, MO_8);
             next_eip = s->pc - s->cs_base;
             tval += next_eip;
             if (dflag == MO_16) {
                 tval &= 0xffff;
             }
 
             l1 = gen_new_label();
             l2 = gen_new_label();
             l3 = gen_new_label();
             b &= 3;
             switch(b) {
             case 0:  
             case 1:  
                 gen_op_add_reg_im(s->aflag, R_ECX, -1);
                 gen_op_jz_ecx(s->aflag, l3);
                 gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);
                 break;
             case 2:  
                 gen_op_add_reg_im(s->aflag, R_ECX, -1);
                 gen_op_jnz_ecx(s->aflag, l1);
                 break;
             default:
             case 3:  
                 gen_op_jz_ecx(s->aflag, l1);
                 break;
             }
 
             gen_set_label(l3);
             gen_jmp_im(next_eip);
             tcg_gen_br(l2);
 
             gen_set_label(l1);
             gen_jmp_im(tval);
             gen_set_label(l2);
             gen_eob(s);
         }
         break;
     case 0x130:  
     case 0x132:  
         if (s->cpl != 0) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             if (b & 2) {
                 gen_helper_rdmsr(cpu_env);
             } else {
                 gen_helper_wrmsr(cpu_env);
             }
         }
         break;
     case 0x131:  
         gen_update_cc_op(s);
         gen_jmp_im(pc_start - s->cs_base);
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_start();
 	}
         gen_helper_rdtsc(cpu_env);
         if (s->tb->cflags & CF_USE_ICOUNT) {
             gen_io_end();
             gen_jmp(s, s->pc - s->cs_base);
         }
         break;
     case 0x133:  
         gen_update_cc_op(s);
         gen_jmp_im(pc_start - s->cs_base);
         gen_helper_rdpmc(cpu_env);
         break;
     case 0x134:  
          
         if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
             goto illegal_op;
         if (!s->pe) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_helper_sysenter(cpu_env);
             gen_eob(s);
         }
         break;
     case 0x135:  
          
         if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
             goto illegal_op;
         if (!s->pe) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));
             gen_eob(s);
         }
         break;
 #ifdef TARGET_X86_64
     case 0x105:  
          
         gen_update_cc_op(s);
         gen_jmp_im(pc_start - s->cs_base);
         gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));
          
         gen_eob_worker(s, false, true);
         break;
     case 0x107:  
         if (!s->pe) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));
              
             if (s->lma) {
                 set_cc_op(s, CC_OP_EFLAGS);
             }
              
             gen_eob_worker(s, false, true);
         }
         break;
 #endif
     case 0x1a2:  
         gen_update_cc_op(s);
         gen_jmp_im(pc_start - s->cs_base);
         gen_helper_cpuid(cpu_env);
         break;
     case 0xf4:  
         if (s->cpl != 0) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));
             s->is_jmp = DISAS_TB_JUMP;
         }
         break;
     case 0x100:
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         op = (modrm >> 3) & 7;
         switch(op) {
         case 0:  
             if (!s->pe || s->vm86)
                 goto illegal_op;
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);
             tcg_gen_ld32u_tl(cpu_T0, cpu_env,
                              offsetof(CPUX86State, ldt.selector));
             ot = mod == 3 ? dflag : MO_16;
             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);
             break;
         case 2:  
             if (!s->pe || s->vm86)
                 goto illegal_op;
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
             } else {
                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);
                 gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);
                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
                 gen_helper_lldt(cpu_env, cpu_tmp2_i32);
             }
             break;
         case 1:  
             if (!s->pe || s->vm86)
                 goto illegal_op;
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);
             tcg_gen_ld32u_tl(cpu_T0, cpu_env,
                              offsetof(CPUX86State, tr.selector));
             ot = mod == 3 ? dflag : MO_16;
             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);
             break;
         case 3:  
             if (!s->pe || s->vm86)
                 goto illegal_op;
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
             } else {
                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);
                 gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);
                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
                 gen_helper_ltr(cpu_env, cpu_tmp2_i32);
             }
             break;
         case 4:  
         case 5:  
             if (!s->pe || s->vm86)
                 goto illegal_op;
             gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);
             gen_update_cc_op(s);
             if (op == 4) {
                 gen_helper_verr(cpu_env, cpu_T0);
             } else {
                 gen_helper_verw(cpu_env, cpu_T0);
             }
             set_cc_op(s, CC_OP_EFLAGS);
             break;
         default:
             goto unknown_op;
         }
         break;
 
     case 0x101:
         modrm = cpu_ldub_code(env, s->pc++);
         switch (modrm) {
         CASE_MODRM_MEM_OP(0):  
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);
             gen_lea_modrm(env, s, modrm);
             tcg_gen_ld32u_tl(cpu_T0,
                              cpu_env, offsetof(CPUX86State, gdt.limit));
             gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);
             gen_add_A0_im(s, 2);
             tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));
             if (dflag == MO_16) {
                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);
             }
             gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);
             break;
 
         case 0xc8:  
             if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {
                 goto illegal_op;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);
             gen_extu(s->aflag, cpu_A0);
             gen_add_A0_ds_seg(s);
             gen_helper_monitor(cpu_env, cpu_A0);
             break;
 
         case 0xc9:  
             if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {
                 goto illegal_op;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));
             gen_eob(s);
             break;
 
         case 0xca:  
             if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)
                 || s->cpl != 0) {
                 goto illegal_op;
             }
             gen_helper_clac(cpu_env);
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
             break;
 
         case 0xcb:  
             if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)
                 || s->cpl != 0) {
                 goto illegal_op;
             }
             gen_helper_stac(cpu_env);
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
             break;
 
         CASE_MODRM_MEM_OP(1):  
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);
             gen_lea_modrm(env, s, modrm);
             tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));
             gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);
             gen_add_A0_im(s, 2);
             tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));
             if (dflag == MO_16) {
                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);
             }
             gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);
             break;
 
         case 0xd0:  
             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0
                 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA
                                  | PREFIX_REPZ | PREFIX_REPNZ))) {
                 goto illegal_op;
             }
             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);
             gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);
             tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);
             break;
 
         case 0xd1:  
             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0
                 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA
                                  | PREFIX_REPZ | PREFIX_REPNZ))) {
                 goto illegal_op;
             }
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],
                                   cpu_regs[R_EDX]);
             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);
             gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);
              
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
             break;
 
         case 0xd8:  
             if (!(s->flags & HF_SVME_MASK) || !s->pe) {
                 goto illegal_op;
             }
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),
                              tcg_const_i32(s->pc - pc_start));
             tcg_gen_exit_tb(0);
             s->is_jmp = DISAS_TB_JUMP;
             break;
 
         case 0xd9:  
             if (!(s->flags & HF_SVME_MASK)) {
                 goto illegal_op;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_vmmcall(cpu_env);
             break;
 
         case 0xda:  
             if (!(s->flags & HF_SVME_MASK) || !s->pe) {
                 goto illegal_op;
             }
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));
             break;
 
         case 0xdb:  
             if (!(s->flags & HF_SVME_MASK) || !s->pe) {
                 goto illegal_op;
             }
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));
             break;
 
         case 0xdc:  
             if ((!(s->flags & HF_SVME_MASK)
                    && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))
                 || !s->pe) {
                 goto illegal_op;
             }
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_stgi(cpu_env);
             break;
 
         case 0xdd:  
             if (!(s->flags & HF_SVME_MASK) || !s->pe) {
                 goto illegal_op;
             }
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_clgi(cpu_env);
             break;
 
         case 0xde:  
             if ((!(s->flags & HF_SVME_MASK)
                  && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))
                 || !s->pe) {
                 goto illegal_op;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_skinit(cpu_env);
             break;
 
         case 0xdf:  
             if (!(s->flags & HF_SVME_MASK) || !s->pe) {
                 goto illegal_op;
             }
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));
             break;
 
         CASE_MODRM_MEM_OP(2):  
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);
             gen_lea_modrm(env, s, modrm);
             gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);
             gen_add_A0_im(s, 2);
             gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);
             if (dflag == MO_16) {
                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);
             }
             tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));
             tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));
             break;
 
         CASE_MODRM_MEM_OP(3):  
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);
             gen_lea_modrm(env, s, modrm);
             gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);
             gen_add_A0_im(s, 2);
             gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);
             if (dflag == MO_16) {
                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);
             }
             tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));
             tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));
             break;
 
         CASE_MODRM_OP(4):  
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);
             tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));
             if (CODE64(s)) {
                 mod = (modrm >> 6) & 3;
                 ot = (mod != 3 ? MO_16 : s->dflag);
             } else {
                 ot = MO_16;
             }
             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);
             break;
         case 0xee:  
             if (prefixes & PREFIX_LOCK) {
                 goto illegal_op;
             }
             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);
             gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);
             tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);
             break;
         case 0xef:  
             if (prefixes & PREFIX_LOCK) {
                 goto illegal_op;
             }
             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],
                                   cpu_regs[R_EDX]);
             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);
             gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);
             break;
         CASE_MODRM_OP(6):  
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);
             gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);
             gen_helper_lmsw(cpu_env, cpu_T0);
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
             break;
 
         CASE_MODRM_MEM_OP(7):  
             if (s->cpl != 0) {
                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 break;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             gen_lea_modrm(env, s, modrm);
             gen_helper_invlpg(cpu_env, cpu_A0);
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
             break;
 
         case 0xf8:  
 #ifdef TARGET_X86_64
             if (CODE64(s)) {
                 if (s->cpl != 0) {
                     gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
                 } else {
                     tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);
                     tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,
                                   offsetof(CPUX86State, kernelgsbase));
                     tcg_gen_st_tl(cpu_T0, cpu_env,
                                   offsetof(CPUX86State, kernelgsbase));
                 }
                 break;
             }
 #endif
             goto illegal_op;
 
         case 0xf9:  
             if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {
                 goto illegal_op;
             }
             gen_update_cc_op(s);
             gen_jmp_im(pc_start - s->cs_base);
             if (s->tb->cflags & CF_USE_ICOUNT) {
                 gen_io_start();
             }
             gen_helper_rdtscp(cpu_env);
             if (s->tb->cflags & CF_USE_ICOUNT) {
                 gen_io_end();
                 gen_jmp(s, s->pc - s->cs_base);
             }
             break;
 
         default:
             goto unknown_op;
         }
         break;
 
     case 0x108:  
     case 0x109:  
         if (s->cpl != 0) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);
              
         }
         break;
     case 0x63:  
 #ifdef TARGET_X86_64
         if (CODE64(s)) {
             int d_ot;
              
             d_ot = dflag;
 
             modrm = cpu_ldub_code(env, s->pc++);
             reg = ((modrm >> 3) & 7) | rex_r;
             mod = (modrm >> 6) & 3;
             rm = (modrm & 7) | REX_B(s);
 
             if (mod == 3) {
                 gen_op_mov_v_reg(MO_32, cpu_T0, rm);
                  
                 if (d_ot == MO_64) {
                     tcg_gen_ext32s_tl(cpu_T0, cpu_T0);
                 }
                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);
             } else {
                 gen_lea_modrm(env, s, modrm);
                 gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);
                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);
             }
         } else
 #endif
         {
             TCGLabel *label1;
             TCGv t0, t1, t2, a0;
 
             if (!s->pe || s->vm86)
                 goto illegal_op;
             t0 = tcg_temp_local_new();
             t1 = tcg_temp_local_new();
             t2 = tcg_temp_local_new();
             ot = MO_16;
             modrm = cpu_ldub_code(env, s->pc++);
             reg = (modrm >> 3) & 7;
             mod = (modrm >> 6) & 3;
             rm = modrm & 7;
             if (mod != 3) {
                 gen_lea_modrm(env, s, modrm);
                 gen_op_ld_v(s, ot, t0, cpu_A0);
                 a0 = tcg_temp_local_new();
                 tcg_gen_mov_tl(a0, cpu_A0);
             } else {
                 gen_op_mov_v_reg(ot, t0, rm);
                 TCGV_UNUSED(a0);
             }
             gen_op_mov_v_reg(ot, t1, reg);
             tcg_gen_andi_tl(cpu_tmp0, t0, 3);
             tcg_gen_andi_tl(t1, t1, 3);
             tcg_gen_movi_tl(t2, 0);
             label1 = gen_new_label();
             tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);
             tcg_gen_andi_tl(t0, t0, ~3);
             tcg_gen_or_tl(t0, t0, t1);
             tcg_gen_movi_tl(t2, CC_Z);
             gen_set_label(label1);
             if (mod != 3) {
                 gen_op_st_v(s, ot, t0, a0);
                 tcg_temp_free(a0);
            } else {
                 gen_op_mov_reg_v(ot, rm, t0);
             }
             gen_compute_eflags(s);
             tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);
             tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);
             tcg_temp_free(t0);
             tcg_temp_free(t1);
             tcg_temp_free(t2);
         }
         break;
     case 0x102:  
     case 0x103:  
         {
             TCGLabel *label1;
             TCGv t0;
             if (!s->pe || s->vm86)
                 goto illegal_op;
             ot = dflag != MO_16 ? MO_32 : MO_16;
             modrm = cpu_ldub_code(env, s->pc++);
             reg = ((modrm >> 3) & 7) | rex_r;
             gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);
             t0 = tcg_temp_local_new();
             gen_update_cc_op(s);
             if (b == 0x102) {
                 gen_helper_lar(t0, cpu_env, cpu_T0);
             } else {
                 gen_helper_lsl(t0, cpu_env, cpu_T0);
             }
             tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);
             label1 = gen_new_label();
             tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);
             gen_op_mov_reg_v(ot, reg, t0);
             gen_set_label(label1);
             set_cc_op(s, CC_OP_EFLAGS);
             tcg_temp_free(t0);
         }
         break;
     case 0x118:
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         op = (modrm >> 3) & 7;
         switch(op) {
         case 0:  
         case 1:  
         case 2:  
         case 3:  
             if (mod == 3)
                 goto illegal_op;
             gen_nop_modrm(env, s, modrm);
              
             break;
         default:  
             gen_nop_modrm(env, s, modrm);
             break;
         }
         break;
     case 0x11a:
         modrm = cpu_ldub_code(env, s->pc++);
         if (s->flags & HF_MPX_EN_MASK) {
             mod = (modrm >> 6) & 3;
             reg = ((modrm >> 3) & 7) | rex_r;
             if (prefixes & PREFIX_REPZ) {
                  
                 if (reg >= 4
                     || (prefixes & PREFIX_LOCK)
                     || s->aflag == MO_16) {
                     goto illegal_op;
                 }
                 gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);
             } else if (prefixes & PREFIX_REPNZ) {
                  
                 if (reg >= 4
                     || (prefixes & PREFIX_LOCK)
                     || s->aflag == MO_16) {
                     goto illegal_op;
                 }
                 TCGv_i64 notu = tcg_temp_new_i64();
                 tcg_gen_not_i64(notu, cpu_bndu[reg]);
                 gen_bndck(env, s, modrm, TCG_COND_GTU, notu);
                 tcg_temp_free_i64(notu);
             } else if (prefixes & PREFIX_DATA) {
                  
                 if (reg >= 4 || s->aflag == MO_16) {
                     goto illegal_op;
                 }
                 if (mod == 3) {
                     int reg2 = (modrm & 7) | REX_B(s);
                     if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {
                         goto illegal_op;
                     }
                     if (s->flags & HF_MPX_IU_MASK) {
                         tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);
                         tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);
                     }
                 } else {
                     gen_lea_modrm(env, s, modrm);
                     if (CODE64(s)) {
                         tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,
                                             s->mem_index, MO_LEQ);
                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);
                         tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,
                                             s->mem_index, MO_LEQ);
                     } else {
                         tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,
                                             s->mem_index, MO_LEUL);
                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);
                         tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,
                                             s->mem_index, MO_LEUL);
                     }
                      
                     gen_set_hflag(s, HF_MPX_IU_MASK);
                 }
             } else if (mod != 3) {
                  
                 AddressParts a = gen_lea_modrm_0(env, s, modrm);
                 if (reg >= 4
                     || (prefixes & PREFIX_LOCK)
                     || s->aflag == MO_16
                     || a.base < -1) {
                     goto illegal_op;
                 }
                 if (a.base >= 0) {
                     tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);
                 } else {
                     tcg_gen_movi_tl(cpu_A0, 0);
                 }
                 gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);
                 if (a.index >= 0) {
                     tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);
                 } else {
                     tcg_gen_movi_tl(cpu_T0, 0);
                 }
                 if (CODE64(s)) {
                     gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);
                     tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,
                                    offsetof(CPUX86State, mmx_t0.MMX_Q(0)));
                 } else {
                     gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);
                     tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);
                     tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);
                 }
                 gen_set_hflag(s, HF_MPX_IU_MASK);
             }
         }
         gen_nop_modrm(env, s, modrm);
         break;
     case 0x11b:
         modrm = cpu_ldub_code(env, s->pc++);
         if (s->flags & HF_MPX_EN_MASK) {
             mod = (modrm >> 6) & 3;
             reg = ((modrm >> 3) & 7) | rex_r;
             if (mod != 3 && (prefixes & PREFIX_REPZ)) {
                  
                 if (reg >= 4
                     || (prefixes & PREFIX_LOCK)
                     || s->aflag == MO_16) {
                     goto illegal_op;
                 }
                 AddressParts a = gen_lea_modrm_0(env, s, modrm);
                 if (a.base >= 0) {
                     tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);
                     if (!CODE64(s)) {
                         tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);
                     }
                 } else if (a.base == -1) {
                      
                     tcg_gen_movi_i64(cpu_bndl[reg], 0);
                 } else {
                      
                     goto illegal_op;
                 }
                 tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));
                 if (!CODE64(s)) {
                     tcg_gen_ext32u_tl(cpu_A0, cpu_A0);
                 }
                 tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);
                  
                 gen_set_hflag(s, HF_MPX_IU_MASK);
                 break;
             } else if (prefixes & PREFIX_REPNZ) {
                  
                 if (reg >= 4
                     || (prefixes & PREFIX_LOCK)
                     || s->aflag == MO_16) {
                     goto illegal_op;
                 }
                 gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);
             } else if (prefixes & PREFIX_DATA) {
                  
                 if (reg >= 4 || s->aflag == MO_16) {
                     goto illegal_op;
                 }
                 if (mod == 3) {
                     int reg2 = (modrm & 7) | REX_B(s);
                     if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {
                         goto illegal_op;
                     }
                     if (s->flags & HF_MPX_IU_MASK) {
                         tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);
                         tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);
                     }
                 } else {
                     gen_lea_modrm(env, s, modrm);
                     if (CODE64(s)) {
                         tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,
                                             s->mem_index, MO_LEQ);
                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);
                         tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,
                                             s->mem_index, MO_LEQ);
                     } else {
                         tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,
                                             s->mem_index, MO_LEUL);
                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);
                         tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,
                                             s->mem_index, MO_LEUL);
                     }
                 }
             } else if (mod != 3) {
                  
                 AddressParts a = gen_lea_modrm_0(env, s, modrm);
                 if (reg >= 4
                     || (prefixes & PREFIX_LOCK)
                     || s->aflag == MO_16
                     || a.base < -1) {
                     goto illegal_op;
                 }
                 if (a.base >= 0) {
                     tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);
                 } else {
                     tcg_gen_movi_tl(cpu_A0, 0);
                 }
                 gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);
                 if (a.index >= 0) {
                     tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);
                 } else {
                     tcg_gen_movi_tl(cpu_T0, 0);
                 }
                 if (CODE64(s)) {
                     gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,
                                         cpu_bndl[reg], cpu_bndu[reg]);
                 } else {
                     gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,
                                         cpu_bndl[reg], cpu_bndu[reg]);
                 }
             }
         }
         gen_nop_modrm(env, s, modrm);
         break;
     case 0x119: case 0x11c ... 0x11f:  
         modrm = cpu_ldub_code(env, s->pc++);
         gen_nop_modrm(env, s, modrm);
         break;
     case 0x120:  
     case 0x122:  
         if (s->cpl != 0) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             modrm = cpu_ldub_code(env, s->pc++);
              
             rm = (modrm & 7) | REX_B(s);
             reg = ((modrm >> 3) & 7) | rex_r;
             if (CODE64(s))
                 ot = MO_64;
             else
                 ot = MO_32;
             if ((prefixes & PREFIX_LOCK) && (reg == 0) &&
                 (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {
                 reg = 8;
             }
             switch(reg) {
             case 0:
             case 2:
             case 3:
             case 4:
             case 8:
                 gen_update_cc_op(s);
                 gen_jmp_im(pc_start - s->cs_base);
                 if (b & 2) {
                     gen_op_mov_v_reg(ot, cpu_T0, rm);
                     gen_helper_write_crN(cpu_env, tcg_const_i32(reg),
                                          cpu_T0);
                     gen_jmp_im(s->pc - s->cs_base);
                     gen_eob(s);
                 } else {
                     gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));
                     gen_op_mov_reg_v(ot, rm, cpu_T0);
                 }
                 break;
             default:
                 goto unknown_op;
             }
         }
         break;
     case 0x121:  
     case 0x123:  
         if (s->cpl != 0) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             modrm = cpu_ldub_code(env, s->pc++);
              
             rm = (modrm & 7) | REX_B(s);
             reg = ((modrm >> 3) & 7) | rex_r;
             if (CODE64(s))
                 ot = MO_64;
             else
                 ot = MO_32;
             if (reg >= 8) {
                 goto illegal_op;
             }
             if (b & 2) {
                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);
                 gen_op_mov_v_reg(ot, cpu_T0, rm);
                 tcg_gen_movi_i32(cpu_tmp2_i32, reg);
                 gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);
                 gen_jmp_im(s->pc - s->cs_base);
                 gen_eob(s);
             } else {
                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);
                 tcg_gen_movi_i32(cpu_tmp2_i32, reg);
                 gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);
                 gen_op_mov_reg_v(ot, rm, cpu_T0);
             }
         }
         break;
     case 0x106:  
         if (s->cpl != 0) {
             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
         } else {
             gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);
             gen_helper_clts(cpu_env);
              
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
         }
         break;
      
     case 0x1c3:  
         if (!(s->cpuid_features & CPUID_SSE2))
             goto illegal_op;
         ot = mo_64_32(dflag);
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         if (mod == 3)
             goto illegal_op;
         reg = ((modrm >> 3) & 7) | rex_r;
          
         gen_ldst_modrm(env, s, modrm, ot, reg, 1);
         break;
     case 0x1ae:
         modrm = cpu_ldub_code(env, s->pc++);
         switch (modrm) {
         CASE_MODRM_MEM_OP(0):  
             if (!(s->cpuid_features & CPUID_FXSR)
                 || (prefixes & PREFIX_LOCK)) {
                 goto illegal_op;
             }
             if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {
                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);
                 break;
             }
             gen_lea_modrm(env, s, modrm);
             gen_helper_fxsave(cpu_env, cpu_A0);
             break;
 
         CASE_MODRM_MEM_OP(1):  
             if (!(s->cpuid_features & CPUID_FXSR)
                 || (prefixes & PREFIX_LOCK)) {
                 goto illegal_op;
             }
             if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {
                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);
                 break;
             }
             gen_lea_modrm(env, s, modrm);
             gen_helper_fxrstor(cpu_env, cpu_A0);
             break;
 
         CASE_MODRM_MEM_OP(2):  
             if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {
                 goto illegal_op;
             }
             if (s->flags & HF_TS_MASK) {
                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);
                 break;
             }
             gen_lea_modrm(env, s, modrm);
             tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);
             gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);
             break;
 
         CASE_MODRM_MEM_OP(3):  
             if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {
                 goto illegal_op;
             }
             if (s->flags & HF_TS_MASK) {
                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);
                 break;
             }
             gen_lea_modrm(env, s, modrm);
             tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));
             gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);
             break;
 
         CASE_MODRM_MEM_OP(4):  
             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0
                 || (prefixes & (PREFIX_LOCK | PREFIX_DATA
                                 | PREFIX_REPZ | PREFIX_REPNZ))) {
                 goto illegal_op;
             }
             gen_lea_modrm(env, s, modrm);
             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],
                                   cpu_regs[R_EDX]);
             gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);
             break;
 
         CASE_MODRM_MEM_OP(5):  
             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0
                 || (prefixes & (PREFIX_LOCK | PREFIX_DATA
                                 | PREFIX_REPZ | PREFIX_REPNZ))) {
                 goto illegal_op;
             }
             gen_lea_modrm(env, s, modrm);
             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],
                                   cpu_regs[R_EDX]);
             gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);
              
             gen_update_cc_op(s);
             gen_jmp_im(s->pc - s->cs_base);
             gen_eob(s);
             break;
 
         CASE_MODRM_MEM_OP(6):  
             if (prefixes & PREFIX_LOCK) {
                 goto illegal_op;
             }
             if (prefixes & PREFIX_DATA) {
                  
                 if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {
                     goto illegal_op;
                 }
                 gen_nop_modrm(env, s, modrm);
             } else {
                  
                 if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0
                     || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0
                     || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {
                     goto illegal_op;
                 }
                 gen_lea_modrm(env, s, modrm);
                 tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],
                                       cpu_regs[R_EDX]);
                 gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);
             }
             break;
 
         CASE_MODRM_MEM_OP(7):  
             if (prefixes & PREFIX_LOCK) {
                 goto illegal_op;
             }
             if (prefixes & PREFIX_DATA) {
                  
                 if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {
                     goto illegal_op;
                 }
             } else {
                  
                 if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))
                     || !(s->cpuid_features & CPUID_CLFLUSH)) {
                     goto illegal_op;
                 }
             }
             gen_nop_modrm(env, s, modrm);
             break;
 
         case 0xc0 ... 0xc7:  
         case 0xc8 ... 0xc8:  
         case 0xd0 ... 0xd7:  
         case 0xd8 ... 0xd8:  
             if (CODE64(s)
                 && (prefixes & PREFIX_REPZ)
                 && !(prefixes & PREFIX_LOCK)
                 && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {
                 TCGv base, treg, src, dst;
 
                  
                 tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);
                 gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);
 
                 base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];
                 treg = cpu_regs[(modrm & 7) | REX_B(s)];
 
                 if (modrm & 0x10) {
                      
                     dst = base, src = treg;
                 } else {
                      
                     dst = treg, src = base;
                 }
 
                 if (s->dflag == MO_32) {
                     tcg_gen_ext32u_tl(dst, src);
                 } else {
                     tcg_gen_mov_tl(dst, src);
                 }
                 break;
             }
             goto unknown_op;
 
         case 0xf8:  
             if (prefixes & PREFIX_DATA) {
                  
                 if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)
                     || (prefixes & PREFIX_LOCK)) {
                     goto illegal_op;
                 }
                 break;
             }
              
         case 0xf9 ... 0xff:  
             if (!(s->cpuid_features & CPUID_SSE)
                 || (prefixes & PREFIX_LOCK)) {
                 goto illegal_op;
             }
             tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);
             break;
         case 0xe8 ... 0xef:  
             if (!(s->cpuid_features & CPUID_SSE)
                 || (prefixes & PREFIX_LOCK)) {
                 goto illegal_op;
             }
             tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);
             break;
         case 0xf0 ... 0xf7:  
             if (!(s->cpuid_features & CPUID_SSE2)
                 || (prefixes & PREFIX_LOCK)) {
                 goto illegal_op;
             }
             tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);
             break;
 
         default:
             goto unknown_op;
         }
         break;
 
     case 0x10d:  
         modrm = cpu_ldub_code(env, s->pc++);
         mod = (modrm >> 6) & 3;
         if (mod == 3)
             goto illegal_op;
         gen_nop_modrm(env, s, modrm);
         break;
     case 0x1aa:  
         gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);
         if (!(s->flags & HF_SMM_MASK))
             goto illegal_op;
         gen_update_cc_op(s);
         gen_jmp_im(s->pc - s->cs_base);
         gen_helper_rsm(cpu_env);
         gen_eob(s);
         break;
     case 0x1b8:  
         if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=
              PREFIX_REPZ)
             goto illegal_op;
         if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))
             goto illegal_op;
 
         modrm = cpu_ldub_code(env, s->pc++);
         reg = ((modrm >> 3) & 7) | rex_r;
 
         if (s->prefix & PREFIX_DATA) {
             ot = MO_16;
         } else {
             ot = mo_64_32(dflag);
         }
 
         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);
         gen_extu(ot, cpu_T0);
         tcg_gen_mov_tl(cpu_cc_src, cpu_T0);
         tcg_gen_ctpop_tl(cpu_T0, cpu_T0);
         gen_op_mov_reg_v(ot, reg, cpu_T0);
 
         set_cc_op(s, CC_OP_POPCNT);
         break;
     case 0x10e ... 0x10f:
          
         s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);
     case 0x110 ... 0x117:
     case 0x128 ... 0x12f:
     case 0x138 ... 0x13a:
     case 0x150 ... 0x179:
     case 0x17c ... 0x17f:
     case 0x1c2:
     case 0x1c4 ... 0x1c6:
     case 0x1d0 ... 0x1fe:
         gen_sse(env, s, b, pc_start, rex_r);
         break;
     default:
         goto unknown_op;
     }
     return s->pc;
  illegal_op:
     gen_illegal_opcode(s);
     return s->pc;
  unknown_op:
     gen_unknown_opcode(env, s);
     return s->pc;
 }","[25, 26, 27, 28]","** DISPUTED ** The disas_insn function in target/i386/translate.c in QEMU before 2.9.0, when TCG mode without hardware acceleration is used, does not limit the instruction size, which allows local users to gain privileges by creating a modified basic block that injects code into a setuid program, as demonstrated by procmail. NOTE: the vendor has stated *this bug does not violate any security guarantees QEMU makes.*"
198320," static av_cold int vqa_decode_init(AVCodecContext *avctx)
 {
     VqaContext *s = avctx->priv_data;
     int i, j, codebook_index;
 
     s->avctx = avctx;
     avctx->pix_fmt = PIX_FMT_PAL8;
 
      
     if (s->avctx->extradata_size != VQA_HEADER_SIZE) {
         av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);
         return -1;
     }
 
      
     s->vqa_version = s->avctx->extradata[0];
     s->width = AV_RL16(&s->avctx->extradata[6]);
     s->height = AV_RL16(&s->avctx->extradata[8]);
     if(av_image_check_size(s->width, s->height, 0, avctx)){
         s->width= s->height= 0;
         return -1;
     }
     s->vector_width = s->avctx->extradata[10];
     s->vector_height = s->avctx->extradata[11];
     s->partial_count = s->partial_countdown = s->avctx->extradata[13];
 
      
     if ((s->vector_width != 4) ||
         ((s->vector_height != 2) && (s->vector_height != 4))) {
          
          return -1;
      }
  
     if (s->width  & (s->vector_width  - 1) ||
         s->height & (s->vector_height - 1)) {
         av_log(avctx, AV_LOG_ERROR, ""Image size not multiple of block size\n"");
         return AVERROR_INVALIDDATA;
     }
 
       
      s->codebook_size = MAX_CODEBOOK_SIZE;
      s->codebook = av_malloc(s->codebook_size);
      
     s->decode_buffer_size = (s->width / s->vector_width) *
         (s->height / s->vector_height) * 2;
     s->decode_buffer = av_malloc(s->decode_buffer_size);
     if (!s->decode_buffer)
         goto fail;
 
      
     if (s->vector_height == 4) {
         codebook_index = 0xFF00 * 16;
         for (i = 0; i < 256; i++)
             for (j = 0; j < 16; j++)
                 s->codebook[codebook_index++] = i;
     } else {
         codebook_index = 0xF00 * 8;
         for (i = 0; i < 256; i++)
             for (j = 0; j < 8; j++)
                 s->codebook[codebook_index++] = i;
     }
     s->next_codebook_buffer_index = 0;
 
     s->frame.data[0] = NULL;
 
     return 0;
 fail:
     av_freep(&s->codebook);
     av_freep(&s->next_codebook_buffer);
     av_freep(&s->decode_buffer);
     return AVERROR(ENOMEM);
 }","[34, 35, 36, 37, 38, 39]","Heap-based buffer overflow in the vqa_decode_chunk function in the VQA codec (vqavideo.c) in libavcodec in Libav 0.5.x before 0.5.9, 0.6.x before 0.6.6, 0.7.x before 0.7.6, and 0.8.x before 0.8.2 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted VQA media file in which the image size is not a multiple of the block size."
202897,"  static void free_user(struct kref *ref)
  {
  	struct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);
 	cleanup_srcu_struct(&user->release_barrier);
  	kfree(user);
  }",[4],"In the Linux kernel before 4.20.5, attackers can trigger a drivers/char/ipmi/ipmi_msghandler.c use-after-free and OOPS by arranging for certain simultaneous execution of the code, as demonstrated by a *service ipmievd restart* loop."
5709,"double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return 0.0;

uint32_t key, insamples;
uint32_t repeat, outsamples;
GPMF_stream find_stream;

if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;

key = GPMF_Key(gs);
repeat = GPMF_Repeat(gs);
if (rate == 0.0)
rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);

if (rate == 0.0)
{
*in = *out = 0.0;
return 0.0;
}

GPMF_CopyState(gs, &find_stream);
if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
{
outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));
insamples = outsamples - repeat;

*in = ((double)insamples / (double)rate);
*out = ((double)outsamples / (double)rate);
}
else
{

*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
}
return rate;
}","[6, 7, 8, 10, 12, 13, 14, 15, 17, 19, 20, 23, 24, 26, 27, 29, 30, 32, 35, 36]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.
8637,"void Compute(OpKernelContext* ctx) override {
const Tensor& a = ctx->input(0);
const Tensor& b = ctx->input(1);
OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),
errors::InvalidArgument(""a is not a matrix""));
OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),
errors::InvalidArgument(""b is not a matrix""));

const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);
const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);
const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);
const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);

OP_REQUIRES(ctx, k == k2,
errors::InvalidArgument(
""Matrix size incompatible: a: "", a.shape().DebugString(),
"", b: "", b.shape().DebugString()));
Tensor* output = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));

if (k == 0) {


functor::SetZeroFunctor<CPUDevice, float> f;
f(ctx->eigen_device<CPUDevice>(), output->flat<float>());
return;
}

auto out = output->matrix<float>();

std::unique_ptr<Tensor> a_float;
std::unique_ptr<Tensor> b_float;
if (!a_is_sparse_ && !b_is_sparse_) {
auto left = &a;
auto right = &b;

if (std::is_same<TL, bfloat16>::value) {
a_float.reset(new Tensor(DT_FLOAT, a.shape()));
BFloat16ToFloat(a.flat<bfloat16>().data(),
a_float->flat<float>().data(), a.NumElements());
left = a_float.get();
}
if (std::is_same<TR, bfloat16>::value) {
b_float.reset(new Tensor(DT_FLOAT, b.shape()));
BFloat16ToFloat(b.flat<bfloat16>().data(),
b_float->flat<float>().data(), b.NumElements());
right = b_float.get();
}
Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;
dim_pair[0].first = transpose_a_ ? 0 : 1;
dim_pair[0].second = transpose_b_ ? 1 : 0;

out.device(ctx->template eigen_device<CPUDevice>()) =
left->matrix<float>().contract(right->matrix<float>(), dim_pair);
return;
}

auto left = &a;
auto right = &b;
bool transpose_output = false;
bool transpose_a = transpose_a_;
bool transpose_b = transpose_b_;
if (!a_is_sparse_) {


std::swap(left, right);
std::swap(transpose_a, transpose_b);
transpose_a = !transpose_a;
transpose_b = !transpose_b;
transpose_output = !transpose_output;
}

std::unique_ptr<Tensor> right_tr;
if (transpose_b) {


OP_REQUIRES(ctx, right->dim_size(0) != 0,
errors::InvalidArgument(""b has an entry 0 in it's shape.""));
OP_REQUIRES(ctx, right->dim_size(1) != 0,
errors::InvalidArgument(""b has an entry 0 in it's shape.""));
right_tr.reset(
new Tensor(right->dtype(),
TensorShape({right->dim_size(1), right->dim_size(0)})));

const auto perm = dsizes_10();
if (transpose_output) {
right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =
right->matrix<TL>().shuffle(perm);
} else {
right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =
right->matrix<TR>().shuffle(perm);
}
right = right_tr.get();
}

if (transpose_output) {
DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),
right->matrix<TL>(), transpose_a,
ctx->device()->tensorflow_cpu_worker_threads(),
transpose_output, &out);
} else {
DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),
right->matrix<TR>(), transpose_a,
ctx->device()->tensorflow_cpu_worker_threads(),
transpose_output, &out);
}
}","[18, 21]","TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."
1836,"rb_fiddle_handle_sym(VALUE self, VALUE sym)
{
struct dl_handle *fiddle_handle;

TypedData_Get_Struct(self, struct dl_handle, &fiddle_handle_data_type, fiddle_handle);
if( ! fiddle_handle->open ){
rb_raise(rb_eFiddleError, ""closed handle"");
}

return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));
}",[10],"The Fiddle::Handle implementation in ext/fiddle/handle.c in Ruby before 2.0.0-p648, 2.1 before 2.1.8, and 2.2 before 2.2.4, as distributed in Apple OS X before 10.11.4 and other products, mishandles tainting, which allows context-dependent attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted string, related to the DL module and the libffi library.  NOTE: this vulnerability exists because of a CVE-2009-5147 regression."
200806," on_unregister_handler(TCMUService1HandlerManager1 *interface,
 		      GDBusMethodInvocation *invocation,
 		      gchar *subtype,
 		      gpointer user_data)
 {
 	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
 	struct dbus_info *info = handler ? handler->opaque : NULL;
 
 	if (!handler) {
 		g_dbus_method_invocation_return_value(invocation,
 			g_variant_new(""(bs)"", FALSE,
  				      ""unknown subtype""));
  		return TRUE;
  	}
 	else if (handler->_is_dbus_handler != 1) {
 		g_dbus_method_invocation_return_value(invocation,
 			g_variant_new(""(bs)"", FALSE,
 				      ""cannot unregister internal handler""));
 		return TRUE;
 	}
 
  	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	tcmur_unregister_dbus_handler(handler);
 
  	g_bus_unwatch_name(info->watcher_id);
  	g_free(info);
  	g_free(handler);
 	g_dbus_method_invocation_return_value(invocation,
 		g_variant_new(""(bs)"", TRUE, ""succeeded""));
 	return TRUE;
 }","[15, 16, 17, 18, 19, 20, 21, 24, 25, 23]",tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service
197745," int phar_get_entry_data(phar_entry_data **ret, char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC)  
 {
 	phar_archive_data *phar;
 	phar_entry_info *entry;
 	int for_write  = mode[0] != 'r' || mode[1] == '+';
 	int for_append = mode[0] == 'a';
 	int for_create = mode[0] != 'r';
 	int for_trunc  = mode[0] == 'w';
 
 	if (!ret) {
 		return FAILURE;
 	}
 
 	*ret = NULL;
 
 	if (error) {
 		*error = NULL;
 	}
 
 	if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {
 		return FAILURE;
 	}
 
 	if (for_write && PHAR_G(readonly) && !phar->is_data) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: file \""%s\"" in phar \""%s\"" cannot be opened for writing, disabled by ini setting"", path, fname);
 		}
 		return FAILURE;
 	}
 
 	if (!path_len) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: file \""\"" in phar \""%s\"" cannot be empty"", fname);
 		}
 		return FAILURE;
 	}
 really_get_entry:
 	if (allow_dir) {
 		if ((entry = phar_get_entry_info_dir(phar, path, path_len, allow_dir, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {
 			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {
 				return SUCCESS;
 			}
 			return FAILURE;
 		}
 	} else {
 		if ((entry = phar_get_entry_info(phar, path, path_len, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {
 			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {
 				return SUCCESS;
 			}
 			return FAILURE;
 		}
 	}
 
 	if (for_write && phar->is_persistent) {
 		if (FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {
 			if (error) {
 				spprintf(error, 4096, ""phar error: file \""%s\"" in phar \""%s\"" cannot be opened for writing, could not make cached phar writeable"", path, fname);
 			}
 			return FAILURE;
 		} else {
 			goto really_get_entry;
 		}
 	}
 
 	if (entry->is_modified && !for_write) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: file \""%s\"" in phar \""%s\"" cannot be opened for reading, writable file pointers are open"", path, fname);
 		}
 		return FAILURE;
 	}
 
 	if (entry->fp_refcount && for_write) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: file \""%s\"" in phar \""%s\"" cannot be opened for writing, readable file pointers are open"", path, fname);
 		}
 		return FAILURE;
 	}
 
 	if (entry->is_deleted) {
 		if (!for_create) {
 			return FAILURE;
 		}
 		entry->is_deleted = 0;
 	}
 
 	if (entry->is_dir) {
 		*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));
 		(*ret)->position = 0;
 		(*ret)->fp = NULL;
 		(*ret)->phar = phar;
 		(*ret)->for_write = for_write;
 		(*ret)->internal_file = entry;
 		(*ret)->is_zip = entry->is_zip;
 		(*ret)->is_tar = entry->is_tar;
 
 		if (!phar->is_persistent) {
 			++(entry->phar->refcount);
 			++(entry->fp_refcount);
 		}
 
 		return SUCCESS;
 	}
 
 	if (entry->fp_type == PHAR_MOD) {
 		if (for_trunc) {
 			if (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {
 				return FAILURE;
 			}
 		} else if (for_append) {
 			phar_seek_efp(entry, 0, SEEK_END, 0, 0 TSRMLS_CC);
 		}
 	} else {
 		if (for_write) {
 			if (entry->link) {
 				efree(entry->link);
 				entry->link = NULL;
 				entry->tar_type = (entry->is_tar ? TAR_FILE : '\0');
 			}
 
 			if (for_trunc) {
 				if (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {
 					return FAILURE;
 				}
 			} else {
 				if (FAILURE == phar_separate_entry_fp(entry, error TSRMLS_CC)) {
 					return FAILURE;
 				}
 			}
 		} else {
 			if (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {
 				return FAILURE;
 			}
 		}
 	}
 
 	*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));
 	(*ret)->position = 0;
 	(*ret)->phar = phar;
 	(*ret)->for_write = for_write;
 	(*ret)->internal_file = entry;
 	(*ret)->is_zip = entry->is_zip;
         (*ret)->is_tar = entry->is_tar;
         (*ret)->fp = phar_get_efp(entry, 1 TSRMLS_CC);
         if (entry->link) {
               (*ret)->zero = phar_get_fp_offset(phar_get_link_source(entry TSRMLS_CC) TSRMLS_CC);
                phar_entry_info *link = phar_get_link_source(entry TSRMLS_CC);
                if(!link) {
                        return FAILURE;
                }
                (*ret)->zero = phar_get_fp_offset(link TSRMLS_CC);
         } else {
                 (*ret)->zero = phar_get_fp_offset(entry TSRMLS_CC);
         }
 	}
 
 	return SUCCESS;
 }
  
 
  
 phar_entry_data *phar_get_or_create_entry_data(char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC)  
 {
 	phar_archive_data *phar;
 	phar_entry_info *entry, etemp;
 	phar_entry_data *ret;
 	const char *pcr_error;
 	char is_dir;
 
 #ifdef PHP_WIN32
 	phar_unixify_path_separators(path, path_len);
 #endif
 
 	is_dir = (path_len && path[path_len - 1] == '/') ? 1 : 0;
 
 	if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {
 		return NULL;
 	}
 
 	if (FAILURE == phar_get_entry_data(&ret, fname, fname_len, path, path_len, mode, allow_dir, error, security TSRMLS_CC)) {
 		return NULL;
 	} else if (ret) {
 		return ret;
 	}
 
 	if (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {
 		if (error) {
 			spprintf(error, 0, ""phar error: invalid path \""%s\"" contains %s"", path, pcr_error);
 		}
 		return NULL;
 	}
 
 	if (phar->is_persistent && FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: file \""%s\"" in phar \""%s\"" cannot be created, could not make cached phar writeable"", path, fname);
 		}
 		return NULL;
 	}
 
 	 
 	ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));
 
 	 
 	memset(&etemp, 0, sizeof(phar_entry_info));
 	etemp.filename_len = path_len;
 	etemp.fp_type = PHAR_MOD;
 	etemp.fp = php_stream_fopen_tmpfile();
 
 	if (!etemp.fp) {
 		if (error) {
 			spprintf(error, 0, ""phar error: unable to create temporary file"");
 		}
 		efree(ret);
 		return NULL;
 	}
 
 	etemp.fp_refcount = 1;
 
 	if (allow_dir == 2) {
 		etemp.is_dir = 1;
 		etemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_DIR;
 	} else {
 		etemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_FILE;
 	}
 	if (is_dir) {
 		etemp.filename_len--;  
 		path_len--;
 	}
 
 	phar_add_virtual_dirs(phar, path, path_len TSRMLS_CC);
 	etemp.is_modified = 1;
 	etemp.timestamp = time(0);
 	etemp.is_crc_checked = 1;
 	etemp.phar = phar;
 	etemp.filename = estrndup(path, path_len);
 	etemp.is_zip = phar->is_zip;
 
 	if (phar->is_tar) {
 		etemp.is_tar = phar->is_tar;
 		etemp.tar_type = etemp.is_dir ? TAR_DIR : TAR_FILE;
 	}
 
 	if (FAILURE == zend_hash_add(&phar->manifest, etemp.filename, path_len, (void*)&etemp, sizeof(phar_entry_info), (void **) &entry)) {
 		php_stream_close(etemp.fp);
 		if (error) {
 			spprintf(error, 0, ""phar error: unable to add new entry \""%s\"" to phar \""%s\"""", etemp.filename, phar->fname);
 		}
 		efree(ret);
 		efree(etemp.filename);
 		return NULL;
 	}
 
 	if (!entry) {
 		php_stream_close(etemp.fp);
 		efree(etemp.filename);
 		efree(ret);
 		return NULL;
 	}
 
 	++(phar->refcount);
 	ret->phar = phar;
 	ret->fp = entry->fp;
 	ret->position = ret->zero = 0;
 	ret->for_write = 1;
 	ret->is_zip = entry->is_zip;
 	ret->is_tar = entry->is_tar;
 	ret->internal_file = entry;
 
 	return ret;
 }
  
 
  
 int phar_open_archive_fp(phar_archive_data *phar TSRMLS_DC)  
 {
 	if (phar_get_pharfp(phar TSRMLS_CC)) {
 		return SUCCESS;
 	}
 
 	if (php_check_open_basedir(phar->fname TSRMLS_CC)) {
 		return FAILURE;
 	}
 
 	phar_set_pharfp(phar, php_stream_open_wrapper(phar->fname, ""rb"", IGNORE_URL|STREAM_MUST_SEEK|0, NULL) TSRMLS_CC);
 
 	if (!phar_get_pharfp(phar TSRMLS_CC)) {
 		return FAILURE;
 	}
 
 	return SUCCESS;
 }
  
 
  
 int phar_copy_entry_fp(phar_entry_info *source, phar_entry_info *dest, char **error TSRMLS_DC)  
 {
 	phar_entry_info *link;
 
 	if (FAILURE == phar_open_entry_fp(source, error, 1 TSRMLS_CC)) {
 		return FAILURE;
 	}
 
 	if (dest->link) {
 		efree(dest->link);
 		dest->link = NULL;
 		dest->tar_type = (dest->is_tar ? TAR_FILE : '\0');
 	}
 
 	dest->fp_type = PHAR_MOD;
 	dest->offset = 0;
 	dest->is_modified = 1;
 	dest->fp = php_stream_fopen_tmpfile();
 	if (dest->fp == NULL) {
 		spprintf(error, 0, ""phar error: unable to create temporary file"");
 		return EOF;
 	}
 	phar_seek_efp(source, 0, SEEK_SET, 0, 1 TSRMLS_CC);
 	link = phar_get_link_source(source TSRMLS_CC);
 
 	if (!link) {
 		link = source;
 	}
 
 	if (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), dest->fp, link->uncompressed_filesize, NULL)) {
 		php_stream_close(dest->fp);
 		dest->fp_type = PHAR_FP;
 		if (error) {
 			spprintf(error, 4096, ""phar error: unable to copy contents of file \""%s\"" to \""%s\"" in phar archive \""%s\"""", source->filename, dest->filename, source->phar->fname);
 		}
 		return FAILURE;
 	}
 
 	return SUCCESS;
 }
  
 
  
 int phar_open_entry_fp(phar_entry_info *entry, char **error, int follow_links TSRMLS_DC)  
 {
 	php_stream_filter *filter;
 	phar_archive_data *phar = entry->phar;
 	char *filtername;
 	off_t loc;
 	php_stream *ufp;
 	phar_entry_data dummy;
 
 	if (follow_links && entry->link) {
 		phar_entry_info *link_entry = phar_get_link_source(entry TSRMLS_CC);
 		if (link_entry && link_entry != entry) {
 			return phar_open_entry_fp(link_entry, error, 1 TSRMLS_CC);
 		}
 	}
 
 	if (entry->is_modified) {
 		return SUCCESS;
 	}
 
 	if (entry->fp_type == PHAR_TMP) {
 		if (!entry->fp) {
 			entry->fp = php_stream_open_wrapper(entry->tmp, ""rb"", STREAM_MUST_SEEK|0, NULL);
 		}
 		return SUCCESS;
 	}
 
 	if (entry->fp_type != PHAR_FP) {
 		 
 		return SUCCESS;
 	}
 
 	if (!phar_get_pharfp(phar TSRMLS_CC)) {
 		if (FAILURE == phar_open_archive_fp(phar TSRMLS_CC)) {
 			spprintf(error, 4096, ""phar error: Cannot open phar archive \""%s\"" for reading"", phar->fname);
 			return FAILURE;
 		}
 	}
 
 	if ((entry->old_flags && !(entry->old_flags & PHAR_ENT_COMPRESSION_MASK)) || !(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {
 		dummy.internal_file = entry;
 		dummy.phar = phar;
 		dummy.zero = entry->offset;
 		dummy.fp = phar_get_pharfp(phar TSRMLS_CC);
 		if (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {
 			return FAILURE;
 		}
 		return SUCCESS;
 	}
 
 	if (!phar_get_entrypufp(entry TSRMLS_CC)) {
 		phar_set_entrypufp(entry, php_stream_fopen_tmpfile() TSRMLS_CC);
 		if (!phar_get_entrypufp(entry TSRMLS_CC)) {
 			spprintf(error, 4096, ""phar error: Cannot open temporary file for decompressing phar archive \""%s\"" file \""%s\"""", phar->fname, entry->filename);
 			return FAILURE;
 		}
 	}
 
 	dummy.internal_file = entry;
 	dummy.phar = phar;
 	dummy.zero = entry->offset;
 	dummy.fp = phar_get_pharfp(phar TSRMLS_CC);
 	if (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {
 		return FAILURE;
 	}
 
 	ufp = phar_get_entrypufp(entry TSRMLS_CC);
 
 	if ((filtername = phar_decompress_filter(entry, 0)) != NULL) {
 		filter = php_stream_filter_create(filtername, NULL, 0 TSRMLS_CC);
 	} else {
 		filter = NULL;
 	}
 
 	if (!filter) {
 		spprintf(error, 4096, ""phar error: unable to read phar \""%s\"" (cannot create %s filter while decompressing file \""%s\"")"", phar->fname, phar_decompress_filter(entry, 1), entry->filename);
 		return FAILURE;
 	}
 
 	 
 	 
 	php_stream_seek(ufp, 0, SEEK_END);
 	loc = php_stream_tell(ufp);
 	php_stream_filter_append(&ufp->writefilters, filter);
 	php_stream_seek(phar_get_entrypfp(entry TSRMLS_CC), phar_get_fp_offset(entry TSRMLS_CC), SEEK_SET);
 
 	if (entry->uncompressed_filesize) {
 		if (SUCCESS != phar_stream_copy_to_stream(phar_get_entrypfp(entry TSRMLS_CC), ufp, entry->compressed_filesize, NULL)) {
 			spprintf(error, 4096, ""phar error: internal corruption of phar \""%s\"" (actual filesize mismatch on file \""%s\"")"", phar->fname, entry->filename);
 			php_stream_filter_remove(filter, 1 TSRMLS_CC);
 			return FAILURE;
 		}
 	}
 
 	php_stream_filter_flush(filter, 1);
 	php_stream_flush(ufp);
 	php_stream_filter_remove(filter, 1 TSRMLS_CC);
 
 	if (php_stream_tell(ufp) - loc != (off_t) entry->uncompressed_filesize) {
 		spprintf(error, 4096, ""phar error: internal corruption of phar \""%s\"" (actual filesize mismatch on file \""%s\"")"", phar->fname, entry->filename);
 		return FAILURE;
 	}
 
 	entry->old_flags = entry->flags;
 
 	 
 	phar_set_fp_type(entry, PHAR_UFP, loc TSRMLS_CC);
 	dummy.zero = entry->offset;
 	dummy.fp = ufp;
 	if (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 0 TSRMLS_CC)) {
 		return FAILURE;
 	}
 	return SUCCESS;
 }
  
 
 int phar_create_writeable_entry(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC)  
 {
 	if (entry->fp_type == PHAR_MOD) {
 		 
 		php_stream_truncate_set_size(entry->fp, 0);
 
 		entry->old_flags = entry->flags;
 		entry->is_modified = 1;
 		phar->is_modified = 1;
 		 
 		entry->uncompressed_filesize = 0;
 		entry->compressed_filesize = 0;
 		entry->crc32 = 0;
 		entry->flags = PHAR_ENT_PERM_DEF_FILE;
 		entry->fp_type = PHAR_MOD;
 		entry->offset = 0;
 		return SUCCESS;
 	}
 
 	if (error) {
 		*error = NULL;
 	}
 
 	 
 	if (entry->link) {
 		efree(entry->link);
 		entry->link = NULL;
 		entry->tar_type = (entry->is_tar ? TAR_FILE : '\0');
 	}
 
 	entry->fp = php_stream_fopen_tmpfile();
 
 	if (!entry->fp) {
 		if (error) {
 			spprintf(error, 0, ""phar error: unable to create temporary file"");
 		}
 		return FAILURE;
 	}
 
 	entry->old_flags = entry->flags;
 	entry->is_modified = 1;
 	phar->is_modified = 1;
 	 
 	entry->uncompressed_filesize = 0;
 	entry->compressed_filesize = 0;
 	entry->crc32 = 0;
 	entry->flags = PHAR_ENT_PERM_DEF_FILE;
 	entry->fp_type = PHAR_MOD;
 	entry->offset = 0;
 	return SUCCESS;
 }
  
 
 int phar_separate_entry_fp(phar_entry_info *entry, char **error TSRMLS_DC)  
 {
 	php_stream *fp;
 	phar_entry_info *link;
 
 	if (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {
 		return FAILURE;
 	}
 
 	if (entry->fp_type == PHAR_MOD) {
 		return SUCCESS;
 	}
 
 	fp = php_stream_fopen_tmpfile();
 	if (fp == NULL) {
 		spprintf(error, 0, ""phar error: unable to create temporary file"");
 		return FAILURE;
 	}
 	phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);
 	link = phar_get_link_source(entry TSRMLS_CC);
 
 	if (!link) {
 		link = entry;
 	}
 
 	if (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: cannot separate entry file \""%s\"" contents in phar archive \""%s\"" for write access"", entry->filename, entry->phar->fname);
 		}
 		return FAILURE;
 	}
 
 	if (entry->link) {
 		efree(entry->link);
 		entry->link = NULL;
 		entry->tar_type = (entry->is_tar ? TAR_FILE : '\0');
 	}
 
 	entry->offset = 0;
 	entry->fp = fp;
 	entry->fp_type = PHAR_MOD;
 	entry->is_modified = 1;
 	return SUCCESS;
 }
  
 
  
 phar_entry_info * phar_open_jit(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC)  
 {
 	if (error) {
 		*error = NULL;
 	}
 	 
 	if (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {
 		return NULL;
 	}
 	if (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {
 		spprintf(error, 4096, ""phar error: cannot seek to start of file \""%s\"" in phar \""%s\"""", entry->filename, phar->fname);
 		return NULL;
 	}
 	return entry;
 }
  
 
 PHP_PHAR_API int phar_resolve_alias(char *alias, int alias_len, char **filename, int *filename_len TSRMLS_DC)   {
 	phar_archive_data **fd_ptr;
 	if (PHAR_GLOBALS->phar_alias_map.arBuckets
 			&& SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void**)&fd_ptr)) {
 		*filename = (*fd_ptr)->fname;
 		*filename_len = (*fd_ptr)->fname_len;
 		return SUCCESS;
 	}
 	return FAILURE;
 }
  
 
 int phar_free_alias(phar_archive_data *phar, char *alias, int alias_len TSRMLS_DC)  
 {
 	if (phar->refcount || phar->is_persistent) {
 		return FAILURE;
 	}
 
 	 
 	if (zend_hash_del(&(PHAR_GLOBALS->phar_fname_map), phar->fname, phar->fname_len) != SUCCESS) {
 		return FAILURE;
 	}
 
 	 
 	PHAR_G(last_phar) = NULL;
 	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;
 
 	return SUCCESS;
 }
  
 
  
 int phar_get_archive(phar_archive_data **archive, char *fname, int fname_len, char *alias, int alias_len, char **error TSRMLS_DC)  
 {
 	phar_archive_data *fd, **fd_ptr;
 	char *my_realpath, *save;
 	int save_len;
 	ulong fhash, ahash = 0;
 
 	phar_request_initialize(TSRMLS_C);
 
 	if (error) {
 		*error = NULL;
 	}
 
 	*archive = NULL;
 
 	if (PHAR_G(last_phar) && fname_len == PHAR_G(last_phar_name_len) && !memcmp(fname, PHAR_G(last_phar_name), fname_len)) {
 		*archive = PHAR_G(last_phar);
 		if (alias && alias_len) {
 
 			if (!PHAR_G(last_phar)->is_temporary_alias && (alias_len != PHAR_G(last_phar)->alias_len || memcmp(PHAR_G(last_phar)->alias, alias, alias_len))) {
 				if (error) {
 					spprintf(error, 0, ""alias \""%s\"" is already used for archive \""%s\"" cannot be overloaded with \""%s\"""", alias, PHAR_G(last_phar)->fname, fname);
 				}
 				*archive = NULL;
 				return FAILURE;
 			}
 
 			if (PHAR_G(last_phar)->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len, (void**)&fd_ptr)) {
 				zend_hash_del(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len);
 			}
 
 			zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&(*archive), sizeof(phar_archive_data*), NULL);
 			PHAR_G(last_alias) = alias;
 			PHAR_G(last_alias_len) = alias_len;
 		}
 
 		return SUCCESS;
 	}
 
 	if (alias && alias_len && PHAR_G(last_phar) && alias_len == PHAR_G(last_alias_len) && !memcmp(alias, PHAR_G(last_alias), alias_len)) {
 		fd = PHAR_G(last_phar);
 		fd_ptr = &fd;
 		goto alias_success;
 	}
 
 	if (alias && alias_len) {
 		ahash = zend_inline_hash_func(alias, alias_len);
 		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void**)&fd_ptr)) {
 alias_success:
 			if (fname && (fname_len != (*fd_ptr)->fname_len || strncmp(fname, (*fd_ptr)->fname, fname_len))) {
 				if (error) {
 					spprintf(error, 0, ""alias \""%s\"" is already used for archive \""%s\"" cannot be overloaded with \""%s\"""", alias, (*fd_ptr)->fname, fname);
 				}
 				if (SUCCESS == phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {
 					if (error) {
 						efree(*error);
 						*error = NULL;
 					}
 				}
 				return FAILURE;
 			}
 
 			*archive = *fd_ptr;
 			fd = *fd_ptr;
 			PHAR_G(last_phar) = fd;
 			PHAR_G(last_phar_name) = fd->fname;
 			PHAR_G(last_phar_name_len) = fd->fname_len;
 			PHAR_G(last_alias) = alias;
 			PHAR_G(last_alias_len) = alias_len;
 
 			return SUCCESS;
 		}
 
 		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, alias, alias_len, ahash, (void **)&fd_ptr)) {
 			goto alias_success;
 		}
 	}
 
 	fhash = zend_inline_hash_func(fname, fname_len);
 	my_realpath = NULL;
 	save = fname;
 	save_len = fname_len;
 
 	if (fname && fname_len) {
 		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {
 			*archive = *fd_ptr;
 			fd = *fd_ptr;
 
 			if (alias && alias_len) {
 				if (!fd->is_temporary_alias && (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len))) {
 					if (error) {
 						spprintf(error, 0, ""alias \""%s\"" is already used for archive \""%s\"" cannot be overloaded with \""%s\"""", alias, (*fd_ptr)->fname, fname);
 					}
 					return FAILURE;
 				}
 
 				if (fd->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len, (void**)&fd_ptr)) {
 					zend_hash_del(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len);
 				}
 
 				zend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);
 			}
 
 			PHAR_G(last_phar) = fd;
 			PHAR_G(last_phar_name) = fd->fname;
 			PHAR_G(last_phar_name_len) = fd->fname_len;
 			PHAR_G(last_alias) = fd->alias;
 			PHAR_G(last_alias_len) = fd->alias_len;
 
 			return SUCCESS;
 		}
 
 		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {
 			*archive = *fd_ptr;
 			fd = *fd_ptr;
 
 			 
 			if (!fd->is_temporary_alias && alias && alias_len) {
 				if (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len)) {
 					if (error) {
 						spprintf(error, 0, ""alias \""%s\"" is already used for archive \""%s\"" cannot be overloaded with \""%s\"""", alias, (*fd_ptr)->fname, fname);
 					}
 					return FAILURE;
 				}
 			}
 
 			PHAR_G(last_phar) = fd;
 			PHAR_G(last_phar_name) = fd->fname;
 			PHAR_G(last_phar_name_len) = fd->fname_len;
 			PHAR_G(last_alias) = fd->alias;
 			PHAR_G(last_alias_len) = fd->alias_len;
 
 			return SUCCESS;
 		}
 
 		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), save, save_len, fhash, (void**)&fd_ptr)) {
 			fd = *archive = *fd_ptr;
 
 			PHAR_G(last_phar) = fd;
 			PHAR_G(last_phar_name) = fd->fname;
 			PHAR_G(last_phar_name_len) = fd->fname_len;
 			PHAR_G(last_alias) = fd->alias;
 			PHAR_G(last_alias_len) = fd->alias_len;
 
 			return SUCCESS;
 		}
 
 		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, save, save_len, fhash, (void**)&fd_ptr)) {
 			fd = *archive = *fd_ptr;
 
 			PHAR_G(last_phar) = fd;
 			PHAR_G(last_phar_name) = fd->fname;
 			PHAR_G(last_phar_name_len) = fd->fname_len;
 			PHAR_G(last_alias) = fd->alias;
 			PHAR_G(last_alias_len) = fd->alias_len;
 
 			return SUCCESS;
 		}
 
 		 
 		my_realpath = expand_filepath(fname, my_realpath TSRMLS_CC);
 
 		if (my_realpath) {
 			fname_len = strlen(my_realpath);
 			fname = my_realpath;
 		} else {
 			return FAILURE;
 		}
 #ifdef PHP_WIN32
 		phar_unixify_path_separators(fname, fname_len);
 #endif
 		fhash = zend_inline_hash_func(fname, fname_len);
 
 		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {
 realpath_success:
 			*archive = *fd_ptr;
 			fd = *fd_ptr;
 
 			if (alias && alias_len) {
 				zend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);
 			}
 
 			efree(my_realpath);
 
 			PHAR_G(last_phar) = fd;
 			PHAR_G(last_phar_name) = fd->fname;
 			PHAR_G(last_phar_name_len) = fd->fname_len;
 			PHAR_G(last_alias) = fd->alias;
 			PHAR_G(last_alias_len) = fd->alias_len;
 
 			return SUCCESS;
 		}
 
 		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {
 			goto realpath_success;
 		}
 
 		efree(my_realpath);
 	}
 
 	return FAILURE;
 }
  
 
  
 char * phar_compress_filter(phar_entry_info * entry, int return_unknown)  
 {
 	switch (entry->flags & PHAR_ENT_COMPRESSION_MASK) {
 	case PHAR_ENT_COMPRESSED_GZ:
 		return ""zlib.deflate"";
 	case PHAR_ENT_COMPRESSED_BZ2:
 		return ""bzip2.compress"";
 	default:
 		return return_unknown ? ""unknown"" : NULL;
 	}
 }
  
 
  
 char * phar_decompress_filter(phar_entry_info * entry, int return_unknown)  
 {
 	php_uint32 flags;
 
 	if (entry->is_modified) {
 		flags = entry->old_flags;
 	} else {
 		flags = entry->flags;
 	}
 
 	switch (flags & PHAR_ENT_COMPRESSION_MASK) {
 		case PHAR_ENT_COMPRESSED_GZ:
 			return ""zlib.inflate"";
 		case PHAR_ENT_COMPRESSED_BZ2:
 			return ""bzip2.decompress"";
 		default:
 			return return_unknown ? ""unknown"" : NULL;
 	}
 }
  
 
  
 phar_entry_info *phar_get_entry_info(phar_archive_data *phar, char *path, int path_len, char **error, int security TSRMLS_DC)  
 {
 	return phar_get_entry_info_dir(phar, path, path_len, 0, error, security TSRMLS_CC);
 }
  
  
 phar_entry_info *phar_get_entry_info_dir(phar_archive_data *phar, char *path, int path_len, char dir, char **error, int security TSRMLS_DC)  
 {
 	const char *pcr_error;
 	phar_entry_info *entry;
 	int is_dir;
 
 #ifdef PHP_WIN32
 	phar_unixify_path_separators(path, path_len);
 #endif
 
 	is_dir = (path_len && (path[path_len - 1] == '/')) ? 1 : 0;
 
 	if (error) {
 		*error = NULL;
 	}
 
 	if (security && path_len >= sizeof("".phar"")-1 && !memcmp(path, "".phar"", sizeof("".phar"")-1)) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: cannot directly access magic \"".phar\"" directory or files within it"");
 		}
 		return NULL;
 	}
 
 	if (!path_len && !dir) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: invalid path \""%s\"" must not be empty"", path);
 		}
 		return NULL;
 	}
 
 	if (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {
 		if (error) {
 			spprintf(error, 4096, ""phar error: invalid path \""%s\"" contains %s"", path, pcr_error);
 		}
 		return NULL;
 	}
 
 	if (!phar->manifest.arBuckets) {
 		return NULL;
 	}
 
 	if (is_dir) {
 		if (!path_len || path_len == 1) {
 			return NULL;
 		}
 		path_len--;
 	}
 
 	if (SUCCESS == zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {
 		if (entry->is_deleted) {
 			 
 			return NULL;
 		}
 		if (entry->is_dir && !dir) {
 			if (error) {
 				spprintf(error, 4096, ""phar error: path \""%s\"" is a directory"", path);
 			}
 			return NULL;
 		}
 		if (!entry->is_dir && dir == 2) {
 			 
 			if (error) {
 				spprintf(error, 4096, ""phar error: path \""%s\"" exists and is a not a directory"", path);
 			}
 			return NULL;
 		}
 		return entry;
 	}
 
 	if (dir) {
 		if (zend_hash_exists(&phar->virtual_dirs, path, path_len)) {
 			 
 			entry = (phar_entry_info *) ecalloc(1, sizeof(phar_entry_info));
 			 
 			entry->is_temp_dir = entry->is_dir = 1;
 			entry->filename = (char *) estrndup(path, path_len + 1);
 			entry->filename_len = path_len;
 			entry->phar = phar;
 			return entry;
 		}
 	}
 
 	if (phar->mounted_dirs.arBuckets && zend_hash_num_elements(&phar->mounted_dirs)) {
 		phar_zstr key;
 		char *str_key;
 		ulong unused;
 		uint keylen;
 
 		zend_hash_internal_pointer_reset(&phar->mounted_dirs);
 		while (FAILURE != zend_hash_has_more_elements(&phar->mounted_dirs)) {
 			if (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(&phar->mounted_dirs, &key, &keylen, &unused, 0, NULL)) {
 				break;
 			}
 
 			PHAR_STR(key, str_key);
 
 			if ((int)keylen >= path_len || strncmp(str_key, path, keylen)) {
 				PHAR_STR_FREE(str_key);
 				continue;
 			} else {
 				char *test;
 				int test_len;
 				php_stream_statbuf ssb;
 
 				if (SUCCESS != zend_hash_find(&phar->manifest, str_key, keylen, (void **) &entry)) {
 					if (error) {
 						spprintf(error, 4096, ""phar internal error: mounted path \""%s\"" could not be retrieved from manifest"", str_key);
 					}
 					PHAR_STR_FREE(str_key);
 					return NULL;
 				}
 
 				if (!entry->tmp || !entry->is_mounted) {
 					if (error) {
 						spprintf(error, 4096, ""phar internal error: mounted path \""%s\"" is not properly initialized as a mounted path"", str_key);
 					}
 					PHAR_STR_FREE(str_key);
 					return NULL;
 				}
 				PHAR_STR_FREE(str_key);
 
 				test_len = spprintf(&test, MAXPATHLEN, ""%s%s"", entry->tmp, path + keylen);
 
 				if (SUCCESS != php_stream_stat_path(test, &ssb)) {
 					efree(test);
 					return NULL;
 				}
 
 				if (ssb.sb.st_mode & S_IFDIR && !dir) {
 					efree(test);
 					if (error) {
 						spprintf(error, 4096, ""phar error: path \""%s\"" is a directory"", path);
 					}
 					return NULL;
 				}
 
 				if ((ssb.sb.st_mode & S_IFDIR) == 0 && dir) {
 					efree(test);
 					 
 					if (error) {
 						spprintf(error, 4096, ""phar error: path \""%s\"" exists and is a not a directory"", path);
 					}
 					return NULL;
 				}
 
 				 
 				if (SUCCESS != phar_mount_entry(phar, test, test_len, path, path_len TSRMLS_CC)) {
 					efree(test);
 					if (error) {
 						spprintf(error, 4096, ""phar error: path \""%s\"" exists as file \""%s\"" and could not be mounted"", path, test);
 					}
 					return NULL;
 				}
 
 				efree(test);
 
 				if (SUCCESS != zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {
 					if (error) {
 						spprintf(error, 4096, ""phar error: path \""%s\"" exists as file \""%s\"" and could not be retrieved after being mounted"", path, test);
 					}
 					return NULL;
 				}
 				return entry;
 			}
 		}
 	}
 
 	return NULL;
 }
  
 
 static const char hexChars[] = ""0123456789ABCDEF"";
 
 static int phar_hex_str(const char *digest, size_t digest_len, char **signature TSRMLS_DC)  
 {
 	int pos = -1;
 	size_t len = 0;
 
 	*signature = (char*)safe_pemalloc(digest_len, 2, 1, PHAR_G(persist));
 
 	for (; len < digest_len; ++len) {
 		(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] >> 4];
 		(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] & 0x0F];
 	}
 	(*signature)[++pos] = '\0';
 	return pos;
 }
  
 
 #ifndef PHAR_HAVE_OPENSSL
 static int phar_call_openssl_signverify(int is_sign, php_stream *fp, off_t end, char *key, int key_len, char **signature, int *signature_len TSRMLS_DC)  
 {
 	zend_fcall_info fci;
 	zend_fcall_info_cache fcc;
 	zval *zdata, *zsig, *zkey, *retval_ptr, **zp[3], *openssl;
 
 	MAKE_STD_ZVAL(zdata);
 	MAKE_STD_ZVAL(openssl);
 	ZVAL_STRINGL(openssl, is_sign ? ""openssl_sign"" : ""openssl_verify"", is_sign ? sizeof(""openssl_sign"")-1 : sizeof(""openssl_verify"")-1, 1);
 	MAKE_STD_ZVAL(zsig);
 	ZVAL_STRINGL(zsig, *signature, *signature_len, 1);
 	MAKE_STD_ZVAL(zkey);
 	ZVAL_STRINGL(zkey, key, key_len, 1);
 	zp[0] = &zdata;
 	zp[1] = &zsig;
 	zp[2] = &zkey;
 
 	php_stream_rewind(fp);
 	Z_TYPE_P(zdata) = IS_STRING;
 	Z_STRLEN_P(zdata) = end;
 
 	if (end != (off_t) php_stream_copy_to_mem(fp, &(Z_STRVAL_P(zdata)), (size_t) end, 0)) {
 		zval_dtor(zdata);
 		zval_dtor(zsig);
 		zval_dtor(zkey);
 		zval_dtor(openssl);
 		efree(openssl);
 		efree(zdata);
 		efree(zkey);
 		efree(zsig);
 		return FAILURE;
 	}
 
 	if (FAILURE == zend_fcall_info_init(openssl, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {
 		zval_dtor(zdata);
 		zval_dtor(zsig);
 		zval_dtor(zkey);
 		zval_dtor(openssl);
 		efree(openssl);
 		efree(zdata);
 		efree(zkey);
 		efree(zsig);
 		return FAILURE;
 	}
 
 	fci.param_count = 3;
 	fci.params = zp;
 	Z_ADDREF_P(zdata);
 	if (is_sign) {
 		Z_SET_ISREF_P(zsig);
 	} else {
 		Z_ADDREF_P(zsig);
 	}
 	Z_ADDREF_P(zkey);
 
 	fci.retval_ptr_ptr = &retval_ptr;
 
 	if (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {
 		zval_dtor(zdata);
 		zval_dtor(zsig);
 		zval_dtor(zkey);
 		zval_dtor(openssl);
 		efree(openssl);
 		efree(zdata);
 		efree(zkey);
 		efree(zsig);
 		return FAILURE;
 	}
 
 	zval_dtor(openssl);
 	efree(openssl);
 	Z_DELREF_P(zdata);
 
 	if (is_sign) {
 		Z_UNSET_ISREF_P(zsig);
 	} else {
 		Z_DELREF_P(zsig);
 	}
 	Z_DELREF_P(zkey);
 
 	zval_dtor(zdata);
 	efree(zdata);
 	zval_dtor(zkey);
 	efree(zkey);
 
 	switch (Z_TYPE_P(retval_ptr)) {
 		default:
 		case IS_LONG:
 			zval_dtor(zsig);
 			efree(zsig);
 			if (1 == Z_LVAL_P(retval_ptr)) {
 				efree(retval_ptr);
 				return SUCCESS;
 			}
 			efree(retval_ptr);
 			return FAILURE;
 		case IS_BOOL:
 			efree(retval_ptr);
 			if (Z_BVAL_P(retval_ptr)) {
 				*signature = estrndup(Z_STRVAL_P(zsig), Z_STRLEN_P(zsig));
 				*signature_len = Z_STRLEN_P(zsig);
 				zval_dtor(zsig);
 				efree(zsig);
 				return SUCCESS;
 			}
 			zval_dtor(zsig);
 			efree(zsig);
 			return FAILURE;
 	}
 }
  
 #endif  
 
 int phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error TSRMLS_DC)  
 {
 	int read_size, len;
 	off_t read_len;
 	unsigned char buf[1024];
 
 	php_stream_rewind(fp);
 
 	switch (sig_type) {
 		case PHAR_SIG_OPENSSL: {
 #ifdef PHAR_HAVE_OPENSSL
 			BIO *in;
 			EVP_PKEY *key;
 			EVP_MD *mdtype = (EVP_MD *) EVP_sha1();
 			EVP_MD_CTX md_ctx;
 #else
 			int tempsig;
 #endif
 			php_uint32 pubkey_len;
 			char *pubkey = NULL, *pfile;
 			php_stream *pfp;
 #ifndef PHAR_HAVE_OPENSSL
 			if (!zend_hash_exists(&module_registry, ""openssl"", sizeof(""openssl""))) {
 				if (error) {
 					spprintf(error, 0, ""openssl not loaded"");
 				}
 				return FAILURE;
 			}
 #endif
 			 
 			spprintf(&pfile, 0, ""%s.pubkey"", fname);
 			pfp = php_stream_open_wrapper(pfile, ""rb"", 0, NULL);
 			efree(pfile);
 
 #if PHP_MAJOR_VERSION > 5
 			if (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, (void **) &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {
 #else
 			if (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {
 #endif
 				if (pfp) {
 					php_stream_close(pfp);
 				}
 				if (error) {
 					spprintf(error, 0, ""openssl public key could not be read"");
 				}
 				return FAILURE;
 			}
 
 			php_stream_close(pfp);
 #ifndef PHAR_HAVE_OPENSSL
 			tempsig = sig_len;
 
 			if (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey, pubkey_len, &sig, &tempsig TSRMLS_CC)) {
 				if (pubkey) {
 					efree(pubkey);
 				}
 
 				if (error) {
 					spprintf(error, 0, ""openssl signature could not be verified"");
 				}
 
 				return FAILURE;
 			}
 
 			if (pubkey) {
 				efree(pubkey);
 			}
 
 			sig_len = tempsig;
 #else
 			in = BIO_new_mem_buf(pubkey, pubkey_len);
 
 			if (NULL == in) {
 				efree(pubkey);
 				if (error) {
 					spprintf(error, 0, ""openssl signature could not be processed"");
 				}
 				return FAILURE;
 			}
 
 			key = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);
 			BIO_free(in);
 			efree(pubkey);
 
 			if (NULL == key) {
 				if (error) {
 					spprintf(error, 0, ""openssl signature could not be processed"");
 				}
 				return FAILURE;
 			}
 
 			EVP_VerifyInit(&md_ctx, mdtype);
 			read_len = end_of_phar;
 
 			if (read_len > sizeof(buf)) {
 				read_size = sizeof(buf);
 			} else {
 				read_size = (int)read_len;
 			}
 
 			php_stream_seek(fp, 0, SEEK_SET);
 
 			while (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
 				EVP_VerifyUpdate (&md_ctx, buf, len);
 				read_len -= (off_t)len;
 
 				if (read_len < read_size) {
 					read_size = (int)read_len;
 				}
 			}
 
 			if (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {
 				 
 				EVP_MD_CTX_cleanup(&md_ctx);
 
 				if (error) {
 					spprintf(error, 0, ""broken openssl signature"");
 				}
 
 				return FAILURE;
 			}
 
 			EVP_MD_CTX_cleanup(&md_ctx);
 #endif
 
 			*signature_len = phar_hex_str((const char*)sig, sig_len, signature TSRMLS_CC);
 		}
 		break;
 #ifdef PHAR_HASH_OK
 		case PHAR_SIG_SHA512: {
 			unsigned char digest[64];
 			PHP_SHA512_CTX context;
 
 			PHP_SHA512Init(&context);
 			read_len = end_of_phar;
 
 			if (read_len > sizeof(buf)) {
 				read_size = sizeof(buf);
 			} else {
 				read_size = (int)read_len;
 			}
 
 			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
 				PHP_SHA512Update(&context, buf, len);
 				read_len -= (off_t)len;
 				if (read_len < read_size) {
 					read_size = (int)read_len;
 				}
 			}
 
 			PHP_SHA512Final(digest, &context);
 
 			if (memcmp(digest, sig, sizeof(digest))) {
 				if (error) {
 					spprintf(error, 0, ""broken signature"");
 				}
 				return FAILURE;
 			}
 
 			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
 			break;
 		}
 		case PHAR_SIG_SHA256: {
 			unsigned char digest[32];
 			PHP_SHA256_CTX context;
 
 			PHP_SHA256Init(&context);
 			read_len = end_of_phar;
 
 			if (read_len > sizeof(buf)) {
 				read_size = sizeof(buf);
 			} else {
 				read_size = (int)read_len;
 			}
 
 			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
 				PHP_SHA256Update(&context, buf, len);
 				read_len -= (off_t)len;
 				if (read_len < read_size) {
 					read_size = (int)read_len;
 				}
 			}
 
 			PHP_SHA256Final(digest, &context);
 
 			if (memcmp(digest, sig, sizeof(digest))) {
 				if (error) {
 					spprintf(error, 0, ""broken signature"");
 				}
 				return FAILURE;
 			}
 
 			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
 			break;
 		}
 #else
 		case PHAR_SIG_SHA512:
 		case PHAR_SIG_SHA256:
 			if (error) {
 				spprintf(error, 0, ""unsupported signature"");
 			}
 			return FAILURE;
 #endif
 		case PHAR_SIG_SHA1: {
 			unsigned char digest[20];
 			PHP_SHA1_CTX  context;
 
 			PHP_SHA1Init(&context);
 			read_len = end_of_phar;
 
 			if (read_len > sizeof(buf)) {
 				read_size = sizeof(buf);
 			} else {
 				read_size = (int)read_len;
 			}
 
 			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
 				PHP_SHA1Update(&context, buf, len);
 				read_len -= (off_t)len;
 				if (read_len < read_size) {
 					read_size = (int)read_len;
 				}
 			}
 
 			PHP_SHA1Final(digest, &context);
 
 			if (memcmp(digest, sig, sizeof(digest))) {
 				if (error) {
 					spprintf(error, 0, ""broken signature"");
 				}
 				return FAILURE;
 			}
 
 			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
 			break;
 		}
 		case PHAR_SIG_MD5: {
 			unsigned char digest[16];
 			PHP_MD5_CTX   context;
 
 			PHP_MD5Init(&context);
 			read_len = end_of_phar;
 
 			if (read_len > sizeof(buf)) {
 				read_size = sizeof(buf);
 			} else {
 				read_size = (int)read_len;
 			}
 
 			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
 				PHP_MD5Update(&context, buf, len);
 				read_len -= (off_t)len;
 				if (read_len < read_size) {
 					read_size = (int)read_len;
 				}
 			}
 
 			PHP_MD5Final(digest, &context);
 
 			if (memcmp(digest, sig, sizeof(digest))) {
 				if (error) {
 					spprintf(error, 0, ""broken signature"");
 				}
 				return FAILURE;
 			}
 
 			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
 			break;
 		}
 		default:
 			if (error) {
 				spprintf(error, 0, ""broken or unsupported signature"");
 			}
 			return FAILURE;
 	}
 	return SUCCESS;
 }
  ","[146, 147, 148, 149, 150, 145]",The phar_get_entry_data function in ext/phar/util.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a .phar file with a crafted TAR archive entry in which the Link indicator references a file that does not exist.
197931," user_change_icon_file_authorized_cb (Daemon                *daemon,
                                      User                  *user,
                                      GDBusMethodInvocation *context,
                                      gpointer               data)
 
 {
         g_autofree gchar *filename = NULL;
         g_autoptr(GFile) file = NULL;
         g_autoptr(GFileInfo) info = NULL;
         guint32 mode;
         GFileType type;
         guint64 size;
 
         filename = g_strdup (data);
 
         if (filename == NULL ||
             *filename == '\0') {
                 g_autofree gchar *dest_path = NULL;
                 g_autoptr(GFile) dest = NULL;
                 g_autoptr(GError) error = NULL;
 
                 g_clear_pointer (&filename, g_free);
 
                 dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                 dest = g_file_new_for_path (dest_path);
 
                 if (!g_file_delete (dest, NULL, &error) &&
                     !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                         throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                         return;
                 }
                 goto icon_saved;
          }
  
          file = g_file_new_for_path (filename);
         g_clear_pointer (&filename, g_free);
 
          
         filename = g_file_get_path (file);
 
          info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                          G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                          G_FILE_ATTRIBUTE_STANDARD_SIZE,
                 return;
         }","[36, 37, 38, 39, 40]",Directory Traversal with ../ sequences occurs in AccountsService before 0.6.50 because of an insufficient path check in user_change_icon_file_authorized_cb() in user.c.
201462,"  void fe_netjoin_deinit(void)
 {
 	while (joinservers != NULL)
 		netjoin_server_remove(joinservers->data);
 	if (join_tag != -1) {
 		g_source_remove(join_tag);
 		signal_remove(""print starting"", (SIGNAL_FUNC) sig_print_starting);
  	}
  
  	signal_remove(""setup changed"", (SIGNAL_FUNC) read_settings);
 	signal_remove(""server disconnected"", (SIGNAL_FUNC) sig_server_disconnected);
  
  	signal_remove(""message quit"", (SIGNAL_FUNC) msg_quit);
  	signal_remove(""message join"", (SIGNAL_FUNC) msg_join);
 	signal_remove(""message irc mode"", (SIGNAL_FUNC) msg_mode);
 }",[11],The netjoin processing in Irssi 1.x before 1.0.2 allows attackers to cause a denial of service (use-after-free) and possibly execute arbitrary code via unspecified vectors.
199439," FUNC_DECODER(dissector_postgresql)
 {
    DECLARE_DISP_PTR(ptr);
    struct ec_session *s = NULL;
    void *ident = NULL;
    char tmp[MAX_ASCII_ADDR_LEN];
    struct postgresql_status *conn_status;
 
     
    (void) DECODE_DATA; 
    (void) DECODE_DATALEN;
    (void) DECODED_LEN;
    
    if (FROM_CLIENT(""postgresql"", PACKET)) {
       if (PACKET->DATA.len < 4)
          return NULL;
 
       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));
 
        
       if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {
           
          unsigned char *u = memmem(ptr, PACKET->DATA.len, ""user"", 4);
          unsigned char *d = memmem(ptr, PACKET->DATA.len, ""database"", 8);
          if (!memcmp(ptr + 4, ""\x00\x03\x00\x00"", 4) && u && d) {
              
             dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));
 
              
             SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));
 
             conn_status = (struct postgresql_status *) s->data;
             conn_status->status = WAIT_AUTH;
 
              
             strncpy((char*)conn_status->user, (char*)(u + 5), 65);
             conn_status->user[64] = 0;
 
              
             strncpy((char*)conn_status->database, (char*)(d + 9), 65);
             conn_status->database[64] = 0;
 
              
             session_put(s);
          }
       } else {
          conn_status = (struct postgresql_status *) s->data;
          if (conn_status->status == WAIT_RESPONSE) {
 
              
             if (ptr[0] == 'p' && conn_status->type == MD5) {
                DEBUG_MSG(""\tDissector_postgresql RESPONSE type is MD5"");
                if(memcmp(ptr + 1, ""\x00\x00\x00\x28"", 4)) {
                   DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40"");
                   return NULL;
                }
                if (PACKET->DATA.len < 40) {
                   DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40"");
                   return NULL;
                }
                memcpy(conn_status->hash, ptr + 5 + 3, 32);
                conn_status->hash[32] = 0;
                DISSECT_MSG(""%s:$postgres$%s*%s*%s:%s:%d\n"", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));
                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
             }
             else if (ptr[0] == 'p' && conn_status->type == CT) {
                 int length;
                 DEBUG_MSG(""\tDissector_postgresql RESPONSE type is clear-text!"");
                 GET_ULONG_BE(length, ptr, 1);
               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);
               conn_status->password[length - 4] = 0;
                length -= 4;
                if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {
                    dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
                    return NULL;
                }
                snprintf((char*)conn_status->password, length+1, ""%s"", (char*)(ptr + 5));
                 DISSECT_MSG(""PostgreSQL credentials:%s-%d:%s:%s\n"", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);
                 dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
              }
          }
       }
    } else {  
       if (PACKET->DATA.len < 9)
          return NULL;
       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));
 
       if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {
          conn_status = (struct postgresql_status *) s->data;
          if (conn_status->status == WAIT_AUTH &&
                ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x0c"", 4)  &&
                !memcmp(ptr + 5, ""\x00\x00\x00\x05"", 4)) {
 
             conn_status->status = WAIT_RESPONSE;
 
             conn_status->type = MD5;
             DEBUG_MSG(""\tDissector_postgresql AUTH type is MD5"");
             hex_encode(ptr + 9, 4, conn_status->salt);  
          }
          else if (conn_status->status == WAIT_AUTH &&
                ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x08"", 4)  &&
                !memcmp(ptr + 5, ""\x00\x00\x00\x03"", 4)) {
             conn_status->status = WAIT_RESPONSE;
             conn_status->type = CT;
             DEBUG_MSG(""\tDissector_postgresql AUTH type is clear-text!"");
          }
       }
    }
 
    SAFE_FREE(ident);
    return NULL;
 }","[72, 73, 74, 75, 76, 77, 70, 71]","The dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service and possibly execute arbitrary code via a crafted password length, which triggers a 0 character to be written to an arbitrary memory location."
198557," display_sigset( const char *msg, sigset_t *mask )
 {
 	int					signo;
         NameTableIterator       next_sig( SigNames );
  
         if( msg ) {
               dprintf( D_ALWAYS, msg );
                dprintf( D_ALWAYS, ""%s"", msg );
         }
         while( (signo = next_sig()) != -1 ) {
                 if( sigismember(mask,signo) ) {
 			dprintf( D_ALWAYS | D_NOHEADER, ""%s "", SigNames.get_name(signo) );
 		}
 	}
 	dprintf( D_ALWAYS | D_NOHEADER, ""\n"" );
 }","[8, 7]","Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors."
206354," void SaveCardBubbleControllerImpl::ShowBubbleForUpload(
     const CreditCard& card,
      std::unique_ptr<base::DictionaryValue> legal_message,
      bool should_cvc_be_requested,
      const base::Closure& save_card_callback) {
    
   if (save_card_bubble_view_)
     return;
 
    is_uploading_ = true;
    is_reshow_ = false;
    should_cvc_be_requested_ = should_cvc_be_requested;
   AutofillMetrics::LogSaveCardPromptMetric(
       AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,
       is_reshow_,
       pref_service_->GetInteger(
           prefs::kAutofillAcceptSaveCreditCardPromptState));
 
   if (!LegalMessageLine::Parse(*legal_message, &legal_message_lines_)) {
     AutofillMetrics::LogSaveCardPromptMetric(
         AutofillMetrics::SAVE_CARD_PROMPT_END_INVALID_LEGAL_MESSAGE,
         is_uploading_, is_reshow_,
         pref_service_->GetInteger(
             prefs::kAutofillAcceptSaveCreditCardPromptState));
     return;
   }
 
   card_ = card;
   save_card_callback_ = save_card_callback;
   ShowBubble();
 }","[6, 7, 8, 9]",A use after free in credit card autofill in Google Chrome prior to 59.0.3071.86 for Linux and Windows allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
198346," int ssl23_get_client_hello(SSL *s)
 	{
 	char buf_space[11];  
 	char *buf= &(buf_space[0]);
 	unsigned char *p,*d,*d_len,*dd;
 	unsigned int i;
 	unsigned int csl,sil,cl;
 	int n=0,j;
 	int type=0;
 	int v[2];
 
 	if (s->state ==	SSL23_ST_SR_CLNT_HELLO_A)
 		{
 		 
 		v[0]=v[1]=0;
 
 		if (!ssl3_setup_buffers(s)) goto err;
 
 		n=ssl23_read_bytes(s, sizeof buf_space);
 		if (n != sizeof buf_space) return(n);  
 
 		p=s->packet;
 
 		memcpy(buf,p,n);
 
 		if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))
 			{
 			 
 			if ((p[3] == 0x00) && (p[4] == 0x02))
 				{
 				v[0]=p[3]; v[1]=p[4];
 				 
 				if (!(s->options & SSL_OP_NO_SSLv2))
 					type=1;
 				}
 			else if (p[3] == SSL3_VERSION_MAJOR)
 				{
 				v[0]=p[3]; v[1]=p[4];
 				 
 				if (p[4] >= TLS1_VERSION_MINOR)
 					{
 					if (p[4] >= TLS1_2_VERSION_MINOR &&
 					   !(s->options & SSL_OP_NO_TLSv1_2))
 						{
 						s->version=TLS1_2_VERSION;
 						s->state=SSL23_ST_SR_CLNT_HELLO_B;
 						}
 					else if (p[4] >= TLS1_1_VERSION_MINOR &&
 					   !(s->options & SSL_OP_NO_TLSv1_1))
 						{
 						s->version=TLS1_1_VERSION;
 						   
 						s->state=SSL23_ST_SR_CLNT_HELLO_B;
 						}
 					else if (!(s->options & SSL_OP_NO_TLSv1))
 						{
 						s->version=TLS1_VERSION;
 						   
 						s->state=SSL23_ST_SR_CLNT_HELLO_B;
 						}
 					else if (!(s->options & SSL_OP_NO_SSLv3))
 						{
 						s->version=SSL3_VERSION;
 						 
 						s->state=SSL23_ST_SR_CLNT_HELLO_B;
 						}
 					else if (!(s->options & SSL_OP_NO_SSLv2))
 						{
 						type=1;
 						}
 					}
 				else if (!(s->options & SSL_OP_NO_SSLv3))
 					{
 					s->version=SSL3_VERSION;
 					 
 					s->state=SSL23_ST_SR_CLNT_HELLO_B;
 					}
 				else if (!(s->options & SSL_OP_NO_SSLv2))
 					type=1;
 
 				}
 			}
 		else if ((p[0] == SSL3_RT_HANDSHAKE) &&
 			 (p[1] == SSL3_VERSION_MAJOR) &&
 			 (p[5] == SSL3_MT_CLIENT_HELLO) &&
 			 ((p[3] == 0 && p[4] < 5  )
 				|| (p[9] >= p[1])))
 			{
 			 
 			
 			v[0]=p[1];  
 			 
                         if (p[3] == 0 && p[4] < 6)
                                 {
#if 0
                                 SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);
                                 goto err;
#else
                               v[1] = TLS1_VERSION_MINOR;
#endif
                                 }
                          
                       else if (p[9] > SSL3_VERSION_MAJOR)
                        if (p[9] > SSL3_VERSION_MAJOR)
                                 v[1]=0xff;
                         else
                                 v[1]=p[10];  
 			else if (p[9] > SSL3_VERSION_MAJOR)
 				v[1]=0xff;
 			else
 				v[1]=p[10];  
 			if (v[1] >= TLS1_VERSION_MINOR)
 				{
 				if (v[1] >= TLS1_2_VERSION_MINOR &&
 					!(s->options & SSL_OP_NO_TLSv1_2))
 					{
 					s->version=TLS1_2_VERSION;
 					type=3;
 					}
 				else if (v[1] >= TLS1_1_VERSION_MINOR &&
 					!(s->options & SSL_OP_NO_TLSv1_1))
 					{
 					s->version=TLS1_1_VERSION;
 					type=3;
 					}
 				else if (!(s->options & SSL_OP_NO_TLSv1))
 					{
 					s->version=TLS1_VERSION;
 					type=3;
 					}
 				else if (!(s->options & SSL_OP_NO_SSLv3))
 					{
 					s->version=SSL3_VERSION;
 					type=3;
 					}
 				}
 			else
 				{
 				 
 				if (!(s->options & SSL_OP_NO_SSLv3))
 					{
 					s->version=SSL3_VERSION;
 					type=3;
 					}
 				else if (!(s->options & SSL_OP_NO_TLSv1))
 					{
 					 
 					s->version=TLS1_VERSION;
 					type=3;
 					}
 				}
 			}
 		else if ((strncmp(""GET "", (char *)p,4) == 0) ||
 			 (strncmp(""POST "",(char *)p,5) == 0) ||
 			 (strncmp(""HEAD "",(char *)p,5) == 0) ||
 			 (strncmp(""PUT "", (char *)p,4) == 0))
 			{
 			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);
 			goto err;
 			}
 		else if (strncmp(""CONNECT"",(char *)p,7) == 0)
 			{
 			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);
 			goto err;
 			}
 		}
 
 	if (s->version < TLS1_2_VERSION && tls1_suiteb(s))
 		{
 		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
 				SSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE);
 		goto err;
 		}
 
 #ifdef OPENSSL_FIPS
 	if (FIPS_mode() && (s->version < TLS1_VERSION))
 		{
 		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
 					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
 		goto err;
 		}
 #endif
 
 	if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL))
 		{
 		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_VERSION_TOO_LOW);
 		goto err;
 		}
 
 	if (s->state == SSL23_ST_SR_CLNT_HELLO_B)
 		{
 		 
                 v[1] = p[4];
  
                 
                 n=((p[0]&0x7f)<<8)|p[1];
                 if (n > (1024*4))
                         {
                         SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);
                         goto err;
                         }
                if (n < 9)
                        {
                        SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
                        goto err;
                        }
  
                 j=ssl23_read_bytes(s,n+2);
                 
                 if (j <= 0) return(j);
  
                 ssl3_finish_mac(s, s->packet+2, s->packet_length-2);
 
 		 
 		*(d++) = SSL3_MT_CLIENT_HELLO;
 		 
 		d_len = d;
 		d += 3;
 
 		 
 		*(d++) = SSL3_VERSION_MAJOR;  
 		*(d++) = v[1];
 
 		 
 		 
 		i=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;
 		memset(d,0,SSL3_RANDOM_SIZE);
 		memcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);
 		d+=SSL3_RANDOM_SIZE;
 
 		 
 		*(d++)=0;
 
 		 
 		j=0;
 		dd=d;
 		d+=2;
 		for (i=0; i<csl; i+=3)
 			{
 			if (p[i] != 0) continue;
 			*(d++)=p[i+1];
 			*(d++)=p[i+2];
 			j+=2;
 			}
 		s2n(j,dd);
 
 		 
 		*(d++)=1;
 		*(d++)=0;
 		
 #if 0
                  
 	        p = p+csl+sil+cl;
 		while (p <  s->packet+s->packet_length)
 			{
 			*(d++)=*(p++);
 			}
 #endif
 
 		i = (d-(unsigned char *)s->init_buf->data) - 4;
 		l2n3((long)i, d_len);
 
 		 
 		s->s3->tmp.reuse_message=1;
 		s->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;
 		s->s3->tmp.message_size=i;
 		}
 
 	 
 	 
 
 	if (type == 1)
 		{
 #ifdef OPENSSL_NO_SSL2
 		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
 		goto err;
 #else
 		 
 		 
 
 		if (s->s2 == NULL)
 			{
 			if (!ssl2_new(s))
 				goto err;
 			}
 		else
 			ssl2_clear(s);
 
 		if (s->s3 != NULL) ssl3_free(s);
 
 		if (!BUF_MEM_grow_clean(s->init_buf,
 			SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))
 			{
 			goto err;
 			}
 
 		s->state=SSL2_ST_GET_CLIENT_HELLO_A;
 		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
 			s->s2->ssl2_rollback=0;
 		else
 			 
 			s->s2->ssl2_rollback=1;
 
 		 
 		s->rstate=SSL_ST_READ_HEADER;
 		s->packet_length=n;
 		s->packet= &(s->s2->rbuf[0]);
 		memcpy(s->packet,buf,n);
 		s->s2->rbuf_left=n;
 		s->s2->rbuf_offs=0;
 
 		s->method=SSLv2_server_method();
 		s->handshake_func=s->method->ssl_accept;
 #endif
 		}
 
 	if ((type == 2) || (type == 3))
 		{
 		 
 
 		if (!ssl_init_wbio_buffer(s,1)) goto err;
 
 		 
 		s->state=SSL3_ST_SR_CLNT_HELLO_A;
 
 		if (type == 3)
 			{
 			 
 			s->rstate=SSL_ST_READ_HEADER;
 			s->packet_length=n;
 			if (s->s3->rbuf.buf == NULL)
 				if (!ssl3_setup_read_buffer(s))
 					goto err;
 
 			s->packet= &(s->s3->rbuf.buf[0]);
 			memcpy(s->packet,buf,n);
 			s->s3->rbuf.left=n;
 			s->s3->rbuf.offset=0;
 			}
 		else
 			{
 			s->packet_length=0;
 			s->s3->rbuf.left=0;
 			s->s3->rbuf.offset=0;
 			}
 		if (s->version == TLS1_2_VERSION)
 			s->method = TLSv1_2_server_method();
 		else if (s->version == TLS1_1_VERSION)
 			s->method = TLSv1_1_server_method();
 		else if (s->version == TLS1_VERSION)
 			s->method = TLSv1_server_method();
 		else
 			s->method = SSLv3_server_method();
 #if 0  
 		s->client_version=(v[0]<<8)|v[1];
 #endif
 		s->handshake_func=s->method->ssl_accept;
 		}
 	
 	if ((type < 1) || (type > 3))
 		{
 		 
 		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);
 		goto err;
 		}
 	s->init_num=0;
 
 	if (buf != buf_space) OPENSSL_free(buf);
 	return(SSL_accept(s));
 err:
 	if (buf != buf_space) OPENSSL_free(buf);
 	return(-1);
 	}","[104, 195, 202, 203, 204, 205, 206, 209, 95, 98, 99, 100, 103]","The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 1.0.1 before 1.0.1i allows man-in-the-middle attackers to force the use of TLS 1.0 by triggering ClientHello message fragmentation in communication between a client and server that both support later TLS versions, related to a ""protocol downgrade"" issue."
204340," bool WebPage::touchEvent(const Platform::TouchEvent& event)
 {
 #if DEBUG_TOUCH_EVENTS
     BBLOG(LogLevelCritical, ""%s"", event.toString().c_str());
 #endif
 
 #if ENABLE(TOUCH_EVENTS)
     if (!d->m_mainFrame)
         return false;
 
     if (d->m_page->defersLoading())
         return false;
 
     PluginView* pluginView = d->m_fullScreenPluginView.get();
     if (pluginView)
          return d->dispatchTouchEventToFullScreenPlugin(pluginView, event);
  
      Platform::TouchEvent tEvent = event;
    for (unsigned i = 0; i < event.m_points.size(); i++) {
        tEvent.m_points[i].m_pos = d->mapFromTransformed(tEvent.m_points[i].m_pos);
        tEvent.m_points[i].m_screenPos = tEvent.m_points[i].m_screenPos;
    }
      if (event.isSingleTap())
          d->m_pluginMayOpenNewTab = true;
      else if (tEvent.m_type == Platform::TouchEvent::TouchStart || tEvent.m_type == Platform::TouchEvent::TouchCancel)
         d->m_pluginMayOpenNewTab = false;
 
     if (tEvent.m_type == Platform::TouchEvent::TouchStart) {
         d->clearCachedHitTestResult();
         d->m_touchEventHandler->doFatFingers(tEvent.m_points[0]);
 
         Element* elementUnderFatFinger = d->m_touchEventHandler->lastFatFingersResult().nodeAsElementIfApplicable();
         if (elementUnderFatFinger)
             d->m_touchEventHandler->drawTapHighlight();
     }
 
     bool handled = false;
 
     if (!event.m_type != Platform::TouchEvent::TouchInjected)
         handled = d->m_mainFrame->eventHandler()->handleTouchEvent(PlatformTouchEvent(&tEvent));
 
     if (d->m_preventDefaultOnTouchStart) {
         if (tEvent.m_type == Platform::TouchEvent::TouchEnd || tEvent.m_type == Platform::TouchEvent::TouchCancel)
             d->m_preventDefaultOnTouchStart = false;
         return true;
     }
 
     if (handled) {
         if (tEvent.m_type == Platform::TouchEvent::TouchStart)
             d->m_preventDefaultOnTouchStart = true;
         return true;
     }
 
     if (event.isTouchHold())
         d->m_touchEventHandler->doFatFingers(tEvent.m_points[0]);
 
 #endif
 
     return false;
 }","[19, 20, 21, 22]",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
206347,"  void InitializeOriginStatFromOriginRequestSummary(
      OriginStat* origin,
      const OriginRequestSummary& summary) {
  origin->set_origin(summary.origin.spec());
   origin->set_origin(summary.origin.GetURL().spec());
    origin->set_number_of_hits(1);
    origin->set_average_position(summary.first_occurrence + 1);
    origin->set_always_access_network(summary.always_access_network);
   origin->set_accessed_network(summary.accessed_network);
 }","[5, 4]","Insufficient validation of untrusted input in Skia in Google Chrome prior to 59.0.3071.86 for Linux, Windows, and Mac, and 59.0.3071.92 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
197979," BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
 {
     int i;
     BIO *out = NULL, *btmp = NULL;
     X509_ALGOR *xa = NULL;
     const EVP_CIPHER *evp_cipher = NULL;
     STACK_OF(X509_ALGOR) *md_sk = NULL;
     STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;
     X509_ALGOR *xalg = NULL;
      PKCS7_RECIP_INFO *ri = NULL;
      ASN1_OCTET_STRING *os = NULL;
  
     if (p7 == NULL) {
         PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);
         return NULL;
     }
      
     if (p7->d.ptr == NULL) {
         PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);
         return NULL;
     }
 
      i = OBJ_obj2nid(p7->type);
      p7->state = PKCS7_S_HEADER;
  
         if (evp_cipher == NULL) {
             PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);
             goto err;
         }
         break;
     case NID_pkcs7_digest:
         xa = p7->d.digest->md;
         os = PKCS7_get_octet_string(p7->d.digest->contents);
         break;
     case NID_pkcs7_data:
         break;
     default:
         PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
         goto err;
     }","[13, 14, 15, 16, 17, 18, 19, 20, 21, 22]","The PKCS#7 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not properly handle a lack of outer ContentInfo, which allows attackers to cause a denial of service (NULL pointer dereference and application crash) by leveraging an application that processes arbitrary PKCS#7 data and providing malformed data with ASN.1 encoding, related to crypto/pkcs7/pk7_doit.c and crypto/pkcs7/pk7_lib.c."
201483," void * CAPSTONE_API cs_winkernel_malloc(size_t size)
 {
 	NT_ASSERT(size);
  
  #pragma prefast(suppress : 30030)		 
	CS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(
			NonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);
 	size_t number_of_bytes = 0;
 	CS_WINKERNEL_MEMBLOCK *block = NULL;
 	 
 	 
 	 
 	if (!NT_SUCCESS(RtlSizeTAdd(size, sizeof(CS_WINKERNEL_MEMBLOCK), &number_of_bytes))) {
 		return NULL;
 	}
 	block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(
 			NonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);
  	if (!block) {
  		return NULL;
  	}
 	block->size = size;
 
 	return block->data;
 }","[8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 6, 7]",Integer overflow in the cs_winkernel_malloc function in winkernel_mm.c in Capstone 3.0.4 and earlier allows attackers to cause a denial of service (heap-based buffer overflow in a kernel driver) or possibly have unspecified other impact via a large value.
206626," bool LocalFrameClientImpl::NavigateBackForward(int offset) const {
   WebViewImpl* webview = web_frame_->ViewImpl();
   if (!webview->Client())
     return false;
 
   DCHECK(offset);
   if (offset > webview->Client()->HistoryForwardListCount())
      return false;
    if (offset < -webview->Client()->HistoryBackListCount())
      return false;
  webview->Client()->NavigateBackForwardSoon(offset);
 
   bool has_user_gesture =
       Frame::HasTransientUserActivation(web_frame_->GetFrame());
   webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);
    return true;
  }","[12, 13, 14, 15, 11]",A renderer initiated back navigation was incorrectly allowed to cancel a browser initiated one in Navigation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to confuse the user about the origin of the current page via a crafted HTML page.
205126,"  void LocalFileSystem::fileSystemNotAvailable(
      PassRefPtrWillBeRawPtr<ExecutionContext> context,
    PassRefPtr<CallbackWrapper> callbacks)
     CallbackWrapper* callbacks)
  {
      context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));
  }","[4, 3]",The URL loader in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.
207725," store_current_palette(png_store *ps, int *npalette)
 {
   
     if (ps->current == NULL)
    {
        store_log(ps, ps->pread, ""no current stream for palette"", 1);
       return NULL;
    }
  
      
     *npalette = ps->current->npalette;
  return ps->current->palette;
 }","[5, 7, 8]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
199855,"  static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)
  {
  	struct xen_pcibk_dev_data *dev_data;
  	int err;
 	u16 val;
 	struct pci_cmd_info *cmd = data;
  
  	dev_data = pci_get_drvdata(dev);
  	if (!pci_is_enabled(dev) && is_enable_cmd(value)) {
 		if (unlikely(verbose_request))
 			printk(KERN_DEBUG DRV_NAME "": %s: enable\n"",
 			       pci_name(dev));
 		err = pci_enable_device(dev);
 		if (err)
 			return err;
 		if (dev_data)
 			dev_data->enable_intx = 1;
 	} else if (pci_is_enabled(dev) && !is_enable_cmd(value)) {
 		if (unlikely(verbose_request))
 			printk(KERN_DEBUG DRV_NAME "": %s: disable\n"",
 			       pci_name(dev));
 		pci_disable_device(dev);
 		if (dev_data)
 			dev_data->enable_intx = 0;
 	}
 
 	if (!dev->is_busmaster && is_master_cmd(value)) {
 		if (unlikely(verbose_request))
 			printk(KERN_DEBUG DRV_NAME "": %s: set bus master\n"",
 			       pci_name(dev));
 		pci_set_master(dev);
 	}
 
 	if (value & PCI_COMMAND_INVALIDATE) {
 		if (unlikely(verbose_request))
 			printk(KERN_DEBUG
 			       DRV_NAME "": %s: enable memory-write-invalidate\n"",
 			       pci_name(dev));
 		err = pci_set_mwi(dev);
 		if (err) {
 			pr_warn(""%s: cannot enable memory-write-invalidate (%d)\n"",
 				pci_name(dev), err);
 			value &= ~PCI_COMMAND_INVALIDATE;
  		}
  	}
  
 	cmd->val = value;
 
 	if (!permissive && (!dev_data || !dev_data->permissive))
 		return 0;
 
 	 
 	err = pci_read_config_word(dev, offset, &val);
 	if (err || val == value)
 		return err;
 
 	value &= PCI_COMMAND_GUEST;
 	value |= val & ~PCI_COMMAND_GUEST;
 
  	return pci_write_config_word(dev, offset, value);
  }","[5, 6, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]","Xen 3.3.x through 4.5.x and the Linux kernel through 3.19.1 do not properly restrict access to PCI command registers, which might allow local guest OS users to cause a denial of service (non-maskable interrupt and host crash) by disabling the (1) memory or (2) I/O decoding for a PCI Express device and then accessing the device, which triggers an Unsupported Request (UR) response."
205131," EntrySync* WorkerGlobalScopeFileSystem::webkitResolveLocalFileSystemSyncURL(WorkerGlobalScope& worker, const String& url, ExceptionState& exceptionState)
 {
     KURL completedURL = worker.completeURL(url);
     ExecutionContext* secureContext = worker.executionContext();
     if (!secureContext->securityOrigin()->canAccessFileSystem() || !secureContext->securityOrigin()->canRequest(completedURL)) {
         exceptionState.throwSecurityError(FileError::securityErrorMessage);
         return 0;
     }
 
     if (!completedURL.isValid()) {
         exceptionState.throwDOMException(EncodingError, ""the URL '"" + url + ""' is invalid."");
          return 0;
      }
  
    RefPtr<EntrySyncCallbackHelper> resolveURLHelper = EntrySyncCallbackHelper::create();
     EntrySyncCallbackHelper* resolveURLHelper = EntrySyncCallbackHelper::create();
      OwnPtr<AsyncFileSystemCallbacks> callbacks = ResolveURICallbacks::create(resolveURLHelper->successCallback(), resolveURLHelper->errorCallback(), &worker);
      callbacks->setShouldBlockUntilCompletion(true);
  
     LocalFileSystem::from(worker)->resolveURL(&worker, completedURL, callbacks.release());
 
     return resolveURLHelper->getResult(exceptionState);
 }","[16, 15]",The URL loader in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.
201117," fr_print(netdissect_options *ndo,
          register const u_char *p, u_int length)
 {
 	int ret;
 	uint16_t extracted_ethertype;
 	u_int dlci;
 	u_int addr_len;
 	uint16_t nlpid;
 	u_int hdr_len;
 	uint8_t flags[4];
 
 	ret = parse_q922_addr(ndo, p, &dlci, &addr_len, flags, length);
 	if (ret == -1)
 		goto trunc;
 	if (ret == 0) {
 		ND_PRINT((ndo, ""Q.922, invalid address""));
 		return 0;
 	}
 
 	ND_TCHECK(p[addr_len]);
 	if (length < addr_len + 1)
 		goto trunc;
 
 	if (p[addr_len] != LLC_UI && dlci != 0) {
                  
 		if (!ND_TTEST2(p[addr_len], 2) || length < addr_len + 2) {
                          
                         ND_PRINT((ndo, ""UI %02x! "", p[addr_len]));
                 } else {
                         extracted_ethertype = EXTRACT_16BITS(p+addr_len);
 
                         if (ndo->ndo_eflag)
                                 fr_hdr_print(ndo, length, addr_len, dlci,
                                     flags, extracted_ethertype);
 
                         if (ethertype_print(ndo, extracted_ethertype,
                                             p+addr_len+ETHERTYPE_LEN,
                                             length-addr_len-ETHERTYPE_LEN,
                                             ndo->ndo_snapend-p-addr_len-ETHERTYPE_LEN,
                                             NULL, NULL) == 0)
                                  
                                 ND_PRINT((ndo, ""UI %02x! "", p[addr_len]));
                         else
                                 return addr_len + 2;
                 }
         }
 
 	ND_TCHECK(p[addr_len+1]);
 	if (length < addr_len + 2)
 		goto trunc;
 
 	if (p[addr_len + 1] == 0) {
 		 
 		if (addr_len != 3)
 			ND_PRINT((ndo, ""Pad! ""));
 		hdr_len = addr_len + 1   + 1   + 1  ;
 	} else {
 		 
 		if (addr_len == 3)
 			ND_PRINT((ndo, ""No pad! ""));
 		hdr_len = addr_len + 1   + 1  ;
 	}
 
         ND_TCHECK(p[hdr_len - 1]);
 	if (length < hdr_len)
 		goto trunc;
 	nlpid = p[hdr_len - 1];
 
 	if (ndo->ndo_eflag)
 		fr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid);
 	p += hdr_len;
 	length -= hdr_len;
 
 	switch (nlpid) {
 	case NLPID_IP:
 	        ip_print(ndo, p, length);
 		break;
 
 	case NLPID_IP6:
 		ip6_print(ndo, p, length);
 		break;
 
  	case NLPID_CLNP:
  	case NLPID_ESIS:
  	case NLPID_ISIS:
		isoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1);  
 		isoclns_print(ndo, p - 1, length + 1);  
  		break;
  
  	case NLPID_SNAP:
 		if (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {
 			 
                         if (!ndo->ndo_eflag)
                             fr_hdr_print(ndo, length + hdr_len, hdr_len,
                                          dlci, flags, nlpid);
 			if (!ndo->ndo_suppress_default_print)
 				ND_DEFAULTPRINT(p - hdr_len, length + hdr_len);
 		}
 		break;
 
         case NLPID_Q933:
 		q933_print(ndo, p, length);
 		break;
 
         case NLPID_MFR:
                 frf15_print(ndo, p, length);
                 break;
 
         case NLPID_PPP:
                 ppp_print(ndo, p, length);
                 break;
 
 	default:
 		if (!ndo->ndo_eflag)
                     fr_hdr_print(ndo, length + hdr_len, addr_len,
 				     dlci, flags, nlpid);
 		if (!ndo->ndo_xflag)
 			ND_DEFAULTPRINT(p, length);
 	}
 
 	return hdr_len;
 
  trunc:
         ND_PRINT((ndo, ""[|fr]""));
         return 0;
 
 }","[87, 86]",The ISO CLNS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isoclns_print().
200573," static void snd_timer_check_master(struct snd_timer_instance *master)
 {
 	struct snd_timer_instance *slave, *tmp;
 
 	 
 	list_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {
 		if (slave->slave_class == master->slave_class &&
  		    slave->slave_id == master->slave_id) {
  			list_move_tail(&slave->open_list, &master->slave_list_head);
  			spin_lock_irq(&slave_active_lock);
 			spin_lock(&master->timer->lock);
  			slave->master = master;
  			slave->timer = master->timer;
  			if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
  				list_add_tail(&slave->active_list,
  					      &master->slave_active_head);
 			spin_unlock(&master->timer->lock);
  			spin_unlock_irq(&slave_active_lock);
  		}
  	}
 }","[11, 17]","sound/core/timer.c in the Linux kernel before 4.4.1 retains certain linked lists after a close or stop action, which allows local users to cause a denial of service (system crash) via a crafted ioctl call, related to the (1) snd_timer_close and (2) _snd_timer_stop functions."
201901,"  int ras_validate(jas_stream_t *in)
  {
	uchar buf[RAS_MAGICLEN];
 	jas_uchar buf[RAS_MAGICLEN];
  	int i;
  	int n;
  	uint_fast32_t magic;
 
 	assert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);
 
 	 
 	if ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {
 		return -1;
 	}
 
 	 
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 
 	 
 	if (n < RAS_MAGICLEN) {
 		return -1;
 	}
 
 	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
 	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
 	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
 	  buf[3];
 
 	 
 	if (magic != RAS_MAGIC) {
 		return -1;
 	}
 	return 0;
 }","[4, 3]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
4098,"fetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
{
int num;
OnigCodePoint c, c2;
OnigSyntaxType* syn = env->syntax;
OnigEncoding enc = env->enc;
UChar* prev;
UChar* p = *src;
PFETCH_READY;

if (PEND) {
tok->type = TK_EOT;
return tok->type;
}

PFETCH(c);
tok->type = TK_CHAR;
tok->base = 0;
tok->u.c  = c;
tok->escaped = 0;

if (c == ']') {
tok->type = TK_CC_CLOSE;
}
else if (c == '-') {
tok->type = TK_CC_RANGE;
}
else if (c == MC_ESC(syn)) {
if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))
goto end;

if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;

PFETCH(c);
tok->escaped = 1;
tok->u.c = c;
switch (c) {
case 'w':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
tok->u.prop.not   = 0;
break;
case 'W':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
tok->u.prop.not   = 1;
break;
case 'd':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
tok->u.prop.not   = 0;
break;
case 'D':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
tok->u.prop.not   = 1;
break;
case 's':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
tok->u.prop.not   = 0;
break;
case 'S':
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
tok->u.prop.not   = 1;
break;
case 'h':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
tok->u.prop.not   = 0;
break;
case 'H':
if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
tok->type = TK_CHAR_TYPE;
tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
tok->u.prop.not   = 1;
break;

case 'p':
case 'P':
if (PEND) break;

c2 = PPEEK;
if (c2 == '{' &&
IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {
PINC;
tok->type = TK_CHAR_PROPERTY;
tok->u.prop.not = (c == 'P' ? 1 : 0);

if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {
PFETCH(c2);
if (c2 == '^') {
tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);
}
else
PUNFETCH;
}
}
break;

case 'x':
if (PEND) break;

prev = p;
if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {
PINC;
num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);
if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;
if (!PEND) {
c2 = PPEEK;
if (ONIGENC_IS_CODE_XDIGIT(enc, c2))
return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;
}

if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {
PINC;
tok->type   = TK_CODE_POINT;
tok->base   = 16;
tok->u.code = (OnigCodePoint )num;
}
else {

p = prev;
}
}
else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {
num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type = TK_RAW_BYTE;
tok->base = 16;
tok->u.c  = num;
}
break;

case 'u':
if (PEND) break;

prev = p;
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {
num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type   = TK_CODE_POINT;
tok->base   = 16;
tok->u.code = (OnigCodePoint )num;
}
break;

case '0':
case '1': case '2': case '3': case '4': case '5': case '6': case '7':
if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {
PUNFETCH;
prev = p;
num = scan_unsigned_octal_number(&p, end, 3, enc);
if (num < 0) return ONIGERR_TOO_BIG_NUMBER;
if (p == prev) {
num = 0;
}
tok->type = TK_RAW_BYTE;
tok->base = 8;
tok->u.c  = num;
}
break;

default:
PUNFETCH;
num = fetch_escaped_value(&p, end, env, &c2);
if (num < 0) return num;
if (tok->u.c != c2) {
tok->u.code = c2;
tok->type   = TK_CODE_POINT;
}
break;
}
}
else if (c == '[') {
if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {
OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };
tok->backp = p;
PINC;
if (str_exist_check_with_esc(send, 2, p, end,
(OnigCodePoint )']', enc, syn)) {
tok->type = TK_POSIX_BRACKET_OPEN;
}
else {
PUNFETCH;
goto cc_in_cc;
}
}
else {
cc_in_cc:
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {
tok->type = TK_CC_CC_OPEN;
}
else {
CC_ESC_WARN(env, (UChar* )""["");
}
}
}
else if (c == '&') {
if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&
!PEND && (PPEEK_IS('&'))) {
PINC;
tok->type = TK_CC_AND;
}
}

end:
*src = p;
return tok->type;
}",[162],"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write or read occurs in next_state_val() during regular expression compilation. Octal numbers larger than 0xff are not handled correctly in fetch_token() and fetch_token_in_cc(). A malformed regular expression containing an octal number in the form of '\700' would produce an invalid code point value larger than 0xff in next_state_val(), resulting in an out-of-bounds write memory corruption."
200624," long join_session_keyring(const char *name)
 {
 	const struct cred *old;
 	struct cred *new;
 	struct key *keyring;
 	long ret, serial;
 
 	new = prepare_creds();
 	if (!new)
 		return -ENOMEM;
 	old = current_cred();
 
 	 
 	if (!name) {
 		ret = install_session_keyring_to_cred(new, NULL);
 		if (ret < 0)
 			goto error;
 
 		serial = new->session_keyring->serial;
 		ret = commit_creds(new);
 		if (ret == 0)
 			ret = serial;
 		goto okay;
 	}
 
 	 
 	mutex_lock(&key_session_mutex);
 
 	 
 	keyring = find_keyring_by_name(name, false);
 	if (PTR_ERR(keyring) == -ENOKEY) {
 		 
 		keyring = keyring_alloc(
 			name, old->uid, old->gid, old,
 			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,
 			KEY_ALLOC_IN_QUOTA, NULL);
 		if (IS_ERR(keyring)) {
 			ret = PTR_ERR(keyring);
 			goto error2;
 		}
 	} else if (IS_ERR(keyring)) {
  		ret = PTR_ERR(keyring);
  		goto error2;
  	} else if (keyring == new->session_keyring) {
 		key_put(keyring);
  		ret = 0;
  		goto error2;
  	}
 
 	 
 	ret = install_session_keyring_to_cred(new, keyring);
 	if (ret < 0)
 		goto error2;
 
 	commit_creds(new);
 	mutex_unlock(&key_session_mutex);
 
 	ret = keyring->serial;
 	key_put(keyring);
 okay:
 	return ret;
 
 error2:
 	mutex_unlock(&key_session_mutex);
 error:
 	abort_creds(new);
 	return ret;
 }",[45],"The join_session_keyring function in security/keys/process_keys.c in the Linux kernel before 4.4.1 mishandles object references in a certain error case, which allows local users to gain privileges or cause a denial of service (integer overflow and use-after-free) via crafted keyctl commands."
207350," xsltIf(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
 	           xmlNodePtr inst, xsltStylePreCompPtr castedComp)
 {
     int res = 0;
 
 #ifdef XSLT_REFACTORED
     xsltStyleItemIfPtr comp = (xsltStyleItemIfPtr) castedComp;
 #else
     xsltStylePreCompPtr comp = castedComp;
 #endif
 
     if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL))
 	return;
     if ((comp == NULL) || (comp->test == NULL) || (comp->comp == NULL)) {
 	xsltTransformError(ctxt, NULL, inst,
 	    ""Internal error in xsltIf(): ""
 	    ""The XSLT 'if' instruction was not compiled.\n"");
 	return;
     }
 
 #ifdef WITH_XSLT_DEBUG_PROCESS
     XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,
 	 ""xsltIf: test %s\n"", comp->test));
 #endif
  
  #ifdef XSLT_FAST_IF
      {
	xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;
	xmlDocPtr oldXPContextDoc = xpctxt->doc;
	xmlNsPtr *oldXPNamespaces = xpctxt->namespaces;
	xmlNodePtr oldXPContextNode = xpctxt->node;
	int oldXPProximityPosition = xpctxt->proximityPosition;
	int oldXPContextSize = xpctxt->contextSize;
	int oldXPNsNr = xpctxt->nsNr;
  	xmlDocPtr oldLocalFragmentTop = ctxt->localRVT;
  
	xpctxt->node = contextNode;
	if (comp != NULL) {
#ifdef XSLT_REFACTORED
	    if (comp->inScopeNs != NULL) {
		xpctxt->namespaces = comp->inScopeNs->list;
		xpctxt->nsNr = comp->inScopeNs->xpathNumber;
	    } else {
		xpctxt->namespaces = NULL;
		xpctxt->nsNr = 0;
	    }
#else
	    xpctxt->namespaces = comp->nsList;
	    xpctxt->nsNr = comp->nsNr;
#endif
	} else {
	    xpctxt->namespaces = NULL;
	    xpctxt->nsNr = 0;
	}
	 
	res = xmlXPathCompiledEvalToBoolean(comp->comp, xpctxt);
 	res = xsltPreCompEvalToBoolean(ctxt, contextNode, comp);
  
  	 
  	if (oldLocalFragmentTop != ctxt->localRVT)
  	    xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);
	xpctxt->doc = oldXPContextDoc;
	xpctxt->node = oldXPContextNode;
	xpctxt->contextSize = oldXPContextSize;
	xpctxt->proximityPosition = oldXPProximityPosition;
	xpctxt->nsNr = oldXPNsNr;
	xpctxt->namespaces = oldXPNamespaces;
      }
  
  #ifdef WITH_XSLT_DEBUG_PROCESS
     XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,
 	""xsltIf: test evaluate to %d\n"", res));
 #endif
 
     if (res == -1) {
 	ctxt->state = XSLT_STATE_STOPPED;
 	goto error;
     }
     if (res == 1) {
 	 
 	xsltApplySequenceConstructor(ctxt,
 	    contextNode, inst->children, NULL);
     }
  
  #else  
      {
	xmlXPathObjectPtr xpobj = NULL;
  	 
	{
	    xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;
	    xmlDocPtr oldXPContextDoc = xpctxt->doc;
	    xmlNsPtr *oldXPNamespaces = xpctxt->namespaces;
	    xmlNodePtr oldXPContextNode = xpctxt->node;
	    int oldXPProximityPosition = xpctxt->proximityPosition;
	    int oldXPContextSize = xpctxt->contextSize;
	    int oldXPNsNr = xpctxt->nsNr;
	    xpctxt->node = contextNode;
	    if (comp != NULL) {
#ifdef XSLT_REFACTORED
		if (comp->inScopeNs != NULL) {
		    xpctxt->namespaces = comp->inScopeNs->list;
		    xpctxt->nsNr = comp->inScopeNs->xpathNumber;
		} else {
		    xpctxt->namespaces = NULL;
		    xpctxt->nsNr = 0;
		}
#else
		xpctxt->namespaces = comp->nsList;
		xpctxt->nsNr = comp->nsNr;
#endif
	    } else {
		xpctxt->namespaces = NULL;
		xpctxt->nsNr = 0;
	    }
	     
	    xpobj = xmlXPathCompiledEval(comp->comp, xpctxt);
	    xpctxt->doc = oldXPContextDoc;
	    xpctxt->node = oldXPContextNode;
	    xpctxt->contextSize = oldXPContextSize;
	    xpctxt->proximityPosition = oldXPProximityPosition;
	    xpctxt->nsNr = oldXPNsNr;
	    xpctxt->namespaces = oldXPNamespaces;
	}
 	xmlXPathObjectPtr xpobj = xsltPreCompEval(ctxt, contextNode, comp);
  	if (xpobj != NULL) {
  	    if (xpobj->type != XPATH_BOOLEAN)
  		xpobj = xmlXPathConvertBoolean(xpobj);
 	    if (xpobj->type == XPATH_BOOLEAN) {
 		res = xpobj->boolval;
 
 #ifdef WITH_XSLT_DEBUG_PROCESS
 		XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,
 		    ""xsltIf: test evaluate to %d\n"", res));
 #endif
 		if (res) {
 		    xsltApplySequenceConstructor(ctxt,
 			contextNode, inst->children, NULL);
 		}
 	    } else {
 
 #ifdef WITH_XSLT_DEBUG_PROCESS
 		XSLT_TRACE(ctxt, XSLT_TRACE_IF,
 		    xsltGenericDebug(xsltGenericDebugContext,
 		    ""xsltIf: test didn't evaluate to a boolean\n""));
 #endif
 		ctxt->state = XSLT_STATE_STOPPED;
 	    }
 	    xmlXPathFreeObject(xpobj);
 	} else {
 	    ctxt->state = XSLT_STATE_STOPPED;
 	}
     }
 #endif  
 
 error:
     return;
 }","[57, 124, 28, 29, 30, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 62, 63, 64, 65, 66, 67, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
207495," static void update_logging() {
  bool should_log = module_started &&
  (logging_enabled_via_api || stack_config->get_btsnoop_turned_on());
 
  if (should_log == is_logging)
  return;
 
   is_logging = should_log;
  if (should_log) {
     btsnoop_net_open();
 
  const char *log_path = stack_config->get_btsnoop_log_path();
 
  if (stack_config->get_btsnoop_should_save_last()) {
  char last_log_path[PATH_MAX];
       snprintf(last_log_path, PATH_MAX, ""%s.%llu"", log_path, btsnoop_timestamp());
  if (!rename(log_path, last_log_path) && errno != ENOENT)
 
          LOG_ERROR(""%s unable to rename '%s' to '%s': %s"", __func__, log_path, last_log_path, strerror(errno));
      }
  
    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
     logfile_fd = TEMP_FAILURE_RETRY(open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH));
      if (logfile_fd == INVALID_FD) {
        LOG_ERROR(""%s unable to open '%s': %s"", __func__, log_path, strerror(errno));
        is_logging = false;
        return;
      }
  
    write(logfile_fd, ""btsnoop\0\0\0\0\1\0\0\x3\xea"", 16);
     TEMP_FAILURE_RETRY(write(logfile_fd, ""btsnoop\0\0\0\0\1\0\0\x3\xea"", 16));
    } else {
      if (logfile_fd != INVALID_FD)
        close(logfile_fd);
 
     logfile_fd = INVALID_FD;
     btsnoop_net_close();
  }
 }","[23, 31, 22, 30]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
201147," static MagickBooleanType SetGrayscaleImage(Image *image)
 {
   CacheView
     *image_view;
 
   ExceptionInfo
     *exception;
 
   MagickBooleanType
     status;
 
   PixelPacket
     *colormap;
 
   register ssize_t
     i;
 
   ssize_t
     *colormap_index,
     j,
     y;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->type != GrayscaleType)
     (void) TransformImageColorspace(image,GRAYColorspace);
   colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize,
     sizeof(*colormap_index));
   if (colormap_index == (ssize_t *) NULL)
     ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
       image->filename);
   if (image->storage_class != PseudoClass)
     {
       ExceptionInfo
         *exception;
 
        (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*
          sizeof(*colormap_index));
        if (AcquireImageColormap(image,MaxColormapSize) == MagickFalse)
        ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
          image->filename);
         {
           colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);
           ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
             image->filename);
         }
        image->colors=0;
        status=MagickTrue;
        exception=(&image->exception);
       image_view=AcquireAuthenticCacheView(image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
       #pragma omp parallel for schedule(static,4) shared(status) \
         magick_threads(image,image,image->rows,1)
 #endif
       for (y=0; y < (ssize_t) image->rows; y++)
       {
         register IndexPacket
           *magick_restrict indexes;
 
         register PixelPacket
           *magick_restrict q;
 
         register ssize_t
           x;
 
         if (status == MagickFalse)
           continue;
         q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
           exception);
         if (q == (PixelPacket *) NULL)
           {
             status=MagickFalse;
             continue;
           }
         indexes=GetCacheViewAuthenticIndexQueue(image_view);
         for (x=0; x < (ssize_t) image->columns; x++)
         {
           register size_t
             intensity;
 
           intensity=ScaleQuantumToMap(GetPixelRed(q));
           if (colormap_index[intensity] < 0)
             {
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
               #pragma omp critical (MagickCore_SetGrayscaleImage)
 #endif
               if (colormap_index[intensity] < 0)
                 {
                   colormap_index[intensity]=(ssize_t) image->colors;
                   image->colormap[image->colors].red=GetPixelRed(q);
                   image->colormap[image->colors].green=GetPixelGreen(q);
                   image->colormap[image->colors].blue=GetPixelBlue(q);
                   image->colors++;
                }
             }
           SetPixelIndex(indexes+x,colormap_index[intensity]);
           q++;
         }
         if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
           status=MagickFalse;
       }
       image_view=DestroyCacheView(image_view);
     }
   for (i=0; i < (ssize_t) image->colors; i++)
     image->colormap[i].opacity=(unsigned short) i;
   qsort((void *) image->colormap,image->colors,sizeof(PixelPacket),
     IntensityCompare);
   colormap=(PixelPacket *) AcquireQuantumMemory(image->colors,
     sizeof(*colormap));
   if (colormap == (PixelPacket *) NULL)
     ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
       image->filename);
   j=0;
   colormap[j]=image->colormap[0];
   for (i=0; i < (ssize_t) image->colors; i++)
   {
     if (IsSameColor(image,&colormap[j],&image->colormap[i]) == MagickFalse)
       {
         j++;
         colormap[j]=image->colormap[i];
       }
     colormap_index[(ssize_t) image->colormap[i].opacity]=j;
   }
   image->colors=(size_t) (j+1);
   image->colormap=(PixelPacket *) RelinquishMagickMemory(image->colormap);
   image->colormap=colormap;
   status=MagickTrue;
   exception=(&image->exception);
   image_view=AcquireAuthenticCacheView(image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static,4) shared(status) \
     magick_threads(image,image,image->rows,1)
 #endif
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register IndexPacket
       *magick_restrict indexes;
 
     register const PixelPacket
       *magick_restrict q;
 
     register ssize_t
       x;
 
     if (status == MagickFalse)
       continue;
     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
     if (q == (PixelPacket *) NULL)
       {
         status=MagickFalse;
         continue;
       }
     indexes=GetCacheViewAuthenticIndexQueue(image_view);
     for (x=0; x < (ssize_t) image->columns; x++)
       SetPixelIndex(indexes+x,colormap_index[ScaleQuantumToMap(GetPixelIndex(
         indexes+x))]);
     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
       status=MagickFalse;
   }
   image_view=DestroyCacheView(image_view);
   colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);
   image->type=GrayscaleType;
   if (SetImageMonochrome(image,&image->exception) != MagickFalse)
     image->type=BilevelType;
   return(status);
 }","[42, 43, 44, 45, 46, 40, 41]",ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c.
205184," void GDataFileSystem::OnCopyDocumentCompleted(
     const FilePath& dir_path,
     const FileOperationCallback& callback,
     GDataErrorCode status,
     scoped_ptr<base::Value> data) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
   DCHECK(!callback.is_null());
 
   GDataFileError error = util::GDataToGDataFileError(status);
   if (error != GDATA_FILE_OK) {
     callback.Run(error);
     return;
   }
 
   scoped_ptr<DocumentEntry> doc_entry(DocumentEntry::ExtractAndParse(*data));
   if (!doc_entry.get()) {
     callback.Run(GDATA_FILE_ERROR_FAILED);
      return;
    }
  
  GDataEntry* entry = GDataEntry::FromDocumentEntry(
      NULL, doc_entry.get(), directory_service_.get());
   GDataEntry* entry = directory_service_->FromDocumentEntry(doc_entry.get());
    if (!entry) {
      callback.Run(GDATA_FILE_ERROR_FAILED);
      return;
   }
 
   directory_service_->root()->AddEntry(entry);
   MoveEntryFromRootDirectory(dir_path,
                              callback,
                              GDATA_FILE_OK,
                              entry->GetFilePath());
 }","[23, 21, 22]",Use-after-free vulnerability in Google Chrome before 24.0.1312.56 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of fonts in CANVAS elements.
198684," main(int argc,
      char **argv)
 {
    int i, gn;
    int test = 0;
    char *action = NULL, *cmd;
    char *output = NULL;
 #ifdef HAVE_EEZE_MOUNT
    Eina_Bool mnt = EINA_FALSE;
    const char *act;
 #endif
    gid_t gid, gl[65536], egid;
    int pid = 0;
 
    for (i = 1; i < argc; i++)
     const char *act;
  #endif
     gid_t gid, gl[65536], egid;
   int pid = 0;
  
     for (i = 1; i < argc; i++)
       {
                ""This is an internal tool for Enlightenment.\n""
                ""do not use it.\n""
                );
              exit(0);
           }
      }",[19],Enlightenment before 0.17.6 might allow local users to gain privileges via vectors involving the gdb method.
203014," ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
 	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
 	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
 	const u_char *cp;
 	const u_char *ep2;
 	uint32_t doi;
 	uint32_t proto;
 	static const char *notify_error_str[] = {
 		NULL,				""INVALID-PAYLOAD-TYPE"",
 		""DOI-NOT-SUPPORTED"",		""SITUATION-NOT-SUPPORTED"",
 		""INVALID-COOKIE"",		""INVALID-MAJOR-VERSION"",
 		""INVALID-MINOR-VERSION"",	""INVALID-EXCHANGE-TYPE"",
 		""INVALID-FLAGS"",		""INVALID-MESSAGE-ID"",
 		""INVALID-PROTOCOL-ID"",		""INVALID-SPI"",
 		""INVALID-TRANSFORM-ID"",		""ATTRIBUTES-NOT-SUPPORTED"",
 		""NO-PROPOSAL-CHOSEN"",		""BAD-PROPOSAL-SYNTAX"",
 		""PAYLOAD-MALFORMED"",		""INVALID-KEY-INFORMATION"",
 		""INVALID-ID-INFORMATION"",	""INVALID-CERT-ENCODING"",
 		""INVALID-CERTIFICATE"",		""CERT-TYPE-UNSUPPORTED"",
 		""INVALID-CERT-AUTHORITY"",	""INVALID-HASH-INFORMATION"",
 		""AUTHENTICATION-FAILED"",	""INVALID-SIGNATURE"",
 		""ADDRESS-NOTIFICATION"",		""NOTIFY-SA-LIFETIME"",
 		""CERTIFICATE-UNAVAILABLE"",	""UNSUPPORTED-EXCHANGE-TYPE"",
 		""UNEQUAL-PAYLOAD-LENGTHS"",
 	};
 	static const char *ipsec_notify_error_str[] = {
 		""RESERVED"",
 	};
 	static const char *notify_status_str[] = {
 		""CONNECTED"",
 	};
 	static const char *ipsec_notify_status_str[] = {
 		""RESPONDER-LIFETIME"",		""REPLAY-STATUS"",
 		""INITIAL-CONTACT"",
 	};
  
 
  
 #define NOTIFY_ERROR_STR(x) \
 	STR_OR_ID((x), notify_error_str)
 
  
 #define IPSEC_NOTIFY_ERROR_STR(x) \
 	STR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)
 
  
 #define NOTIFY_STATUS_STR(x) \
 	STR_OR_ID((u_int)((x) - 16384), notify_status_str)
 
  
 #define IPSEC_NOTIFY_STATUS_STR(x) \
 	STR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)
 
 	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_N)));
 
 	p = (const struct ikev1_pl_n *)ext;
 	ND_TCHECK(*p);
 	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
 	doi = ntohl(n.doi);
 	proto = n.prot_id;
 	if (doi != 1) {
 		ND_PRINT((ndo,"" doi=%d"", doi));
 		ND_PRINT((ndo,"" proto=%d"", proto));
 		if (ntohs(n.type) < 8192)
 			ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
 		else if (ntohs(n.type) < 16384)
 			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
 		else if (ntohs(n.type) < 24576)
 			ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
 		else
 			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
 		if (n.spi_size) {
 			ND_PRINT((ndo,"" spi=""));
 			if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
 				goto trunc;
 		}
 		return (const u_char *)(p + 1) + n.spi_size;
 	}
 
 	ND_PRINT((ndo,"" doi=ipsec""));
 	ND_PRINT((ndo,"" proto=%s"", PROTOIDSTR(proto)));
 	if (ntohs(n.type) < 8192)
 		ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
 	else if (ntohs(n.type) < 16384)
 		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));
 	else if (ntohs(n.type) < 24576)
 		ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
 	else if (ntohs(n.type) < 32768)
 		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));
 	else
 		ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
 	if (n.spi_size) {
 		ND_PRINT((ndo,"" spi=""));
 		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
 			goto trunc;
 	}
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
 			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);
 				if (cp == NULL) {
 					ND_PRINT((ndo,"")""));
 					goto trunc;
 				}
 			}
 			ND_PRINT((ndo,"")""));
 			break;
  		    }
  		case IPSECDOI_NTYPE_REPLAY_STATUS:
  			ND_PRINT((ndo,"" status=(""));
 			ND_TCHECK_32BITS(cp);
  			ND_PRINT((ndo,""replay detection %sabled"",
  				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
  			ND_PRINT((ndo,"")""));
 			break;
 		default:
 			 
 			if (ndo->ndo_vflag > 3) {
 				ND_PRINT((ndo,"" data=(""));
 				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
 					goto trunc;
 				ND_PRINT((ndo,"")""));
 			} else {
 				if (!ike_show_somedata(ndo, cp, ep))
 					goto trunc;
 			}
 			break;
 		}
 	}
 	return (const u_char *)ext + item_len;
 trunc:
 	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
 	return NULL;
 }",[124],The IKEv1 parser in tcpdump before 4.9.3 has a buffer over-read in print-isakmp.c:ikev1_n_print().
200688," get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)
  {
      static gprincs_ret              ret;
      char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
     gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
      OM_uint32                       minor_stat;
      kadm5_server_handle_t           handle;
      const char                      *errmsg = NULL;
 
     xdr_free(xdr_gprincs_ret, &ret);
 
     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
         goto exit_func;
 
     if ((ret.code = check_handle((void *)handle)))
         goto exit_func;
 
     ret.api_version = handle->api_version;
 
     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
         ret.code = KADM5_FAILURE;
         goto exit_func;
     }
     prime_arg = arg->exp;
     if (prime_arg == NULL)
         prime_arg = ""*"";
 
     if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                        rqst2name(rqstp),
                                                        ACL_LIST,
                                                        NULL,
                                                        NULL)) {
         ret.code = KADM5_AUTH_LIST;
         log_unauth(""kadm5_get_principals"", prime_arg,
                    &client_name, &service_name, rqstp);
     } else {
         ret.code  = kadm5_get_principals((void *)handle,
                                          arg->exp, &ret.princs,
                                          &ret.count);
         if( ret.code != 0 )
             errmsg = krb5_get_error_message(handle->context, ret.code);
 
         log_done(""kadm5_get_principals"", prime_arg, errmsg,
                  &client_name, &service_name, rqstp);
 
         if (errmsg != NULL)
              krb5_free_error_message(handle->context, errmsg);
  
      }
 exit_func:
      gss_release_buffer(&minor_stat, &client_name);
      gss_release_buffer(&minor_stat, &service_name);
exit_func:
      free_server_handle(handle);
      return &ret;
  }","[7, 8, 53, 5, 6, 56]",Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name.
205200," void RenderMessageFilter::OnCreateWindow(
     const ViewHostMsg_CreateWindow_Params& params,
     int* route_id,
     int* surface_id,
     int64* cloned_session_storage_namespace_id) {
    bool no_javascript_access;
    bool can_create_window =
        GetContentClient()->browser()->CanCreateWindow(
          GURL(params.opener_url),
          GURL(params.opener_security_origin),
           params.opener_url,
           params.opener_security_origin,
            params.window_container_type,
            resource_context_,
            render_process_id_,
           &no_javascript_access);
 
   if (!can_create_window) {
     *route_id = MSG_ROUTING_NONE;
     *surface_id = 0;
     return;
   }
 
   scoped_refptr<SessionStorageNamespaceImpl> cloned_namespace =
       new SessionStorageNamespaceImpl(dom_storage_context_,
                                       params.session_storage_namespace_id);
   *cloned_session_storage_namespace_id = cloned_namespace->id();
 
   render_widget_helper_->CreateNewWindow(params,
                                          no_javascript_access,
                                          peer_handle(),
                                          route_id,
                                          surface_id,
                                          cloned_namespace);
 }","[11, 12, 9, 10]","Google Chrome before 24.0.1312.56 does not validate URLs during the opening of new windows, which has unspecified impact and remote attack vectors."
203403," static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,
 			       struct pipe_inode_info *opipe,
 			       size_t len, unsigned int flags)
 {
 	struct pipe_buffer *ibuf, *obuf;
 	int ret = 0, nbuf;
 	bool input_wakeup = false;
 
 
 retry:
 	ret = ipipe_prep(ipipe, flags);
 	if (ret)
 		return ret;
 
 	ret = opipe_prep(opipe, flags);
 	if (ret)
 		return ret;
 
 	 
 	pipe_double_lock(ipipe, opipe);
 
 	do {
 		if (!opipe->readers) {
 			send_sig(SIGPIPE, current, 0);
 			if (!ret)
 				ret = -EPIPE;
 			break;
 		}
 
 		if (!ipipe->nrbufs && !ipipe->writers)
 			break;
 
 		 
 		if (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {
 			 
 			if (ret)
 				break;
 
 			if (flags & SPLICE_F_NONBLOCK) {
 				ret = -EAGAIN;
 				break;
 			}
 
 			 
 			pipe_unlock(ipipe);
 			pipe_unlock(opipe);
 			goto retry;
 		}
 
 		ibuf = ipipe->bufs + ipipe->curbuf;
 		nbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);
 		obuf = opipe->bufs + nbuf;
 
 		if (len >= ibuf->len) {
 			 
 			*obuf = *ibuf;
 			ibuf->ops = NULL;
 			opipe->nrbufs++;
 			ipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);
 			ipipe->nrbufs--;
 			input_wakeup = true;
 		} else {
 			 
			pipe_buf_get(ipipe, ibuf);
 			if (!pipe_buf_get(ipipe, ibuf)) {
 				if (ret == 0)
 					ret = -EFAULT;
 				break;
 			}
  			*obuf = *ibuf;
  
  			 
 			obuf->flags &= ~PIPE_BUF_FLAG_GIFT;
 
 			obuf->len = len;
 			opipe->nrbufs++;
 			ibuf->offset += obuf->len;
 			ibuf->len -= obuf->len;
 		}
 		ret += obuf->len;
 		len -= obuf->len;
 	} while (len);
 
 	pipe_unlock(ipipe);
 	pipe_unlock(opipe);
 
 	 
 	if (ret > 0)
 		wakeup_pipe_readers(opipe);
 
 	if (input_wakeup)
 		wakeup_pipe_writers(ipipe);
 
 	return ret;
 }","[65, 66, 67, 68, 69, 64]","The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests."
200690," get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)
  {
      static gstrings_ret             ret;
      char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
     gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
      OM_uint32                       minor_stat;
      kadm5_server_handle_t           handle;
      const char                      *errmsg = NULL;
 
     xdr_free(xdr_gstrings_ret, &ret);
 
     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
         goto exit_func;
 
     if ((ret.code = check_handle((void *)handle)))
         goto exit_func;
 
     ret.api_version = handle->api_version;
 
     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
         ret.code = KADM5_FAILURE;
         goto exit_func;
     }
     if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
         ret.code = KADM5_BAD_PRINCIPAL;
         goto exit_func;
     }
 
     if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&
         (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
                                                         rqst2name(rqstp),
                                                         ACL_INQUIRE,
                                                         arg->princ,
                                                         NULL))) {
         ret.code = KADM5_AUTH_GET;
         log_unauth(""kadm5_get_strings"", prime_arg,
                    &client_name, &service_name, rqstp);
     } else {
         ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,
                                      &ret.count);
         if (ret.code != 0)
             errmsg = krb5_get_error_message(handle->context, ret.code);
 
         log_done(""kadm5_get_strings"", prime_arg, errmsg,
                  &client_name, &service_name, rqstp);
 
         if (errmsg != NULL)
              krb5_free_error_message(handle->context, errmsg);
      }
      free(prime_arg);
 exit_func:
      gss_release_buffer(&minor_stat, &client_name);
      gss_release_buffer(&minor_stat, &service_name);
exit_func:
      free_server_handle(handle);
      return &ret;
  }","[7, 8, 54, 5, 6, 57]",Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name.
207760," read_png(struct control *control)
   
 
  {
     png_structp png_ptr;
     png_infop info_ptr = NULL;
   volatile png_bytep row = NULL, display = NULL;
     volatile int rc;
  
     png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, control,
       error_handler, warning_handler);
 
  if (png_ptr == NULL)
  {
   
       log_error(&control->file, LIBPNG_ERROR_CODE, ""OOM allocating png_struct"");
       control->file.status_code |= INTERNAL_ERROR;
  return LIBPNG_ERROR_CODE;
  }
 
 
     rc = setjmp(control->file.jmpbuf);
     if (rc == 0)
     {
 #     ifdef PNG_SET_USER_LIMITS_SUPPORTED
           
          png_set_user_limits(png_ptr, 0x7fffffff, 0x7fffffff);
          png_set_chunk_cache_max(png_ptr, 0);
          png_set_chunk_malloc_max(png_ptr, 0);
 #     endif
 
        png_set_read_fn(png_ptr, control, read_callback);
  
        info_ptr = png_create_info_struct(png_ptr);
  if (info_ptr == NULL)
          png_error(png_ptr, ""OOM allocating info structure"");
 
  if (control->file.global->verbose)
          fprintf(stderr, "" INFO\n"");
 
 
        png_read_info(png_ptr, info_ptr);
  
        {
         png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);
         png_uint_32 height = png_get_image_height(png_ptr, info_ptr);
         int passes = png_set_interlace_handling(png_ptr);
         int pass;
  
         row = png_voidcast(png_byte*, malloc(rowbytes));
         display = png_voidcast(png_byte*, malloc(rowbytes));
         png_start_read_image(png_ptr);
  
         if (row == NULL || display == NULL)
            png_error(png_ptr, ""OOM allocating row buffers"");
         for (pass = 0; pass < passes; ++pass)
         {
            png_uint_32 y = height;
  
         {
            png_uint_32 height = png_get_image_height(png_ptr, info_ptr);
            int passes = png_set_interlace_handling(png_ptr);
            int pass;
            png_start_read_image(png_ptr);
            for (pass = 0; pass < passes; ++pass)
            {
               png_uint_32 y = height;
                
               while (y-- > 0)
                  png_read_row(png_ptr, row, display);
            }
         }
             
            while (y-- > 0)
               png_read_row(png_ptr, NULL, NULL);
         }
        }
  
        if (control->file.global->verbose)
          fprintf(stderr, "" END\n"");
 
   
       png_read_end(png_ptr, info_ptr);
 
     }
  
     png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
   if (row != NULL) free(row);
   if (display != NULL) free(display);
     return rc;
  }","[25, 26, 27, 28, 29, 30, 31, 46, 47, 48, 52, 56, 57, 58, 73, 74, 75, 76, 7, 45, 50, 51, 54, 55, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 88, 89]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
5877,"void recovery_cipher_finalize(void)
{
static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = """";
static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];
volatile bool auto_completed = true;


char *tok = strtok(mnemonic, "" "");

while(tok) {
strlcpy(temp_word, tok, CURRENT_WORD_BUF);

auto_completed &= attempt_auto_complete(temp_word);

strlcat(new_mnemonic, temp_word, MNEMONIC_BUF);
strlcat(new_mnemonic, "" "", MNEMONIC_BUF);

tok = strtok(NULL, "" "");
}
memzero(temp_word, sizeof(temp_word));

if (!auto_completed && !enforce_wordlist) {
if (!dry_run) {
storage_reset();
}
fsm_sendFailure(FailureType_Failure_SyntaxError,
""Words were not entered correctly. Make sure you are using the substition cipher."");
awaiting_character = false;
layoutHome();
return;
}


new_mnemonic[strlen(new_mnemonic) - 1] = '\0';

if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {
storage_setMnemonic(new_mnemonic);
memzero(new_mnemonic, sizeof(new_mnemonic));
if (!enforce_wordlist) {

storage_setImported(true);
}
storage_commit();
fsm_sendSuccess(""Device recovered"");
} else if (dry_run) {
bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);
if (match) {
review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"",
""The seed is valid and MATCHES the one in the device."");
fsm_sendSuccess(""The seed is valid and matches the one in the device."");
} else if (mnemonic_check(new_mnemonic)) {
review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"",
""The seed is valid, but DOES NOT MATCH the one in the device."");
fsm_sendFailure(FailureType_Failure_Other,
""The seed is valid, but does not match the one in the device."");
} else {
review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"",
""The seed is INVALID, and DOES NOT MATCH the one in the device."");
fsm_sendFailure(FailureType_Failure_Other,
""The seed is invalid, and does not match the one in the device."");
}
memzero(new_mnemonic, sizeof(new_mnemonic));
} else {
session_clear(true);
fsm_sendFailure(FailureType_Failure_SyntaxError,
""Invalid mnemonic, are words in correct order?"");
recovery_abort();
}

memzero(new_mnemonic, sizeof(new_mnemonic));
awaiting_character = false;
memzero(mnemonic, sizeof(mnemonic));
memzero(cipher, sizeof(cipher));
layoutHome();
}","[3, 34]","Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB."
9669,"static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)
{
struct elo_priv *priv;
int ret;
struct usb_device *udev;

if (!hid_is_usb(hdev))
return -EINVAL;

priv = kzalloc(sizeof(*priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;

INIT_DELAYED_WORK(&priv->work, elo_work);
udev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));
priv->usbdev = usb_get_dev(udev);

hid_set_drvdata(hdev, priv);

ret = hid_parse(hdev);
if (ret) {
hid_err(hdev, ""parse failed\n"");
goto err_free;
}

ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
if (ret) {
hid_err(hdev, ""hw start failed\n"");
goto err_free;
}

if (elo_broken_firmware(priv->usbdev)) {
hid_info(hdev, ""broken firmware found, installing workaround\n"");
queue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);
}

return 0;
err_free:
kfree(priv);
return ret;
}",[39],"In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition."
200531," static int cypress_generic_port_probe(struct usb_serial_port *port)
 {
  	struct usb_serial *serial = port->serial;
  	struct cypress_private *priv;
  
 	if (!port->interrupt_out_urb || !port->interrupt_in_urb) {
 		dev_err(&port->dev, ""required endpoint is missing\n"");
 		return -ENODEV;
 	}
 
  	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
  	if (!priv)
  		return -ENOMEM;
 
 	priv->comm_is_ok = !0;
 	spin_lock_init(&priv->lock);
 	if (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {
 		kfree(priv);
 		return -ENOMEM;
 	}
 
 	 
 	if (!is_frwd(serial->dev))
 		usb_reset_configuration(serial->dev);
 
 	priv->cmd_ctrl = 0;
 	priv->line_control = 0;
 	priv->termios_initialized = 0;
 	priv->rx_flags = 0;
 	 
 	if (port->interrupt_out_size > 9)
 		priv->pkt_fmt = packet_format_1;
 	else
 		priv->pkt_fmt = packet_format_2;
 
 	if (interval > 0) {
 		priv->write_urb_interval = interval;
 		priv->read_urb_interval = interval;
 		dev_dbg(&port->dev, ""%s - read & write intervals forced to %d\n"",
 			__func__, interval);
 	} else {
 		priv->write_urb_interval = port->interrupt_out_urb->interval;
 		priv->read_urb_interval = port->interrupt_in_urb->interval;
 		dev_dbg(&port->dev, ""%s - intervals: read=%d write=%d\n"",
 			__func__, priv->read_urb_interval,
 			priv->write_urb_interval);
 	}
 	usb_set_serial_port_data(port, priv);
 
 	port->port.drain_delay = 256;
 
 	return 0;
 }","[6, 7, 8, 9, 10]","drivers/usb/serial/cypress_m8.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both an interrupt-in and an interrupt-out endpoint descriptor, related to the cypress_generic_port_probe and cypress_open functions."
198914," static int ghash_final(struct shash_desc *desc, u8 *dst)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
  	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
  	u8 *buf = dctx->buffer;
  
 	if (!ctx->gf128)
 		return -ENOKEY;
 
  	ghash_flush(ctx, dctx);
  	memcpy(dst, buf, GHASH_BLOCK_SIZE);
  
 	return 0;
 }","[7, 8, 9]","crypto/ghash-generic.c in the Linux kernel before 3.1 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact by triggering a failed or missing ghash_setkey function call, followed by a (1) ghash_update function call or (2) ghash_final function call, as demonstrated by a write operation on an AF_ALG socket."
202986," smb_fdata(netdissect_options *ndo,
           const u_char *buf, const char *fmt, const u_char *maxbuf,
           int unicodestr)
 {
     static int depth = 0;
     char s[128];
     char *p;
 
     while (*fmt) {
 	switch (*fmt) {
 	case '*':
 	    fmt++;
  	    while (buf < maxbuf) {
  		const u_char *buf2;
  		depth++;
		buf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);
 		 
 		if (depth == 10)
 			ND_PRINT((ndo, ""(too many nested levels, not recursing)""));
 		else
 			buf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);
  		depth--;
  		if (buf2 == NULL)
  		    return(NULL);
 		if (buf2 == buf)
 		    return(buf);
 		buf = buf2;
 	    }
 	    return(buf);
 
 	case '|':
 	    fmt++;
 	    if (buf >= maxbuf)
 		return(buf);
 	    break;
 
 	case '%':
 	    fmt++;
 	    buf = maxbuf;
 	    break;
 
 	case '#':
 	    fmt++;
 	    return(buf);
 	    break;
 
 	case '[':
 	    fmt++;
 	    if (buf >= maxbuf)
 		return(buf);
 	    memset(s, 0, sizeof(s));
 	    p = strchr(fmt, ']');
 	    if ((size_t)(p - fmt + 1) > sizeof(s)) {
 		 
 		return(buf);
 	    }
 	    strncpy(s, fmt, p - fmt);
 	    s[p - fmt] = '\0';
 	    fmt = p + 1;
 	    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);
 	    if (buf == NULL)
 		return(NULL);
 	    break;
 
 	default:
 	    ND_PRINT((ndo, ""%c"", *fmt));
 	    fmt++;
 	    break;
 	}
     }
     if (!depth && buf < maxbuf) {
 	size_t len = PTR_DIFF(maxbuf, buf);
 	ND_PRINT((ndo, ""Data: (%lu bytes)\n"", (unsigned long)len));
 	smb_print_data(ndo, buf, len);
 	return(buf + len);
     }
     return(buf);
 }","[17, 18, 19, 20, 21, 16]",The SMB parser in tcpdump before 4.9.3 has stack exhaustion in smbutil.c:smb_fdata() via recursion.
205478," bool IsSmartVirtualKeyboardEnabled() {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
            keyboard::switches::kEnableVirtualKeyboard)) {
      return false;
    }
  return !base::CommandLine::ForCurrentProcess()->HasSwitch(
      keyboard::switches::kDisableSmartVirtualKeyboard);
   return keyboard::IsSmartDeployEnabled();
  }","[8, 6, 7]","Use-after-free vulnerability in modules/speech/SpeechSynthesis.cpp in Blink, as used in Google Chrome before 33.0.1750.149, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper handling of a certain utterance data structure."
208591,"    void CheckSADs() {
      unsigned int reference_sad, exp_sad[4];
  
      SADs(exp_sad);
    for (int block = 0; block < 4; block++) {
      reference_sad = ReferenceSAD(UINT_MAX, block);
     for (int block = 0; block < 4; ++block) {
       reference_sad = ReferenceSAD(block);
  
      EXPECT_EQ(exp_sad[block], reference_sad) << ""block "" << block;
       EXPECT_EQ(reference_sad, exp_sad[block]) << ""block "" << block;
      }
    }","[7, 8, 11, 5, 6, 10]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
205372," float SVGLayoutSupport::calculateScreenFontSizeScalingFactor(const LayoutObject* layoutObject)
 {
     ASSERT(layoutObject);
 
      AffineTransform ctm = deprecatedCalculateTransformToLayer(layoutObject) * SubtreeContentTransformScope::currentContentTransformation();
      ctm.scale(layoutObject->document().frameHost()->deviceScaleFactorDeprecated());
  
    return narrowPrecisionToFloat(sqrt((pow(ctm.xScale(), 2) + pow(ctm.yScale(), 2)) / 2));
     return narrowPrecisionToFloat(sqrt((ctm.xScaleSquared() + ctm.yScaleSquared()) / 2));
  }","[9, 8]",Multiple unspecified vulnerabilities in Google Chrome before 36.0.1985.143 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
204453,"    void CleanUp(DownloadId id) {
     MockDownloadFile* file = download_file_factory_->GetExistingFile(id);
     ASSERT_TRUE(file != NULL);
 
     EXPECT_CALL(*file, Cancel());
  
      download_file_manager_->CancelDownload(id);
  
    EXPECT_TRUE(NULL == download_file_manager_->GetDownloadFile(id));
     EXPECT_EQ(NULL, download_file_manager_->GetDownloadFile(id));
    }","[10, 9]",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
200826," _kdc_as_rep(kdc_request_t r,
 	    krb5_data *reply,
 	    const char *from,
 	    struct sockaddr *from_addr,
 	    int datagram_reply)
 {
     krb5_context context = r->context;
     krb5_kdc_configuration *config = r->config;
     KDC_REQ *req = &r->req;
     KDC_REQ_BODY *b = NULL;
     AS_REP rep;
     KDCOptions f;
     krb5_enctype setype;
     krb5_error_code ret = 0;
     Key *skey;
     int found_pa = 0;
     int i, flags = HDB_F_FOR_AS_REQ;
     METHOD_DATA error_method;
     const PA_DATA *pa;
 
     memset(&rep, 0, sizeof(rep));
     error_method.len = 0;
     error_method.val = NULL;
 
      
     ret = _kdc_fast_unwrap_request(r);
     if (ret) {
 	_kdc_r_log(r, 0, ""FAST unwrap request from %s failed: %d"", from, ret);
 	goto out;
     }
 
     b = &req->req_body;
     f = b->kdc_options;
 
     if (f.canonicalize)
 	flags |= HDB_F_CANON;
 
     if(b->sname == NULL){
 	ret = KRB5KRB_ERR_GENERIC;
 	_kdc_set_e_text(r, ""No server in request"");
     } else{
 	ret = _krb5_principalname2krb5_principal (context,
 						  &r->server_princ,
 						  *(b->sname),
 						  b->realm);
 	if (ret == 0)
 	    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);
     }
     if (ret) {
 	kdc_log(context, config, 0,
 		""AS-REQ malformed server name from %s"", from);
 	goto out;
     }
     if(b->cname == NULL){
 	ret = KRB5KRB_ERR_GENERIC;
 	_kdc_set_e_text(r, ""No client in request"");
     } else {
 	ret = _krb5_principalname2krb5_principal (context,
 						  &r->client_princ,
 						  *(b->cname),
 						  b->realm);
 	if (ret)
 	    goto out;
 
 	ret = krb5_unparse_name(context, r->client_princ, &r->client_name);
     }
     if (ret) {
 	kdc_log(context, config, 0,
 		""AS-REQ malformed client name from %s"", from);
 	goto out;
     }
 
     kdc_log(context, config, 0, ""AS-REQ %s from %s for %s"",
 	    r->client_name, from, r->server_name);
 
      
 
     if (_kdc_is_anonymous(context, r->client_princ)) {
 	if (!_kdc_is_anon_request(b)) {
 	    kdc_log(context, config, 0, ""Anonymous ticket w/o anonymous flag"");
 	    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
 	    goto out;
 	}
     } else if (_kdc_is_anon_request(b)) {
 	kdc_log(context, config, 0,
 		""Request for a anonymous ticket with non ""
 		""anonymous client name: %s"", r->client_name);
 	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
 	goto out;
     }
 
      
 
     ret = _kdc_db_fetch(context, config, r->client_princ,
 			HDB_F_GET_CLIENT | flags, NULL,
 			&r->clientdb, &r->client);
     if(ret == HDB_ERR_NOT_FOUND_HERE) {
 	kdc_log(context, config, 5, ""client %s does not have secrets at this KDC, need to proxy"",
 		r->client_name);
 	goto out;
     } else if (ret == HDB_ERR_WRONG_REALM) {
 	char *fixed_client_name = NULL;
 
 	ret = krb5_unparse_name(context, r->client->entry.principal,
 				&fixed_client_name);
 	if (ret) {
 	    goto out;
 	}
 
 	kdc_log(context, config, 0, ""WRONG_REALM - %s -> %s"",
 		r->client_name, fixed_client_name);
 	free(fixed_client_name);
 
 	ret = _kdc_fast_mk_error(context, r,
 				 &error_method,
 				 r->armor_crypto,
 				 &req->req_body,
 				 KRB5_KDC_ERR_WRONG_REALM,
 				 NULL,
 				 r->server_princ,
 				 NULL,
 				 &r->client->entry.principal->realm,
 				 NULL, NULL,
 				 reply);
 	goto out;
     } else if(ret){
 	const char *msg = krb5_get_error_message(context, ret);
 	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->client_name, msg);
 	krb5_free_error_message(context, msg);
 	ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
 	goto out;
     }
     ret = _kdc_db_fetch(context, config, r->server_princ,
 			HDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,
 			NULL, NULL, &r->server);
     if(ret == HDB_ERR_NOT_FOUND_HERE) {
 	kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"",
 		r->server_name);
 	goto out;
     } else if(ret){
 	const char *msg = krb5_get_error_message(context, ret);
 	kdc_log(context, config, 0, ""UNKNOWN -- %s: %s"", r->server_name, msg);
 	krb5_free_error_message(context, msg);
 	ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
 	goto out;
     }
 
      
 
     ret = _kdc_find_etype(context,
 			  krb5_principal_is_krbtgt(context, r->server_princ) ?
 			  config->tgt_use_strongest_session_key :
 			  config->svc_use_strongest_session_key, FALSE,
 			  r->client, b->etype.val, b->etype.len, &r->sessionetype,
 			  NULL);
     if (ret) {
 	kdc_log(context, config, 0,
 		""Client (%s) from %s has no common enctypes with KDC ""
 		""to use for the session key"",
 		r->client_name, from);
 	goto out;
     }
 
      
 
     if(req->padata){
 	unsigned int n;
 
 	log_patypes(context, config, req->padata);
 
 	 
 
 	for (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {
 	    if (pat[n].validate == NULL)
 		continue;
 	    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))
 		continue;
 
 	    kdc_log(context, config, 5,
 		    ""Looking for %s pa-data -- %s"", pat[n].name, r->client_name);
 	    i = 0;
 	    pa = _kdc_find_padata(req, &i, pat[n].type);
 	    if (pa) {
 		ret = pat[n].validate(r, pa);
 		if (ret != 0) {
 		    goto out;
 		}
 		kdc_log(context, config, 0,
 			""%s pre-authentication succeeded -- %s"",
 			pat[n].name, r->client_name);
 		found_pa = 1;
 		r->et.flags.pre_authent = 1;
 	    }
 	}
     }
 
     if (found_pa == 0) {
 	Key *ckey = NULL;
 	size_t n;
 
 	for (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {
 	    if ((pat[n].flags & PA_ANNOUNCE) == 0)
 		continue;
 	    ret = krb5_padata_add(context, &error_method,
 				  pat[n].type, NULL, 0);
 	    if (ret)
 		goto out;
 	}
 
 	 
 	ret = _kdc_find_etype(context,
 			      config->preauth_use_strongest_session_key, TRUE,
 			      r->client, b->etype.val, b->etype.len, NULL, &ckey);
 	if (ret == 0) {
 
 	     
 
 	    if (older_enctype(ckey->key.keytype)) {
 		ret = get_pa_etype_info(context, config,
 					&error_method, ckey);
 		if (ret)
 		    goto out;
 	    }
 	    ret = get_pa_etype_info2(context, config,
 				     &error_method, ckey);
 	    if (ret)
 		goto out;
 	}
 
 	 
 	if (require_preauth_p(r) || _kdc_is_anon_request(b)) {
 	    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;
 	    _kdc_set_e_text(r, ""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ"");
 	    goto out;
 	}
 
 	if (ckey == NULL) {
 	    ret = KRB5KDC_ERR_CLIENT_NOTYET;
 	    _kdc_set_e_text(r, ""Doesn't have a client key available"");
 	    goto out;
 	}
 	krb5_free_keyblock_contents(r->context,  &r->reply_key);
 	ret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);
 	if (ret)
 	    goto out;
     }
 
     if (r->clientdb->hdb_auth_status) {
 	r->clientdb->hdb_auth_status(context, r->clientdb, r->client, 
 				     HDB_AUTH_SUCCESS);
     }
 
      
 
     ret = _kdc_check_access(context, config, r->client, r->client_name,
 			    r->server, r->server_name,
 			    req, &error_method);
     if(ret)
 	goto out;
 
      
 
     ret = _kdc_get_preferred_key(context, config,
 				 r->server, r->server_name,
 				 &setype, &skey);
     if(ret)
 	goto out;
 
     if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey
        || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {
 	ret = KRB5KDC_ERR_BADOPTION;
 	_kdc_set_e_text(r, ""Bad KDC options"");
 	goto out;
     }
 
      
 
     rep.pvno = 5;
     rep.msg_type = krb_as_rep;
 
     if (_kdc_is_anonymous(context, r->client_princ)) {
 	Realm anon_realm=KRB5_ANON_REALM;
 	ret = copy_Realm(&anon_realm, &rep.crealm);
     } else
 	ret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);
     if (ret)
 	goto out;
     ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);
     if (ret)
 	goto out;
 
     rep.ticket.tkt_vno = 5;
     ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);
     if (ret)
 	goto out;
     _krb5_principal2principalname(&rep.ticket.sname,
 				  r->server->entry.principal);
      
 #define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)
     if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))
 	rep.ticket.sname.name_type = b->sname->name_type;
 #undef CNT
 
     r->et.flags.initial = 1;
     if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)
 	r->et.flags.forwardable = f.forwardable;
     else if (f.forwardable) {
 	_kdc_set_e_text(r, ""Ticket may not be forwardable"");
 	ret = KRB5KDC_ERR_POLICY;
 	goto out;
     }
     if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)
 	r->et.flags.proxiable = f.proxiable;
     else if (f.proxiable) {
 	_kdc_set_e_text(r, ""Ticket may not be proxiable"");
 	ret = KRB5KDC_ERR_POLICY;
 	goto out;
     }
     if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)
 	r->et.flags.may_postdate = f.allow_postdate;
     else if (f.allow_postdate){
 	_kdc_set_e_text(r, ""Ticket may not be postdate"");
 	ret = KRB5KDC_ERR_POLICY;
 	goto out;
     }
 
      
     if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {
 	_kdc_set_e_text(r, ""Bad address list in requested"");
 	ret = KRB5KRB_AP_ERR_BADADDR;
 	goto out;
     }
 
     ret = copy_PrincipalName(&rep.cname, &r->et.cname);
     if (ret)
 	goto out;
     ret = copy_Realm(&rep.crealm, &r->et.crealm);
     if (ret)
 	goto out;
 
     {
 	time_t start;
 	time_t t;
 	
 	start = r->et.authtime = kdc_time;
 
 	if(f.postdated && req->req_body.from){
 	    ALLOC(r->et.starttime);
 	    start = *r->et.starttime = *req->req_body.from;
 	    r->et.flags.invalid = 1;
 	    r->et.flags.postdated = 1;  
 	}
 	_kdc_fix_time(&b->till);
 	t = *b->till;
 
 	 
 
 	if(r->client->entry.max_life)
 	    t = start + min(t - start, *r->client->entry.max_life);
 	if(r->server->entry.max_life)
 	    t = start + min(t - start, *r->server->entry.max_life);
 #if 0
 	t = min(t, start + realm->max_life);
 #endif
 	r->et.endtime = t;
 	if(f.renewable_ok && r->et.endtime < *b->till){
 	    f.renewable = 1;
 	    if(b->rtime == NULL){
 		ALLOC(b->rtime);
 		*b->rtime = 0;
 	    }
 	    if(*b->rtime < *b->till)
 		*b->rtime = *b->till;
 	}
 	if(f.renewable && b->rtime){
 	    t = *b->rtime;
 	    if(t == 0)
 		t = MAX_TIME;
 	    if(r->client->entry.max_renew)
 		t = start + min(t - start, *r->client->entry.max_renew);
 	    if(r->server->entry.max_renew)
 		t = start + min(t - start, *r->server->entry.max_renew);
 #if 0
 	    t = min(t, start + realm->max_renew);
 #endif
 	    ALLOC(r->et.renew_till);
 	    *r->et.renew_till = t;
 	    r->et.flags.renewable = 1;
 	}
     }
 
     if (_kdc_is_anon_request(b))
 	r->et.flags.anonymous = 1;
 
     if(b->addresses){
 	ALLOC(r->et.caddr);
 	copy_HostAddresses(b->addresses, r->et.caddr);
     }
 
     r->et.transited.tr_type = DOMAIN_X500_COMPRESS;
     krb5_data_zero(&r->et.transited.contents);
 
      
     r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));
     if (r->ek.last_req.val == NULL) {
 	ret = ENOMEM;
 	goto out;
     }
     r->ek.last_req.len = 0;
     if (r->client->entry.pw_end
 	&& (config->kdc_warn_pwexpire == 0
 	    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {
 	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;
 	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;
 	++r->ek.last_req.len;
     }
     if (r->client->entry.valid_end) {
 	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;
 	r->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;
 	++r->ek.last_req.len;
     }
     if (r->ek.last_req.len == 0) {
 	r->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;
 	r->ek.last_req.val[r->ek.last_req.len].lr_value = 0;
 	++r->ek.last_req.len;
     }
     r->ek.nonce = b->nonce;
     if (r->client->entry.valid_end || r->client->entry.pw_end) {
 	ALLOC(r->ek.key_expiration);
 	if (r->client->entry.valid_end) {
 	    if (r->client->entry.pw_end)
 		*r->ek.key_expiration = min(*r->client->entry.valid_end,
 					 *r->client->entry.pw_end);
 	    else
 		*r->ek.key_expiration = *r->client->entry.valid_end;
 	} else
 	    *r->ek.key_expiration = *r->client->entry.pw_end;
     } else
 	r->ek.key_expiration = NULL;
     r->ek.flags = r->et.flags;
     r->ek.authtime = r->et.authtime;
     if (r->et.starttime) {
 	ALLOC(r->ek.starttime);
 	*r->ek.starttime = *r->et.starttime;
     }
     r->ek.endtime = r->et.endtime;
     if (r->et.renew_till) {
 	ALLOC(r->ek.renew_till);
 	*r->ek.renew_till = *r->et.renew_till;
     }
     ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);
     if (ret)
 	goto out;
     ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);
     if (ret)
 	goto out;
     if(r->et.caddr){
 	ALLOC(r->ek.caddr);
 	copy_HostAddresses(r->et.caddr, r->ek.caddr);
     }
 
      
 
     if (r->session_key.keytype == ETYPE_NULL) {
 	ret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);
 	if (ret)
 	    goto out;
     }
 
     if (r->reply_key.keytype == ETYPE_NULL) {
 	_kdc_set_e_text(r, ""Client have no reply key"");
 	ret = KRB5KDC_ERR_CLIENT_NOTYET;
 	goto out;
     }
 
     ret = copy_EncryptionKey(&r->session_key, &r->et.key);
     if (ret)
 	goto out;
 
     ret = copy_EncryptionKey(&r->session_key, &r->ek.key);
     if (ret)
 	goto out;
 
     if (r->outpadata.len) {
 
 	ALLOC(rep.padata);
 	if (rep.padata == NULL) {
 	    ret = ENOMEM;
 	    goto out;
 	}
 	ret = copy_METHOD_DATA(&r->outpadata, rep.padata);
 	if (ret)
 	    goto out;
     }
 
      
     if (send_pac_p(context, req)) {
 	generate_pac(r, skey);
     }
 
     _kdc_log_timestamp(context, config, ""AS-REQ"", r->et.authtime, r->et.starttime,
 		       r->et.endtime, r->et.renew_till);
 
      
     ret = _kdc_add_KRB5SignedPath(context,
 				  config,
 				  r->server,
 				  setype,
 				  r->client->entry.principal,
 				  NULL,
 				  NULL,
 				  &r->et);
     if (ret)
 	goto out;
 
     log_as_req(context, config, r->reply_key.keytype, setype, b);
 
      
 
     r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;
 
      
 
     i = 0;
     pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);
     if (pa) {
 
 	ret = add_enc_pa_rep(r);
 	if (ret) {
 	    const char *msg = krb5_get_error_message(r->context, ret);
 	    _kdc_r_log(r, 0, ""add_enc_pa_rep failed: %s: %d"", msg, ret);
 	    krb5_free_error_message(r->context, msg);
 	    goto out;
 	}
     }
 
      
 
     ret = _kdc_encode_reply(context, config,
 			    r->armor_crypto, req->req_body.nonce,
 			    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,
 			    &skey->key, r->client->entry.kvno,
 			    &r->reply_key, 0, &r->e_text, reply);
     if (ret)
 	goto out;
 
      
     if (datagram_reply && reply->length > config->max_datagram_reply_length) {
 	krb5_data_free(reply);
 	ret = KRB5KRB_ERR_RESPONSE_TOO_BIG;
 	_kdc_set_e_text(r, ""Reply packet too large"");
     }
 
 out:
     free_AS_REP(&rep);
 
       
    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
     if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
  	ret = _kdc_fast_mk_error(context, r,
  				 &error_method,
  				 r->armor_crypto,
  				 &req->req_body,
  				 ret, r->e_text,
  				 r->server_princ,
				 &r->client_princ->name,
				 &r->client_princ->realm,
 				 r->client_princ ?
                                      &r->client_princ->name : NULL,
 				 r->client_princ ?
                                      &r->client_princ->realm : NULL,
  				 NULL, NULL,
  				 reply);
  	if (ret)
 	    goto out2;
     }
 out2:
     free_EncTicketPart(&r->et);
     free_EncKDCRepPart(&r->ek);
     free_KDCFastState(&r->fast);
 
     if (error_method.len)
 	free_METHOD_DATA(&error_method);
     if (r->outpadata.len)
 	free_METHOD_DATA(&r->outpadata);
     if (r->client_princ) {
 	krb5_free_principal(context, r->client_princ);
 	r->client_princ = NULL;
     }
     if (r->client_name) {
 	free(r->client_name);
 	r->client_name = NULL;
     }
     if (r->server_princ){
 	krb5_free_principal(context, r->server_princ);
 	r->server_princ = NULL;
     }
     if (r->server_name) {
 	free(r->server_name);
 	r->server_name = NULL;
     }
     if (r->client)
 	_kdc_free_ent(context, r->client);
     if (r->server)
 	_kdc_free_ent(context, r->server);
     if (r->armor_crypto) {
 	krb5_crypto_destroy(r->context, r->armor_crypto);
 	r->armor_crypto = NULL;
     }
     krb5_free_keyblock_contents(r->context, &r->reply_key);
     krb5_free_keyblock_contents(r->context, &r->session_key);
     return ret;
 }","[559, 568, 569, 570, 571, 558, 566, 567]","In Heimdal through 7.4, remote unauthenticated attackers are able to crash the KDC by sending a crafted UDP packet containing empty data fields for client name or realm. The parser would unconditionally dereference NULL pointers in that case, leading to a segmentation fault. This is related to the _kdc_as_rep function in kdc/kerberos5.c and the der_length_visible_string function in lib/asn1/der_length.c."
201635," TIFFNumberOfStrips(TIFF* tif)
 {
  	TIFFDirectory *td = &tif->tif_dir;
  	uint32 nstrips;
  
     
    if( td->td_nstrips )
        return td->td_nstrips;
  	nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :
  	     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));
  	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
 		nstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,
 		    ""TIFFNumberOfStrips"");
 	return (nstrips);
 }","[6, 7, 8]","LibTIFF 4.0.7 allows remote attackers to cause a denial of service (heap-based buffer over-read) or possibly have unspecified other impact via a crafted TIFF image, related to *READ of size 8* and libtiff/tif_read.c:523:22."
207826," Cluster* Cluster::Create(Segment* pSegment, long idx, long long off)
{
  assert(pSegment);
  assert(off >= 0);
 Cluster* Cluster::Create(Segment* pSegment, long idx, long long off) {
   if (!pSegment || off < 0)
     return NULL;
  
    const long long element_start = pSegment->m_start + off;
  
  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);
  assert(pCluster);
   Cluster* const pCluster =
       new (std::nothrow) Cluster(pSegment, idx, element_start);
  
    return pCluster;
  }","[5, 6, 7, 13, 14, 2, 3, 4, 11, 12]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
204797," static v8::Handle<v8::Value> strictFunctionCallback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestObj.strictFunction"");
      if (args.Length() < 3)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestObj* imp = V8TestObj::toNative(args.Holder());
      ExceptionCode ec = 0;
      {
     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
     EXCEPTION_BLOCK(float, a, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));
     EXCEPTION_BLOCK(int, b, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);
     RefPtr<bool> result = imp->strictFunction(str, a, b, ec);
     if (UNLIKELY(ec))
         goto fail;
     return toV8(result.release(), args.GetIsolate());
     }
     fail:
     V8Proxy::setDOMException(ec, args.GetIsolate());
     return v8::Handle<v8::Value>();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
208337," const BlockEntry* Cluster::GetEntry(
    const Track* pTrack,
    long long time_ns) const
{
    assert(pTrack);
    if (m_pSegment == NULL)   
        return pTrack->GetEOS();
   if (m_pSegment == NULL)   
     return pTrack->GetEOS();
  
  #if 0
  
  LoadBlockEntries();
 
  if ((m_entries == NULL) || (m_entries_count <= 0))
  return NULL;  
 
  const BlockEntry* pResult = pTrack->GetEOS();
 
  BlockEntry** i = m_entries;
     assert(i);
 
  BlockEntry** const j = i + m_entries_count;
 
  while (i != j)
  {
  const BlockEntry* const pEntry = *i++;
         assert(pEntry);
         assert(!pEntry->EOS());
 
  const Block* const pBlock = pEntry->GetBlock();
         assert(pBlock);
 
  if (pBlock->GetTrackNumber() != pTrack->GetNumber())
  continue;
 
  if (pTrack->VetEntry(pEntry))
  {
  if (time_ns < 0)  
  return pEntry;
 
  const long long ns = pBlock->GetTime(this);
 
  if (ns > time_ns)
  break;
 
             pResult = pEntry;
  }
  else if (time_ns >= 0)
  {
  const long long ns = pBlock->GetTime(this);
 
  if (ns > time_ns)
  break;
  }
  }
 
  return pResult;
 
  
  #else
  
    const BlockEntry* pResult = pTrack->GetEOS();
   const BlockEntry* pResult = pTrack->GetEOS();
  
    long index = 0;
   long index = 0;
  
    for (;;)
    {
        if (index >= m_entries_count)
        {
            long long pos;
            long len;
   for (;;) {
     if (index >= m_entries_count) {
       long long pos;
       long len;
  
            const long status = Parse(pos, len);
            assert(status >= 0);
       const long status = Parse(pos, len);
       assert(status >= 0);
  
            if (status > 0)   
                return pResult;
       if (status > 0)   
         return pResult;
  
            if (status < 0)   
                return 0;
       if (status < 0)   
         return 0;
  
            assert(m_entries);
            assert(index < m_entries_count);
        }
        const BlockEntry* const pEntry = m_entries[index];
        assert(pEntry);
        assert(!pEntry->EOS());
        const Block* const pBlock = pEntry->GetBlock();
        assert(pBlock);
        if (pBlock->GetTrackNumber() != pTrack->GetNumber())
        {
            ++index;
            continue;
        }
        if (pTrack->VetEntry(pEntry))
        {
            if (time_ns < 0)   
                return pEntry;
            const long long ns = pBlock->GetTime(this);
            if (ns > time_ns)
                return pResult;
            pResult = pEntry;   
        }
        else if (time_ns >= 0)
        {
            const long long ns = pBlock->GetTime(this);
            if (ns > time_ns)
                return pResult;
        }
        ++index;
       assert(m_entries);
       assert(index < m_entries_count);
      }
  
     const BlockEntry* const pEntry = m_entries[index];
     assert(pEntry);
     assert(!pEntry->EOS());
 
     const Block* const pBlock = pEntry->GetBlock();
     assert(pBlock);
 
     if (pBlock->GetTrackNumber() != pTrack->GetNumber()) {
       ++index;
       continue;
     }
 
     if (pTrack->VetEntry(pEntry)) {
       if (time_ns < 0)   
         return pEntry;
 
       const long long ns = pBlock->GetTime(this);
 
       if (ns > time_ns)
         return pResult;
 
       pResult = pEntry;   
     } else if (time_ns >= 0) {
       const long long ns = pBlock->GetTime(this);
 
       if (ns > time_ns)
         return pResult;
     }
 
     ++index;
   }
 
  #endif
  }","[8, 9, 64, 67, 75, 76, 77, 78, 82, 83, 87, 88, 92, 93, 124, 125, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 2, 3, 4, 5, 6, 7, 63, 66, 69, 70, 71, 72, 73, 74, 80, 81, 85, 86, 90, 91, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
207812," OMX_ERRORTYPE  omx_vdec::set_config(OMX_IN OMX_HANDLETYPE      hComp,
         OMX_IN OMX_INDEXTYPE configIndex,
         OMX_IN OMX_PTR        configData)
 {
  (void) hComp;
  if (m_state == OMX_StateInvalid) {
         DEBUG_PRINT_ERROR(""Get Config in Invalid State"");
  return OMX_ErrorInvalidState;
  }
 
     OMX_ERRORTYPE ret = OMX_ErrorNone;
     OMX_VIDEO_CONFIG_NALSIZE *pNal;
 
     DEBUG_PRINT_LOW(""Set Config Called"");
 
  if (configIndex == (OMX_INDEXTYPE)OMX_IndexVendorVideoExtraData) {
         OMX_VENDOR_EXTRADATATYPE *config = (OMX_VENDOR_EXTRADATATYPE *) configData;
         DEBUG_PRINT_LOW(""Index OMX_IndexVendorVideoExtraData called"");
  if (!strcmp(drv_ctx.kind, ""OMX.qcom.video.decoder.avc"") ||
  !strcmp(drv_ctx.kind, ""OMX.qcom.video.decoder.mvc"")) {
             DEBUG_PRINT_LOW(""Index OMX_IndexVendorVideoExtraData AVC"");
             OMX_U32 extra_size;
 
             nal_length = (config->pData[4] & 0x03) + 1;
 
             extra_size = 0;
  if (nal_length > 2) {
   
                 extra_size = (nal_length - 2) * 2;
  }
 
             OMX_U8 *pSrcBuf = (OMX_U8 *) (&config->pData[6]);
             OMX_U8 *pDestBuf;
             m_vendor_config.nPortIndex = config->nPortIndex;
 
             m_vendor_config.nDataSize = config->nDataSize - 6 - 1 + extra_size;
             m_vendor_config.pData = (OMX_U8 *) malloc(m_vendor_config.nDataSize);
             OMX_U32 len;
             OMX_U8 index = 0;
             pDestBuf = m_vendor_config.pData;
 
             DEBUG_PRINT_LOW(""Rxd SPS+PPS nPortIndex[%u] len[%u] data[%p]"",
  (unsigned int)m_vendor_config.nPortIndex,
  (unsigned int)m_vendor_config.nDataSize,
                     m_vendor_config.pData);
  while (index < 2) {
  uint8 *psize;
                 len = *pSrcBuf;
                 len = len << 8;
                 len |= *(pSrcBuf + 1);
                 psize = (uint8 *) & len;
                 memcpy(pDestBuf + nal_length, pSrcBuf + 2,len);
  for (unsigned int i = 0; i < nal_length; i++) {
                     pDestBuf[i] = psize[nal_length - 1 - i];
  }
                 pDestBuf += len + nal_length;
                 pSrcBuf += len + 2;
                 index++;
                 pSrcBuf++;  
                 len = 0;
  }
  } else if (!strcmp(drv_ctx.kind, ""OMX.qcom.video.decoder.mpeg4"") ||
  !strcmp(drv_ctx.kind, ""OMX.qcom.video.decoder.mpeg2"")) {
             m_vendor_config.nPortIndex = config->nPortIndex;
             m_vendor_config.nDataSize = config->nDataSize;
             m_vendor_config.pData = (OMX_U8 *) malloc((config->nDataSize));
             memcpy(m_vendor_config.pData, config->pData,config->nDataSize);
  } else if (!strcmp(drv_ctx.kind, ""OMX.qcom.video.decoder.vc1"")) {
  if (m_vendor_config.pData) {
                 free(m_vendor_config.pData);
                 m_vendor_config.pData = NULL;
                 m_vendor_config.nDataSize = 0;
  }
 
  if (((*((OMX_U32 *) config->pData)) &
                         VC1_SP_MP_START_CODE_MASK) ==
                     VC1_SP_MP_START_CODE) {
                 DEBUG_PRINT_LOW(""set_config - VC1 simple/main profile"");
                 m_vendor_config.nPortIndex = config->nPortIndex;
                 m_vendor_config.nDataSize = config->nDataSize;
                 m_vendor_config.pData =
  (OMX_U8 *) malloc(config->nDataSize);
                 memcpy(m_vendor_config.pData, config->pData,
                         config->nDataSize);
                 m_vc1_profile = VC1_SP_MP_RCV;
  } else if (*((OMX_U32 *) config->pData) == VC1_AP_SEQ_START_CODE) {
                 DEBUG_PRINT_LOW(""set_config - VC1 Advance profile"");
                 m_vendor_config.nPortIndex = config->nPortIndex;
                 m_vendor_config.nDataSize = config->nDataSize;
                 m_vendor_config.pData =
  (OMX_U8 *) malloc((config->nDataSize));
                 memcpy(m_vendor_config.pData, config->pData,
                         config->nDataSize);
                 m_vc1_profile = VC1_AP;
  } else if ((config->nDataSize == VC1_STRUCT_C_LEN)) {
                 DEBUG_PRINT_LOW(""set_config - VC1 Simple/Main profile struct C only"");
                 m_vendor_config.nPortIndex = config->nPortIndex;
                 m_vendor_config.nDataSize  = config->nDataSize;
                 m_vendor_config.pData = (OMX_U8*)malloc(config->nDataSize);
                 memcpy(m_vendor_config.pData,config->pData,config->nDataSize);
                 m_vc1_profile = VC1_SP_MP_RCV;
  } else {
                 DEBUG_PRINT_LOW(""set_config - Error: Unknown VC1 profile"");
  }
  }
  return ret;
  } else if (configIndex == OMX_IndexConfigVideoNalSize) {
 
          struct v4l2_control temp;
          temp.id = V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT;
  
         VALIDATE_OMX_PARAM_DATA(configData, OMX_VIDEO_CONFIG_NALSIZE);
          pNal = reinterpret_cast < OMX_VIDEO_CONFIG_NALSIZE * >(configData);
          switch (pNal->nNaluBytes) {
              case 0:
                 temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_STARTCODES;
  break;
  case 2:
                 temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_TWO_BYTE_LENGTH;
  break;
  case 4:
                 temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_FOUR_BYTE_LENGTH;
  break;
  default:
  return OMX_ErrorUnsupportedSetting;
  }
 
  if (!arbitrary_bytes) {
   
  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &temp)) {
                 DEBUG_PRINT_ERROR(""Failed to set V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT"");
  return OMX_ErrorHardware;
  }
  }
 
         nal_length = pNal->nNaluBytes;
         m_frame_parser.init_nal_length(nal_length);
 
         DEBUG_PRINT_LOW(""OMX_IndexConfigVideoNalSize called with Size %d"", nal_length);
  return ret;
  } else if ((int)configIndex == (int)OMX_IndexVendorVideoFrameRate) {
         OMX_VENDOR_VIDEOFRAMERATE *config = (OMX_VENDOR_VIDEOFRAMERATE *) configData;
         DEBUG_PRINT_HIGH(""Index OMX_IndexVendorVideoFrameRate %u"", (unsigned int)config->nFps);
 
  if (config->nPortIndex == OMX_CORE_INPUT_PORT_INDEX) {
  if (config->bEnabled) {
  if ((config->nFps >> 16) > 0) {
                     DEBUG_PRINT_HIGH(""set_config: frame rate set by omx client : %u"",
  (unsigned int)config->nFps >> 16);
                     Q16ToFraction(config->nFps, drv_ctx.frame_rate.fps_numerator,
                             drv_ctx.frame_rate.fps_denominator);
 
  if (!drv_ctx.frame_rate.fps_numerator) {
                         DEBUG_PRINT_ERROR(""Numerator is zero setting to 30"");
                         drv_ctx.frame_rate.fps_numerator = 30;
  }
 
  if (drv_ctx.frame_rate.fps_denominator) {
                         drv_ctx.frame_rate.fps_numerator = (int)
                             drv_ctx.frame_rate.fps_numerator / drv_ctx.frame_rate.fps_denominator;
  }
 
                     drv_ctx.frame_rate.fps_denominator = 1;
                     frm_int = drv_ctx.frame_rate.fps_denominator * 1e6 /
                         drv_ctx.frame_rate.fps_numerator;
 
  struct v4l2_outputparm oparm;
   
                     oparm.timeperframe.numerator = drv_ctx.frame_rate.fps_denominator;
                     oparm.timeperframe.denominator = drv_ctx.frame_rate.fps_numerator;
 
  struct v4l2_streamparm sparm;
                     sparm.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
                     sparm.parm.output = oparm;
  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_PARM, &sparm)) {
                         DEBUG_PRINT_ERROR(""Unable to convey fps info to driver, \
                                 performance might be affected"");
                         ret = OMX_ErrorHardware;
  }
                     client_set_fps = true;
  } else {
                     DEBUG_PRINT_ERROR(""Frame rate not supported."");
                     ret = OMX_ErrorUnsupportedSetting;
  }
  } else {
                 DEBUG_PRINT_HIGH(""set_config: Disabled client's frame rate"");
                 client_set_fps = false;
  }
  } else {
             DEBUG_PRINT_ERROR("" Set_config: Bad Port idx %d"",
  (int)config->nPortIndex);
             ret = OMX_ErrorBadPortIndex;
  }
 
  return ret;
  } else if ((int)configIndex == (int)OMX_QcomIndexConfigPerfLevel) {
         OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =
  (OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;
  struct v4l2_control control;
 
         DEBUG_PRINT_LOW(""Set perf level: %d"", perf->ePerfLevel);
 
         control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;
 
  switch (perf->ePerfLevel) {
  case OMX_QCOM_PerfLevelNominal:
                 control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL;
  break;
  case OMX_QCOM_PerfLevelTurbo:
                 control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO;
  break;
  default:
                 ret = OMX_ErrorUnsupportedSetting;
  break;
  }
 
  if (ret == OMX_ErrorNone) {
             ret = (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control) < 0) ?
                 OMX_ErrorUnsupportedSetting : OMX_ErrorNone;
  }
 
  return ret;
  } else if ((int)configIndex == (int)OMX_IndexConfigPriority) {
         OMX_PARAM_U32TYPE *priority = (OMX_PARAM_U32TYPE *)configData;
         DEBUG_PRINT_LOW(""Set_config: priority %d"", priority->nU32);
 
  struct v4l2_control control;
 
         control.id = V4L2_CID_MPEG_VIDC_VIDEO_PRIORITY;
  if (priority->nU32 == 0)
             control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_ENABLE;
  else
             control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_DISABLE;
 
  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {
             DEBUG_PRINT_ERROR(""Failed to set Priority"");
             ret = OMX_ErrorUnsupportedSetting;
  }
  return ret;
  } else if ((int)configIndex == (int)OMX_IndexConfigOperatingRate) {
         OMX_PARAM_U32TYPE *rate = (OMX_PARAM_U32TYPE *)configData;
         DEBUG_PRINT_LOW(""Set_config: operating-rate %u fps"", rate->nU32 >> 16);
 
  struct v4l2_control control;
 
         control.id = V4L2_CID_MPEG_VIDC_VIDEO_OPERATING_RATE;
         control.value = rate->nU32;
 
  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {
             ret = errno == -EBUSY ? OMX_ErrorInsufficientResources :
                     OMX_ErrorUnsupportedSetting;
             DEBUG_PRINT_ERROR(""Failed to set operating rate %u fps (%s)"",
                     rate->nU32 >> 16, errno == -EBUSY ? ""HW Overload"" : strerror(errno));
  }
  return ret;
  }
 
  return OMX_ErrorNotImplemented;
 }",[112],"The mm-video-v4l2 vidc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate certain OMX parameter data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27532721."
201260," grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,
                      struct grub_ext4_extent_header *ext_block,
                      grub_uint32_t fileblock)
 {
   struct grub_ext4_extent_idx *index;
 
   while (1)
     {
       int i;
       grub_disk_addr_t block;
 
       index = (struct grub_ext4_extent_idx *) (ext_block + 1);
 
       if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)
         return 0;
 
       if (ext_block->depth == 0)
         return ext_block;
 
       for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)
         {
           if (fileblock < grub_le_to_cpu32(index[i].block))
             break;
         }
 
       if (--i < 0)
         return 0;
 
       block = grub_le_to_cpu16 (index[i].leaf_hi);
        block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);
        if (grub_disk_read (data->disk,
                            block << LOG2_EXT2_BLOCK_SIZE (data),
                          0, EXT2_BLOCK_SIZE(data), buf))
                           0, EXT2_BLOCK_SIZE(data), buf)) {
          return 0;
       }
  
        ext_block = (struct grub_ext4_extent_header *) buf;
      }
 }","[34, 36, 33]","The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array."
199703," int hashtable_init(hashtable_t *hashtable)
 {
      size_t i;
  
      hashtable->size = 0;
    hashtable->num_buckets = 0;   
    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
     hashtable->order = 3;
     hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
      if(!hashtable->buckets)
          return -1;
  
      list_init(&hashtable->list);
  
    for(i = 0; i < num_buckets(hashtable); i++)
     for(i = 0; i < hashsize(hashtable->order); i++)
      {
          hashtable->buckets[i].first = hashtable->buckets[i].last =
              &hashtable->list;
     }
 
     return 0;
 }","[8, 9, 16, 6, 7, 15]","Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document."
9698,"void jbd2_journal_wait_updates(journal_t *journal)
{
transaction_t *commit_transaction = journal->j_running_transaction;

if (!commit_transaction)
return;

spin_lock(&commit_transaction->t_handle_lock);
while (atomic_read(&commit_transaction->t_updates)) {
DEFINE_WAIT(wait);

prepare_to_wait(&journal->j_wait_updates, &wait,
TASK_UNINTERRUPTIBLE);
if (atomic_read(&commit_transaction->t_updates)) {
spin_unlock(&commit_transaction->t_handle_lock);
write_unlock(&journal->j_state_lock);
schedule();
write_lock(&journal->j_state_lock);
spin_lock(&commit_transaction->t_handle_lock);
}
finish_wait(&journal->j_wait_updates, &wait);
}
spin_unlock(&commit_transaction->t_handle_lock);
}","[3, 5, 6, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 21, 23, 23]",jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before 5.17.1 has a use-after-free caused by a transaction_t race condition.
205165," RenderProcessHost* RenderProcessHostImpl::GetProcessHostForSite(
     BrowserContext* browser_context,
     const GURL& url) {
    SiteProcessMap* map =
        GetSiteProcessMapForBrowserContext(browser_context);
  
    
    
    std::string site = SiteInstance::GetSiteForURL(browser_context, url)
        .possibly_invalid_spec();
  return map->FindProcess(site);
   RenderProcessHost* host = map->FindProcess(site);
   if (host && !IsSuitableHost(host, browser_context, url)) {
      
      
     RecordAction(UserMetricsAction(""BindingsMismatch_GetProcessHostPerSite""));
     map->RemoveProcess(host);
     host = NULL;
   }
 
   return host;
  }","[7, 8, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 11]","Google Chrome before 25.0.1364.152 does not properly manage bindings of extension processes, which has unspecified impact and attack vectors."
207385," status_t MPEG4Source::read(
  MediaBuffer **out, const ReadOptions *options) {
  Mutex::Autolock autoLock(mLock);
 
     CHECK(mStarted);
 
  if (mFirstMoofOffset > 0) {
  return fragmentedRead(out, options);
  }
 
  *out = NULL;
 
  int64_t targetSampleTimeUs = -1;
 
  int64_t seekTimeUs;
  ReadOptions::SeekMode mode;
  if (options && options->getSeekTo(&seekTimeUs, &mode)) {
  uint32_t findFlags = 0;
  switch (mode) {
  case ReadOptions::SEEK_PREVIOUS_SYNC:
                 findFlags = SampleTable::kFlagBefore;
  break;
  case ReadOptions::SEEK_NEXT_SYNC:
                 findFlags = SampleTable::kFlagAfter;
  break;
  case ReadOptions::SEEK_CLOSEST_SYNC:
  case ReadOptions::SEEK_CLOSEST:
                 findFlags = SampleTable::kFlagClosest;
  break;
  default:
                 CHECK(!""Should not be here."");
  break;
  }
 
  uint32_t sampleIndex;
  status_t err = mSampleTable->findSampleAtTime(
                 seekTimeUs, 1000000, mTimescale,
  &sampleIndex, findFlags);
 
  if (mode == ReadOptions::SEEK_CLOSEST) {
             findFlags = SampleTable::kFlagBefore;
  }
 
  uint32_t syncSampleIndex;
  if (err == OK) {
             err = mSampleTable->findSyncSampleNear(
                     sampleIndex, &syncSampleIndex, findFlags);
  }
 
  uint32_t sampleTime;
  if (err == OK) {
             err = mSampleTable->getMetaDataForSample(
                     sampleIndex, NULL, NULL, &sampleTime);
  }
 
  if (err != OK) {
  if (err == ERROR_OUT_OF_RANGE) {
                 err = ERROR_END_OF_STREAM;
  }
             ALOGV(""end of stream"");
  return err;
  }
 
  if (mode == ReadOptions::SEEK_CLOSEST) {
             targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;
  }
 
 #if 0
  uint32_t syncSampleTime;
         CHECK_EQ(OK, mSampleTable->getMetaDataForSample(
                     syncSampleIndex, NULL, NULL, &syncSampleTime));
 
         ALOGI(""seek to time %lld us => sample at time %lld us, ""
  ""sync sample at time %lld us"",
              seekTimeUs,
              sampleTime * 1000000ll / mTimescale,
              syncSampleTime * 1000000ll / mTimescale);
 #endif
 
         mCurrentSampleIndex = syncSampleIndex;
  if (mBuffer != NULL) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  }
 
  off64_t offset;
  size_t size;
  uint32_t cts, stts;
  bool isSyncSample;
  bool newBuffer = false;
  if (mBuffer == NULL) {
         newBuffer = true;
 
  status_t err =
             mSampleTable->getMetaDataForSample(
                     mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);
 
  if (err != OK) {
  return err;
  }
 
         err = mGroup->acquire_buffer(&mBuffer);
 
  if (err != OK) {
             CHECK(mBuffer == NULL);
  return err;
  }
  }
 
  if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {
  if (newBuffer) {
  ssize_t num_bytes_read =
                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);
 
  if (num_bytes_read < (ssize_t)size) {
                 mBuffer->release();
                 mBuffer = NULL;
 
  return ERROR_IO;
  }
 
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
             mBuffer->meta_data()->clear();
             mBuffer->meta_data()->setInt64(
                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
             mBuffer->meta_data()->setInt64(
                     kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
                 mBuffer->meta_data()->setInt64(
                         kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
  }
 
  if (!mIsAVC && !mIsHEVC) {
  *out = mBuffer;
             mBuffer = NULL;
 
  return OK;
  }
 
 
         CHECK(mBuffer->range_length() >= mNALLengthSize);
 
  const uint8_t *src =
  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
 
  size_t nal_size = parseNALSize(src);
  if (mBuffer->range_length() < mNALLengthSize + nal_size) {
             ALOGE(""incomplete NAL unit."");
 
             mBuffer->release();
             mBuffer = NULL;
 
  return ERROR_MALFORMED;
  }
 
  MediaBuffer *clone = mBuffer->clone();
         CHECK(clone != NULL);
         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);
 
         CHECK(mBuffer != NULL);
         mBuffer->set_range(
                 mBuffer->range_offset() + mNALLengthSize + nal_size,
                 mBuffer->range_length() - mNALLengthSize - nal_size);
 
  if (mBuffer->range_length() == 0) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  *out = clone;
 
  return OK;
  } else {
  ssize_t num_bytes_read = 0;
  int32_t drm = 0;
  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
  if (usesDRM) {
             num_bytes_read =
                 mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);
  } else {
             num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);
  }
 
  if (num_bytes_read < (ssize_t)size) {
             mBuffer->release();
             mBuffer = NULL;
 
  return ERROR_IO;
  }
 
  if (usesDRM) {
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
 
  } else {
  uint8_t *dstData = (uint8_t *)mBuffer->data();
  size_t srcOffset = 0;
 
              size_t dstOffset = 0;
  
              while (srcOffset < size) {
                bool isMalFormed = (srcOffset + mNALLengthSize > size);
                 bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);
                  size_t nalLength = 0;
                  if (!isMalFormed) {
                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                      srcOffset += mNALLengthSize;
                    isMalFormed = srcOffset + nalLength > size;
                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);
                  }
  
                  if (isMalFormed) {
                     ALOGE(""Video is malformed"");
                     mBuffer->release();
                     mBuffer = NULL;
  return ERROR_MALFORMED;
  }
 
  if (nalLength == 0) {
  continue;
  }
 
                 CHECK(dstOffset + 4 <= mBuffer->size());
 
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 1;
                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);
                 srcOffset += nalLength;
                 dstOffset += nalLength;
  }
             CHECK_EQ(srcOffset, size);
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, dstOffset);
  }
 
         mBuffer->meta_data()->clear();
         mBuffer->meta_data()->setInt64(
                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
         mBuffer->meta_data()->setInt64(
                 kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
             mBuffer->meta_data()->setInt64(
                     kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
 
  *out = mBuffer;
         mBuffer = NULL;
 
  return OK;
  }
 }","[214, 220, 213, 219]","Multiple buffer overflows in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via invalid size values of NAL units in MP4 data, aka internal bug 19641538."
202089," static int __videobuf_mmap_mapper(struct videobuf_queue *q,
 			 struct vm_area_struct *vma)
 {
 	struct videbuf_vmalloc_memory *mem;
 	struct videobuf_mapping *map;
 	unsigned int first;
 	int retval;
 	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
 
 	if (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))
 		return -EINVAL;
 
 	 
 	for (first = 0; first < VIDEO_MAX_FRAME; first++) {
 		if (NULL == q->bufs[first])
 			continue;
 
 		if (V4L2_MEMORY_MMAP != q->bufs[first]->memory)
 			continue;
 		if (q->bufs[first]->boff == offset)
 			break;
 	}
 	if (VIDEO_MAX_FRAME == first) {
 		dprintk(1,""mmap app bug: offset invalid [offset=0x%lx]\n"",
 			(vma->vm_pgoff << PAGE_SHIFT));
 		return -EINVAL;
  	}
  
  	 
	map = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);
 	map = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);
  	if (NULL == map)
  		return -ENOMEM;
  
 	map->start = vma->vm_start;
 	map->end   = vma->vm_end;
 	map->q     = q;
 
 	q->bufs[first]->baddr = vma->vm_start;
 
 	vma->vm_ops          = &videobuf_vm_ops;
 	vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;
 	vma->vm_private_data = map;
 
 	mem=q->bufs[first]->priv;
 	BUG_ON (!mem);
 	MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);
 
 	 
 	retval=remap_vmalloc_range(vma, mem->vmalloc,0);
 	if (retval<0) {
 		dprintk(1,""mmap: postponing remap_vmalloc_range\n"");
 
 		mem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);
 		if (!mem->vma) {
 			kfree(map);
 			q->bufs[first]->map=NULL;
 			return -ENOMEM;
 		}
 		memcpy(mem->vma,vma,sizeof(*vma));
 	}
 
 	dprintk(1,""mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n"",
 		map,q,vma->vm_start,vma->vm_end,
 		(long int) q->bufs[first]->bsize,
 		vma->vm_pgoff,first);
 
 	videobuf_vm_open(vma);
 
 	return (0);
 }","[31, 30]","drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321."
6167,"bit_write_MC (Bit_Chain *dat, BITCODE_MC val)
{
int i, j;
int negative = 0;
unsigned char byte[5];
BITCODE_UMC mask = 0x0000007f;
BITCODE_UMC value = (BITCODE_UMC)val;

if (val < 0)
{
negative = 1;
value = (BITCODE_UMC)-val;
}
for (i = 4, j = 0; i >= 0; i--, j += 7)
{
byte[i] = (unsigned char)((value & mask) >> j);
byte[i] |= 0x80;
mask = mask << 7;
}
for (i = 0; i < 4; i++)
if (byte[i] & 0x7f)
break;

if (byte[i] & 0x40)
i--;
byte[i] &= 0x7f;
if (negative)
byte[i] |= 0x40;
for (j = 4; j >= i; j--)
bit_write_RC (dat, byte[j]);
}",[24],An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to a heap-based buffer over-read in bit_write_TF in bits.c.
199247," static int key_notify_sa_flush(const struct km_event *c)
 {
 	struct sk_buff *skb;
 	struct sadb_msg *hdr;
 
 	skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
 	if (!skb)
 		return -ENOBUFS;
 	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
 	hdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);
 	hdr->sadb_msg_type = SADB_FLUSH;
 	hdr->sadb_msg_seq = c->seq;
 	hdr->sadb_msg_pid = c->portid;
  	hdr->sadb_msg_version = PF_KEY_V2;
  	hdr->sadb_msg_errno = (uint8_t) 0;
  	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr->sadb_msg_reserved = 0;
  
  	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
  
 	return 0;
 }",[17],"The (1) key_notify_sa_flush and (2) key_notify_policy_flush functions in net/key/af_key.c in the Linux kernel before 3.10 do not initialize certain structure members, which allows local users to obtain sensitive information from kernel heap memory by reading a broadcast message from the notify interface of an IPSec key_socket."
198227," void chain_reply(struct smb_request *req)
 {
 	size_t smblen = smb_len(req->inbuf);
 	size_t already_used, length_needed;
 	uint8_t chain_cmd;
 	uint32_t chain_offset;	 
 
 	uint8_t wct;
 	uint16_t *vwv;
 	uint16_t buflen;
 	uint8_t *buf;
 
 	if (IVAL(req->outbuf, smb_rcls) != 0) {
 		fixup_chain_error_packet(req);
 	}
 
 	 
  
         if ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {
                if (req->chain_outbuf == NULL) {
                        req->chain_outbuf = TALLOC_REALLOC_ARRAY(
                                req, req->outbuf, uint8_t,
                                smb_len(req->outbuf) + 4);
                        if (req->chain_outbuf == NULL) {
                                smb_panic(""talloc failed"");
                        }
                }
                req->outbuf = NULL;
                 goto error;
         }
  
 
 	if (req->chain_outbuf == NULL) {
 		 
 		req->chain_outbuf = TALLOC_REALLOC_ARRAY(
 			req, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);
 		if (req->chain_outbuf == NULL) {
 			goto error;
 		}
 		req->outbuf = NULL;
 	} else {
 		 
 
 	chain_cmd = CVAL(req->vwv+0, 0);
 	chain_offset = SVAL(req->vwv+1, 0);
 
 	if (chain_cmd == 0xff) {
 		 
 		smb_setlen((char *)(req->chain_outbuf),
 			   talloc_get_size(req->chain_outbuf) - 4);
 
 		if (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,
 				  true, req->seqnum+1,
 				  IS_CONN_ENCRYPTED(req->conn)
 				  ||req->encrypted,
 				  &req->pcd)) {
 			exit_server_cleanly(""chain_reply: srv_send_smb ""
 					    ""failed."");
 		}
 		TALLOC_FREE(req->chain_outbuf);
 		req->done = true;
 		return;
 	}
 
 	 
 	SMB_PERFCOUNT_ADD(&req->pcd);
 	SMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);
 	SMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);
 
 	 
 
 	already_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));
 	if (chain_offset < already_used) {
 		goto error;
 	}
 
 	 
 
 	length_needed = chain_offset+1;	 
 	if (length_needed > smblen) {
 		goto error;
 	}
 
 	 
 
 	wct = CVAL(smb_base(req->inbuf), chain_offset);
 
 	 
 
 	length_needed += (wct+1)*sizeof(uint16_t);  
 	if (length_needed > smblen) {
 		goto error;
 	}
 	vwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);
 
 	 
 
 	buflen = SVAL(vwv+wct, 0);
 
 	 
 
 	length_needed += buflen;
 	if (length_needed > smblen) {
 		goto error;
 	}
 	buf = (uint8_t *)(vwv+wct+1);
 
 	req->cmd = chain_cmd;
 	req->wct = wct;
 	req->vwv = vwv;
 	req->buflen = buflen;
 	req->buf = buf;
 
 	switch_message(chain_cmd, req, smblen);
 
 	if (req->outbuf == NULL) {
 		 
 		return;
 	}
 
 	 
 	goto done;
 
  error:
 	 
 	reply_force_doserror(req, ERRSRV, ERRerror);
 	fixup_chain_error_packet(req);
 
  done:
 	 
 	SSVAL(req->chain_outbuf, smb_flg2,
 	      (SVAL(req->chain_outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)
 	      | (SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));
 
 	 
 	SSVAL(req->chain_outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));
 	SSVAL(req->chain_outbuf, smb_err, SVAL(req->outbuf, smb_err));
 
 	if (!smb_splice_chain(&req->chain_outbuf,
 			      CVAL(req->outbuf, smb_com),
 			      CVAL(req->outbuf, smb_wct),
 			      (uint16_t *)(req->outbuf + smb_vwv),
 			      0, smb_buflen(req->outbuf),
 			      (uint8_t *)smb_buf(req->outbuf))) {
 		exit_server_cleanly(""chain_reply: smb_splice_chain failed\n"");
 	}
 	TALLOC_FREE(req->outbuf);
 
 	smb_setlen((char *)(req->chain_outbuf),
 		   talloc_get_size(req->chain_outbuf) - 4);
 
 	show_msg((char *)(req->chain_outbuf));
 
 	if (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,
 			  true, req->seqnum+1,
 			  IS_CONN_ENCRYPTED(req->conn)||req->encrypted,
 			  &req->pcd)) {
 		exit_server_cleanly(""construct_reply: srv_send_smb failed."");
 	}
 	TALLOC_FREE(req->chain_outbuf);
 	req->done = true;
 }","[20, 21, 22, 23, 24, 25, 26, 27, 28]",The chain_reply function in process.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to cause a denial of service (NULL pointer dereference and process crash) via a Negotiate Protocol request with a certain 0x0003 field value followed by a Session Setup AndX request with a certain 0x8003 field value.
198832," raptor_rdfxml_parse_start(raptor_parser* rdf_parser)
 {
   raptor_uri *uri = rdf_parser->base_uri;
   raptor_rdfxml_parser* rdf_xml_parser;
 
   rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;
 
    
   if(!uri)
     return 1;
 
    
   raptor_sax2_set_option(rdf_xml_parser->sax2,
                          RAPTOR_OPTION_NORMALIZE_LANGUAGE, NULL,
                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));
 
    
   raptor_sax2_set_option(rdf_xml_parser->sax2, 
                          RAPTOR_OPTION_NO_NET, NULL,
                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));
    raptor_sax2_set_option(rdf_xml_parser->sax2, 
                           RAPTOR_OPTION_NO_FILE, NULL,
                           RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));
   raptor_sax2_set_option(rdf_xml_parser->sax2, 
                          RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,
                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));
    if(rdf_parser->uri_filter)
      raptor_sax2_set_uri_filter(rdf_xml_parser->sax2, rdf_parser->uri_filter,
                                 rdf_parser->uri_filter_user_data);
 
   raptor_sax2_parse_start(rdf_xml_parser->sax2, uri);
 
    
   if(rdf_xml_parser->id_set) {
     raptor_free_id_set(rdf_xml_parser->id_set);
     rdf_xml_parser->id_set = NULL;
   }
   
    
   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {
     rdf_xml_parser->id_set = raptor_new_id_set(rdf_parser->world);
     if(!rdf_xml_parser->id_set)
       return 1;
   }
   
   return 0;
 }","[24, 25, 26]","Redland Raptor (aka libraptor) before 2.0.7, as used by OpenOffice 3.3 and 3.4 Beta, LibreOffice before 3.4.6 and 3.5.x before 3.5.1, and other products, allows user-assisted remote attackers to read arbitrary files via a crafted XML external entity (XXE) declaration and reference in an RDF document."
200086," static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct tcp_sock *tp;
 	struct sk_buff *opt_skb = NULL;
 
 	 
 
  	if (skb->protocol == htons(ETH_P_IP))
  		return tcp_v4_do_rcv(sk, skb);
  
	if (sk_filter(sk, skb))
 	if (tcp_filter(sk, skb))
  		goto discard;
  
  	 
 
 	 
 	if (np->rxopt.all)
 		opt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));
 
 	if (sk->sk_state == TCP_ESTABLISHED) {  
 		struct dst_entry *dst = sk->sk_rx_dst;
 
 		sock_rps_save_rxhash(sk, skb);
 		sk_mark_napi_id(sk, skb);
 		if (dst) {
 			if (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||
 			    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {
 				dst_release(dst);
 				sk->sk_rx_dst = NULL;
 			}
 		}
 
 		tcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);
 		if (opt_skb)
 			goto ipv6_pktoptions;
 		return 0;
 	}
 
 	if (tcp_checksum_complete(skb))
 		goto csum_err;
 
 	if (sk->sk_state == TCP_LISTEN) {
 		struct sock *nsk = tcp_v6_cookie_check(sk, skb);
 
 		if (!nsk)
 			goto discard;
 
 		if (nsk != sk) {
 			sock_rps_save_rxhash(nsk, skb);
 			sk_mark_napi_id(nsk, skb);
 			if (tcp_child_process(sk, nsk, skb))
 				goto reset;
 			if (opt_skb)
 				__kfree_skb(opt_skb);
 			return 0;
 		}
 	} else
 		sock_rps_save_rxhash(sk, skb);
 
 	if (tcp_rcv_state_process(sk, skb))
 		goto reset;
 	if (opt_skb)
 		goto ipv6_pktoptions;
 	return 0;
 
 reset:
 	tcp_v6_send_reset(sk, skb);
 discard:
 	if (opt_skb)
 		__kfree_skb(opt_skb);
 	kfree_skb(skb);
 	return 0;
 csum_err:
 	TCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);
 	TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);
 	goto discard;
 
 
 ipv6_pktoptions:
 	 
 	tp = tcp_sk(sk);
 	if (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&
 	    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {
 		if (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)
 			np->mcast_oif = tcp_v6_iif(opt_skb);
 		if (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)
 			np->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;
 		if (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)
 			np->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));
 		if (np->repflow)
 			np->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));
 		if (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {
 			skb_set_owner_r(opt_skb, sk);
 			tcp_v6_restore_cb(opt_skb);
 			opt_skb = xchg(&np->pktoptions, opt_skb);
 		} else {
 			__kfree_skb(opt_skb);
 			opt_skb = xchg(&np->pktoptions, NULL);
 		}
 	}
 
 	kfree_skb(opt_skb);
 	return 0;
 }","[13, 12]","The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c."
207471," static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)
 {
  struct ifreq ifr;
  int sk, err;
 
     sk = socket(AF_INET, SOCK_DGRAM, 0);
  if (sk < 0)
  return -1;
 
 
      memset(&ifr, 0, sizeof(ifr));
      strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
    err = ioctl(sk, SIOCGIFHWADDR, &ifr);
     err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCGIFHWADDR, &ifr));
      if (err < 0)
      {
          BTIF_TRACE_ERROR(""Could not get network hardware for interface:%s, errno:%s"", devname, strerror(errno));
         close(sk);
  return -1;
  }
 
     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
     memcpy(ifr.ifr_hwaddr.sa_data, addr->address, 6);
 
   
  if (ifr.ifr_hwaddr.sa_data[0] & 0x01) {
         BTIF_TRACE_WARNING(""Not a unicast MAC address, force multicast bit flipping"");
 
          ifr.ifr_hwaddr.sa_data[0] &= ~0x01;
      }
  
    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);
     err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr));
  
      if (err < 0) {
          BTIF_TRACE_ERROR(""Could not set bt address for interface:%s, errno:%s"", devname, strerror(errno));
         close(sk);
  return -1;
  }
 
     memset(&ifr, 0, sizeof(ifr));
     strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);
 
 
      ifr.ifr_flags |= IFF_UP;
      ifr.ifr_flags |= IFF_MULTICAST;
  
    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);
     err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));
  
  
      if (err < 0) {
         BTIF_TRACE_ERROR(""Could not bring up network interface:%s, errno:%d"", devname, errno);
         close(sk);
  return -1;
  }
     close(sk);
     BTIF_TRACE_DEBUG(""network interface: %s is up"", devname);
  return 0;
 }","[14, 33, 49, 13, 32, 48]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
202229," iasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)
 {
 	struct sc_context *ctx = card->ctx;
 	struct sc_iin *iin = &card->serialnr.iin;
 	struct sc_apdu apdu;
 	unsigned char rbuf[0xC0];
 	size_t ii, offs;
 	int rv;
 
 	LOG_FUNC_CALLED(ctx);
 	if (card->serialnr.len)
 		goto end;
 
 	memset(&card->serialnr, 0, sizeof(card->serialnr));
 
 	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, 0x80 | IASECC_SFI_EF_SN, 0);
 	apdu.le = sizeof(rbuf);
 	apdu.resp = rbuf;
 	apdu.resplen = sizeof(rbuf);
 
 	rv = sc_transmit_apdu(card, &apdu);
 	LOG_TEST_RET(ctx, rv, ""APDU transmit failed"");
 	rv = sc_check_sw(card, apdu.sw1, apdu.sw2);
 	LOG_TEST_RET(ctx, rv, ""Get 'serial number' data failed"");
 
 	if (rbuf[0] != ISO7812_PAN_SN_TAG)
 		LOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, ""serial number parse error"");
 
 	iin->mii = (rbuf[2] >> 4) & 0x0F;
 
 	iin->country = 0;
 	for (ii=5; ii<8; ii++)   {
 		iin->country *= 10;
 		iin->country += (rbuf[ii/2] >> ((ii & 0x01) ? 0 : 4)) & 0x0F;
 	}
 
 	iin->issuer_id = 0;
 	for (ii=8; ii<10; ii++)   {
 		iin->issuer_id *= 10;
 		iin->issuer_id += (rbuf[ii/2] >> (ii & 0x01 ? 0 : 4)) & 0x0F;
 	}
 
 	offs = rbuf[1] > 8 ? rbuf[1] - 8 : 0;
  	if (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {
  		 
  		 
		for (ii=0; ii < rbuf[1] - offs; ii++)
 		for (ii=0; (ii < rbuf[1] - offs) && (ii + offs + 2 < sizeof(rbuf)); ii++)
  			*(card->serialnr.value + ii) = ((rbuf[ii + offs + 1] & 0x0F) << 4)
  				+ ((rbuf[ii + offs + 2] & 0xF0) >> 4) ;
  		card->serialnr.len = ii;
 	}
 	else   {
 		for (ii=0; ii < rbuf[1] - offs; ii++)
 			*(card->serialnr.value + ii) = rbuf[ii + offs + 2];
 		card->serialnr.len = ii;
 	}
 
 	do  {
 		char txt[0x200];
 
 		for (ii=0;ii<card->serialnr.len;ii++)
 			sprintf(txt + ii*2, ""%02X"", *(card->serialnr.value + ii));
 
 		sc_log(ctx, ""serial number '%s'; mii %i; country %i; issuer_id %li"", txt, iin->mii, iin->country, iin->issuer_id);
 	} while(0);
 
 end:
 	if (serial)
 		memcpy(serial, &card->serialnr, sizeof(*serial));
 
 	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
 }","[48, 47]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.
201182,"  void acpi_ns_terminate(void)
  {
  	acpi_status status;
 	union acpi_operand_object *prev;
 	union acpi_operand_object *next;
  
  	ACPI_FUNCTION_TRACE(ns_terminate);
  
#ifdef ACPI_EXEC_APP
	{
		union acpi_operand_object *prev;
		union acpi_operand_object *next;
 	 
  
		 
		next = acpi_gbl_module_code_list;
		while (next) {
			prev = next;
			next = next->method.mutex;
			prev->method.mutex = NULL;	 
			acpi_ut_remove_reference(prev);
		}
 	next = acpi_gbl_module_code_list;
 	while (next) {
 		prev = next;
 		next = next->method.mutex;
 		prev->method.mutex = NULL;	 
 		acpi_ut_remove_reference(prev);
  	}
#endif
  
  	 
 	acpi_ns_delete_namespace_subtree(acpi_gbl_root_node);
 
 	 
 
 	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
 	if (ACPI_FAILURE(status)) {
 		return_VOID;
 	}
 
 	acpi_ns_delete_node(acpi_gbl_root_node);
 	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, ""Namespace freed\n""));
 	return_VOID;
 }","[4, 5, 13, 23, 24, 25, 26, 27, 28, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 22, 30]","The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."
198749," static void _out_verify(conn_t out, nad_t nad) {
     int attr, ns;
     jid_t from, to;
     conn_t in;
     char *rkey;
     int valid;
 
     attr = nad_find_attr(nad, 0, -1, ""from"", NULL);
     if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {
         log_debug(ZONE, ""missing or invalid from on db verify packet"");
         nad_free(nad);
         return;
     }
 
     attr = nad_find_attr(nad, 0, -1, ""to"", NULL);
     if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {
         log_debug(ZONE, ""missing or invalid to on db verify packet"");
         jid_free(from);
         nad_free(nad);
         return;
     }
 
     attr = nad_find_attr(nad, 0, -1, ""id"", NULL);
     if(attr < 0) {
         log_debug(ZONE, ""missing id on db verify packet"");
         jid_free(from);
         jid_free(to);
         nad_free(nad);
         return;
     }
 
      
     in = xhash_getx(out->s2s->in, NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr));
     if(in == NULL) {
         log_debug(ZONE, ""got a verify for incoming conn %.*s, but it doesn't exist, dropping the packet"", NAD_AVAL_L(nad, attr), NAD_AVAL(nad, attr));
         jid_free(from);
         jid_free(to);
         nad_free(nad);
         return;
     }
 
      rkey = s2s_route_key(NULL, to->domain, from->domain);
  
      attr = nad_find_attr(nad, 0, -1, ""type"", ""valid"");
    if(attr >= 0) {
     if(attr >= 0 && xhash_get(in->states, rkey) == (void*) conn_INPROGRESS) {
          xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);
          log_write(in->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] incoming route '%s' is now valid%s%s"", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? "", TLS negotiated"" : """", in->s->compressed ? "", ZLIB compression enabled"" : """");
          valid = 1;
     } else {
         log_write(in->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] incoming route '%s' is now invalid"", in->fd->fd, in->ip, in->port, rkey);
         valid = 0;
     }
 
     free(rkey);
 
     nad_free(nad);
 
      
     --out->verify;
 
      
     nad = nad_new();
 
     ns = nad_add_namespace(nad, uri_DIALBACK, ""db"");
     nad_append_elem(nad, ns, ""result"", 0);
     nad_append_attr(nad, -1, ""to"", from->domain);
     nad_append_attr(nad, -1, ""from"", to->domain);
     nad_append_attr(nad, -1, ""type"", valid ? ""valid"" : ""invalid"");
 
      
     sx_nad_write(in->s, nad);
 
      
     if (!valid) {
          
         sx_error(in->s, stream_err_INVALID_ID, ""dialback negotiation failed"");
 
          
         sx_close(in->s);
     }
 
     jid_free(from);
     jid_free(to);
 }","[46, 45]","s2s/out.c in jabberd2 2.2.16 and earlier does not verify that a request was made for an XMPP Server Dialback response, which allows remote XMPP servers to spoof domains via a (1) Verify Response or (2) Authorization Response."
208063," WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,
                          WORD32 i4_poc,
  pocstruct_t *ps_temp_poc,
                          UWORD16 u2_frame_num,
  dec_pic_params_t *ps_pps)
 {
  pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;
  pocstruct_t *ps_cur_poc = ps_temp_poc;
 
  pic_buffer_t *pic_buf;
 
  ivd_video_decode_op_t * ps_dec_output =
  (ivd_video_decode_op_t *)ps_dec->pv_dec_out;
  dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
  dec_seq_params_t *ps_seq = ps_pps->ps_sps;
     UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;
     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
   
  high_profile_tools_t s_high_profile;
     WORD32 ret;
 
     H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);
 
     ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
     ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
     ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                     ps_cur_poc->i4_delta_pic_order_cnt_bottom;
     ps_prev_poc->i4_delta_pic_order_cnt[0] =
                     ps_cur_poc->i4_delta_pic_order_cnt[0];
     ps_prev_poc->i4_delta_pic_order_cnt[1] =
                     ps_cur_poc->i4_delta_pic_order_cnt[1];
     ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;
     ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
     ps_prev_poc->u2_frame_num = u2_frame_num;
     ps_dec->i1_prev_mb_qp_delta = 0;
     ps_dec->i1_next_ctxt_idx = 0;
 
 
     ps_dec->u4_nmb_deblk = 0;
  if(ps_dec->u4_num_cores == 1)
        ps_dec->u4_nmb_deblk = 1;
 
 
 
  if(ps_seq->u1_mb_aff_flag == 1)
  {
         ps_dec->u4_nmb_deblk = 0;
  if(ps_dec->u4_num_cores > 2)
             ps_dec->u4_num_cores = 2;
  }
 
         ps_dec->u4_use_intrapred_line_copy = 0;
 
 
 
  if (ps_seq->u1_mb_aff_flag == 0)
  {
         ps_dec->u4_use_intrapred_line_copy = 1;
  }
 
     ps_dec->u4_app_disable_deblk_frm = 0;
   
  if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)
  {
         WORD32 degrade_pic;
         ps_dec->i4_degrade_pic_cnt++;
         degrade_pic = 0;
 
   
  switch(ps_dec->i4_degrade_pics)
  {
  case 4:
  {
                 degrade_pic = 1;
  break;
  }
  case 3:
  {
  if(ps_cur_slice->u1_slice_type != I_SLICE)
                     degrade_pic = 1;
 
  break;
  }
  case 2:
  {
 
   
  if((ps_cur_slice->u1_slice_type != I_SLICE)
  && (ps_dec->i4_degrade_pic_cnt
  != ps_dec->i4_nondegrade_interval))
                     degrade_pic = 1;
 
  break;
  }
  case 1:
  {
   
  if(0 == ps_cur_slice->u1_nal_ref_idc)
  {
                     degrade_pic = 1;
  }
  break;
  }
 
  }
  if(degrade_pic)
  {
  if(ps_dec->i4_degrade_type & 0x2)
                 ps_dec->u4_app_disable_deblk_frm = 1;
 
   
  if(0 == ps_cur_slice->u1_nal_ref_idc)
  {
  if(ps_dec->i4_degrade_type & 0x4)
                     ps_dec->i4_mv_frac_mask = 0;
 
  if(ps_dec->i4_degrade_type & 0x8)
                     ps_dec->i4_mv_frac_mask = 0;
  }
  }
  else
             ps_dec->i4_degrade_pic_cnt = 0;
  }
 
  {
  dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
  if(ps_dec->u1_sl_typ_5_9
  && ((ps_cur_slice->u1_slice_type == I_SLICE)
  || (ps_cur_slice->u1_slice_type
  == SI_SLICE)))
             ps_err->u1_cur_pic_type = PIC_TYPE_I;
  else
             ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
 
  if(ps_err->u1_pic_aud_i == PIC_TYPE_I)
  {
             ps_err->u1_cur_pic_type = PIC_TYPE_I;
             ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
  }
 
  if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
  {
  if(ps_err->u1_err_flag)
                 ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
  }
  }
 
  if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)
  {
   
         WORD32 j;
  for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
  {
 
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                   j,
                                   BUF_MGR_REF);
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                   ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                   BUF_MGR_REF);
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                   j,
                                   BUF_MGR_IO);
  }
 
   
         ps_dec->u1_second_field = 0;
         ps_dec->i4_cur_display_seq = 0;
 
   
   
   
   
 
         ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
  }
     ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);
  if(ret != OK)
  return ret;
 
     ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;
     ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;
     ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;
  if(ps_dec->u1_separate_parse)
  {
         UWORD16 pic_wd = ps_dec->u4_width_at_init;
         UWORD16 pic_ht = ps_dec->u4_height_at_init;
         UWORD32 num_mbs;
 
  if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
  {
             pic_wd = ps_dec->u2_pic_wd;
             pic_ht = ps_dec->u2_pic_ht;
  }
         num_mbs = (pic_wd * pic_ht) >> 8;
 
  if(ps_dec->pu1_dec_mb_map)
  {
             memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);
  }
 
  if(ps_dec->pu1_recon_mb_map)
  {
 
             memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);
  }
 
  if(ps_dec->pu2_slice_num_map)
  {
             memset((void *)ps_dec->pu2_slice_num_map, 0,
  (num_mbs * sizeof(UWORD16)));
  }
 
  }
 
     ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->u2_cur_slice_num = 0;
 
   
     ps_dec->s_high_profile.u1_scaling_present = 0;
     ps_dec->s_high_profile.u1_transform8x8_present = 0;
 
   
  if(1 == ps_dec->u4_share_disp_buf)
  {
         UWORD32 i;
   
  for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
  {
  if(0 == ps_dec->u4_disp_buf_to_be_freed[i])
  continue;
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,
             BUF_MGR_IO);
             ps_dec->u4_disp_buf_to_be_freed[i] = 0;
             ps_dec->u4_disp_buf_mapping[i] = 0;
 
  }
  }
  if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))  
  {
  pic_buffer_t *ps_cur_pic;
         WORD32 cur_pic_buf_id, cur_mv_buf_id;
  col_mv_buf_t *ps_col_mv;
  while(1)
  {
             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
  &cur_pic_buf_id);
  if(ps_cur_pic == NULL)
  {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
  return ERROR_UNAVAIL_PICBUF_T;
  }
  if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])
  {
  break;
  }
 
  }
         ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
  &cur_mv_buf_id);
  if(ps_col_mv == NULL)
  {
             ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
  return ERROR_UNAVAIL_MVBUF_T;
  }
 
         ps_dec->ps_cur_pic = ps_cur_pic;
         ps_dec->u1_pic_buf_id = cur_pic_buf_id;
         ps_cur_pic->u4_ts = ps_dec->u4_ts;
 
 
         ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
         ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
 
         ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
         ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
         ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
 
  {
   
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
  *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;
   
  *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;
  }
 
  if(!ps_dec->ps_cur_pic)
  {
             WORD32 j;
             H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n"");
  for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
  {
 
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                       j,
                                       BUF_MGR_REF);
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                       ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                       BUF_MGR_REF);
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                       j,
                                       BUF_MGR_IO);
  }
 
             ps_dec->i4_cur_display_seq = 0;
             ps_dec->i4_prev_max_display_seq = 0;
             ps_dec->i4_max_poc = 0;
 
             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
  &cur_pic_buf_id);
  if(ps_cur_pic == NULL)
  {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
  return ERROR_UNAVAIL_PICBUF_T;
  }
 
             ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
  &cur_mv_buf_id);
  if(ps_col_mv == NULL)
  {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
  return ERROR_UNAVAIL_MVBUF_T;
  }
 
             ps_dec->ps_cur_pic = ps_cur_pic;
             ps_dec->u1_pic_buf_id = cur_pic_buf_id;
             ps_cur_pic->u4_ts = ps_dec->u4_ts;
             ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;
 
             ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
             ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
 
             ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
             ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
             ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
 
  }
 
         ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;
         ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;
         H264_DEC_DEBUG_PRINT(""got a buffer\n"");
  }
  else
  {
         H264_DEC_DEBUG_PRINT(""did not get a buffer\n"");
  }
 
     ps_dec->u4_pic_buf_got = 1;
 
     ps_dec->ps_cur_pic->i4_poc = i4_poc;
     ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;
     ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;
     ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;
     ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =
                     ps_pps->i4_bottom_field_order_cnt;
     ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;
     ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;
 
     ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);
  if(u1_field_pic_flag && u1_bottom_field_flag)
  {
         WORD32 i4_temp_poc;
         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
   
         ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;
         ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;
         ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;
         ps_dec->s_cur_pic.ps_mv +=
  ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);
         ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht
  * ps_dec->u2_pic_wd) >> 5);
         ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;
         i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         i4_temp_poc = MIN(i4_top_field_order_poc,
                                  i4_bot_field_order_poc);
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
  }
 
     ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
  && (!u1_field_pic_flag);
 
     ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag
  << 2);
 
     ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;  
     ps_dec->ps_cur_mb_row++;  
     ps_dec->ps_top_mb_row =
                     ps_dec->ps_nbr_mb_row
  + ((ps_dec->u2_frm_wd_in_mbs + 1)
  << (1
  - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));
     ps_dec->ps_top_mb_row++;  
 
     ps_dec->pu1_y = ps_dec->pu1_y_scratch[0];
     ps_dec->pu1_u = ps_dec->pu1_u_scratch[0];
     ps_dec->pu1_v = ps_dec->pu1_v_scratch[0];
     ps_dec->u1_yuv_scratch_idx = 0;
   
     ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
     ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];
   
     ps_dec->u1_mv_top_p = 0;
     ps_dec->u1_mb_idx = 0;
   
     ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;
     ps_dec->pu1_yleft = 0;
     ps_dec->pu1_uleft = 0;
     ps_dec->pu1_vleft = 0;
     ps_dec->u1_not_wait_rec = 2;
     ps_dec->u2_total_mbs_coded = 0;
     ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);
     ps_dec->u4_pred_info_idx = 0;
     ps_dec->u4_pred_info_pkd_idx = 0;
     ps_dec->u4_dma_buf_idx = 0;
     ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;
     ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;
     ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;
     ps_dec->ps_part = ps_dec->ps_parse_part_params;
     ps_dec->i2_prev_slice_mbx = -1;
     ps_dec->i2_prev_slice_mby = 0;
     ps_dec->u2_mv_2mb[0] = 0;
     ps_dec->u2_mv_2mb[1] = 0;
     ps_dec->u1_last_pic_not_decoded = 0;
 
     ps_dec->u2_cur_slice_num_dec_thread = 0;
     ps_dec->u2_cur_slice_num_bs = 0;
     ps_dec->u4_intra_pred_line_ofst = 0;
     ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;
     ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;
     ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;
 
     ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;
     ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;
     ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;
 
 
 
 
 
     ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line
  + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);
 
     ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line
  + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;
     ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line
  + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;
 
     ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
     ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn;
     ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp;
   
  {
  if(ps_cur_slice->u1_mbaff_frame_flag)
  {
             ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;
             ps_dec->pf_mvpred = ih264d_mvpred_mbaff;
  }
  else
  {
             ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;
             ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;
  }
  }
   
  {
         UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
         UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;
 
         UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)
  % (ps_dec->u1_recon_mb_grp >> u1_mbaff));
         UWORD16 ui16_lastmbs_widthY =
  (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp
  >> u1_mbaff) << 4));
         UWORD16 ui16_lastmbs_widthUV =
                         uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp
  >> u1_mbaff) << 3);
 
         ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
         ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
         ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
 
         ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y
  << u1_field_pic_flag;
         ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv
  << u1_field_pic_flag;
 
  if(u1_field_pic_flag)
  {
             ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;
             ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;
  }
 
   
         ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)
  >> u1_mbaff);
         ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)
  >> u1_mbaff);
 
   
         ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY
  + (PAD_LEN_Y_H << 1)
  + ps_dec->s_tran_addrecon.u2_frm_wd_y
  * ((15 << u1_mbaff) + u1_mbaff));
         ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV
  + (PAD_LEN_UV_H << 2)
  + ps_dec->s_tran_addrecon.u2_frm_wd_uv
  * ((15 << u1_mbaff) + u1_mbaff));
 
   
   
         ih264d_assign_pic_num(ps_dec);
         ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp
  << 2) - 1 - (u1_mbaff << 2);
         ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp
  >> u1_mbaff) - 1) << (4 + u1_mbaff);
  }
   
   
   
  if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)
  {
  if((ps_seq->i4_seq_scaling_matrix_present_flag)
  || (ps_pps->i4_pic_scaling_matrix_present_flag))
  {
             ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);
             ps_dec->s_high_profile.u1_scaling_present = 1;
  }
  else
  {
             ih264d_form_default_scaling_matrix(ps_dec);
  }
 
  if(ps_pps->i4_transform_8x8_mode_flag)
  {
             ps_dec->s_high_profile.u1_transform8x8_present = 1;
  }
  }
  else
  {
         ih264d_form_default_scaling_matrix(ps_dec);
  }
 
   
     ps_dec->s_high_profile.u1_direct_8x8_inference_flag =
                     ps_seq->u1_direct_8x8_inference_flag;
     ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;
 
     ps_dec->i1_recon_in_thread3_flag = 1;
     ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;
  if(ps_dec->u1_separate_parse)
  {
         memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,
  sizeof(tfr_ctxt_t));
  if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)
  {
             memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,
  sizeof(tfr_ctxt_t));
             ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;
  }
  }
 
 
     ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),
                                ps_dec->u2_frm_wd_in_mbs, 0);
 
     ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;
     ps_dec->u4_cur_deblk_mb_num = 0;
 
     ps_dec->u4_deblk_mb_x = 0;
 
      ps_dec->u4_deblk_mb_y = 0;
      ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
  
     ps_dec->u4_first_slice_in_pic = 0;
      H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
      return OK;
  }",[581],"An information disclosure vulnerability in libavc in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33551775."
10045,"Status ImportNodes(ValueMapManager value_manager,
const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {
Location unknown_loc = builder.getUnknownLoc();
MLIRContext* context = builder.getContext();

Type placeholder_ty = OpaqueTensorType::get(context);
Type control_ty = ControlType::get(context);
TFGraphDialect* tfgDialect =
cast<TFGraphDialect>(context->getLoadedDialect(""tfg""));
StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();
StringAttr name_attr = tfgDialect->getNameAttrIdentifier();
StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();

for (const NodeDef& node : nodes) {
DVLOG(1) << ""Processing node "" << node.name() << ""\n"";
if (node.op().empty()) return InvalidArgument(""empty op type"");
OperationState state(unknown_loc, absl::StrCat(""tfg."", node.op()));

for (const std::string& input : node.input())
state.operands.push_back(
value_manager.GetValueOrCreatePlaceholder(input));


state.types.push_back(placeholder_ty);
state.types.push_back(control_ty);

for (const auto& namedAttr : node.attr()) {
const std::string& name = namedAttr.first;
const AttrValue& tf_attr = namedAttr.second;
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(tf_attr, builder, tfgDialect));
state.addAttribute(name, attr);
}
if (!node.device().empty())
state.addAttribute(device_attr, StringAttr::get(context, node.device()));
if (!node.name().empty())
state.addAttribute(name_attr, StringAttr::get(context, node.name()));
if (node.has_experimental_type()) {
TF_ASSIGN_OR_RETURN(
tf_type::FullTypeAttr type,
ConvertAttribute(node.experimental_type(), builder, tfgDialect));
state.addAttribute(fulltype_attr, type);
}

Operation* op = builder.create(state);

StringRef node_name = node.name();
{
size_t colon_sep = node_name.find_first_of(':');
if (colon_sep != StringRef::npos)
node_name = node_name.take_front(colon_sep);
}
TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));
}

for (Operation& op : *builder.getInsertionBlock()) {
if (op.getName().getStringRef() == ""tfg.__mlir_placeholder"") {
return InvalidArgument(absl::StrCat(
""Couldn't import graph: placeholder left "",
op.getAttrOfType<StringAttr>(name_attr).getValue().str()));
}
}
return Status::OK();
}","[19, 24]","TensorFlow is an open source platform for machine learning. When `mlir::tfg::ConvertGenericFunctionToFunctionDef` is given empty function attributes, it crashes. We have patched the issue in GitHub commit ad069af92392efee1418c48ff561fd3070a03d7b. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
3739,"static int rename_in_ns(int pid, char *oldname, char **newnamep)
{
int fd = -1, ofd = -1, ret, ifindex = -1;
bool grab_newname = false;

ofd = lxc_preserve_ns(getpid(), ""net"");
if (ofd < 0) {
fprintf(stderr, ""Failed opening network namespace path for '%d'."", getpid());
return -1;
}

fd = lxc_preserve_ns(pid, ""net"");
if (fd < 0) {
fprintf(stderr, ""Failed opening network namespace path for '%d'."", pid);
return -1;
}

if (setns(fd, 0) < 0) {
fprintf(stderr, ""setns to container network namespace\n"");
goto out_err;
}
close(fd); fd = -1;
if (!*newnamep) {
grab_newname = true;
*newnamep = VETH_DEF_NAME;
if (!(ifindex = if_nametoindex(oldname))) {
fprintf(stderr, ""failed to get netdev index\n"");
goto out_err;
}
}
if ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {
fprintf(stderr, ""Error %d renaming netdev %s to %s in container\n"", ret, oldname, *newnamep);
goto out_err;
}
if (grab_newname) {
char ifname[IFNAMSIZ], *namep = ifname;
if (!if_indextoname(ifindex, namep)) {
fprintf(stderr, ""Failed to get new netdev name\n"");
goto out_err;
}
*newnamep = strdup(namep);
if (!*newnamep)
goto out_err;
}
if (setns(ofd, 0) < 0) {
fprintf(stderr, ""Error returning to original netns\n"");
close(ofd);
return -1;
}
close(ofd);

return 0;

out_err:
if (ofd >= 0)
close(ofd);
if (setns(ofd, 0) < 0)
fprintf(stderr, ""Error returning to original network namespace\n"");
if (fd >= 0)
close(fd);
return -1;
}","[3, 8, 9, 14, 15, 18, 19, 20, 22, 26, 27, 28, 31, 32, 33, 35, 36, 38, 39, 41, 43, 45, 46, 47, 48, 50, 52, 54, 55, 56, 57, 58, 61]",lxc-user-nic in Linux Containers (LXC) allows local users with a lxc-usernet allocation to create network interfaces on the host and choose the name of those interfaces by leveraging lack of netns ownership check.
1307,"static int snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace)
{
struct snd_card *card = file->card;
struct snd_kcontrol kctl, *_kctl;
unsigned int access;
long private_size;
struct user_element *ue;
int idx, err;

if (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)
return -ENOMEM;
if (info->count < 1)
return -EINVAL;
access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|
SNDRV_CTL_ELEM_ACCESS_INACTIVE|
SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
info->id.numid = 0;
memset(&kctl, 0, sizeof(kctl));
down_write(&card->controls_rwsem);
_kctl = snd_ctl_find_id(card, &info->id);
err = 0;
if (_kctl) {
if (replace)
err = snd_ctl_remove(card, _kctl);
else
err = -EBUSY;
} else {
if (replace)
err = -ENOENT;
}
up_write(&card->controls_rwsem);
if (err < 0)
return err;
memcpy(&kctl.id, &info->id, sizeof(info->id));
kctl.count = info->owner ? info->owner : 1;
access |= SNDRV_CTL_ELEM_ACCESS_USER;
if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)
kctl.info = snd_ctl_elem_user_enum_info;
else
kctl.info = snd_ctl_elem_user_info;
if (access & SNDRV_CTL_ELEM_ACCESS_READ)
kctl.get = snd_ctl_elem_user_get;
if (access & SNDRV_CTL_ELEM_ACCESS_WRITE)
kctl.put = snd_ctl_elem_user_put;
if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {
kctl.tlv.c = snd_ctl_elem_user_tlv;
access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;
}
switch (info->type) {
case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
case SNDRV_CTL_ELEM_TYPE_INTEGER:
private_size = sizeof(long);
if (info->count > 128)
return -EINVAL;
break;
case SNDRV_CTL_ELEM_TYPE_INTEGER64:
private_size = sizeof(long long);
if (info->count > 64)
return -EINVAL;
break;
case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
private_size = sizeof(unsigned int);
if (info->count > 128 || info->value.enumerated.items == 0)
return -EINVAL;
break;
case SNDRV_CTL_ELEM_TYPE_BYTES:
private_size = sizeof(unsigned char);
if (info->count > 512)
return -EINVAL;
break;
case SNDRV_CTL_ELEM_TYPE_IEC958:
private_size = sizeof(struct snd_aes_iec958);
if (info->count != 1)
return -EINVAL;
break;
default:
return -EINVAL;
}
private_size *= info->count;
ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);
if (ue == NULL)
return -ENOMEM;
ue->card = card;
ue->info = *info;
ue->info.access = 0;
ue->elem_data = (char *)ue + sizeof(*ue);
ue->elem_data_size = private_size;
if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
err = snd_ctl_elem_init_enum_names(ue);
if (err < 0) {
kfree(ue);
return err;
}
}
kctl.private_free = snd_ctl_elem_user_free;
_kctl = snd_ctl_new(&kctl, access);
if (_kctl == NULL) {
kfree(ue->priv_data);
kfree(ue);
return -ENOMEM;
}
_kctl->private_data = ue;
for (idx = 0; idx < _kctl->count; idx++)
_kctl->vd[idx].owner = file;
err = snd_ctl_add(card, _kctl);
if (err < 0)
return err;

down_write(&card->controls_rwsem);
card->user_ctl_count++;
up_write(&card->controls_rwsem);

return 0;
}","[11, 12, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35]","The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not check authorization for SNDRV_CTL_IOCTL_ELEM_REPLACE commands, which allows local users to remove kernel controls and cause a denial of service (use-after-free and system crash) by leveraging /dev/snd/controlCX access for an ioctl call."
207064,"  void PaymentRequest::CanMakePayment() {
   if (!IsInitialized()) {
     log_.Error(""Attempted canMakePayment without initialization"");
     OnConnectionTerminated();
     return;
   }
 
    
 
    if (observer_for_testing_)
      observer_for_testing_->OnCanMakePaymentCalled();
  
   if (!delegate_->GetPrefService()->GetBoolean(kCanMakePaymentEnabled) ||
       !state_) {
     CanMakePaymentCallback( false);
   } else {
     state_->CanMakePayment(
         base::BindOnce(&PaymentRequest::CanMakePaymentCallback,
                        weak_ptr_factory_.GetWeakPtr()));
    }
  }","[2, 3, 4, 5, 6, 7, 8, 9]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
207802," OMX_ERRORTYPE  omx_video::free_buffer(OMX_IN OMX_HANDLETYPE         hComp,
         OMX_IN OMX_U32                 port,
         OMX_IN OMX_BUFFERHEADERTYPE* buffer)
 {
  (void)hComp;
     OMX_ERRORTYPE eRet = OMX_ErrorNone;
  unsigned int nPortIndex;
 
     DEBUG_PRINT_LOW(""In for encoder free_buffer"");
 
  if (m_state == OMX_StateIdle &&
  (BITMASK_PRESENT(&m_flags ,OMX_COMPONENT_LOADING_PENDING))) {
         DEBUG_PRINT_LOW("" free buffer while Component in Loading pending"");
  } else if ((m_sInPortDef.bEnabled == OMX_FALSE && port == PORT_INDEX_IN)||
  (m_sOutPortDef.bEnabled == OMX_FALSE && port == PORT_INDEX_OUT)) {
         DEBUG_PRINT_LOW(""Free Buffer while port %u disabled"", (unsigned int)port);
  } else if (m_state == OMX_StateExecuting || m_state == OMX_StatePause) {
         DEBUG_PRINT_ERROR(""ERROR: Invalid state to free buffer,ports need to be disabled"");
         post_event(OMX_EventError,
                 OMX_ErrorPortUnpopulated,
                 OMX_COMPONENT_GENERATE_EVENT);
  return eRet;
  } else {
         DEBUG_PRINT_ERROR(""ERROR: Invalid state to free buffer,port lost Buffers"");
         post_event(OMX_EventError,
                 OMX_ErrorPortUnpopulated,
                 OMX_COMPONENT_GENERATE_EVENT);
  }
 
  if (port == PORT_INDEX_IN) {
         nPortIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);
 
  
          DEBUG_PRINT_LOW(""free_buffer on i/p port - Port idx %u, actual cnt %u"",
                  nPortIndex, (unsigned int)m_sInPortDef.nBufferCountActual);
        if (nPortIndex < m_sInPortDef.nBufferCountActual) {
         if (nPortIndex < m_sInPortDef.nBufferCountActual &&
                 BITMASK_PRESENT(&m_inp_bm_count, nPortIndex)) {
              BITMASK_CLEAR(&m_inp_bm_count,nPortIndex);
              free_input_buffer (buffer);
             m_sInPortDef.bPopulated = OMX_FALSE;
 
   
  if (release_input_done()
 #ifdef _ANDROID_ICS_
  && !meta_mode_enable
 #endif
  ) {
                 input_use_buffer = false;
  if (m_inp_mem_ptr) {
                     DEBUG_PRINT_LOW(""Freeing m_inp_mem_ptr"");
                     free (m_inp_mem_ptr);
                     m_inp_mem_ptr = NULL;
  }
  if (m_pInput_pmem) {
                     DEBUG_PRINT_LOW(""Freeing m_pInput_pmem"");
                     free(m_pInput_pmem);
                     m_pInput_pmem = NULL;
  }
 #ifdef USE_ION
  if (m_pInput_ion) {
                     DEBUG_PRINT_LOW(""Freeing m_pInput_ion"");
                     free(m_pInput_ion);
                     m_pInput_ion = NULL;
  }
 #endif
  }
  } else {
             DEBUG_PRINT_ERROR(""ERROR: free_buffer ,Port Index Invalid"");
             eRet = OMX_ErrorBadPortIndex;
  }
 
  if (BITMASK_PRESENT((&m_flags),OMX_COMPONENT_INPUT_DISABLE_PENDING)
  && release_input_done()) {
             DEBUG_PRINT_LOW(""MOVING TO DISABLED STATE"");
             BITMASK_CLEAR((&m_flags),OMX_COMPONENT_INPUT_DISABLE_PENDING);
             post_event(OMX_CommandPortDisable,
                     PORT_INDEX_IN,
                     OMX_COMPONENT_GENERATE_EVENT);
  }
  } else if (port == PORT_INDEX_OUT) {
         nPortIndex = buffer - (OMX_BUFFERHEADERTYPE*)m_out_mem_ptr;
 
  
          DEBUG_PRINT_LOW(""free_buffer on o/p port - Port idx %u, actual cnt %u"",
                  nPortIndex, (unsigned int)m_sOutPortDef.nBufferCountActual);
        if (nPortIndex < m_sOutPortDef.nBufferCountActual) {
         if (nPortIndex < m_sOutPortDef.nBufferCountActual &&
                 BITMASK_PRESENT(&m_out_bm_count, nPortIndex)) {
              BITMASK_CLEAR(&m_out_bm_count,nPortIndex);
              m_sOutPortDef.bPopulated = OMX_FALSE;
             free_output_buffer (buffer);
 
  if (release_output_done()) {
                 output_use_buffer = false;
  if (m_out_mem_ptr) {
                     DEBUG_PRINT_LOW(""Freeing m_out_mem_ptr"");
                     free (m_out_mem_ptr);
                     m_out_mem_ptr = NULL;
  }
  if (m_pOutput_pmem) {
                     DEBUG_PRINT_LOW(""Freeing m_pOutput_pmem"");
                     free(m_pOutput_pmem);
                     m_pOutput_pmem = NULL;
  }
 #ifdef USE_ION
  if (m_pOutput_ion) {
                     DEBUG_PRINT_LOW(""Freeing m_pOutput_ion"");
                     free(m_pOutput_ion);
                     m_pOutput_ion = NULL;
  }
 #endif
  }
  } else {
             DEBUG_PRINT_ERROR(""ERROR: free_buffer , Port Index Invalid"");
             eRet = OMX_ErrorBadPortIndex;
  }
  if (BITMASK_PRESENT((&m_flags),OMX_COMPONENT_OUTPUT_DISABLE_PENDING)
  && release_output_done() ) {
             DEBUG_PRINT_LOW(""FreeBuffer : If any Disable event pending,post it"");
 
             DEBUG_PRINT_LOW(""MOVING TO DISABLED STATE"");
             BITMASK_CLEAR((&m_flags),OMX_COMPONENT_OUTPUT_DISABLE_PENDING);
             post_event(OMX_CommandPortDisable,
                     PORT_INDEX_OUT,
                     OMX_COMPONENT_GENERATE_EVENT);
 
  }
  } else {
         eRet = OMX_ErrorBadPortIndex;
  }
  if ((eRet == OMX_ErrorNone) &&
  (BITMASK_PRESENT(&m_flags ,OMX_COMPONENT_LOADING_PENDING))) {
  if (release_done()) {
  if (dev_stop() != 0) {
                 DEBUG_PRINT_ERROR(""ERROR: dev_stop() FAILED"");
                 eRet = OMX_ErrorHardware;
  }
             BITMASK_CLEAR((&m_flags),OMX_COMPONENT_LOADING_PENDING);
             post_event(OMX_CommandStateSet, OMX_StateLoaded,
                     OMX_COMPONENT_GENERATE_EVENT);
  } else {
             DEBUG_PRINT_HIGH(""in free buffer, release not done, need to free more buffers input %"" PRIx64"" output %"" PRIx64,
                     m_out_bm_count, m_inp_bm_count);
  }
  }
 
  return eRet;
 }","[37, 38, 88, 89, 36, 87]","The mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 mishandles a buffer count, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27662502."
206922,"  bool XmlReader::LoadFile(const std::string& file_path) {
    const int kParseOptions = XML_PARSE_RECOVER |   
                            XML_PARSE_NONET |     
                            XML_PARSE_NOXXE;      
                             XML_PARSE_NONET;      
    reader_ = xmlReaderForFile(file_path.c_str(), NULL, kParseOptions);
    return reader_ != NULL;
  }","[5, 3, 4]","An integer overflow in xmlmemory.c in libxml2 before 2.9.5, as used in Google Chrome prior to 62.0.3202.62 and other products, allowed a remote attacker to potentially exploit heap corruption via a crafted XML file."
199269," int create_user_ns(struct cred *new)
 {
 	struct user_namespace *ns, *parent_ns = new->user_ns;
 	kuid_t owner = new->euid;
  	kgid_t group = new->egid;
  	int ret;
  
 	 
 	if (current_chrooted())
 		return -EPERM;
 
  	 
 	if (!kuid_has_mapping(parent_ns, owner) ||
 	    !kgid_has_mapping(parent_ns, group))
 		return -EPERM;
 
 	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
 	if (!ns)
 		return -ENOMEM;
 
 	ret = proc_alloc_inum(&ns->proc_inum);
 	if (ret) {
 		kmem_cache_free(user_ns_cachep, ns);
 		return ret;
 	}
 
 	atomic_set(&ns->count, 1);
 	 
 	ns->parent = parent_ns;
 	ns->owner = owner;
 	ns->group = group;
 
 	set_cred_user_ns(new, ns);
 
 	return 0;
 }","[8, 9, 10, 11]","The create_user_ns function in kernel/user_namespace.c in the Linux kernel before 3.8.6 does not check whether a chroot directory exists that differs from the namespace root directory, which allows local users to bypass intended filesystem restrictions via a crafted clone system call."
7347,"zfs_fuid_create(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr,
zfs_fuid_type_t type, zfs_fuid_info_t **fuidpp)
{
#ifdef HAVE_KSID
const char *domain;
char *kdomain;
uint32_t fuid_idx = FUID_INDEX(id);
uint32_t rid;
idmap_stat status;
uint64_t idx = 0;
zfs_fuid_t *zfuid = NULL;
zfs_fuid_info_t *fuidp = NULL;









if (!zfsvfs->z_use_fuids || !IS_EPHEMERAL(id) || fuid_idx != 0)
return (id);

if (zfsvfs->z_replay) {
fuidp = zfsvfs->z_fuid_replay;







if (fuidp == NULL)
return (UID_NOBODY);

VERIFY3U(type, >=, ZFS_OWNER);
VERIFY3U(type, <=, ZFS_ACE_GROUP);

switch (type) {
case ZFS_ACE_USER:
case ZFS_ACE_GROUP:
zfuid = list_head(&fuidp->z_fuids);
rid = FUID_RID(zfuid->z_logfuid);
idx = FUID_INDEX(zfuid->z_logfuid);
break;
case ZFS_OWNER:
rid = FUID_RID(fuidp->z_fuid_owner);
idx = FUID_INDEX(fuidp->z_fuid_owner);
break;
case ZFS_GROUP:
rid = FUID_RID(fuidp->z_fuid_group);
idx = FUID_INDEX(fuidp->z_fuid_group);
break;
};
domain = fuidp->z_domain_table[idx - 1];
} else {
if (type == ZFS_OWNER || type == ZFS_ACE_USER)
status = kidmap_getsidbyuid(crgetzone(cr), id,
&domain, &rid);
else
status = kidmap_getsidbygid(crgetzone(cr), id,
&domain, &rid);

if (status != 0) {





rid = UID_NOBODY;
domain = nulldomain;
}
}

idx = zfs_fuid_find_by_domain(zfsvfs, domain, &kdomain, B_TRUE);

if (!zfsvfs->z_replay)
zfs_fuid_node_add(fuidpp, kdomain,
rid, idx, id, type);
else if (zfuid != NULL) {
list_remove(&fuidp->z_fuids, zfuid);
kmem_free(zfuid, sizeof (zfs_fuid_t));
}
return (FUID_ENCODE(idx, rid));
#else



return (id);
#endif
}","[8, 10]","OpenZFS before 2.0.0-rc1, when used on FreeBSD, allows execute permissions for all directories."
205755,"  void PrintWebViewHelper::OnPrintingDone(bool success) {
   CHECK_LE(ipc_nesting_level_, 1);
    notify_browser_of_print_failure_ = false;
    if (!success)
      LOG(ERROR) << ""Failure in OnPrintingDone"";
   DidFinishPrinting(success ? OK : FAIL_PRINT);
 }",[2],"Multiple use-after-free vulnerabilities in the PrintWebViewHelper class in components/printing/renderer/print_web_view_helper.cc in Google Chrome before 45.0.2454.85 allow user-assisted remote attackers to cause a denial of service or possibly have unspecified other impact by triggering nested IPC messages during preparation for printing, as demonstrated by messages associated with PDF documents in conjunction with messages about printer capabilities."
592,"static PyObject* get_value(PyObject* self, const char* buffer, int* position,
int type, int max, PyObject* as_class,
unsigned char tz_aware, unsigned char uuid_subtype) {
struct module_state *state = GETSTATE(self);

PyObject* value;
PyObject* error;
switch (type) {
case 1:
{
double d;
if (max < 8) {
goto invalid;
}
memcpy(&d, buffer + *position, 8);
value = PyFloat_FromDouble(d);
if (!value) {
return NULL;
}
*position += 8;
break;
}
case 2:
case 14:
{
int value_length = ((int*)(buffer + *position))[0] - 1;
if (max < value_length) {
goto invalid;
}
*position += 4;
value = PyUnicode_DecodeUTF8(buffer + *position, value_length, ""strict"");
if (!value) {
return NULL;
}
*position += value_length + 1;
break;
}
case 3:
{
int size;
memcpy(&size, buffer + *position, 4);
if (max < size) {
goto invalid;
}
value = elements_to_dict(self, buffer + *position + 4,
size - 5, as_class, tz_aware, uuid_subtype);
if (!value) {
return NULL;
}


if (strcmp(buffer + *position + 5, ""$ref"") == 0) {
PyObject* dbref;
PyObject* collection = PyDict_GetItemString(value, ""$ref"");
PyObject* id = PyDict_GetItemString(value, ""$id"");
PyObject* database = PyDict_GetItemString(value, ""$db"");

Py_INCREF(collection);
PyDict_DelItemString(value, ""$ref"");
Py_INCREF(id);
PyDict_DelItemString(value, ""$id"");

if (database == NULL) {
database = Py_None;
Py_INCREF(database);
} else {
Py_INCREF(database);
PyDict_DelItemString(value, ""$db"");
}

dbref = PyObject_CallFunctionObjArgs(state->DBRef, collection, id, database, value, NULL);
Py_DECREF(value);
value = dbref;

Py_DECREF(id);
Py_DECREF(collection);
Py_DECREF(database);
if (!value) {
return NULL;
}
}

*position += size;
break;
}
case 4:
{
int size,
end;

memcpy(&size, buffer + *position, 4);
if (max < size) {
goto invalid;
}
end = *position + size - 1;
*position += 4;

value = PyList_New(0);
if (!value) {
return NULL;
}
while (*position < end) {
PyObject* to_append;

int type = (int)buffer[(*position)++];
int key_size = strlen(buffer + *position);
*position += key_size + 1;
to_append = get_value(self, buffer, position, type,
max - key_size, as_class, tz_aware, uuid_subtype);
if (!to_append) {
Py_DECREF(value);
return NULL;
}
PyList_Append(value, to_append);
Py_DECREF(to_append);
}
(*position)++;
break;
}
case 5:
{
PyObject* data;
PyObject* st;
int length, subtype;

memcpy(&length, buffer + *position, 4);
if (max < length) {
goto invalid;
}
subtype = (unsigned char)buffer[*position + 4];
#if PY_MAJOR_VERSION >= 3

if (subtype == 0) {
value = PyBytes_FromStringAndSize(buffer + *position + 5, length);
*position += length + 5;
break;
}
if (subtype == 2) {
data = PyBytes_FromStringAndSize(buffer + *position + 9, length - 4);
} else {
data = PyBytes_FromStringAndSize(buffer + *position + 5, length);
}
#else
if (subtype == 2) {
data = PyString_FromStringAndSize(buffer + *position + 9, length - 4);
} else {
data = PyString_FromStringAndSize(buffer + *position + 5, length);
}
#endif
if (!data) {
return NULL;
}
if ((subtype == 3 || subtype == 4) && state->UUID) {
PyObject* kwargs;
PyObject* args = PyTuple_New(0);
if (!args) {
Py_DECREF(data);
return NULL;
}
kwargs = PyDict_New();
if (!kwargs) {
Py_DECREF(data);
Py_DECREF(args);
return NULL;
}

assert(length == 16);

if (uuid_subtype == CSHARP_LEGACY) {

PyDict_SetItemString(kwargs, ""bytes_le"", data);
}
else {
if (uuid_subtype == JAVA_LEGACY) {

char big_endian[16];
_fix_java(buffer + *position + 5, big_endian);

Py_DECREF(data);
#if PY_MAJOR_VERSION >= 3
data = PyBytes_FromStringAndSize(big_endian, length);
#else
data = PyString_FromStringAndSize(big_endian, length);
#endif
}
PyDict_SetItemString(kwargs, ""bytes"", data);
}
value = PyObject_Call(state->UUID, args, kwargs);

Py_DECREF(args);
Py_DECREF(kwargs);
Py_DECREF(data);
if (!value) {
return NULL;
}

*position += length + 5;
break;
}

#if PY_MAJOR_VERSION >= 3
st = PyLong_FromLong(subtype);
#else
st = PyInt_FromLong(subtype);
#endif
if (!st) {
Py_DECREF(data);
return NULL;
}
value = PyObject_CallFunctionObjArgs(state->Binary, data, st, NULL);
Py_DECREF(st);
Py_DECREF(data);
if (!value) {
return NULL;
}
*position += length + 5;
break;
}
case 6:
case 10:
{
value = Py_None;
Py_INCREF(value);
break;
}
case 7:
{
if (max < 12) {
goto invalid;
}
#if PY_MAJOR_VERSION >= 3
value = PyObject_CallFunction(state->ObjectId, ""y#"", buffer + *position, 12);
#else
value = PyObject_CallFunction(state->ObjectId, ""s#"", buffer + *position, 12);
#endif
if (!value) {
return NULL;
}
*position += 12;
break;
}
case 8:
{
value = buffer[(*position)++] ? Py_True : Py_False;
Py_INCREF(value);
break;
}
case 9:
{
PyObject* naive;
PyObject* replace;
PyObject* args;
PyObject* kwargs;
if (max < 8) {
goto invalid;
}
naive = datetime_from_millis(*(long long*)(buffer + *position));
*position += 8;
if (!tz_aware) {
value = naive;
break;
}

if (!naive) {
return NULL;
}
replace = PyObject_GetAttrString(naive, ""replace"");
Py_DECREF(naive);
if (!replace) {
return NULL;
}
args = PyTuple_New(0);
if (!args) {
Py_DECREF(replace);
return NULL;
}
kwargs = PyDict_New();
if (!kwargs) {
Py_DECREF(replace);
Py_DECREF(args);
return NULL;
}
if (PyDict_SetItemString(kwargs, ""tzinfo"", state->UTC) == -1) {
Py_DECREF(replace);
Py_DECREF(args);
Py_DECREF(kwargs);
return NULL;
}
value = PyObject_Call(replace, args, kwargs);
Py_DECREF(replace);
Py_DECREF(args);
Py_DECREF(kwargs);
break;
}
case 11:
{
PyObject* pattern;
int flags_length,
flags,
i;
int pattern_length = strlen(buffer + *position);
if (max < pattern_length) {
goto invalid;
}
pattern = PyUnicode_DecodeUTF8(buffer + *position, pattern_length, ""strict"");
if (!pattern) {
return NULL;
}
*position += pattern_length + 1;
flags_length = strlen(buffer + *position);
if (max < pattern_length + flags_length) {
Py_DECREF(pattern);
goto invalid;
}
flags = 0;
for (i = 0; i < flags_length; i++) {
if (buffer[*position + i] == 'i') {
flags |= 2;
} else if (buffer[*position + i] == 'l') {
flags |= 4;
} else if (buffer[*position + i] == 'm') {
flags |= 8;
} else if (buffer[*position + i] == 's') {
flags |= 16;
} else if (buffer[*position + i] == 'u') {
flags |= 32;
} else if (buffer[*position + i] == 'x') {
flags |= 64;
}
}
*position += flags_length + 1;
value = PyObject_CallFunction(state->RECompile, ""Oi"", pattern, flags);
Py_DECREF(pattern);
break;
}
case 12:
{
int collection_length;
PyObject* collection;
PyObject* id;

*position += 4;
collection_length = strlen(buffer + *position);
if (max < collection_length) {
goto invalid;
}
collection = PyUnicode_DecodeUTF8(buffer + *position, collection_length, ""strict"");
if (!collection) {
return NULL;
}
*position += collection_length + 1;
if (max < collection_length + 12) {
Py_DECREF(collection);
goto invalid;
}
id = PyObject_CallFunction(state->ObjectId, ""s#"", buffer + *position, 12);
if (!id) {
Py_DECREF(collection);
return NULL;
}
*position += 12;
value = PyObject_CallFunctionObjArgs(state->DBRef, collection, id, NULL);
Py_DECREF(collection);
Py_DECREF(id);
break;
}
case 13:
{
PyObject* code;
int value_length = ((int*)(buffer + *position))[0] - 1;
if (max < value_length) {
goto invalid;
}
*position += 4;
code = PyUnicode_DecodeUTF8(buffer + *position, value_length, ""strict"");
if (!code) {
return NULL;
}
*position += value_length + 1;
value = PyObject_CallFunctionObjArgs(state->Code, code, NULL, NULL);
Py_DECREF(code);
break;
}
case 15:
{
int code_length,
scope_size;
PyObject* code;
PyObject* scope;

*position += 8;
code_length = strlen(buffer + *position);
if (max < 8 + code_length) {
goto invalid;
}
code = PyUnicode_DecodeUTF8(buffer + *position, code_length, ""strict"");
if (!code) {
return NULL;
}
*position += code_length + 1;

memcpy(&scope_size, buffer + *position, 4);
scope = elements_to_dict(self, buffer + *position + 4, scope_size - 5,
(PyObject*)&PyDict_Type, tz_aware, uuid_subtype);
if (!scope) {
Py_DECREF(code);
return NULL;
}
*position += scope_size;

value = PyObject_CallFunctionObjArgs(state->Code, code, scope, NULL);
Py_DECREF(code);
Py_DECREF(scope);
break;
}
case 16:
{
int i;
if (max < 4) {
goto invalid;
}
memcpy(&i, buffer + *position, 4);
#if PY_MAJOR_VERSION >= 3
value = PyLong_FromLong(i);
#else
value = PyInt_FromLong(i);
#endif
if (!value) {
return NULL;
}
*position += 4;
break;
}
case 17:
{
unsigned int time, inc;
if (max < 8) {
goto invalid;
}
memcpy(&inc, buffer + *position, 4);
memcpy(&time, buffer + *position + 4, 4);
value = PyObject_CallFunction(state->Timestamp, ""II"", time, inc);
if (!value) {
return NULL;
}
*position += 8;
break;
}
case 18:
{
long long ll;
if (max < 8) {
goto invalid;
}
memcpy(&ll, buffer + *position, 8);
value = PyLong_FromLongLong(ll);
if (!value) {
return NULL;
}
*position += 8;
break;
}
case -1:
{
value = PyObject_CallFunctionObjArgs(state->MinKey, NULL);
break;
}
case 127:
{
value = PyObject_CallFunctionObjArgs(state->MaxKey, NULL);
break;
}
default:
{
PyObject* InvalidDocument = _error(""InvalidDocument"");
PyErr_SetString(InvalidDocument, ""no c decoder for this type yet"");
Py_DECREF(InvalidDocument);
return NULL;
}
}
return value;

invalid:

error = _error(""InvalidBSON"");
PyErr_SetNone(error);
Py_DECREF(error);
return NULL;
}","[60, 61]","bson/_cbsonmodule.c in the mongo-python-driver (aka. pymongo) before 2.5.2, as used in MongoDB, allows context-dependent attackers to cause a denial of service (NULL pointer dereference and crash) via vectors related to decoding of an ""invalid DBRef."""
8551,"PJ_DEF(pj_status_t) pjmedia_vid_conf_remove_port( pjmedia_vid_conf *vid_conf,
unsigned slot)
{
vconf_port *cport;

PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);

pj_mutex_lock(vid_conf->mutex);


cport = vid_conf->ports[slot];
if (cport == NULL) {
pj_mutex_unlock(vid_conf->mutex);
return PJ_EINVAL;
}


while (cport->listener_cnt) {
pjmedia_vid_conf_disconnect_port(vid_conf, slot,
cport->listener_slots[0]);
}


while (cport->transmitter_cnt) {
pjmedia_vid_conf_disconnect_port(vid_conf,
cport->transmitter_slots[0], slot);
}


vid_conf->ports[slot] = NULL;
--vid_conf->port_cnt;

PJ_LOG(4,(THIS_FILE,""Removed port %d (%.*s)"",
slot, (int)cport->name.slen, cport->name.ptr));


pj_pool_safe_release(&cport->pool);

if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {
pj_status_t status;


status = pjmedia_clock_stop(vid_conf->clock);
if (status != PJ_SUCCESS) {
PJ_PERROR(4, (THIS_FILE, status, ""Failed to stop clock""));
return status;
}
}

pj_mutex_unlock(vid_conf->mutex);

return PJ_SUCCESS;
}",[46],"PJSIP is a free and open source multimedia communication library written in the C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In various parts of PJSIP, when error/failure occurs, it is found that the function returns without releasing the currently held locks. This could result in a system deadlock, which cause a denial of service for the users. No release has yet been made which contains the linked fix commit. All versions up to an including 2.11.1 are affected. Users may need to manually apply the patch."
202269," err_t verify_signed_hash(const struct RSA_public_key *k
                          , u_char *s, unsigned int s_max_octets
                          , u_char **psig
                          , size_t hash_len
                          , const u_char *sig_val, size_t sig_len)
 {
     unsigned int padlen;
 
      
     {
 	chunk_t temp_s;
 	MP_INT c;
 
 	n_to_mpz(&c, sig_val, sig_len);
 	oswcrypto.mod_exp(&c, &c, &k->e, &k->n);
 
 	temp_s = mpz_to_n(&c, sig_len);	 
         if(s_max_octets < sig_len) {
             return ""2""""exponentiation failed; too many octets"";
         }
 	memcpy(s, temp_s.ptr, sig_len);
 	pfree(temp_s.ptr);
 	mpz_clear(&c);
     }
 
      
      
     padlen = sig_len - 3 - hash_len;
      
 
     DBG(DBG_CRYPT,
 	DBG_dump(""verify_sh decrypted SIG1:"", s, sig_len));
     DBG(DBG_CRYPT, DBG_log(""pad_len calculated: %d hash_len: %d"", padlen, (int)hash_len));
 
      
     if(s[0]    != 0x00
        || s[1] != 0x01
        || s[padlen+2] != 0x00) {
  	return ""3""""SIG padding does not check out"";
      }
  
    s += padlen + 3;
    (*psig) = s;
      
     (*psig) = s + padlen + 3;
 
      
     {
         const u_char *p;
         size_t cnt_ffs = 0;
 
         for (p = s+2; p < s+padlen+2; p++)
             if (*p == 0xFF)
                 cnt_ffs ++;
 
         if (cnt_ffs != padlen)
             return ""4"" ""invalid Padding String"";
     }
  
       
      return NULL;
 }","[44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 42, 43]","In verify_signed_hash() in lib/liboswkeys/signatures.c in Openswan before 2.6.50.1, the RSA implementation does not verify the value of padding string during PKCS#1 v1.5 signature verification. Consequently, a remote attacker can forge signatures when small public exponents are being used. IKEv2 signature verification is affected when RAW RSA keys are used."
8128,"static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)
{
u8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;
u32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;
u8 dimension_id_len[16], dim_bit_offset[16];
u8                          NumLayerSets,                                           rep_format_idx_present_flag, ols_ids_to_ls_idx;
u8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];
u8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];
u8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];

u32 k, d, r, p, iNuhLId, jNuhLId;
u8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];
u8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];




u8 layer_id_in_list_flag[64];
Bool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];

vps->vps_extension_found = 1;
if ((vps->max_layers > 1) && vps->base_layer_internal_flag)
hevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);

splitting_flag = gf_bs_read_int_log(bs, 1, ""splitting_flag"");
num_scalability_types = 0;
for (i = 0; i < 16; i++) {
vps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, ""scalability_mask"", i);
num_scalability_types += vps->scalability_mask[i];
}
if (num_scalability_types >= 16) {
num_scalability_types = 16;
}
dimension_id_len[0] = 0;
for (i = 0; i < (num_scalability_types - splitting_flag); i++) {
dimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, ""dimension_id_len_minus1"", i);
}

if (splitting_flag) {
for (i = 0; i < num_scalability_types; i++) {
dim_bit_offset[i] = 0;
for (j = 0; j < i; j++)
dim_bit_offset[i] += dimension_id_len[j];
}
dimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);
dim_bit_offset[num_scalability_types] = 6;
}

vps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, ""vps_nuh_layer_id_present_flag"");
vps->layer_id_in_nuh[0] = 0;
vps->layer_id_in_vps[0] = 0;
for (i = 1; i < vps->max_layers; i++) {
if (vps_nuh_layer_id_present_flag) {
vps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, ""layer_id_in_nuh"", i);
}
else {
vps->layer_id_in_nuh[i] = i;
}
vps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;

if (!splitting_flag) {
for (j = 0; j < num_scalability_types; j++) {
vps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], ""dimension_id"", i, j);
}
}
}

if (splitting_flag) {
for (i = 0; i < vps->max_layers; i++)
for (j = 0; j < num_scalability_types; j++)
vps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);
}
else {
for (j = 0; j < num_scalability_types; j++)
vps->dimension_id[0][j] = 0;
}

view_id_len = gf_bs_read_int_log(bs, 4, ""view_id_len"");
if (view_id_len > 0) {
for (i = 0; i < lhvc_get_num_views(vps); i++) {
gf_bs_read_int_log_idx(bs, view_id_len, ""view_id_val"", i);
}
}

for (i = 1; i < vps->max_layers; i++) {
for (j = 0; j < i; j++) {
vps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, ""direct_dependency_flag"", i);
}
}


for (i = 0; i < MAX_LHVC_LAYERS; i++) {
if (i >= vps->max_layers) break;
for (j = 0; j < vps->max_layers; j++) {
dependency_flag[i][j] = vps->direct_dependency_flag[i][j];
for (k = 0; k < i; k++)
if (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])
dependency_flag[i][j] = 1;
}
}

for (i = 0; i < vps->max_layers; i++) {
iNuhLId = vps->layer_id_in_nuh[i];
d = r = p = 0;
for (j = 0; j < vps->max_layers; j++) {
jNuhLId = vps->layer_id_in_nuh[j];
if (vps->direct_dependency_flag[i][j]) {

d++;
}
if (dependency_flag[i][j]) {

r++;
}

if (dependency_flag[j][i])
id_pred_layers[iNuhLId][p++] = jNuhLId;
}
num_direct_ref_layers[iNuhLId] = d;

num_pred_layers[iNuhLId] = p;
}

memset(layer_id_in_list_flag, 0, 64 * sizeof(u8));
k = 0;
for (i = 0; i < vps->max_layers; i++) {
iNuhLId = vps->layer_id_in_nuh[i];
if (!num_direct_ref_layers[iNuhLId]) {
u32 h = 1;

for (j = 0; j < num_pred_layers[iNuhLId]; j++) {
u32 predLId = id_pred_layers[iNuhLId][j];
if (!layer_id_in_list_flag[predLId]) {

layer_id_in_list_flag[predLId] = 1;
}
}
num_layers_in_tree_partition[k++] = h;
}
}
num_indepentdent_layers = k;

num_add_layer_set = 0;
if (num_indepentdent_layers > 1)
num_add_layer_set = gf_bs_read_ue_log(bs, ""num_add_layer_set"");

for (i = 0; i < num_add_layer_set; i++)
for (j = 1; j < num_indepentdent_layers; j++) {
nb_bits = 1;
while ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))
nb_bits++;
gf_bs_read_int_log_idx2(bs, nb_bits, ""highest_layer_idx_plus1"", i, j);
}


if (gf_bs_read_int_log(bs, 1, ""vps_sub_layers_max_minus1_present_flag"")) {
for (i = 0; i < vps->max_layers; i++) {
gf_bs_read_int_log_idx(bs, 3, ""sub_layers_vps_max_minus1"", i);
}
}

if (gf_bs_read_int_log(bs, 1, ""max_tid_ref_present_flag"")) {
for (i = 0; i < (vps->max_layers - 1); i++) {
for (j = i + 1; j < vps->max_layers; j++) {
if (vps->direct_dependency_flag[j][i])
gf_bs_read_int_log_idx2(bs, 3, ""max_tid_il_ref_pics_plus1"", i, j);
}
}
}
gf_bs_read_int_log(bs, 1, ""default_ref_layers_active_flag"");

vps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, ""num_profile_tier_level"");
if (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Wrong number of PTLs in VPS %d\n"", vps->num_profile_tier_level));
vps->num_profile_tier_level = 1;
return GF_FALSE;
}

for (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {
Bool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, ""vps_profile_present_flag"", i);
hevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);
}

NumLayerSets = vps->num_layer_sets + num_add_layer_set;
num_add_olss = 0;

if (NumLayerSets > 1) {
num_add_olss = gf_bs_read_ue_log(bs, ""num_add_olss"");
default_output_layer_idc = gf_bs_read_int_log(bs, 2, ""default_output_layer_idc"");
default_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;
}
vps->num_output_layer_sets = num_add_olss + NumLayerSets;


layer_set_idx_for_ols_minus1[0] = 1;
vps->output_layer_flag[0][0] = 1;

for (i = 0; i < vps->num_output_layer_sets; i++) {
if ((NumLayerSets > 2) && (i >= NumLayerSets)) {
nb_bits = 1;
while ((1 << nb_bits) < (NumLayerSets - 1))
nb_bits++;
layer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, ""layer_set_idx_for_ols_minus1"", i);
}
else
layer_set_idx_for_ols_minus1[i] = 0;
ols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;

if ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)
vps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, ""output_layer_flag"", i, j);
}

if ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
if ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))
OutputLayerFlag[i][j] = GF_TRUE;
else
OutputLayerFlag[i][j] = GF_FALSE;
}
}

for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
if (OutputLayerFlag[i][j]) {
u32 curLayerID;
vps->necessary_layers_flag[i][j] = GF_TRUE;
curLayerID = vps->LayerSetLayerIdList[i][j];
for (k = 0; k < j; k++) {
u32 refLayerId = vps->LayerSetLayerIdList[i][k];
if (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])
vps->necessary_layers_flag[i][k] = GF_TRUE;
}
}
}
vps->num_necessary_layers[i] = 0;
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
if (vps->necessary_layers_flag[i][j])
vps->num_necessary_layers[i] += 1;
}

if (i == 0) {
if (vps->base_layer_internal_flag) {
if (vps->max_layers > 1)
vps->profile_tier_level_idx[0][0] = 1;
else
vps->profile_tier_level_idx[0][0] = 0;
}
continue;
}
nb_bits = 1;
while ((u32)(1 << nb_bits) < vps->num_profile_tier_level)
nb_bits++;
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)
if (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)
vps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, ""profile_tier_level_idx"", i, j);
else
vps->profile_tier_level_idx[i][j] = 0;


nb_output_layers_in_output_layer_set[i] = 0;
for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {
nb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];
if (OutputLayerFlag[i][j]) {
ols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];
}
}
if (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)
vps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, ""alt_output_layer_flag"", i);
}

vps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, ""num_rep_formats_minus1"");
if (vps->num_rep_formats > 16) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Wrong number of rep formats in VPS %d\n"", vps->num_rep_formats));
vps->num_rep_formats = 0;
return GF_FALSE;
}

for (i = 0; i < vps->num_rep_formats; i++) {
lhvc_parse_rep_format(&vps->rep_formats[i], bs, i);
}
if (vps->num_rep_formats > 1)
rep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, ""rep_format_idx_present_flag"");
else
rep_format_idx_present_flag = 0;

vps->rep_format_idx[0] = 0;
nb_bits = 1;
while ((u32)(1 << nb_bits) < vps->num_rep_formats)
nb_bits++;
for (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {
if (rep_format_idx_present_flag) {
vps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, ""rep_format_idx"", i);
}
else {
vps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;
}
}


return GF_TRUE;
}",[195],Stack buffer overflow in the hevc_parse_vps_extension function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.
207321," xsltResolveSASCallback(xsltAttrElemPtr values, xsltStylesheetPtr style,
 xsltResolveSASCallbackInt(xsltAttrElemPtr values, xsltStylesheetPtr style,
  	               const xmlChar *name, const xmlChar *ns,
		       ATTRIBUTE_UNUSED const xmlChar *ignored) {
 		       int depth) {
      xsltAttrElemPtr tmp;
      xsltAttrElemPtr refs;
  
      tmp = values;
     if ((name == NULL) || (name[0] == 0))
         return;
     if (depth > 100) {
 	xsltGenericError(xsltGenericErrorContext,
 	""xsl:attribute-set : use-attribute-sets recursion detected on %s\n"",
 			 name);
 	return;
     }
      while (tmp != NULL) {
  	if (tmp->set != NULL) {
  	     
 	    if ((xmlStrEqual(name, tmp->set)) && (xmlStrEqual(ns, tmp->ns))) {
 		xsltGenericError(xsltGenericErrorContext,
      ""xsl:attribute-set : use-attribute-sets recursion detected on %s\n"",
                                  name);
 	    } else {
 #ifdef WITH_XSLT_DEBUG_ATTRIBUTES
 		xsltGenericDebug(xsltGenericDebugContext,
 			""Importing attribute list %s\n"", tmp->set);
 #endif
 
 		refs = xsltGetSAS(style, tmp->set, tmp->ns);
 		if (refs == NULL) {
 		    xsltGenericError(xsltGenericErrorContext,
      ""xsl:attribute-set : use-attribute-sets %s reference missing %s\n"",
 				     name, tmp->set);
 		} else {
  		     
		    xsltResolveSASCallback(refs, style, name, ns, NULL);
 		    xsltResolveSASCallbackInt(refs, style, name, ns, depth + 1);
  		     
 		    xsltMergeAttrElemList(style, values, refs);
 		     
 		    tmp->set = NULL;
 		    tmp->ns = NULL;
 		}
 	    }
 	}
 	tmp = tmp->next;
      }
  }","[2, 5, 10, 11, 12, 13, 14, 15, 16, 17, 39, 4, 38]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
202649," int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)
 {
     if (!g_teredo_enabled)
         return TM_ECODE_FAILED;
 
     uint8_t *start = pkt;
 
      
     if (len < IPV6_HEADER_LEN)
         return TM_ECODE_FAILED;
 
      
     if (start[0] == 0x0) {
         switch (start[1]) {
              
             case 0x0:
                  
                 if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)
                     start += TEREDO_ORIG_INDICATION_LENGTH;
                 else
                     return TM_ECODE_FAILED;
                 break;
              
             case 0x1:
                 return TM_ECODE_FAILED;
              
             default:
                 return TM_ECODE_FAILED;
         }
     }
 
       
      if (IP_GET_RAW_VER(start) == 6) {
          IPV6Hdr *thdr = (IPV6Hdr *)start;
 
          
         if (IPV6_GET_RAW_HLIM(thdr) == 0)
             return TM_ECODE_FAILED;
 
          
         if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)
             return TM_ECODE_FAILED;
 
          if (len ==  IPV6_HEADER_LEN +
                  IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {
              if (pq != NULL) {
                  int blen = len - (start - pkt);
                   
                  Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,
                                                  DECODE_TUNNEL_IPV6, pq);
                                                   DECODE_TUNNEL_IPV6_TEREDO, pq);
                  if (tp != NULL) {
                      PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);
                       
                     PacketEnqueue(pq,tp);
                     StatsIncr(tv, dtv->counter_teredo);
                     return TM_ECODE_OK;
                 }
             }
         }
         return TM_ECODE_FAILED;
     }
 
     return TM_ECODE_FAILED;
 }","[35, 36, 37, 38, 39, 40, 41, 42, 43, 51, 50]","Open Information Security Foundation Suricata prior to version 4.1.2 is affected by: Denial of Service - DNS detection bypass. The impact is: An attacker can evade a signature detection with a specialy formed network packet. The component is: app-layer-detect-proto.c, decode.c, decode-teredo.c and decode-ipv6.c (https://github.com/OISF/suricata/pull/3590/commits/11f3659f64a4e42e90cb3c09fcef66894205aefe, https://github.com/OISF/suricata/pull/3590/commits/8357ef3f8ffc7d99ef6571350724160de356158b). The attack vector is: An attacker can trigger the vulnerability by sending a specifically crafted network request. The fixed version is: 4.1.2."
203800,"  void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
  {
      if (m_errorCallback)
        m_errorCallback->handleEvent(error);
         m_errorCallback->handleEvent(error, m_owner.get());
  
      clear();
  }","[5, 4]","Google V8, as used in Google Chrome before 14.0.835.163, does not properly perform object sealing, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage *type confusion.*"
199278," SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)
 {
 	struct fs_struct *fs, *new_fs = NULL;
 	struct files_struct *fd, *new_fd = NULL;
 	struct cred *new_cred = NULL;
 	struct nsproxy *new_nsproxy = NULL;
 	int do_sysvsem = 0;
 	int err;
 
 	 
  	if (unshare_flags & CLONE_NEWUSER)
		unshare_flags |= CLONE_THREAD;
 		unshare_flags |= CLONE_THREAD | CLONE_FS;
  	 
 	if (unshare_flags & CLONE_NEWPID)
 		unshare_flags |= CLONE_THREAD;
 	 
 	if (unshare_flags & CLONE_THREAD)
 		unshare_flags |= CLONE_VM;
 	 
 	if (unshare_flags & CLONE_VM)
 		unshare_flags |= CLONE_SIGHAND;
 	 
 	if (unshare_flags & CLONE_NEWNS)
 		unshare_flags |= CLONE_FS;
 
 	err = check_unshare_flags(unshare_flags);
 	if (err)
 		goto bad_unshare_out;
 	 
 	if (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))
 		do_sysvsem = 1;
 	err = unshare_fs(unshare_flags, &new_fs);
 	if (err)
 		goto bad_unshare_out;
 	err = unshare_fd(unshare_flags, &new_fd);
 	if (err)
 		goto bad_unshare_cleanup_fs;
 	err = unshare_userns(unshare_flags, &new_cred);
 	if (err)
 		goto bad_unshare_cleanup_fd;
 	err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,
 					 new_cred, new_fs);
 	if (err)
 		goto bad_unshare_cleanup_cred;
 
 	if (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {
 		if (do_sysvsem) {
 			 
 			exit_sem(current);
 		}
 
 		if (new_nsproxy)
 			switch_task_namespaces(current, new_nsproxy);
 
 		task_lock(current);
 
 		if (new_fs) {
 			fs = current->fs;
 			spin_lock(&fs->lock);
 			current->fs = new_fs;
 			if (--fs->users)
 				new_fs = NULL;
 			else
 				new_fs = fs;
 			spin_unlock(&fs->lock);
 		}
 
 		if (new_fd) {
 			fd = current->files;
 			current->files = new_fd;
 			new_fd = fd;
 		}
 
 		task_unlock(current);
 
 		if (new_cred) {
 			 
 			commit_creds(new_cred);
 			new_cred = NULL;
 		}
 	}
 
 bad_unshare_cleanup_cred:
 	if (new_cred)
 		put_cred(new_cred);
 bad_unshare_cleanup_fd:
 	if (new_fd)
 		put_files_struct(new_fd);
 
 bad_unshare_cleanup_fs:
 	if (new_fs)
 		free_fs_struct(new_fs);
 
 bad_unshare_out:
 	return err;
 }","[13, 12]","The clone system-call implementation in the Linux kernel before 3.8.3 does not properly handle a combination of the CLONE_NEWUSER and CLONE_FS flags, which allows local users to gain privileges by calling chroot and leveraging the sharing of the / directory between a parent process and a child process."
200143," static int __f2fs_set_acl(struct inode *inode, int type,
 			struct posix_acl *acl, struct page *ipage)
 {
 	int name_index;
 	void *value = NULL;
 	size_t size = 0;
 	int error;
 
 	switch (type) {
  	case ACL_TYPE_ACCESS:
  		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
  		if (acl) {
			error = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (error < 0)
 			error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
 			if (error)
  				return error;
  			set_acl_inode(inode, inode->i_mode);
			if (error == 0)
				acl = NULL;
  		}
  		break;
  
 	case ACL_TYPE_DEFAULT:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;
 		if (!S_ISDIR(inode->i_mode))
 			return acl ? -EACCES : 0;
 		break;
 
 	default:
 		return -EINVAL;
 	}
 
 	if (acl) {
 		value = f2fs_acl_to_disk(acl, &size);
 		if (IS_ERR(value)) {
 			clear_inode_flag(inode, FI_ACL_MODE);
 			return (int)PTR_ERR(value);
 		}
 	}
 
 	error = f2fs_setxattr(inode, name_index, """", value, size, ipage, 0);
 
 	kfree(value);
 	if (!error)
 		set_cached_acl(inode, type, acl);
 
 	clear_inode_flag(inode, FI_ACL_MODE);
 	return error;
 }","[15, 16, 13, 14, 19, 20]","The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions."
6169,"void ModuleSQL::init()
{
Dispatcher = new DispatcherThread(this);
ServerInstance->Threads.Start(Dispatcher);
}",[3],"An issue was discovered in InspIRCd 2 before 2.0.28 and 3 before 3.3.0. The mysql module contains a NULL pointer dereference when built against mariadb-connector-c 3.0.5 or newer. When combined with the sqlauth or sqloper modules, this vulnerability can be used for remote crashing of an InspIRCd server by any user able to connect to a server."
200424,"  struct bpf_map *bpf_map_get_with_uref(u32 ufd)
 {
 	struct fd f = fdget(ufd);
 	struct bpf_map *map;
 
 	map = __bpf_map_get(f);
  	if (IS_ERR(map))
  		return map;
  
	bpf_map_inc(map, true);
 	map = bpf_map_inc(map, true);
  	fdput(f);
  
  	return map;
 }","[11, 10]","The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count."
9713,"void Compute(OpKernelContext* ctx) override {
const Tensor& handle = ctx->input(0);
const string& name = handle.scalar<tstring>()();
auto session_state = ctx->session_state();
OP_REQUIRES(ctx, session_state != nullptr,
errors::FailedPrecondition(
""DeleteSessionTensor called on null session state""));
OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));
}",[3],"TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.DeleteSessionTensor` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."
204547," void GpuProcessHost::EstablishChannelError(
     const EstablishChannelCallback& callback,
      const IPC::ChannelHandle& channel_handle,
      base::ProcessHandle renderer_process_for_gpu,
      const content::GPUInfo& gpu_info) {
  callback.Run(channel_handle, renderer_process_for_gpu, gpu_info);
   callback.Run(channel_handle, gpu_info);
  }","[7, 6]","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
198782," int hugetlb_reserve_pages(struct inode *inode,
 					long from, long to,
 					struct vm_area_struct *vma,
 					vm_flags_t vm_flags)
  {
  	long ret, chg;
  	struct hstate *h = hstate_inode(inode);
 	struct hugepage_subpool *spool = subpool_inode(inode);
  
  	 
  	if (vm_flags & VM_NORESERVE)
  		return 0;
 
 	 
 	if (!vma || vma->vm_flags & VM_MAYSHARE)
 		chg = region_chg(&inode->i_mapping->private_list, from, to);
 	else {
 		struct resv_map *resv_map = resv_map_alloc();
 		if (!resv_map)
 			return -ENOMEM;
 
 		chg = to - from;
 
 		set_vma_resv_map(vma, resv_map);
 		set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
 	}
 
  	if (chg < 0)
  		return chg;
  
 	 
	if (hugetlb_get_quota(inode->i_mapping, chg))
 	if (hugepage_subpool_get_pages(spool, chg))
  		return -ENOSPC;
  
  	 
  	ret = hugetlb_acct_memory(h, chg);
  	if (ret < 0) {
		hugetlb_put_quota(inode->i_mapping, chg);
 		hugepage_subpool_put_pages(spool, chg);
  		return ret;
  	}
  
 	 
 	if (!vma || vma->vm_flags & VM_MAYSHARE)
 		region_add(&inode->i_mapping->private_list, from, to);
 	return 0;
 }","[8, 33, 40, 32, 39]","Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data."
207972," void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)
 {
  stream_t *ps_stream;
 
      ps_stream = &ps_dec->s_bit_stream;
      impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
  
    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&
             (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))
      {
  
          if (impeg2d_bit_stream_get(ps_stream,8) != 0)
  {
   
  }
 
  }
  return;
 }","[10, 11, 8, 9]","libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591."
207080,"  MediaStreamDispatcherHost::MediaStreamDispatcherHost(
      int render_process_id,
      int render_frame_id,
      MediaStreamManager* media_stream_manager)
      : render_process_id_(render_process_id),
        render_frame_id_(render_frame_id),
       requester_id_(next_requester_id_++),
        media_stream_manager_(media_stream_manager),
        salt_and_origin_callback_(
            base::BindRepeating(&GetMediaDeviceSaltAndOrigin)),
        weak_factory_(this) {
    DCHECK_CURRENTLY_ON(BrowserThread::IO);
  bindings_.set_connection_error_handler(
      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,
                 weak_factory_.GetWeakPtr()));
  }","[7, 13, 14, 15]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
199979," static void destroy_super(struct super_block *s)
 {
  	int i;
  	list_lru_destroy(&s->s_dentry_lru);
  	list_lru_destroy(&s->s_inode_lru);
#ifdef CONFIG_SMP
	free_percpu(s->s_files);
#endif
  	for (i = 0; i < SB_FREEZE_LEVELS; i++)
  		percpu_counter_destroy(&s->s_writers.counter[i]);
  	security_sb_free(s);
 	WARN_ON(!list_empty(&s->s_mounts));
 	kfree(s->s_subtype);
 	kfree(s->s_options);
 	kfree_rcu(s, rcu);
 }","[6, 7, 8]","The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations."
202872," static void Sp_search(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
 	Resub m;
 
 	text = checkstring(J, 0);
 
 	if (js_isregexp(J, 1))
 		js_copy(J, 1);
 	else if (js_isundefined(J, 1))
 		js_newregexp(J, """", 0);
 	else
 		js_newregexp(J, js_tostring(J, 1), 0);
  
  	re = js_toregexp(J, -1);
  
	if (!js_regexec(re->prog, text, &m, 0))
 	if (!js_doregexec(J, re->prog, text, &m, 0))
  		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
  	else
  		js_pushnumber(J, -1);
 }","[19, 18]",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.
5931,"mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,
struct devlink_fmsg *fmsg, void *priv_ctx)
{
struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);
u32 crdump_size = dev->priv.health.crdump_size;
u32 *cr_data;
u32 data_size;
u32 offset;
int err;

if (!mlx5_core_is_pf(dev))
return -EPERM;

cr_data = kvmalloc(crdump_size, GFP_KERNEL);
if (!cr_data)
return -ENOMEM;
err = mlx5_crdump_collect(dev, cr_data);
if (err)
return err;

if (priv_ctx) {
struct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;

err = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);
if (err)
goto free_data;
}

err = devlink_fmsg_arr_pair_nest_start(fmsg, ""crdump_data"");
if (err)
goto free_data;
for (offset = 0; offset < crdump_size; offset += data_size) {
if (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)
data_size = crdump_size - offset;
else
data_size = MLX5_CR_DUMP_CHUNK_SIZE;
err = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,
data_size);
if (err)
goto free_data;
}
err = devlink_fmsg_arr_pair_nest_end(fmsg);

free_data:
kvfree(cr_data);
return err;
}",[19],"A memory leak in the mlx5_fw_fatal_reporter_dump() function in drivers/net/ethernet/mellanox/mlx5/core/health.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_crdump_collect() failures, aka CID-c7ed6d0183d5."
202011,"  static void sycc420_to_rgb(opj_image_t *img)
  {
  	int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;
  	const int *y, *cb, *cr, *ny;
	unsigned int maxw, maxh, max;
 	size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;
  	int offset, upb;
	unsigned int i, j;
 	size_t i;
  
  	upb = (int)img->comps[0].prec;
  	offset = 1<<(upb - 1); upb = (1<<upb)-1;
  
	maxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;
 	maxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;
  	max = maxw * maxh;
  
  	y = img->comps[0].data;
  	cb = img->comps[1].data;
  	cr = img->comps[2].data;
  
	d0 = r = (int*)malloc(sizeof(int) * (size_t)max);
	d1 = g = (int*)malloc(sizeof(int) * (size_t)max);
	d2 = b = (int*)malloc(sizeof(int) * (size_t)max);
	if(r == NULL || g == NULL || b == NULL) goto fails;
 	d0 = r = (int*)malloc(sizeof(int) * max);
 	d1 = g = (int*)malloc(sizeof(int) * max);
 	d2 = b = (int*)malloc(sizeof(int) * max);
 	
 	if (r == NULL || g == NULL || b == NULL) goto fails;
 	
 	 
 	offx = img->x0 & 1U;
 	loopmaxw = maxw - offx;
 	 
 	offy = img->y0 & 1U;
 	loopmaxh = maxh - offy;
 	
 	if (offy > 0U) {
 		size_t j;
 		
 		for(j=0; j < maxw; ++j)
 		{
 			sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
 			++y; ++r; ++g; ++b;
 		}
 	}
  
	for(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)
 	for(i=0U; i < (loopmaxh & ~(size_t)1U); i += 2U)
  	{
 		size_t j;
 		
  		ny = y + maxw;
  		nr = r + maxw; ng = g + maxw; nb = b + maxw;
 		
 		if (offx > 0U) {
 			sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
 			++y; ++r; ++g; ++b;
 			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
 			++ny; ++nr; ++ng; ++nb;
 		}
  
		for(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)
 		for(j=0; j < (loopmaxw & ~(size_t)1U); j += 2U)
  		{
  			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
  			++y; ++r; ++g; ++b;
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 			++y; ++r; ++g; ++b;
 
 			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
 			++ny; ++nr; ++ng; ++nb;
  			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
  			++ny; ++nr; ++ng; ++nb; ++cb; ++cr;
  		}
		if(j < maxw)
 		if(j < loopmaxw)
  		{
  			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
  			++y; ++r; ++g; ++b;
 
 			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
 			++ny; ++nr; ++ng; ++nb; ++cb; ++cr;
  		}
  		y += maxw; r += maxw; g += maxw; b += maxw;
  	}
	if(i < maxh)
 	if(i < loopmaxh)
  	{
		for(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)
 		size_t j;
 		
 		for(j=0U; j < (maxw & ~(size_t)1U); j += 2U)
  		{
  			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
  
 			++y; ++r; ++g; ++b;
 
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 
 			++y; ++r; ++g; ++b; ++cb; ++cr;
 		}
 		if(j < maxw)
 		{
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 		}
 	}
 
 	free(img->comps[0].data); img->comps[0].data = d0;
  	free(img->comps[1].data); img->comps[1].data = d1;
  	free(img->comps[2].data); img->comps[2].data = d2;
  
#if defined(USE_JPWL) || defined(USE_MJ2)
	img->comps[1].w = maxw; img->comps[1].h = maxh;
	img->comps[2].w = maxw; img->comps[2].h = maxh;
#else
	img->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;
	img->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;
#endif
	img->comps[1].dx = img->comps[0].dx;
	img->comps[2].dx = img->comps[0].dx;
	img->comps[1].dy = img->comps[0].dy;
	img->comps[2].dy = img->comps[0].dy;
 	img->comps[1].w = img->comps[2].w = img->comps[0].w;
 	img->comps[1].h = img->comps[2].h = img->comps[0].h;
 	img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;
 	img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;
 	img->color_space = OPJ_CLRSPC_SRGB;
  	return;
  
  fails:
	if(r) free(r);
	if(g) free(g);
	if(b) free(b);
 	free(r);
 	free(g);
 	free(b);
  } ","[6, 9, 15, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 50, 52, 53, 56, 57, 58, 59, 60, 61, 62, 65, 78, 89, 92, 93, 94, 125, 126, 127, 128, 129, 136, 137, 138, 5, 8, 14, 22, 23, 24, 25, 49, 64, 77, 88, 91, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 133, 134, 135]",The sycc422_t_rgb function in common/color.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted jpeg2000 file.
200944," int tcp_disconnect(struct sock *sk, int flags)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
 	int err = 0;
 	int old_state = sk->sk_state;
 
 	if (old_state != TCP_CLOSE)
 		tcp_set_state(sk, TCP_CLOSE);
 
 	 
 	if (old_state == TCP_LISTEN) {
 		inet_csk_listen_stop(sk);
 	} else if (unlikely(tp->repair)) {
 		sk->sk_err = ECONNABORTED;
 	} else if (tcp_need_reset(old_state) ||
 		   (tp->snd_nxt != tp->write_seq &&
 		    (1 << old_state) & (TCPF_CLOSING | TCPF_LAST_ACK))) {
 		 
 		tcp_send_active_reset(sk, gfp_any());
 		sk->sk_err = ECONNRESET;
 	} else if (old_state == TCP_SYN_SENT)
 		sk->sk_err = ECONNRESET;
 
 	tcp_clear_xmit_timers(sk);
 	__skb_queue_purge(&sk->sk_receive_queue);
 	tcp_write_queue_purge(sk);
 	tcp_fastopen_active_disable_ofo_check(sk);
 	skb_rbtree_purge(&tp->out_of_order_queue);
 
 	inet->inet_dport = 0;
 
 	if (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))
 		inet_reset_saddr(sk);
 
 	sk->sk_shutdown = 0;
 	sock_reset_flag(sk, SOCK_DONE);
 	tp->srtt_us = 0;
 	tp->write_seq += tp->max_window + 2;
 	if (tp->write_seq == 0)
 		tp->write_seq = 1;
 	icsk->icsk_backoff = 0;
 	tp->snd_cwnd = 2;
 	icsk->icsk_probes_out = 0;
 	tp->packets_out = 0;
 	tp->snd_ssthresh = TCP_INFINITE_SSTHRESH;
 	tp->snd_cwnd_cnt = 0;
 	tp->window_clamp = 0;
  	tcp_set_ca_state(sk, TCP_CA_Open);
  	tcp_clear_retrans(tp);
  	inet_csk_delack_init(sk);
 	 
 	icsk->icsk_ack.rcv_mss = TCP_MIN_MSS;
  	tcp_init_send_head(sk);
  	memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
  	__sk_dst_reset(sk);
 	tcp_saved_syn_free(tp);
 
 	 
 	tcp_free_fastopen_req(tp);
 	inet->defer_connect = 0;
 
 	WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
 
 	sk->sk_error_report(sk);
 	return err;
 }","[53, 54]",The tcp_disconnect function in net/ipv4/tcp.c in the Linux kernel before 4.12 allows local users to cause a denial of service (__tcp_select_window divide-by-zero error and system crash) by triggering a disconnect within a certain tcp_recvmsg code path.
207384," status_t MPEG4Source::fragmentedRead(
  MediaBuffer **out, const ReadOptions *options) {
 
     ALOGV(""MPEG4Source::fragmentedRead"");
 
     CHECK(mStarted);
 
  *out = NULL;
 
  int64_t targetSampleTimeUs = -1;
 
  int64_t seekTimeUs;
  ReadOptions::SeekMode mode;
  if (options && options->getSeekTo(&seekTimeUs, &mode)) {
 
  int numSidxEntries = mSegments.size();
  if (numSidxEntries != 0) {
  int64_t totalTime = 0;
  off64_t totalOffset = mFirstMoofOffset;
  for (int i = 0; i < numSidxEntries; i++) {
  const SidxEntry *se = &mSegments[i];
  if (totalTime + se->mDurationUs > seekTimeUs) {
  if ((mode == ReadOptions::SEEK_NEXT_SYNC && seekTimeUs > totalTime) ||
  (mode == ReadOptions::SEEK_CLOSEST_SYNC &&
  (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {
                         totalTime += se->mDurationUs;
                         totalOffset += se->mSize;
  }
  break;
  }
                 totalTime += se->mDurationUs;
                 totalOffset += se->mSize;
  }
             mCurrentMoofOffset = totalOffset;
             mCurrentSamples.clear();
             mCurrentSampleIndex = 0;
             parseChunk(&totalOffset);
             mCurrentTime = totalTime * mTimescale / 1000000ll;
  } else {
             mCurrentMoofOffset = mFirstMoofOffset;
             mCurrentSamples.clear();
             mCurrentSampleIndex = 0;
  off64_t tmp = mCurrentMoofOffset;
             parseChunk(&tmp);
             mCurrentTime = 0;
  }
 
  if (mBuffer != NULL) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  }
 
  off64_t offset = 0;
  size_t size = 0;
  uint32_t cts = 0;
  bool isSyncSample = false;
  bool newBuffer = false;
  if (mBuffer == NULL) {
         newBuffer = true;
 
  if (mCurrentSampleIndex >= mCurrentSamples.size()) {
  if (mNextMoofOffset <= mCurrentMoofOffset) {
  return ERROR_END_OF_STREAM;
  }
  off64_t nextMoof = mNextMoofOffset;
             mCurrentMoofOffset = nextMoof;
             mCurrentSamples.clear();
             mCurrentSampleIndex = 0;
             parseChunk(&nextMoof);
  if (mCurrentSampleIndex >= mCurrentSamples.size()) {
  return ERROR_END_OF_STREAM;
  }
  }
 
  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];
         offset = smpl->offset;
         size = smpl->size;
         cts = mCurrentTime + smpl->compositionOffset;
         mCurrentTime += smpl->duration;
         isSyncSample = (mCurrentSampleIndex == 0);  
 
  status_t err = mGroup->acquire_buffer(&mBuffer);
 
  if (err != OK) {
             CHECK(mBuffer == NULL);
             ALOGV(""acquire_buffer returned %d"", err);
  return err;
  }
  }
 
  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];
  const sp<MetaData> bufmeta = mBuffer->meta_data();
     bufmeta->clear();
  if (smpl->encryptedsizes.size()) {
         bufmeta->setData(kKeyPlainSizes, 0,
                 smpl->clearsizes.array(), smpl->clearsizes.size() * 4);
         bufmeta->setData(kKeyEncryptedSizes, 0,
                 smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);
         bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16);  
         bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);
         bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);
         bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);
  }
 
  if ((!mIsAVC && !mIsHEVC)|| mWantsNALFragments) {
  if (newBuffer) {
  ssize_t num_bytes_read =
                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);
 
  if (num_bytes_read < (ssize_t)size) {
                 mBuffer->release();
                 mBuffer = NULL;
 
                 ALOGV(""i/o error"");
  return ERROR_IO;
  }
 
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
             mBuffer->meta_data()->setInt64(
                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
             mBuffer->meta_data()->setInt64(
                     kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
                 mBuffer->meta_data()->setInt64(
                         kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
  }
 
  if (!mIsAVC && !mIsHEVC) {
  *out = mBuffer;
             mBuffer = NULL;
 
  return OK;
  }
 
 
         CHECK(mBuffer->range_length() >= mNALLengthSize);
 
  const uint8_t *src =
  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
 
  size_t nal_size = parseNALSize(src);
  if (mBuffer->range_length() < mNALLengthSize + nal_size) {
             ALOGE(""incomplete NAL unit."");
 
             mBuffer->release();
             mBuffer = NULL;
 
  return ERROR_MALFORMED;
  }
 
  MediaBuffer *clone = mBuffer->clone();
         CHECK(clone != NULL);
         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);
 
         CHECK(mBuffer != NULL);
         mBuffer->set_range(
                 mBuffer->range_offset() + mNALLengthSize + nal_size,
                 mBuffer->range_length() - mNALLengthSize - nal_size);
 
  if (mBuffer->range_length() == 0) {
             mBuffer->release();
             mBuffer = NULL;
  }
 
  *out = clone;
 
  return OK;
  } else {
         ALOGV(""whole NAL"");
  ssize_t num_bytes_read = 0;
  int32_t drm = 0;
  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
  if (usesDRM) {
             num_bytes_read =
                 mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);
  } else {
             num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);
  }
 
  if (num_bytes_read < (ssize_t)size) {
             mBuffer->release();
             mBuffer = NULL;
 
             ALOGV(""i/o error"");
  return ERROR_IO;
  }
 
  if (usesDRM) {
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, size);
 
  } else {
  uint8_t *dstData = (uint8_t *)mBuffer->data();
  size_t srcOffset = 0;
 
              size_t dstOffset = 0;
  
              while (srcOffset < size) {
                bool isMalFormed = (srcOffset + mNALLengthSize > size);
                 bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);
                  size_t nalLength = 0;
                  if (!isMalFormed) {
                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                      srcOffset += mNALLengthSize;
                    isMalFormed = srcOffset + nalLength > size;
                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);
                  }
  
                  if (isMalFormed) {
                     ALOGE(""Video is malformed"");
                     mBuffer->release();
                     mBuffer = NULL;
  return ERROR_MALFORMED;
  }
 
  if (nalLength == 0) {
  continue;
  }
 
                 CHECK(dstOffset + 4 <= mBuffer->size());
 
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 1;
                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);
                 srcOffset += nalLength;
                 dstOffset += nalLength;
  }
             CHECK_EQ(srcOffset, size);
             CHECK(mBuffer != NULL);
             mBuffer->set_range(0, dstOffset);
  }
 
         mBuffer->meta_data()->setInt64(
                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
         mBuffer->meta_data()->setInt64(
                 kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);
 
  if (targetSampleTimeUs >= 0) {
             mBuffer->meta_data()->setInt64(
                     kKeyTargetTime, targetSampleTimeUs);
  }
 
  if (isSyncSample) {
             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
  }
 
  ++mCurrentSampleIndex;
 
  *out = mBuffer;
         mBuffer = NULL;
 
  return OK;
  }
 }","[211, 217, 210, 216]","Multiple buffer overflows in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via invalid size values of NAL units in MP4 data, aka internal bug 19641538."
200693," modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)
  {
      static generic_ret              ret;
      char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
     gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
      OM_uint32                       minor_stat;
      kadm5_server_handle_t           handle;
      restriction_t                   *rp;
     const char                      *errmsg = NULL;
 
     xdr_free(xdr_generic_ret, &ret);
 
     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
         goto exit_func;
 
     if ((ret.code = check_handle((void *)handle)))
         goto exit_func;
 
     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
         ret.code = KADM5_FAILURE;
         goto exit_func;
     }
     if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {
         ret.code = KADM5_BAD_PRINCIPAL;
         goto exit_func;
     }
 
     if (CHANGEPW_SERVICE(rqstp)
         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,
                                arg->rec.principal, &rp)
         || kadm5int_acl_impose_restrictions(handle->context,
                                             &arg->rec, &arg->mask, rp)) {
         ret.code = KADM5_AUTH_MODIFY;
         log_unauth(""kadm5_modify_principal"", prime_arg,
                    &client_name, &service_name, rqstp);
     } else {
         ret.code = kadm5_modify_principal((void *)handle, &arg->rec,
                                           arg->mask);
         if( ret.code != 0 )
             errmsg = krb5_get_error_message(handle->context, ret.code);
 
         log_done(""kadm5_modify_principal"", prime_arg, errmsg,
                  &client_name, &service_name, rqstp);
 
         if (errmsg != NULL)
              krb5_free_error_message(handle->context, errmsg);
      }
      free(prime_arg);
 exit_func:
      gss_release_buffer(&minor_stat, &client_name);
      gss_release_buffer(&minor_stat, &service_name);
exit_func:
      free_server_handle(handle);
      return &ret;
  }","[7, 8, 52, 5, 6, 55]",Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name.
199454," static int do_remount(struct path *path, int flags, int mnt_flags,
 		      void *data)
 {
 	int err;
 	struct super_block *sb = path->mnt->mnt_sb;
 	struct mount *mnt = real_mount(path->mnt);
 
 	if (!check_mnt(mnt))
 		return -EINVAL;
 
 	if (path->dentry != path->mnt->mnt_root)
 		return -EINVAL;
 
 	 
 	if ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&
  	    !(mnt_flags & MNT_READONLY)) {
  		return -EPERM;
  	}
 	if ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&
 	    !(mnt_flags & MNT_NODEV)) {
 		return -EPERM;
 	}
 	if ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&
 	    !(mnt_flags & MNT_NOSUID)) {
 		return -EPERM;
 	}
 	if ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&
 	    !(mnt_flags & MNT_NOEXEC)) {
 		return -EPERM;
 	}
 	if ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&
 	    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {
 		return -EPERM;
 	}
 
  	err = security_sb_remount(sb, data);
  	if (err)
  		return err;
 
 	down_write(&sb->s_umount);
 	if (flags & MS_BIND)
 		err = change_mount_flags(path->mnt, flags);
 	else if (!capable(CAP_SYS_ADMIN))
 		err = -EPERM;
 	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
 		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
 	}
 	up_write(&sb->s_umount);
 	return err;
 }","[19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]","fs/namespace.c in the Linux kernel through 3.16.1 does not properly restrict clearing MNT_NODEV, MNT_NOSUID, and MNT_NOEXEC and changing MNT_ATIME_MASK during a remount of a bind mount, which allows local users to gain privileges, interfere with backups and auditing on systems that had atime enabled, or cause a denial of service (excessive filesystem updating) on systems that had atime disabled via a *mount -o remount* command within a user namespace."
208511,"  int main(int argc, char **argv) {
  FILE *infile = NULL;
  vpx_codec_ctx_t codec;
  vpx_codec_enc_cfg_t cfg;
  int frame_count = 0;
  vpx_image_t raw;
  vpx_codec_err_t res;
  VpxVideoInfo info = {0};
  VpxVideoWriter *writer = NULL;
  const VpxInterface *encoder = NULL;
  const int fps = 30;  
  const int bitrate = 200;  
  int keyframe_interval = 0;
 
  const char *codec_arg = NULL;
  const char *width_arg = NULL;
  const char *height_arg = NULL;
  const char *infile_arg = NULL;
  const char *outfile_arg = NULL;
  const char *keyframe_interval_arg = NULL;
 
   exec_name = argv[0];
 
  if (argc < 7)
     die(""Invalid number of arguments"");
 
   codec_arg = argv[1];
   width_arg = argv[2];
   height_arg = argv[3];
   infile_arg = argv[4];
   outfile_arg = argv[5];
   keyframe_interval_arg = argv[6];
 
   encoder = get_vpx_encoder_by_name(codec_arg);
  if (!encoder)
      die(""Unsupported codec."");
 
   info.codec_fourcc = encoder->fourcc;
   info.frame_width = strtol(width_arg, NULL, 0);
   info.frame_height = strtol(height_arg, NULL, 0);
   info.time_base.numerator = 1;
   info.time_base.denominator = fps;
 
  if (info.frame_width <= 0 ||
       info.frame_height <= 0 ||
  (info.frame_width % 2) != 0 ||
  (info.frame_height % 2) != 0) {
     die(""Invalid frame size: %dx%d"", info.frame_width, info.frame_height);
  }
 
  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,
                                              info.frame_height, 1)) {
     die(""Failed to allocate image."");
  }
 
   keyframe_interval = strtol(keyframe_interval_arg, NULL, 0);
 
    if (keyframe_interval < 0)
      die(""Invalid keyframe interval value."");
  
  printf(""Using %s\n"", vpx_codec_iface_name(encoder->interface()));
   printf(""Using %s\n"", vpx_codec_iface_name(encoder->codec_interface()));
  
  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);
   res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);
    if (res)
      die_codec(&codec, ""Failed to get default codec config."");
  
   cfg.g_w = info.frame_width;
   cfg.g_h = info.frame_height;
   cfg.g_timebase.num = info.time_base.numerator;
   cfg.g_timebase.den = info.time_base.denominator;
   cfg.rc_target_bitrate = bitrate;
   cfg.g_error_resilient = argc > 7 ? strtol(argv[7], NULL, 0) : 0;
 
   writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);
  if (!writer)
     die(""Failed to open %s for writing."", outfile_arg);
 
 
    if (!(infile = fopen(infile_arg, ""rb"")))
      die(""Failed to open %s for reading."", infile_arg);
  
  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))
   if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))
      die_codec(&codec, ""Failed to initialize encoder"");
  
    
    while (vpx_img_read(&raw, infile)) {
      int flags = 0;
      if (keyframe_interval > 0 && frame_count % keyframe_interval == 0)
        flags |= VPX_EFLAG_FORCE_KF;
      encode_frame(&codec, &raw, frame_count++, flags, writer);
    }
  encode_frame(&codec, NULL, -1, 0, writer);   
 
    
   while (encode_frame(&codec, NULL, -1, 0, writer)) {};
  
    printf(""\n"");
    fclose(infile);
   printf(""Processed %d frames.\n"", frame_count);
 
   vpx_img_free(&raw);
  if (vpx_codec_destroy(&codec))
     die_codec(&codec, ""Failed to destroy codec."");
 
   vpx_video_writer_close(writer);
 
  return EXIT_SUCCESS;
 }","[62, 65, 85, 88, 96, 97, 98, 61, 64, 84, 95]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
200658," static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
  {
  	int result;
  	handle_t *handle = NULL;
	struct super_block *sb = file_inode(vma->vm_file)->i_sb;
 	struct inode *inode = file_inode(vma->vm_file);
 	struct super_block *sb = inode->i_sb;
  	bool write = vmf->flags & FAULT_FLAG_WRITE;
  
  	if (write) {
  		sb_start_pagefault(sb);
  		file_update_time(vma->vm_file);
 		down_read(&EXT4_I(inode)->i_mmap_sem);
  		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
  						EXT4_DATA_TRANS_BLOCKS(sb));
	}
 	} else
 		down_read(&EXT4_I(inode)->i_mmap_sem);
  
  	if (IS_ERR(handle))
  		result = VM_FAULT_SIGBUS;
 	else
 		result = __dax_fault(vma, vmf, ext4_get_block_dax,
 						ext4_end_io_unwritten);
 
  	if (write) {
  		if (!IS_ERR(handle))
  			ext4_journal_stop(handle);
 		up_read(&EXT4_I(inode)->i_mmap_sem);
  		sb_end_pagefault(sb);
	}
 	} else
 		up_read(&EXT4_I(inode)->i_mmap_sem);
  
  	return result;
  }","[6, 7, 13, 17, 18, 29, 32, 33, 5, 16, 31]",Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.
201187," gss_export_sec_context(minor_status,
                        context_handle,
                        interprocess_token)
 
 OM_uint32 *		minor_status;
 gss_ctx_id_t *		context_handle;
 gss_buffer_t		interprocess_token;
 
 {
     OM_uint32		status;
     OM_uint32 		length;
     gss_union_ctx_id_t	ctx = NULL;
     gss_mechanism	mech;
     gss_buffer_desc	token = GSS_C_EMPTY_BUFFER;
     char		*buf;
 
     status = val_exp_sec_ctx_args(minor_status,
 				  context_handle, interprocess_token);
     if (status != GSS_S_COMPLETE)
 	return (status);
 
      
  
      ctx = (gss_union_ctx_id_t) *context_handle;
     if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
 	return (GSS_S_NO_CONTEXT);
      mech = gssint_get_mechanism (ctx->mech_type);
      if (!mech)
  	return GSS_S_BAD_MECH;
     if (!mech->gss_export_sec_context)
 	return (GSS_S_UNAVAILABLE);
 
     status = mech->gss_export_sec_context(minor_status,
 					  &ctx->internal_ctx_id, &token);
     if (status != GSS_S_COMPLETE) {
 	map_error(minor_status, mech);
 	goto cleanup;
     }
 
     length = token.length + 4 + ctx->mech_type->length;
     interprocess_token->length = length;
     interprocess_token->value = malloc(length);
     if (interprocess_token->value == 0) {
 	*minor_status = ENOMEM;
 	status = GSS_S_FAILURE;
 	goto cleanup;
     }
     buf = interprocess_token->value;
     length = ctx->mech_type->length;
     buf[3] = (unsigned char) (length & 0xFF);
     length >>= 8;
     buf[2] = (unsigned char) (length & 0xFF);
     length >>= 8;
     buf[1] = (unsigned char) (length & 0xFF);
     length >>= 8;
     buf[0] = (unsigned char) (length & 0xFF);
     memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);
     memcpy(buf+4+ctx->mech_type->length, token.value, token.length);
 
     status = GSS_S_COMPLETE;
 
 cleanup:
     (void) gss_release_buffer(minor_status, &token);
     if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {
 	 
 	free(ctx->mech_type->elements);
 	free(ctx->mech_type);
 	free(ctx);
 	*context_handle = GSS_C_NO_CONTEXT;
     }
     return status;
 }","[25, 26]",Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.
203963,"    virtual bool SetImeConfig(const std::string& section,
                              const std::string& config_name,
                            const ImeConfigValue& value) {
                             const input_method::ImeConfigValue& value) {
      return false;
    }","[4, 3]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
205634," void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,
                                         const VisiblePosition& extent_position,
                                         TextGranularity granularity) {
   SelectionInDOMTree new_selection =
       SelectionInDOMTree::Builder()
            .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),
                                        extent_position.DeepEquivalent())
            .SetAffinity(base_position.Affinity())
          .SetIsHandleVisible(IsHandleVisible())
            .Build();
  
    if (new_selection.IsNone())
     return;
 
   const VisibleSelection& visible_selection =
       CreateVisibleSelectionWithGranularity(new_selection, granularity);
   if (visible_selection.IsNone())
     return;
 
   SelectionInDOMTree::Builder builder;
   if (visible_selection.IsBaseFirst()) {
     builder.SetBaseAndExtent(visible_selection.Start(),
                              visible_selection.End());
   } else {
     builder.SetBaseAndExtent(visible_selection.End(),
                               visible_selection.Start());
    }
    builder.SetAffinity(visible_selection.Affinity());
  builder.SetIsHandleVisible(IsHandleVisible());
    SetSelection(builder.Build(), SetSelectionData::Builder()
                                      .SetShouldCloseTyping(true)
                                      .SetShouldClearTypingStyle(true)
                                      .SetGranularity(granularity)
                                     .SetShouldShowHandle(IsHandleVisible())
                                      .Build());
  }","[34, 9, 29]","The convolution implementation in Skia, as used in Google Chrome before 47.0.2526.73, does not properly constrain row lengths, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via crafted graphics data."
199223," int iscsi_decode_text_input(
 	u8 phase,
 	u8 sender,
 	char *textbuf,
 	u32 length,
 	struct iscsi_conn *conn)
 {
 	struct iscsi_param_list *param_list = conn->param_list;
 	char *tmpbuf, *start = NULL, *end = NULL;
 
 	tmpbuf = kzalloc(length + 1, GFP_KERNEL);
 	if (!tmpbuf) {
 		pr_err(""Unable to allocate memory for tmpbuf.\n"");
 		return -1;
 	}
 
 	memcpy(tmpbuf, textbuf, length);
 	tmpbuf[length] = '\0';
 	start = tmpbuf;
 	end = (start + length);
 
 	while (start < end) {
 		char *key, *value;
 		struct iscsi_param *param;
 
 		if (iscsi_extract_key_value(start, &key, &value) < 0) {
 			kfree(tmpbuf);
 			return -1;
 		}
 
 		pr_debug(""Got key: %s=%s\n"", key, value);
  
  		if (phase & PHASE_SECURITY) {
  			if (iscsi_check_for_auth_key(key) > 0) {
				char *tmpptr = key + strlen(key);
				*tmpptr = '=';
  				kfree(tmpbuf);
  				return 1;
  			}
 		}
 
 		param = iscsi_check_key(key, phase, sender, param_list);
 		if (!param) {
 			if (iscsi_add_notunderstood_response(key,
 					value, param_list) < 0) {
 				kfree(tmpbuf);
 				return -1;
 			}
 			start += strlen(key) + strlen(value) + 2;
 			continue;
 		}
 		if (iscsi_check_value(param, value) < 0) {
 			kfree(tmpbuf);
 			return -1;
 		}
 
 		start += strlen(key) + strlen(value) + 2;
 
 		if (IS_PSTATE_PROPOSER(param)) {
 			if (iscsi_check_proposer_state(param, value) < 0) {
 				kfree(tmpbuf);
 				return -1;
 			}
 			SET_PSTATE_RESPONSE_GOT(param);
 		} else {
 			if (iscsi_check_acceptor_state(param, value, conn) < 0) {
 				kfree(tmpbuf);
 				return -1;
 			}
 			SET_PSTATE_ACCEPTOR(param);
 		}
 	}
 
 	kfree(tmpbuf);
 	return 0;
 }","[35, 36]",Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.
199206," static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 			     struct msghdr *msg, size_t len, int flags)
 {
 	int noblock = flags & MSG_DONTWAIT;
 	struct sock *sk = sock->sk;
 	unsigned int copied, rlen;
 	struct sk_buff *skb, *cskb;
 	int err = 0;
  
  	pr_debug(""%p %zu\n"", sk, len);
  
 	msg->msg_namelen = 0;
 
  	lock_sock(sk);
  
  	if (sk->sk_state == LLCP_CLOSED &&
 	    skb_queue_empty(&sk->sk_receive_queue)) {
 		release_sock(sk);
 		return 0;
 	}
 
 	release_sock(sk);
 
 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		pr_err(""Recv datagram failed state %d %d %d"",
 		       sk->sk_state, err, sock_error(sk));
 
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 
 		return err;
 	}
 
 	rlen = skb->len;		 
 	copied = min_t(unsigned int, rlen, len);
 
 	cskb = skb;
 	if (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {
 		if (!(flags & MSG_PEEK))
 			skb_queue_head(&sk->sk_receive_queue, skb);
 		return -EFAULT;
 	}
 
 	sock_recv_timestamp(msg, sk, skb);
 
 	if (sk->sk_type == SOCK_DGRAM && msg->msg_name) {
 		struct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);
 		struct sockaddr_nfc_llcp *sockaddr =
 			(struct sockaddr_nfc_llcp *) msg->msg_name;
 
 		msg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);
  
  		pr_debug(""Datagram socket %d %d\n"", ui_cb->dsap, ui_cb->ssap);
  
 		memset(sockaddr, 0, sizeof(*sockaddr));
  		sockaddr->sa_family = AF_NFC;
  		sockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;
  		sockaddr->dsap = ui_cb->dsap;
 		sockaddr->ssap = ui_cb->ssap;
 	}
 
 	 
 	if (!(flags & MSG_PEEK)) {
 
 		 
 		if (sk->sk_type == SOCK_STREAM ||
 		    sk->sk_type == SOCK_DGRAM ||
 		    sk->sk_type == SOCK_RAW) {
 			skb_pull(skb, copied);
 			if (skb->len) {
 				skb_queue_head(&sk->sk_receive_queue, skb);
 				goto done;
 			}
 		}
 
 		kfree_skb(skb);
 	}
 
 	 
 
 done:
 	 
 	if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))
 		copied = rlen;
 
 	return copied;
 }","[12, 13, 59]","The llcp_sock_recvmsg function in net/nfc/llcp/sock.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable and a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
205820," void UtilityServiceFactory::RegisterServices(ServiceMap* services) {
   GetContentClient()->utility()->RegisterServices(services);
 
   service_manager::EmbeddedServiceInfo video_capture_info;
   video_capture_info.factory = base::Bind(&CreateVideoCaptureService);
   services->insert(
       std::make_pair(video_capture::mojom::kServiceName, video_capture_info));
  
  #if BUILDFLAG(ENABLE_PEPPER_CDMS)
    service_manager::EmbeddedServiceInfo info;
  info.factory = base::Bind(&CreateMediaService);
  services->insert(std::make_pair(media::mojom::kMediaServiceName, info));
   info.factory = base::Bind(&CreateCdmService);
   services->insert(std::make_pair(media::mojom::kCdmServiceName, info));
  #endif
  
    service_manager::EmbeddedServiceInfo shape_detection_info;
   shape_detection_info.factory =
       base::Bind(&shape_detection::ShapeDetectionService::Create);
   services->insert(std::make_pair(shape_detection::mojom::kServiceName,
                                   shape_detection_info));
 
   service_manager::EmbeddedServiceInfo data_decoder_info;
   data_decoder_info.factory = base::Bind(&CreateDataDecoderService);
   services->insert(
       std::make_pair(data_decoder::mojom::kServiceName, data_decoder_info));
 
   if (base::FeatureList::IsEnabled(features::kNetworkService)) {
     GetContentClient()->utility()->RegisterNetworkBinders(
         network_registry_.get());
     service_manager::EmbeddedServiceInfo network_info;
     network_info.factory = base::Bind(
         &UtilityServiceFactory::CreateNetworkService, base::Unretained(this));
     network_info.task_runner = ChildProcess::current()->io_task_runner();
     services->insert(
         std::make_pair(content::mojom::kNetworkServiceName, network_info));
   }
 }","[13, 14, 11, 12]","SkPictureShader.cpp in Skia, as used in Google Chrome before 44.0.2403.89, allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging access to a renderer process and providing crafted serialized data."
201157," static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,
   Image **image,ExceptionInfo *exception)
 {
   char
     message[MagickPathExtent];
 
   Image
     *msl_image;
 
   int
     status;
 
   ssize_t
     n;
 
   MSLInfo
     msl_info;
 
   xmlSAXHandler
     sax_modules;
 
   xmlSAXHandlerPtr
     sax_handler;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(image != (Image **) NULL);
   msl_image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       ThrowFileException(exception,FileOpenError,""UnableToOpenFile"",
         msl_image->filename);
       msl_image=DestroyImageList(msl_image);
       return(MagickFalse);
     }
   msl_image->columns=1;
   msl_image->rows=1;
    
   (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));
   msl_info.exception=exception;
   msl_info.image_info=(ImageInfo **) AcquireMagickMemory(
     sizeof(*msl_info.image_info));
   msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(
     sizeof(*msl_info.draw_info));
    
   msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));
   msl_info.attributes=(Image **) AcquireMagickMemory(
     sizeof(*msl_info.attributes));
   msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(
     sizeof(*msl_info.group_info));
   if ((msl_info.image_info == (ImageInfo **) NULL) ||
       (msl_info.image == (Image **) NULL) ||
       (msl_info.attributes == (Image **) NULL) ||
       (msl_info.group_info == (MSLGroupInfo *) NULL))
     ThrowFatalException(ResourceLimitFatalError,""UnableToInterpretMSLImage"");
   *msl_info.image_info=CloneImageInfo(image_info);
   *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
   *msl_info.attributes=AcquireImage(image_info,exception);
   msl_info.group_info[0].numImages=0;
    
   *msl_info.image=msl_image;
   if (*image != (Image *) NULL)
     MSLPushImage(&msl_info,*image);
   (void) xmlSubstituteEntitiesDefault(1);
   (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));
   sax_modules.internalSubset=MSLInternalSubset;
   sax_modules.isStandalone=MSLIsStandalone;
   sax_modules.hasInternalSubset=MSLHasInternalSubset;
   sax_modules.hasExternalSubset=MSLHasExternalSubset;
   sax_modules.resolveEntity=MSLResolveEntity;
   sax_modules.getEntity=MSLGetEntity;
   sax_modules.entityDecl=MSLEntityDeclaration;
   sax_modules.notationDecl=MSLNotationDeclaration;
   sax_modules.attributeDecl=MSLAttributeDeclaration;
   sax_modules.elementDecl=MSLElementDeclaration;
   sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;
   sax_modules.setDocumentLocator=MSLSetDocumentLocator;
   sax_modules.startDocument=MSLStartDocument;
   sax_modules.endDocument=MSLEndDocument;
   sax_modules.startElement=MSLStartElement;
   sax_modules.endElement=MSLEndElement;
   sax_modules.reference=MSLReference;
   sax_modules.characters=MSLCharacters;
   sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;
   sax_modules.processingInstruction=MSLProcessingInstructions;
   sax_modules.comment=MSLComment;
   sax_modules.warning=MSLWarning;
   sax_modules.error=MSLError;
   sax_modules.fatalError=MSLError;
   sax_modules.getParameterEntity=MSLGetParameterEntity;
   sax_modules.cdataBlock=MSLCDataBlock;
   sax_modules.externalSubset=MSLExternalSubset;
   sax_handler=(&sax_modules);
   msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,
     msl_image->filename);
   while (ReadBlobString(msl_image,message) != (char *) NULL)
   {
     n=(ssize_t) strlen(message);
     if (n == 0)
       continue;
     status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);
     if (status != 0)
       break;
     (void) xmlParseChunk(msl_info.parser,"" "",1,MagickFalse);
     if (msl_info.exception->severity >= ErrorException)
       break;
    }
    if (msl_info.exception->severity == UndefinedException)
      (void) xmlParseChunk(msl_info.parser,"" "",1,MagickTrue);
    
    xmlFreeParserCtxt(msl_info.parser);
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""end SAX"");
    msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(
      msl_info.group_info);
    if (*image == (Image *) NULL)
      *image=(*msl_info.image);
   *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);
   msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(
     msl_info.image_info);
   *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);
   msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);
   msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);
   *msl_info.attributes=DestroyImage(*msl_info.attributes);
   msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);
   msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(
     msl_info.group_info);
    if (msl_info.exception->severity != UndefinedException)
      return(MagickFalse);
    return(MagickTrue);
 }","[115, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131]","The ProcessMSLScript function in coders/msl.c in ImageMagick before 6.9.9-5 and 7.x before 7.0.6-5 allows remote attackers to cause a denial of service (memory leak) via a crafted file, related to the WriteMSLImage function."
201380," static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 {
  	struct cp2112_device *dev = gpiochip_get_data(chip);
  	struct hid_device *hdev = dev->hdev;
  	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
  	int ret;
  
	spin_lock_irqsave(&dev->lock, flags);
 	mutex_lock(&dev->lock);
  
  	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
  				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
 				 HID_REQ_GET_REPORT);
 	if (ret != CP2112_GPIO_CONFIG_LENGTH) {
 		hid_err(hdev, ""error requesting GPIO config: %d\n"", ret);
 		goto exit;
 	}
 
 	buf[1] &= ~(1 << offset);
 	buf[2] = gpio_push_pull;
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
 				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
 				 HID_REQ_SET_REPORT);
 	if (ret < 0) {
 		hid_err(hdev, ""error setting GPIO config: %d\n"", ret);
 		goto exit;
 	}
 
  	ret = 0;
  
  exit:
	spin_unlock_irqrestore(&dev->lock, flags);
 	mutex_unlock(&dev->lock);
  	return ret <= 0 ? ret : -EIO;
  }","[10, 35, 6, 9, 34]","drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors."
204958," void WebURLLoaderImpl::Context::OnReceivedResponse(
     const ResourceResponseInfo& info) {
   if (!client_)
     return;
 
   WebURLResponse response;
   response.initialize();
   PopulateURLResponse(request_.url(), info, &response);
 
   bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");
 
   if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
     if (show_raw_listing) {
       response.setMIMEType(""text/plain"");
     } else {
       response.setMIMEType(""text/html"");
      }
    }
  
   scoped_refptr<Context> protect(this);
    client_->didReceiveResponse(loader_, response);
  
   if (!client_)
     return;
 
   DCHECK(!ftp_listing_delegate_.get());
   DCHECK(!multipart_delegate_.get());
   if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
     std::string content_type;
     info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);
 
     std::string mime_type;
     std::string charset;
     bool had_charset = false;
     std::string boundary;
     net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                     &had_charset, &boundary);
     TrimString(boundary, "" \"""", &boundary);
 
     if (!boundary.empty()) {
       multipart_delegate_.reset(
           new MultipartResponseDelegate(client_, loader_, response, boundary));
     }
   } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
              !show_raw_listing) {
     ftp_listing_delegate_.reset(
         new FtpDirectoryListingResponseDelegate(client_, loader_, response));
   }
 }",[20],Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving a 404 HTTP status code during the loading of resources.
201967," static Image *ReadWPGImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   typedef struct
   {
     size_t FileId;
     MagickOffsetType DataOffset;
     unsigned int ProductType;
     unsigned int FileType;
     unsigned char MajorVersion;
     unsigned char MinorVersion;
     unsigned int EncryptKey;
     unsigned int Reserved;
   } WPGHeader;
 
   typedef struct
   {
     unsigned char RecType;
     size_t RecordLength;
   } WPGRecord;
 
   typedef struct
   {
     unsigned char Class;
     unsigned char RecType;
     size_t Extension;
     size_t RecordLength;
   } WPG2Record;
 
   typedef struct
   {
     unsigned  HorizontalUnits;
     unsigned  VerticalUnits;
     unsigned char PosSizePrecision;
   } WPG2Start;
 
   typedef struct
   {
     unsigned int Width;
     unsigned int Height;
     unsigned int Depth;
     unsigned int HorzRes;
     unsigned int VertRes;
   } WPGBitmapType1;
 
   typedef struct
   {
     unsigned int Width;
     unsigned int Height;
     unsigned char Depth;
     unsigned char Compression;
   } WPG2BitmapType1;
 
   typedef struct
   {
     unsigned int RotAngle;
     unsigned int LowLeftX;
     unsigned int LowLeftY;
     unsigned int UpRightX;
     unsigned int UpRightY;
     unsigned int Width;
     unsigned int Height;
     unsigned int Depth;
     unsigned int HorzRes;
     unsigned int VertRes;
   } WPGBitmapType2;
 
   typedef struct
   {
     unsigned int StartIndex;
     unsigned int NumOfEntries;
   } WPGColorMapRec;
 
    
 
   Image
     *image;
 
   unsigned int
     status;
 
   WPGHeader
     Header;
 
   WPGRecord
     Rec;
 
   WPG2Record
     Rec2;
 
   WPG2Start StartWPG;
 
   WPGBitmapType1
     BitmapHeader1;
 
   WPG2BitmapType1
     Bitmap2Header1;
 
   WPGBitmapType2
     BitmapHeader2;
 
   WPGColorMapRec
     WPG_Palette;
 
   int
     i,
     bpp,
     WPG2Flags;
 
   ssize_t
     ldblk;
 
   size_t
     one;
 
   unsigned char
     *BImgBuff;
 
   tCTM CTM;          
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   one=1;
   image=AcquireImage(image_info,exception);
   image->depth=8;
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   Header.FileId=ReadBlobLSBLong(image);
   Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);
   Header.ProductType=ReadBlobLSBShort(image);
   Header.FileType=ReadBlobLSBShort(image);
   Header.MajorVersion=ReadBlobByte(image);
   Header.MinorVersion=ReadBlobByte(image);
   Header.EncryptKey=ReadBlobLSBShort(image);
   Header.Reserved=ReadBlobLSBShort(image);
 
   if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if (Header.EncryptKey!=0)
     ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported"");
 
   image->columns = 1;
   image->rows = 1;
   image->colors = 0;
   bpp=0;
   BitmapHeader2.RotAngle=0;
 
   switch(Header.FileType)
     {
     case 1:      
       while(!EOFBlob(image))  
         {
           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
           if(EOFBlob(image))
             break;
 
           Rec.RecType=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec.RecordLength);
           if(EOFBlob(image))
             break;
 
           Header.DataOffset=TellBlob(image)+Rec.RecordLength;
 
           switch(Rec.RecType)
             {
             case 0x0B:  
               BitmapHeader1.Width=ReadBlobLSBShort(image);
               BitmapHeader1.Height=ReadBlobLSBShort(image);
               if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))
                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
               BitmapHeader1.Depth=ReadBlobLSBShort(image);
               BitmapHeader1.HorzRes=ReadBlobLSBShort(image);
               BitmapHeader1.VertRes=ReadBlobLSBShort(image);
 
               if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)
                 {
                   image->units=PixelsPerCentimeterResolution;
                   image->resolution.x=BitmapHeader1.HorzRes/470.0;
                   image->resolution.y=BitmapHeader1.VertRes/470.0;
                 }
               image->columns=BitmapHeader1.Width;
               image->rows=BitmapHeader1.Height;
               bpp=BitmapHeader1.Depth;
 
               goto UnpackRaster;
 
             case 0x0E:   
               WPG_Palette.StartIndex=ReadBlobLSBShort(image);
               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
 
               image->colors=WPG_Palette.NumOfEntries;
               if (!AcquireImageColormap(image,image->colors,exception))
                 goto NoMemory;
               for (i=WPG_Palette.StartIndex;
                    i < (int)WPG_Palette.NumOfEntries; i++)
                 {
                   image->colormap[i].red=ScaleCharToQuantum((unsigned char)
                     ReadBlobByte(image));
                   image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                     ReadBlobByte(image));
                   image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
                     ReadBlobByte(image));
                 }
               break;
      
             case 0x11:   
               if(Rec.RecordLength > 8)
                 image=ExtractPostscript(image,image_info,
                   TellBlob(image)+8,    
                   (ssize_t) Rec.RecordLength-8,exception);
               break;     
 
             case 0x14:   
               BitmapHeader2.RotAngle=ReadBlobLSBShort(image);
               BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);
               BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);
               BitmapHeader2.UpRightX=ReadBlobLSBShort(image);
               BitmapHeader2.UpRightY=ReadBlobLSBShort(image);
               BitmapHeader2.Width=ReadBlobLSBShort(image);
               BitmapHeader2.Height=ReadBlobLSBShort(image);
               if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))
                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
               BitmapHeader2.Depth=ReadBlobLSBShort(image);
               BitmapHeader2.HorzRes=ReadBlobLSBShort(image);
               BitmapHeader2.VertRes=ReadBlobLSBShort(image);
 
               image->units=PixelsPerCentimeterResolution;
               image->page.width=(unsigned int)
                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);
               image->page.height=(unsigned int)
                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);
               image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);
               image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);
               if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)
                 {
                   image->resolution.x=BitmapHeader2.HorzRes/470.0;
                   image->resolution.y=BitmapHeader2.VertRes/470.0;
                 }
               image->columns=BitmapHeader2.Width;
               image->rows=BitmapHeader2.Height;
               bpp=BitmapHeader2.Depth;
 
             UnpackRaster:      
               if ((image->colors == 0) && (bpp != 24))
                 {
                   image->colors=one << bpp;
                   if (!AcquireImageColormap(image,image->colors,exception))
                     {
                     NoMemory:
                       ThrowReaderException(ResourceLimitError,
                         ""MemoryAllocationFailed"");
                     }
                    
                   for (i=0; (i < (int) image->colors) && (i < 256); i++)
                     {               
                       image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);
                       image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);
                       image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);
                     }
                 }
               else
                 {
                   if (bpp < 24)
                     if ( (image->colors < (one << bpp)) && (bpp != 24) )
                       image->colormap=(PixelInfo *) ResizeQuantumMemory(
                         image->colormap,(size_t) (one << bpp),
                         sizeof(*image->colormap));
                 }
           
               if (bpp == 1)
                 {
                   if(image->colormap[0].red==0 &&
                      image->colormap[0].green==0 &&
                      image->colormap[0].blue==0 &&
                      image->colormap[1].red==0 &&
                      image->colormap[1].green==0 &&
                      image->colormap[1].blue==0)
                     {   
                       image->colormap[1].red =
                         image->colormap[1].green =
                         image->colormap[1].blue = QuantumRange;
                     }
                 }      
 
               if(UnpackWPGRaster(image,bpp,exception) < 0)
                  
                 {
                 DecompressionFailed:
                   ThrowReaderException(CoderError,""UnableToDecompressImage"");
                     }
 
               if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)
                 {  
                    
                   if(BitmapHeader2.RotAngle & 0x8000)
                     {
                       Image
                         *flop_image;
 
                       flop_image = FlopImage(image, exception);
                       if (flop_image != (Image *) NULL) {
                         DuplicateBlob(flop_image,image);
                         (void) RemoveLastImageFromList(&image);
                         AppendImageToList(&image,flop_image);
                       }
                     }
                    
                   if(BitmapHeader2.RotAngle & 0x2000)
                     {
                       Image
                         *flip_image;
 
                       flip_image = FlipImage(image, exception);
                       if (flip_image != (Image *) NULL) {
                         DuplicateBlob(flip_image,image);
                         (void) RemoveLastImageFromList(&image);
                         AppendImageToList(&image,flip_image);    
                       }
                     }
     
        
                   if(BitmapHeader2.RotAngle & 0x0FFF)
                     {
                       Image
                         *rotate_image;
 
                       rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &
                         0x0FFF), exception);
                       if (rotate_image != (Image *) NULL) {
                         DuplicateBlob(rotate_image,image);
                         (void) RemoveLastImageFromList(&image);
                         AppendImageToList(&image,rotate_image);    
                       }
                     }                
                 }
 
                
               AcquireNextImage(image_info,image,exception);
               image->depth=8;
               if (image->next == (Image *) NULL)
                 goto Finish;
               image=SyncNextImageInList(image);
               image->columns=image->rows=0;
               image->colors=0;
               break;
 
             case 0x1B:   
               if(Rec.RecordLength>0x3C)
                 image=ExtractPostscript(image,image_info,
                   TellBlob(image)+0x3C,    
                   (ssize_t) Rec.RecordLength-0x3C,exception);
               break;
             }
         }
       break;
 
     case 2:   
       (void) memset(CTM,0,sizeof(CTM));
       StartWPG.PosSizePrecision = 0;
       while(!EOFBlob(image))  
         {
           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
           if(EOFBlob(image))
             break;
 
           Rec2.Class=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rec2.RecType=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec2.Extension);
           Rd_WP_DWORD(image,&Rec2.RecordLength);
           if(EOFBlob(image))
             break;
 
           Header.DataOffset=TellBlob(image)+Rec2.RecordLength;
 
           switch(Rec2.RecType)
             {
       case 1:
               StartWPG.HorizontalUnits=ReadBlobLSBShort(image);
               StartWPG.VerticalUnits=ReadBlobLSBShort(image);
               StartWPG.PosSizePrecision=ReadBlobByte(image);
               break;
             case 0x0C:     
               WPG_Palette.StartIndex=ReadBlobLSBShort(image);
               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
 
               image->colors=WPG_Palette.NumOfEntries;
               if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
                 ThrowReaderException(ResourceLimitError,
                   ""MemoryAllocationFailed"");
               for (i=WPG_Palette.StartIndex;
                    i < (int)WPG_Palette.NumOfEntries; i++)
                 {
                   image->colormap[i].red=ScaleCharToQuantum((char)
                     ReadBlobByte(image));
                   image->colormap[i].green=ScaleCharToQuantum((char)
                     ReadBlobByte(image));
                   image->colormap[i].blue=ScaleCharToQuantum((char)
                     ReadBlobByte(image));
                   (void) ReadBlobByte(image);    
                 }
               break;
             case 0x0E:
               Bitmap2Header1.Width=ReadBlobLSBShort(image);
               Bitmap2Header1.Height=ReadBlobLSBShort(image);
               if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))
                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
               Bitmap2Header1.Depth=ReadBlobByte(image);
               Bitmap2Header1.Compression=ReadBlobByte(image);
 
               if(Bitmap2Header1.Compression > 1)
                 continue;  
               switch(Bitmap2Header1.Depth)
                 {
                 case 1:
                   bpp=1;
                   break;
                 case 2:
                   bpp=2;
                   break;
                 case 3:
                   bpp=4;
                   break;
                 case 4:
                   bpp=8;
                   break;
                 case 8:
                   bpp=24;
                   break;
                 default:
                   continue;   
                 }
               image->columns=Bitmap2Header1.Width;
               image->rows=Bitmap2Header1.Height;  
 
               if ((image->colors == 0) && (bpp != 24))
                 {
                   size_t
                     one;
 
                   one=1;
                   image->colors=one << bpp;
                   if (!AcquireImageColormap(image,image->colors,exception))
                     goto NoMemory;
                 }
               else
                 {
                   if(bpp < 24)
                     if( image->colors<(one << bpp) && bpp!=24 )
                       image->colormap=(PixelInfo *) ResizeQuantumMemory(
                        image->colormap,(size_t) (one << bpp),
                        sizeof(*image->colormap));
                 }
 
 
               switch(Bitmap2Header1.Compression)
                 {
                 case 0:     
                    {
                      ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                      BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                      ldblk,sizeof(*BImgBuff));
                       ldblk+1,sizeof(*BImgBuff));
                      if (BImgBuff == (unsigned char *) NULL)
                        goto NoMemory;
  
                     for(i=0; i< (ssize_t) image->rows; i++)
                       {
                         (void) ReadBlob(image,ldblk,BImgBuff);
                         InsertRow(image,BImgBuff,i,bpp,exception);
                       }
 
                     if(BImgBuff)
                       BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);;
                     break;
                   }
                 case 1:     
                   {
                     if( UnpackWPG2Raster(image,bpp,exception) < 0)
                       goto DecompressionFailed;
                     break;
                   }   
                 }
 
               if(CTM[0][0]<0 && !image_info->ping)
                 {     
                   Image
                     *flop_image;
 
                   flop_image = FlopImage(image, exception);
                   if (flop_image != (Image *) NULL) {
                     DuplicateBlob(flop_image,image);
                     (void) RemoveLastImageFromList(&image);
                     AppendImageToList(&image,flop_image);
                   }
                                      
                 }
               if(CTM[1][1]<0 && !image_info->ping)
                 {     
                   Image
                     *flip_image;
 
                    flip_image = FlipImage(image, exception);
                    if (flip_image != (Image *) NULL) {
                      DuplicateBlob(flip_image,image);
                      (void) RemoveLastImageFromList(&image);
                      AppendImageToList(&image,flip_image);
                     }
                          
               }    
     
 
                
               AcquireNextImage(image_info,image,exception);
               image->depth=8;
               if (image->next == (Image *) NULL)
                 goto Finish;
               image=SyncNextImageInList(image);
               image->columns=image->rows=1;
               image->colors=0;
               break;
 
             case 0x12:   
         i=ReadBlobLSBShort(image);
               if(Rec2.RecordLength > (unsigned int) i)
                 image=ExtractPostscript(image,image_info,
                   TellBlob(image)+i,     
                   (ssize_t) (Rec2.RecordLength-i-2),exception);
               break;
 
       case 0x1B:           
               WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);
               (void) WPG2Flags;
               break;
             }
         }
 
       break;
 
     default:
       {
          ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
       }
    }
   status=SetImageExtent(image,image->columns,image->rows,exception);
   if (status == MagickFalse)
     return(DestroyImageList(image));
 
  Finish:
   (void) CloseBlob(image);
 
   {
     Image
       *p;
 
     ssize_t
       scene=0;
 
      
     p=image;
     image=NULL;
     while (p != (Image *) NULL)
       {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
           p=p->previous;
         }
       }
      
     for (p=image; p != (Image *) NULL; p=p->next)
       p->scene=(size_t) scene++;
   }
   if (image == (Image *) NULL)
     ThrowReaderException(CorruptImageError,
       ""ImageFileDoesNotContainAnyImageData"");
   return(image);
 }","[476, 475]",The ReadWPGImage function in coders/wpg.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted WPG file.
4975,"static bool parseOperands(char* str, ArmOp *op) {
char *t = strdup (str);
int operand = 0;
char *token = t;
char *x;
int imm_count = 0;
int mem_opt = 0;
if (!token) {
return false;
}

while (token) {
char *next = strchr (token, ',');
if (next) {
*next++ = 0;
}
while (token[0] == ' ') {
token++;
}
op->operands[operand].type = ARM_NOTYPE;
op->operands[operand].reg_type = ARM_UNDEFINED;
op->operands[operand].shift = ARM_NO_SHIFT;

while (token[0] == ' ' || token[0] == '[' || token[0] == ']') {
token ++;
}

if (!strncmp (token, ""lsl"", 3)) {
op->operands[operand].shift = ARM_LSL;
} else if (!strncmp (token, ""lsr"", 3)) {
op->operands[operand].shift = ARM_LSR;
} else if (!strncmp (token, ""asr"", 3)) {
op->operands[operand].shift = ARM_ASR;
}
if (op->operands[operand].shift != ARM_NO_SHIFT) {
op->operands_count ++;
op->operands[operand].shift_amount = r_num_math (NULL, token + 4);
if (op->operands[operand].shift_amount > 63) {
return false;
}
operand ++;
token = next;
continue;
}

switch (token[0]) {
case 'x':
x = strchr (token, ',');
if (x) {
x[0] = '\0';
}
op->operands_count ++;
op->operands[operand].type = ARM_GPR;
op->operands[operand].reg_type = ARM_REG64;
op->operands[operand].reg = r_num_math (NULL, token + 1);
if (op->operands[operand].reg > 31) {
return false;
}
break;
case 'w':
op->operands_count ++;
op->operands[operand].type = ARM_GPR;
op->operands[operand].reg_type = ARM_REG32;
op->operands[operand].reg = r_num_math (NULL, token + 1);
if (op->operands[operand].reg > 31) {
return false;
}
break;
case 'v':
op->operands_count ++;
op->operands[operand].type = ARM_FP;
op->operands[operand].reg = r_num_math (NULL, token + 1);
break;
case 's':
case 'S':
if (token[1] == 'P' || token [1] == 'p') {
int i;
for (i = 0; msr_const[i].name; i++) {
if (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {
op->operands[operand].sp_val = msr_const[i].val;
break;
}
}
op->operands_count ++;
op->operands[operand].type = ARM_GPR;
op->operands[operand].reg_type = ARM_SP | ARM_REG64;
op->operands[operand].reg = 31;
break;
}
mem_opt = get_mem_option (token);
if (mem_opt != -1) {
op->operands_count ++;
op->operands[operand].type = ARM_MEM_OPT;
op->operands[operand].mem_option = mem_opt;
}
break;
case 'L':
case 'l':
case 'I':
case 'i':
case 'N':
case 'n':
case 'O':
case 'o':
case 'p':
case 'P':
mem_opt = get_mem_option (token);
if (mem_opt != -1) {
op->operands_count ++;
op->operands[operand].type = ARM_MEM_OPT;
op->operands[operand].mem_option = mem_opt;
}
break;
case '-':
op->operands[operand].sign = -1;

default:
op->operands_count ++;
op->operands[operand].type = ARM_CONSTANT;
op->operands[operand].immediate = r_num_math (NULL, token);
imm_count++;
break;
}
token = next;

operand ++;
if (operand > MAX_OPERANDS) {
free (t);
return false;
}
}
free (t);
return true;
}",[20],"In radare2 prior to 3.1.2, the parseOperands function in libr/asm/arch/arm/armass64.c allows attackers to cause a denial-of-service (application crash caused by stack-based buffer overflow) by crafting an input file."
202610,"  int test(char *URL)
  {
   int errors = 0;
   (void)URL;  
 
   errors += test_weird_arguments();
 
   errors += test_unsigned_short_formatting();
 
   errors += test_signed_short_formatting();
 
   errors += test_unsigned_int_formatting();
 
   errors += test_signed_int_formatting();
 
   errors += test_unsigned_long_formatting();
 
   errors += test_signed_long_formatting();
 
   errors += test_curl_off_t_formatting();
  
    errors += test_string_formatting();
  
   errors += test_float_formatting();
 
    if(errors)
      return TEST_ERR_MAJOR_BAD;
    else
     return 0;
 }","[24, 25]","curl before version 7.52.0 is vulnerable to a buffer overflow when doing a large floating point output in libcurl's implementation of the printf() functions. If there are any application that accepts a format string from the outside without necessary input filtering, it could allow remote attacks."
206583," PageHandler::PageHandler(EmulationHandler* emulation_handler)
 PageHandler::PageHandler(EmulationHandler* emulation_handler,
                          bool allow_set_download_behavior)
      : DevToolsDomainHandler(Page::Metainfo::domainName),
        enabled_(false),
        screencast_enabled_(false),
       screencast_quality_(kDefaultScreenshotQuality),
       screencast_max_width_(-1),
       screencast_max_height_(-1),
       capture_every_nth_frame_(1),
       capture_retry_count_(0),
       has_compositor_frame_metadata_(false),
       session_id_(0),
       frame_counter_(0),
       frames_in_flight_(0),
       video_consumer_(nullptr),
        last_surface_size_(gfx::Size()),
        host_(nullptr),
        emulation_handler_(emulation_handler),
       allow_set_download_behavior_(allow_set_download_behavior),
        observer_(this),
        weak_factory_(this) {
    bool create_video_consumer = true;
 #ifdef OS_ANDROID
   if (!CompositorImpl::IsInitialized())
     create_video_consumer = false;
 #endif
   if (create_video_consumer) {
     video_consumer_ = std::make_unique<DevToolsVideoConsumer>(
         base::BindRepeating(&PageHandler::OnFrameFromVideoConsumer,
                             weak_factory_.GetWeakPtr()));
   }
   DCHECK(emulation_handler_);
 }","[2, 3, 20]",Inappropriate allowance of the setDownloadBehavior devtools protocol feature in Extensions in Google Chrome prior to 71.0.3578.80 allowed a remote attacker with control of an installed extension to access files on the local file system via a crafted Chrome Extension.
207799," void SoftMP3::onQueueFilled(OMX_U32  ) {
  if (mSignalledError || mOutputPortSettingsChange != NONE) {
  return;
  }
 
  List<BufferInfo *> &inQueue = getPortQueue(0);
  List<BufferInfo *> &outQueue = getPortQueue(1);
 
  while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {
  BufferInfo *inInfo = NULL;
         OMX_BUFFERHEADERTYPE *inHeader = NULL;
  if (!inQueue.empty()) {
             inInfo = *inQueue.begin();
             inHeader = inInfo->mHeader;
  }
 
  BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
         outHeader->nFlags = 0;
 
  if (inHeader) {
  if (inHeader->nOffset == 0 && inHeader->nFilledLen) {
                 mAnchorTimeUs = inHeader->nTimeStamp;
                 mNumFramesOutput = 0;
  }
 
  if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                 mSawInputEos = true;
  }
 
             mConfig->pInputBuffer =
                 inHeader->pBuffer + inHeader->nOffset;
 
             mConfig->inputBufferCurrentLength = inHeader->nFilledLen;
  } else {
             mConfig->pInputBuffer = NULL;
             mConfig->inputBufferCurrentLength = 0;
  }
         mConfig->inputBufferMaxLength = 0;
 
          mConfig->inputBufferUsedLength = 0;
  
          mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
         if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {
             ALOGE(""input buffer too small: got %lu, expected %u"",
                 outHeader->nAllocLen, mConfig->outputFrameSize);
             android_errorWriteLog(0x534e4554, ""27793371"");
             notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
             mSignalledError = true;
             return;
         }
  
          mConfig->pOutputBuffer =
              reinterpret_cast<int16_t *>(outHeader->pBuffer);
 
         ERROR_CODE decoderErr;
  if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))
  != NO_DECODING_ERROR) {
             ALOGV(""mp3 decoder returned error %d"", decoderErr);
 
  if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR
  && decoderErr != SIDE_INFO_ERROR) {
                 ALOGE(""mp3 decoder returned error %d"", decoderErr);
 
                 notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
                 mSignalledError = true;
  return;
  }
 
  if (mConfig->outputFrameSize == 0) {
                 mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
  }
 
  if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {
  if (!mIsFirst) {
                     outHeader->nOffset = 0;
                     outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);
 
                     memset(outHeader->pBuffer, 0, outHeader->nFilledLen);
  }
                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;
                 mSignalledOutputEos = true;
  } else {
 
                 ALOGV_IF(mIsFirst, ""insufficient data for first frame, sending silence"");
                 memset(outHeader->pBuffer,
  0,
                        mConfig->outputFrameSize * sizeof(int16_t));
 
  if (inHeader) {
                     mConfig->inputBufferUsedLength = inHeader->nFilledLen;
  }
  }
  } else if (mConfig->samplingRate != mSamplingRate
  || mConfig->num_channels != mNumChannels) {
             mSamplingRate = mConfig->samplingRate;
             mNumChannels = mConfig->num_channels;
 
             notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
             mOutputPortSettingsChange = AWAITING_DISABLED;
  return;
  }
 
  if (mIsFirst) {
             mIsFirst = false;
             outHeader->nOffset =
                 kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);
 
             outHeader->nFilledLen =
                 mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;
  } else if (!mSignalledOutputEos) {
             outHeader->nOffset = 0;
             outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);
  }
 
         outHeader->nTimeStamp =
             mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;
 
  if (inHeader) {
             CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);
 
             inHeader->nOffset += mConfig->inputBufferUsedLength;
             inHeader->nFilledLen -= mConfig->inputBufferUsedLength;
 
 
  if (inHeader->nFilledLen == 0) {
                 inInfo->mOwnedByUs = false;
                 inQueue.erase(inQueue.begin());
                 inInfo = NULL;
                 notifyEmptyBufferDone(inHeader);
                 inHeader = NULL;
  }
  }
 
         mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;
 
         outInfo->mOwnedByUs = false;
         outQueue.erase(outQueue.begin());
         outInfo = NULL;
         notifyFillBufferDone(outHeader);
         outHeader = NULL;
  }
 }","[44, 45, 46, 47, 48, 49, 50, 51]","mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate the relationship between allocated memory and the frame size, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27793371."
206743," Response ServiceWorkerHandler::DeliverPushMessage(
     const std::string& origin,
     const std::string& registration_id,
      const std::string& data) {
    if (!enabled_)
      return CreateDomainNotEnabledErrorResponse();
  if (!process_)
   if (!browser_context_)
      return CreateContextErrorResponse();
    int64_t id = 0;
    if (!base::StringToInt64(registration_id, &id))
      return CreateInvalidVersionIdErrorResponse();
    PushEventPayload payload;
    if (data.size() > 0)
      payload.setData(data);
  BrowserContext::DeliverPushMessage(process_->GetBrowserContext(),
                                     GURL(origin), id, payload,
                                     base::Bind(&PushDeliveryNoOp));
   BrowserContext::DeliverPushMessage(
       browser_context_, GURL(origin), id, payload,
       base::BindRepeating([](mojom::PushDeliveryStatus status) {}));
 
    return Response::OK();
  }","[8, 19, 20, 21, 22, 7, 16, 17, 18]",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
6388,"static int smtp_open(struct Connection *conn, bool esmtp)
{
int rc;

if (mutt_socket_open(conn))
return -1;


rc = smtp_get_resp(conn);
if (rc != 0)
return rc;

rc = smtp_helo(conn, esmtp);
if (rc != 0)
return rc;

#ifdef USE_SSL
enum QuadOption ans = MUTT_NO;
if (conn->ssf)
ans = MUTT_NO;
else if (C_SslForceTls)
ans = MUTT_YES;
else if ((Capabilities & SMTP_CAP_STARTTLS) &&
((ans = query_quadoption(C_SslStarttls,
_(""Secure connection with TLS?""))) == MUTT_ABORT))
{
return -1;
}

if (ans == MUTT_YES)
{
if (mutt_socket_send(conn, ""STARTTLS\r\n"") < 0)
return SMTP_ERR_WRITE;
rc = smtp_get_resp(conn);
if (rc != 0)
return rc;

if (mutt_ssl_starttls(conn))
{
mutt_error(_(""Could not negotiate TLS connection""));
return -1;
}


rc = smtp_helo(conn, esmtp);
if (rc != 0)
return rc;
}
#endif

if (conn->account.flags & MUTT_ACCT_USER)
{
if (!(Capabilities & SMTP_CAP_AUTH))
{
mutt_error(_(""SMTP server does not support authentication""));
return -1;
}

return smtp_auth(conn);
}

return 0;
}",[35],"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection."""
206842," void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,
                                        mojo::ScopedSharedBufferHandle handle) {
   DVLOG(1) << __func__ << "" buffer_id: "" << buffer_id;
   DCHECK(io_thread_checker_.CalledOnValidThread());
   DCHECK(handle.is_valid());
  
    base::SharedMemoryHandle memory_handle;
    size_t memory_size = 0;
  bool read_only_flag = false;
   mojo::UnwrappedSharedMemoryHandleProtection protection;
  
    const MojoResult result = mojo::UnwrapSharedMemoryHandle(
      std::move(handle), &memory_handle, &memory_size, &read_only_flag);
       std::move(handle), &memory_handle, &memory_size, &protection);
    DCHECK_EQ(MOJO_RESULT_OK, result);
    DCHECK_GT(memory_size, 0u);
  
    
    
    
 
    std::unique_ptr<base::SharedMemory> shm(
        new base::SharedMemory(memory_handle, true  ));
    if (!shm->Map(memory_size)) {
     DLOG(ERROR) << ""OnBufferCreated: Map failed."";
     return;
   }
   const bool inserted =
       client_buffers_
           .insert(std::make_pair(buffer_id,
                                  new ClientBuffer(std::move(shm), memory_size)))
           .second;
   DCHECK(inserted);
 }","[10, 14, 18, 19, 20, 21, 9, 13]",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
207584,"  int res_unpack(vorbis_info_residue *info,
		vorbis_info *vi,oggpack_buffer *opb){
                 vorbis_info *vi,oggpack_buffer *opb){
    int j,k;
    codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;
    memset(info,0,sizeof(*info));
 
   info->type=oggpack_read(opb,16);
  if(info->type>2 || info->type<0)goto errout;
   info->begin=oggpack_read(opb,24);
   info->end=oggpack_read(opb,24);
   info->grouping=oggpack_read(opb,24)+1;
   info->partitions=(char)(oggpack_read(opb,6)+1);
   info->groupbook=(unsigned char)oggpack_read(opb,8);
  if(info->groupbook>=ci->books)goto errout;
 
   info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));
   info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));
 
  for(j=0;j<info->partitions;j++){
  int cascade=oggpack_read(opb,3);
  if(oggpack_read(opb,1))
       cascade|=(oggpack_read(opb,5)<<3);
     info->stagemasks[j]=cascade;
  }
 
 
    for(j=0;j<info->partitions;j++){
      for(k=0;k<8;k++){
        if((info->stagemasks[j]>>k)&1){
	unsigned char book=(unsigned char)oggpack_read(opb,8);
	if(book>=ci->books)goto errout;
	info->stagebooks[j*8+k]=book;
	if(k+1>info->stages)info->stages=k+1;
         unsigned char book=(unsigned char)oggpack_read(opb,8);
         if(book>=ci->books)goto errout;
         info->stagebooks[j*8+k]=book;
         if(k+1>info->stages)info->stages=k+1;
        }else
	info->stagebooks[j*8+k]=0xff;
         info->stagebooks[j*8+k]=0xff;
      }
    }
  
  if(oggpack_eop(opb))goto errout;
 
  return 0;
  errout:
   res_clear_info(info);
  return 1;
 
  }","[3, 35, 36, 37, 38, 41, 2, 31, 32, 33, 34, 40]","Tremolo/res012.c in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate the number of partitions, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28556125."
207935," WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 u4_isdc,
                                                 UWORD32 u4_total_coeff_trail_one,  
  dec_bit_stream_t *ps_bitstrm )
 {
     UWORD32 u4_total_zeroes;
     WORD32 i;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
 
      UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
      UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
      UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
    WORD16 i2_level_arr[16];
      
      
      
     WORD16 ai2_level_arr[19]; 
     WORD16 *i2_level_arr = &ai2_level_arr[3];
  
      tu_sblk4x4_coeff_data_t *ps_tu_4x4;
      WORD16 *pi2_coeff_data;
  dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
 
     ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
     ps_tu_4x4->u2_sig_coeff_map = 0;
     pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
 
     i = u4_total_coeff - 1;
  if(u4_trailing_ones)
  {
   
   
   
   
         UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
         WORD16 (*ppi2_trlone_lkup)[3] =
  (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
         WORD16 *pi2_trlone_lkup;
 
         GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
 
         pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
 
  while(u4_cnt--)
             i2_level_arr[i--] = *pi2_trlone_lkup++;
  }
 
   
   
   
  if(i >= 0)
  {
   
   
   
   
         UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
         UWORD16 u2_lev_code, u2_abs_value;
         UWORD32 u4_lev_prefix;
 
  if(u4_trailing_ones < 3)
  {
   
   
   
   
   
   
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             u4_lev_suffix_size =
  (15 <= u4_lev_prefix) ? (u4_lev_prefix - 3) : 1;
 
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code = 2 + (MIN(u4_lev_prefix,15) << 1) + u4_lev_suffix;
 
  if(16 <= u4_lev_prefix)
  {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
  }
  }
  else
  {
   
   
   
   
   
   
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
   
   
   
             u2_lev_code = MIN(15, u4_lev_prefix);
 
             u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);
 
  if(14 == u4_lev_prefix)
                 u4_lev_suffix_size = 4;
  else if(15 <= u4_lev_prefix)
  {
                 u2_lev_code += 15;
                 u4_lev_suffix_size = (u4_lev_prefix - 3);
  }
  else
                 u4_lev_suffix_size = 0;
 
  if(16 <= u4_lev_prefix)
  {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
  }
  if(u4_lev_suffix_size)
  {
                 GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                         u4_lev_suffix_size);
                 u2_lev_code += u4_lev_suffix;
  }
  }
 
         u2_abs_value = (u2_lev_code + 2) >> 1;
   
   
   
         i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
         u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
 
   
   
   
  while(i >= 0)
  {
 
   
   
   
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             u4_lev_suffix_size =
  (15 <= u4_lev_prefix) ?
  (u4_lev_prefix - 3) : u4_suffix_len;
 
   
   
   
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
  + u4_lev_suffix;
 
  if(16 <= u4_lev_prefix)
  {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
  }
             u2_abs_value = (u2_lev_code + 2) >> 1;
 
   
   
   
             i2_level_arr[i--] =
  (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
   
   
   
             u4_suffix_len +=
  (u4_suffix_len < 6) ?
  (u2_abs_value
  > (3
  << (u4_suffix_len
  - 1))) :
  0;
  }
 
   
   
   
  }
 
  if(u4_total_coeff < (16 - u4_isdc))
  {
         UWORD32 u4_index;
  const UWORD8 (*ppu1_total_zero_lkup)[16] =
  (const UWORD8 (*)[16])gau1_ih264d_table_total_zero_11to15;
 
         NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 4);
         u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 11][u4_index];
 
         FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
         u4_total_zeroes &= 0xf;
  }
  else
         u4_total_zeroes = 0;
 
   
   
   
  {
  const UWORD8 *pu1_table_runbefore;
         UWORD32 u4_run;
         WORD32 k;
         UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
         WORD32 u4_zeroes_left = u4_total_zeroes;
         k = u4_total_coeff - 1;
 
   
   
   
         pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
  while((u4_zeroes_left > 0) && k)
  {
             UWORD32 u4_code;
             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
 
             u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
             u4_run = u4_code >> 2;
 
             FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
  *pi2_coeff_data++ = i2_level_arr[k--];
             u4_zeroes_left -= u4_run;
             u4_scan_pos -= (u4_run + 1);
  }
   
   
   
 
   
   
   
  if(u4_zeroes_left < 0)
  return -1;
  while(k >= 0)
  {
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
  *pi2_coeff_data++ = i2_level_arr[k--];
             u4_scan_pos--;
  }
  }
 
  {
         WORD32 offset;
         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
         offset = ALIGN4(offset);
         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
  }
 
     ps_bitstrm->u4_ofst = u4_bitstream_offset;
  return 0;
 }","[13, 14, 15, 16, 17, 12]","Multiple stack-based buffer underflows in decoder/ih264d_parse_cavlc.c in mediaserver in Android 6.x before 2016-04-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26399350."
206712,"   MediaStreamManagerTest()
       : thread_bundle_(content::TestBrowserThreadBundle::IO_MAINLOOP) {
     audio_manager_ = std::make_unique<MockAudioManager>();
     audio_system_ =
         std::make_unique<media::AudioSystemImpl>(audio_manager_.get());
     auto video_capture_provider = std::make_unique<MockVideoCaptureProvider>();
     video_capture_provider_ = video_capture_provider.get();
      media_stream_manager_ = std::make_unique<MediaStreamManager>(
          audio_system_.get(), audio_manager_->GetTaskRunner(),
          std::move(video_capture_provider));
     media_observer_ = std::make_unique<MockMediaObserver>();
     browser_content_client_ =
         std::make_unique<TestBrowserClient>(media_observer_.get());
     SetBrowserClientForTesting(browser_content_client_.get());
      base::RunLoop().RunUntilIdle();
  
      ON_CALL(*video_capture_provider_, DoGetDeviceInfosAsync(_))
         .WillByDefault(Invoke(
             [](VideoCaptureProvider::GetDeviceInfosCallback& result_callback) {
               std::vector<media::VideoCaptureDeviceInfo> stub_results;
               base::ResetAndReturn(&result_callback).Run(stub_results);
             }));
   }","[11, 12, 13, 14]",A stagnant permission prompt in Prompts in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to bypass permission policy via a crafted HTML page.
208179,"  void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
      if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", outHeader->nAllocLen, len);
         ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
          android_errorWriteLog(0x534e4554, ""29422022"");
          notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
          mSignalledError = true;
  return NULL;
  }
  return memset(outHeader->pBuffer, c, len);
 }","[4, 3]","Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022."
201941," static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
 {
 	int rlen, remain;
 	dpIOCtxPtr dctx;
 	dynamicPtr *dp;
 
 	dctx = (dpIOCtxPtr) ctx;
 	dp = dctx->dp;
 
 	remain = dp->logicalSize - dp->pos;
  	if(remain >= len) {
  		rlen = len;
  	} else {
		if(remain == 0) {
 		if(remain <= 0) {
  			 
 			return 0;  
 		}
 
 		rlen = remain;
 	}
 
 	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
 	dp->pos += rlen;
 
 	return rlen;
 }","[15, 14]","Integer signedness error in the dynamicGetbuf function in gd_io_dp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted imagecreatefromstring call."
201952," ossl_cipher_initialize(VALUE self, VALUE str)
 {
      EVP_CIPHER_CTX *ctx;
      const EVP_CIPHER *cipher;
      char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
  
      name = StringValueCStr(str);
      GetCipherInit(self, ctx);
     if (ctx) {
 	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
     }
     AllocCipher(self, ctx);
      if (!(cipher = EVP_get_cipherbyname(name))) {
  	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
      }
     
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
     if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
  	ossl_raise(eCipherError, NULL);
  
      return self;
 }","[19, 6, 17, 18]","The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism."
8353,"TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,
int axis, TfLiteTensor* output) {
const TfLiteIntArray& input_dims = *input.dims;
if (axis < 0) {
axis = input_dims.size + 1 + axis;
}
TF_LITE_ENSURE(context, axis <= input_dims.size);

TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);
for (int i = 0; i < output_dims->size; ++i) {
if (i < axis) {
output_dims->data[i] = input_dims.data[i];
} else if (i == axis) {
output_dims->data[i] = 1;
} else {
output_dims->data[i] = input_dims.data[i - 1];
}
}

return context->ResizeTensor(context, output, output_dims);
}",[9],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`expand_dims.cc`](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/expand_dims.cc#L36-L50) contains a vulnerability which allows reading one element outside of bounds of heap allocated data. If `axis` is a large negative value (e.g., `-100000`), then after the first `if` it would still be negative. The check following the `if` statement will pass and the `for` loop would read one element before the start of `input_dims.data` (when `i = 0`). We have patched the issue in GitHub commit d94ffe08a65400f898241c0374e9edc6fa8ed257. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
206212,"  TabsCustomBindings::TabsCustomBindings(ScriptContext* context)
      : ObjectBackedNativeHandler(context) {
  RouteFunction(""OpenChannelToTab"",
      base::Bind(&TabsCustomBindings::OpenChannelToTab,
                 base::Unretained(this)));
   RouteFunction(""OpenChannelToTab"", ""tabs"",
                 base::Bind(&TabsCustomBindings::OpenChannelToTab,
                            base::Unretained(this)));
  }","[6, 7, 8, 3, 4, 5]","The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors."
9923,"void Compute(OpKernelContext* context) override {
int32_t dim = context->input(0).scalar<int32_t>()();
int32_t num_results = context->input(1).scalar<int32_t>()();
int32_t skip = context->input(2).scalar<int32_t>()();

OP_REQUIRES(context, dim >= 1,
errors::InvalidArgument(""dim must be at least one""));
OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,
errors::InvalidArgument(""dim must be at most "",
sobol_data::kMaxSobolDim));
OP_REQUIRES(context, num_results >= 1,
errors::InvalidArgument(""num_results must be at least one""));
OP_REQUIRES(context, skip >= 0,
errors::InvalidArgument(""skip must be non-negative""));
OP_REQUIRES(context,
num_results < std::numeric_limits<int32_t>::max() - skip,
errors::InvalidArgument(""num_results+skip must be less than "",
std::numeric_limits<int32_t>::max()));

Tensor* output = nullptr;
OP_REQUIRES_OK(context,
context->allocate_output(
0, TensorShape({num_results, dim}), &output));
auto output_flat = output->flat<T>();
const DeviceBase::CpuWorkerThreads& worker_threads =
*(context->device()->tensorflow_cpu_worker_threads());
int num_threads = worker_threads.num_threads;
int block_size = std::max(
kMinBlockSize, static_cast<int>(std::ceil(
static_cast<float>(num_results) / num_threads)));
worker_threads.workers->TransformRangeConcurrently(
block_size, num_results            ,
[&dim, &skip, &output_flat](const int start, const int end) {
CalculateSobolSample<T>(dim, end - start                  , skip,
start, output_flat);
});
}","[3, 4]","TensorFlow is an open source platform for machine learning. The implementation of SobolSampleOp is vulnerable to a denial of service via CHECK-failure (assertion failure) caused by assuming `input(0)`, `input(1)`, and `input(2)` to be scalar. This issue has been patched in GitHub commit c65c67f88ad770662e8f191269a907bf2b94b1bf. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
199799," static int pit_ioport_read(struct kvm_io_device *this,
 			   gpa_t addr, int len, void *data)
 {
 	struct kvm_pit *pit = dev_to_pit(this);
 	struct kvm_kpit_state *pit_state = &pit->pit_state;
 	struct kvm *kvm = pit->kvm;
 	int ret, count;
 	struct kvm_kpit_channel_state *s;
 	if (!pit_in_range(addr))
  		return -EOPNOTSUPP;
  
  	addr &= KVM_PIT_CHANNEL_MASK;
 	if (addr == 3)
 		return 0;
 
  	s = &pit_state->channels[addr];
  
  	mutex_lock(&pit_state->lock);
 
 	if (s->status_latched) {
 		s->status_latched = 0;
 		ret = s->status;
 	} else if (s->count_latched) {
 		switch (s->count_latched) {
 		default:
 		case RW_STATE_LSB:
 			ret = s->latched_count & 0xff;
 			s->count_latched = 0;
 			break;
 		case RW_STATE_MSB:
 			ret = s->latched_count >> 8;
 			s->count_latched = 0;
 			break;
 		case RW_STATE_WORD0:
 			ret = s->latched_count & 0xff;
 			s->count_latched = RW_STATE_MSB;
 			break;
 		}
 	} else {
 		switch (s->read_state) {
 		default:
 		case RW_STATE_LSB:
 			count = pit_get_count(kvm, addr);
 			ret = count & 0xff;
 			break;
 		case RW_STATE_MSB:
 			count = pit_get_count(kvm, addr);
 			ret = (count >> 8) & 0xff;
 			break;
 		case RW_STATE_WORD0:
 			count = pit_get_count(kvm, addr);
 			ret = count & 0xff;
 			s->read_state = RW_STATE_WORD1;
 			break;
 		case RW_STATE_WORD1:
 			count = pit_get_count(kvm, addr);
 			ret = (count >> 8) & 0xff;
 			s->read_state = RW_STATE_WORD0;
 			break;
 		}
 	}
 
 	if (len > sizeof(ret))
 		len = sizeof(ret);
 	memcpy(data, (char *)&ret, len);
 
 	mutex_unlock(&pit_state->lock);
 	return 0;
 }","[13, 14, 15]","The pit_ioport_read in i8254.c in the Linux kernel before 2.6.33 and QEMU before 2.3.1 does not distinguish between read lengths and write lengths, which might allow guest OS users to execute arbitrary code on the host OS by triggering use of an invalid index."
206215," void Dispatcher::RegisterNativeHandlers(ModuleSystem* module_system,
                                         ScriptContext* context,
                                         Dispatcher* dispatcher,
                                         RequestSender* request_sender,
                                          V8SchemaRegistry* v8_schema_registry) {
    module_system->RegisterNativeHandler(
        ""chrome"", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));
  module_system->RegisterNativeHandler(
      ""lazy_background_page"",
      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));
    module_system->RegisterNativeHandler(
        ""logging"", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));
    module_system->RegisterNativeHandler(""schema_registry"",
                                         v8_schema_registry->AsNativeHandler());
  module_system->RegisterNativeHandler(
      ""print"", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));
    module_system->RegisterNativeHandler(
        ""test_features"",
        scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));
   module_system->RegisterNativeHandler(
       ""test_native_handler"",
       scoped_ptr<NativeHandler>(new TestNativeHandler(context)));
   module_system->RegisterNativeHandler(
       ""user_gestures"",
       scoped_ptr<NativeHandler>(new UserGesturesNativeHandler(context)));
   module_system->RegisterNativeHandler(
       ""utils"", scoped_ptr<NativeHandler>(new UtilsNativeHandler(context)));
   module_system->RegisterNativeHandler(
       ""v8_context"",
       scoped_ptr<NativeHandler>(new V8ContextNativeHandler(context)));
   module_system->RegisterNativeHandler(
       ""event_natives"", scoped_ptr<NativeHandler>(new EventBindings(context)));
   module_system->RegisterNativeHandler(
       ""messaging_natives"",
       scoped_ptr<NativeHandler>(MessagingBindings::Get(dispatcher, context)));
   module_system->RegisterNativeHandler(
       ""apiDefinitions"",
       scoped_ptr<NativeHandler>(
           new ApiDefinitionsNatives(dispatcher, context)));
   module_system->RegisterNativeHandler(
       ""sendRequest"",
       scoped_ptr<NativeHandler>(
           new SendRequestNatives(request_sender, context)));
   module_system->RegisterNativeHandler(
       ""setIcon"",
       scoped_ptr<NativeHandler>(new SetIconNatives(context)));
   module_system->RegisterNativeHandler(
       ""activityLogger"",
       scoped_ptr<NativeHandler>(new APIActivityLogger(context)));
   module_system->RegisterNativeHandler(
       ""renderFrameObserverNatives"",
       scoped_ptr<NativeHandler>(new RenderFrameObserverNatives(context)));
 
   module_system->RegisterNativeHandler(
       ""file_system_natives"",
       scoped_ptr<NativeHandler>(new FileSystemNatives(context)));
 
   module_system->RegisterNativeHandler(
       ""app_window_natives"",
       scoped_ptr<NativeHandler>(new AppWindowCustomBindings(context)));
   module_system->RegisterNativeHandler(
       ""blob_natives"",
       scoped_ptr<NativeHandler>(new BlobNativeHandler(context)));
   module_system->RegisterNativeHandler(
       ""context_menus"",
       scoped_ptr<NativeHandler>(new ContextMenusCustomBindings(context)));
   module_system->RegisterNativeHandler(
       ""css_natives"", scoped_ptr<NativeHandler>(new CssNativeHandler(context)));
   module_system->RegisterNativeHandler(
       ""document_natives"",
       scoped_ptr<NativeHandler>(new DocumentCustomBindings(context)));
   module_system->RegisterNativeHandler(
        ""guest_view_internal"",
        scoped_ptr<NativeHandler>(
            new GuestViewInternalCustomBindings(context)));
  module_system->RegisterNativeHandler(
      ""i18n"", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));
    module_system->RegisterNativeHandler(
        ""id_generator"",
        scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));
   module_system->RegisterNativeHandler(
       ""runtime"", scoped_ptr<NativeHandler>(new RuntimeCustomBindings(context)));
   module_system->RegisterNativeHandler(
       ""display_source"",
       scoped_ptr<NativeHandler>(new DisplaySourceCustomBindings(context)));
 }","[8, 9, 10, 15, 16, 76, 77]","The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors."
206448," bool ResourceLoader::WillFollowRedirect(
     const WebURL& new_url,
     const WebURL& new_site_for_cookies,
     const WebString& new_referrer,
     WebReferrerPolicy new_referrer_policy,
     const WebString& new_method,
     const WebURLResponse& passed_redirect_response,
     bool& report_raw_headers) {
   DCHECK(!passed_redirect_response.IsNull());
 
   if (is_cache_aware_loading_activated_) {
     HandleError(
         ResourceError::CacheMissError(resource_->LastResourceRequest().Url()));
     return false;
   }
 
   const ResourceRequest& last_request = resource_->LastResourceRequest();
   ResourceRequest new_request(new_url);
   new_request.SetSiteForCookies(new_site_for_cookies);
   new_request.SetDownloadToFile(last_request.DownloadToFile());
   new_request.SetUseStreamOnResponse(last_request.UseStreamOnResponse());
   new_request.SetRequestContext(last_request.GetRequestContext());
   new_request.SetFrameType(last_request.GetFrameType());
   new_request.SetServiceWorkerMode(
       passed_redirect_response.WasFetchedViaServiceWorker()
           ? WebURLRequest::ServiceWorkerMode::kAll
           : WebURLRequest::ServiceWorkerMode::kNone);
   new_request.SetShouldResetAppCache(last_request.ShouldResetAppCache());
   new_request.SetFetchRequestMode(last_request.GetFetchRequestMode());
   new_request.SetFetchCredentialsMode(last_request.GetFetchCredentialsMode());
   new_request.SetKeepalive(last_request.GetKeepalive());
   String referrer =
       new_referrer.IsEmpty() ? Referrer::NoReferrer() : String(new_referrer);
   new_request.SetHTTPReferrer(
       Referrer(referrer, static_cast<ReferrerPolicy>(new_referrer_policy)));
   new_request.SetPriority(last_request.Priority());
   new_request.SetHTTPMethod(new_method);
   if (new_request.HttpMethod() == last_request.HttpMethod())
     new_request.SetHTTPBody(last_request.HttpBody());
   new_request.SetCheckForBrowserSideNavigation(
       last_request.CheckForBrowserSideNavigation());
 
   Resource::Type resource_type = resource_->GetType();
 
   const ResourceRequest& initial_request = resource_->GetResourceRequest();
   WebURLRequest::RequestContext request_context =
       initial_request.GetRequestContext();
   WebURLRequest::FrameType frame_type = initial_request.GetFrameType();
   WebURLRequest::FetchRequestMode fetch_request_mode =
       initial_request.GetFetchRequestMode();
   WebURLRequest::FetchCredentialsMode fetch_credentials_mode =
       initial_request.GetFetchCredentialsMode();
 
   const ResourceLoaderOptions& options = resource_->Options();
 
   const ResourceResponse& redirect_response(
       passed_redirect_response.ToResourceResponse());
 
   new_request.SetRedirectStatus(
       ResourceRequest::RedirectStatus::kFollowedRedirect);
 
   if (!IsManualRedirectFetchRequest(initial_request)) {
     bool unused_preload = resource_->IsUnusedPreload();
 
     SecurityViolationReportingPolicy reporting_policy =
         unused_preload ? SecurityViolationReportingPolicy::kSuppressReporting
                        : SecurityViolationReportingPolicy::kReport;
 
     Context().CheckCSPForRequest(
         request_context, new_url, options, reporting_policy,
         ResourceRequest::RedirectStatus::kFollowedRedirect);
 
     ResourceRequestBlockedReason blocked_reason = Context().CanRequest(
         resource_type, new_request, new_url, options, reporting_policy,
         FetchParameters::kUseDefaultOriginRestrictionForType,
         ResourceRequest::RedirectStatus::kFollowedRedirect);
     if (blocked_reason != ResourceRequestBlockedReason::kNone) {
       CancelForRedirectAccessCheckError(new_url, blocked_reason);
       return false;
     }
 
     if (options.cors_handling_by_resource_fetcher ==
             kEnableCORSHandlingByResourceFetcher &&
         fetch_request_mode == WebURLRequest::kFetchRequestModeCORS) {
       RefPtr<SecurityOrigin> source_origin = options.security_origin;
       if (!source_origin.get())
         source_origin = Context().GetSecurityOrigin();
       WebSecurityOrigin source_web_origin(source_origin.get());
       WrappedResourceRequest new_request_wrapper(new_request);
       WebString cors_error_msg;
       if (!WebCORS::HandleRedirect(
               source_web_origin, new_request_wrapper, redirect_response.Url(),
               redirect_response.HttpStatusCode(),
               redirect_response.HttpHeaderFields(), fetch_credentials_mode,
               resource_->MutableOptions(), cors_error_msg)) {
         resource_->SetCORSStatus(CORSStatus::kFailed);
 
         if (!unused_preload) {
           Context().AddErrorConsoleMessage(cors_error_msg,
                                            FetchContext::kJSSource);
         }
 
         CancelForRedirectAccessCheckError(new_url,
                                           ResourceRequestBlockedReason::kOther);
         return false;
       }
 
       source_origin = source_web_origin;
     }
     if (resource_type == Resource::kImage &&
         fetcher_->ShouldDeferImageLoad(new_url)) {
       CancelForRedirectAccessCheckError(new_url,
                                         ResourceRequestBlockedReason::kOther);
       return false;
     }
   }
 
   bool cross_origin =
       !SecurityOrigin::AreSameSchemeHostPort(redirect_response.Url(), new_url);
   fetcher_->RecordResourceTimingOnRedirect(resource_.Get(), redirect_response,
                                            cross_origin);
 
   if (options.cors_handling_by_resource_fetcher ==
           kEnableCORSHandlingByResourceFetcher &&
       fetch_request_mode == WebURLRequest::kFetchRequestModeCORS) {
     bool allow_stored_credentials = false;
     switch (fetch_credentials_mode) {
       case WebURLRequest::kFetchCredentialsModeOmit:
         break;
       case WebURLRequest::kFetchCredentialsModeSameOrigin:
         allow_stored_credentials = !options.cors_flag;
         break;
       case WebURLRequest::kFetchCredentialsModeInclude:
       case WebURLRequest::kFetchCredentialsModePassword:
         allow_stored_credentials = true;
         break;
     }
     new_request.SetAllowStoredCredentials(allow_stored_credentials);
   }
 
 
    Context().PrepareRequest(new_request,
                             FetchContext::RedirectType::kForRedirect);
    Context().DispatchWillSendRequest(resource_->Identifier(), new_request,
                                    redirect_response, options.initiator_info);
                                     redirect_response, resource_->GetType(),
                                     options.initiator_info);
  
   DCHECK(KURL(new_site_for_cookies) == new_request.SiteForCookies());
 
   DCHECK_EQ(new_request.GetRequestContext(), request_context);
   DCHECK_EQ(new_request.GetFrameType(), frame_type);
   DCHECK_EQ(new_request.GetFetchRequestMode(), fetch_request_mode);
   DCHECK_EQ(new_request.GetFetchCredentialsMode(), fetch_credentials_mode);
 
   if (new_request.Url() != KURL(new_url)) {
     CancelForRedirectAccessCheckError(new_request.Url(),
                                       ResourceRequestBlockedReason::kOther);
     return false;
   }
 
   if (!resource_->WillFollowRedirect(new_request, redirect_response)) {
     CancelForRedirectAccessCheckError(new_request.Url(),
                                       ResourceRequestBlockedReason::kOther);
     return false;
   }
 
   report_raw_headers = new_request.ReportRawHeaders();
 
   return true;
 }","[146, 147, 145]","WebRTC in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, failed to perform proper bounds checking, which allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
208011,"  long vorbis_book_decodevv_add(codebook *book,ogg_int32_t **a,
			      long offset,int ch,
			      oggpack_buffer *b,int n,int point){
                               long offset,int ch,
                               oggpack_buffer *b,int n,int point){
    if(book->used_entries>0){
  
      ogg_int32_t *v = book->dec_buf; 
  long i,j;
  int chptr=0;
 
 
      if (!v) return -1;
      for(i=offset;i<offset+n;){
        if(decode_map(book,b,v,point))return -1;
      for (j=0;j<book->dim;j++){
	a[chptr++][i]+=v[j];
	if(chptr==ch){
	  chptr=0;
	  i++;
	}
       for (j=0;j<book->dim && i < offset + n;j++){
         a[chptr++][i]+=v[j];
         if(chptr==ch){
           chptr=0;
           i++;
         }
        }
      }
    }
 
  return 0;
 }","[4, 5, 22, 23, 24, 25, 26, 27, 2, 3, 16, 17, 18, 19, 20, 21]","An information disclosure vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-62800140."
207541," OMX_ERRORTYPE  omx_video::allocate_input_buffer(
         OMX_IN OMX_HANDLETYPE            hComp,
         OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,
         OMX_IN OMX_U32                   port,
         OMX_IN OMX_PTR                   appData,
         OMX_IN OMX_U32                   bytes)
 {
  (void)hComp, (void)port;
     OMX_ERRORTYPE eRet = OMX_ErrorNone;
  unsigned   i = 0;
 
     DEBUG_PRINT_HIGH(""allocate_input_buffer()::"");
  if (bytes != m_sInPortDef.nBufferSize) {
         DEBUG_PRINT_ERROR(""ERROR: Buffer size mismatch error: bytes[%u] != nBufferSize[%u]"",
  (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);
  return OMX_ErrorBadParameter;
  }
 
  if (!m_inp_mem_ptr) {
         DEBUG_PRINT_HIGH(""%s: size = %u, actual cnt %u"", __FUNCTION__,
  (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountActual);
         m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \
                         calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);
  if (m_inp_mem_ptr == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_inp_mem_ptr"");
  return OMX_ErrorInsufficientResources;
  }
 
         DEBUG_PRINT_LOW(""Successfully allocated m_inp_mem_ptr = %p"", m_inp_mem_ptr);
         m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);
 
  if (m_pInput_pmem == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_pInput_pmem"");
  return OMX_ErrorInsufficientResources;
  }
 #ifdef USE_ION
         m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);
  if (m_pInput_ion == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_pInput_ion"");
  return OMX_ErrorInsufficientResources;
  }
 #endif
  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {
             m_pInput_pmem[i].fd = -1;
 #ifdef USE_ION
             m_pInput_ion[i].ion_device_fd =-1;
             m_pInput_ion[i].fd_ion_data.fd =-1;
             m_pInput_ion[i].ion_alloc_data.handle = 0;
 #endif
  }
  }
 
  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {
  if (BITMASK_ABSENT(&m_inp_bm_count,i)) {
  break;
  }
  }
  if (i < m_sInPortDef.nBufferCountActual) {
 
  *bufferHdr = (m_inp_mem_ptr + i);
  (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);
  (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;
  (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;
  (*bufferHdr)->pAppPrivate       = appData;
  (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;
  (*bufferHdr)->pInputPortPrivate = (OMX_PTR)&m_pInput_pmem[i];
 
 #ifdef USE_ION
 #ifdef _MSM8974_
         m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,
  &m_pInput_ion[i].ion_alloc_data,
  &m_pInput_ion[i].fd_ion_data,0);
 #else
         m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,
  &m_pInput_ion[i].ion_alloc_data,
  &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);
 #endif
  if (m_pInput_ion[i].ion_device_fd < 0) {
             DEBUG_PRINT_ERROR(""ERROR:ION device open() Failed"");
  return OMX_ErrorInsufficientResources;
  }
 
         m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;
 #else
         m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
 
  if (m_pInput_pmem[i].fd == 0) {
             m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
  }
 
  if (m_pInput_pmem[i].fd < 0) {
             DEBUG_PRINT_ERROR(""ERROR: /dev/pmem_adsp open() Failed"");
  return OMX_ErrorInsufficientResources;
  }
 #endif
         m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;
         m_pInput_pmem[i].offset = 0;
 
         m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;
  if(!secure_session) {
             m_pInput_pmem[i].buffer = (unsigned char *)mmap(NULL,
                 m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,
                 MAP_SHARED,m_pInput_pmem[i].fd,0);
  if (m_pInput_pmem[i].buffer == MAP_FAILED) {
                 DEBUG_PRINT_ERROR(""ERROR: mmap FAILED= %d"", errno);
             close(m_pInput_pmem[i].fd);
 #ifdef USE_ION
             free_ion_memory(&m_pInput_ion[i]);
 #endif
  return OMX_ErrorInsufficientResources;
  }
  } else {
 
              m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));
             (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);
          }
  
          (*bufferHdr)->pBuffer           = (OMX_U8 *)m_pInput_pmem[i].buffer;
         DEBUG_PRINT_LOW(""Virtual address in allocate buffer is %p"", m_pInput_pmem[i].buffer);
         BITMASK_SET(&m_inp_bm_count,i);
  if (!mUseProxyColorFormat && (dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true)) {
             DEBUG_PRINT_ERROR(""ERROR: dev_use_buf FAILED for i/p buf"");
  return OMX_ErrorInsufficientResources;
  }
  } else {
         DEBUG_PRINT_ERROR(""ERROR: All i/p buffers are allocated, invalid allocate buf call""
  ""for index [%d]"", i);
         eRet = OMX_ErrorInsufficientResources;
  }
 
  return eRet;
 }",[115],"mm-video-v4l2/vidc/venc/src/omx_video_base.cpp in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allocates an incorrect amount of memory, which allows attackers to gain privileges via a crafted application, aka internal bug 28816964."
202814," static void destroy_server_connect(SERVER_CONNECT_REC *conn)
 {
 	IRC_SERVER_CONNECT_REC *ircconn;
 
         ircconn = IRC_SERVER_CONNECT(conn);
 	if (ircconn == NULL)
 		return;
  
  	g_free_not_null(ircconn->usermode);
  	g_free_not_null(ircconn->alternate_nick);
 	g_free_not_null(ircconn->sasl_username);
 	g_free_not_null(ircconn->sasl_password);
  }","[11, 12]","Irssi before 1.0.8, 1.1.x before 1.1.3, and 1.2.x before 1.2.1, when SASL is enabled, has a use after free when sending SASL login to the server."
3413,"static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,
OPJ_BYTE * p_data,
OPJ_UINT32 * p_data_written,
OPJ_UINT32 p_total_data_size,
opj_stream_private_t *p_stream,
struct opj_event_mgr * p_manager
)
{
OPJ_UINT32 tilepartno = 0;
OPJ_UINT32 l_nb_bytes_written = 0;
OPJ_UINT32 l_current_nb_bytes_written;
OPJ_UINT32 l_part_tile_size;
OPJ_UINT32 tot_num_tp;
OPJ_UINT32 pino;

OPJ_BYTE * l_begin_data;
opj_tcp_t *l_tcp = 00;
opj_tcd_t * l_tcd = 00;
opj_cp_t * l_cp = 00;

l_tcd = p_j2k->m_tcd;
l_cp = &(p_j2k->m_cp);
l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;


tot_num_tp = opj_j2k_get_num_tp(l_cp, 0, p_j2k->m_current_tile_number);


++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) {
p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
l_current_nb_bytes_written = 0;
l_part_tile_size = 0;
l_begin_data = p_data;

if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,
p_manager)) {
return OPJ_FALSE;
}

l_nb_bytes_written += l_current_nb_bytes_written;
p_data += l_current_nb_bytes_written;
p_total_data_size -= l_current_nb_bytes_written;
l_part_tile_size += l_current_nb_bytes_written;

l_current_nb_bytes_written = 0;
if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,
p_total_data_size, p_stream, p_manager)) {
return OPJ_FALSE;
}

p_data += l_current_nb_bytes_written;
l_nb_bytes_written += l_current_nb_bytes_written;
p_total_data_size -= l_current_nb_bytes_written;
l_part_tile_size += l_current_nb_bytes_written;


opj_write_bytes(l_begin_data + 6, l_part_tile_size,
4);

if (OPJ_IS_CINEMA(l_cp->rsiz)) {
opj_j2k_update_tlm(p_j2k, l_part_tile_size);
}

++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
}

for (pino = 1; pino <= l_tcp->numpocs; ++pino) {
l_tcd->cur_pino = pino;


tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);
for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) {
p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
l_current_nb_bytes_written = 0;
l_part_tile_size = 0;
l_begin_data = p_data;

if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,
p_manager)) {
return OPJ_FALSE;
}

l_nb_bytes_written += l_current_nb_bytes_written;
p_data += l_current_nb_bytes_written;
p_total_data_size -= l_current_nb_bytes_written;
l_part_tile_size += l_current_nb_bytes_written;

l_current_nb_bytes_written = 0;

if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,
p_total_data_size, p_stream, p_manager)) {
return OPJ_FALSE;
}

l_nb_bytes_written += l_current_nb_bytes_written;
p_data += l_current_nb_bytes_written;
p_total_data_size -= l_current_nb_bytes_written;
l_part_tile_size += l_current_nb_bytes_written;


opj_write_bytes(l_begin_data + 6, l_part_tile_size,
4);

if (OPJ_IS_CINEMA(l_cp->rsiz)) {
opj_j2k_update_tlm(p_j2k, l_part_tile_size);
}

++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
}
}

*p_data_written = l_nb_bytes_written;

return OPJ_TRUE;
}","[36, 79]","A size-validation issue was discovered in opj_j2k_write_sot in lib/openjp2/j2k.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_write_bytes_LE in lib/openjp2/cio.c) or possibly remote code execution. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-14152."
200763," static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)
 {
 	double width_d;
 	double scale_f_d = 1.0;
 	const double filter_width_d = DEFAULT_BOX_RADIUS;
 	int windows_size;
 	unsigned int u;
 	LineContribType *res;
 
 	if (scale_d < 1.0) {
 		width_d = filter_width_d / scale_d;
 		scale_f_d = scale_d;
 	}  else {
 		width_d= filter_width_d;
 	}
 
 	windows_size = 2 * (int)ceil(width_d) + 1;
 	res = _gdContributionsAlloc(line_size, windows_size);
 
 	for (u = 0; u < line_size; u++) {
 		const double dCenter = (double)u / scale_d;
 		 
 		register int iLeft = MAX(0, (int)floor (dCenter - width_d));
 		int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);
  		double dTotalWeight = 0.0;
  		int iSrc;
  
		res->ContribRow[u].Left = iLeft;
		res->ContribRow[u].Right = iRight;
  		 
  		if (iRight - iLeft + 1 > windows_size)  {
  			if (iLeft < ((int)src_size - 1 / 2))  {
 				iLeft++;
 			} else {
 				iRight--;
  			}
  		}
  
 		res->ContribRow[u].Left = iLeft;
 		res->ContribRow[u].Right = iRight;
 
  		for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
  			dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));
  		}
 
 		if (dTotalWeight < 0.0) {
 			_gdContributionsFree(res);
 			return NULL;
 		}
 
 		if (dTotalWeight > 0.0) {
 			for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
 				res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;
 			}
 		}
 	}
 	return res;
 }","[39, 40, 41, 28, 29]","gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function."
201484," aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)
 {	const AIFF_CAF_CHANNEL_MAP * map_info ;
 	unsigned channel_bitmap, channel_decriptions, bytesread ;
 	int layout_tag ;
 
 	bytesread = psf_binheader_readf (psf, ""444"", &layout_tag, &channel_bitmap, &channel_decriptions) ;
 
 	if ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)
 		return 0 ;
 
 	psf_log_printf (psf, ""  Tag    : %x\n"", layout_tag) ;
 	if (map_info)
 		psf_log_printf (psf, ""  Layout : %s\n"", map_info->name) ;
 
 	if (bytesread < dword)
  		psf_binheader_readf (psf, ""j"", dword - bytesread) ;
  
  	if (map_info->channel_map != NULL)
	{	size_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;
 	{	size_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;
  
  		free (psf->channel_map) ;
  
 		if ((psf->channel_map = malloc (chanmap_size)) == NULL)
 			return SFE_MALLOC_FAILED ;
 
 		memcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;
 		} ;
 
 	return 0 ;
 }  ","[20, 19]","In libsndfile version 1.0.28, an error in the *aiff_read_chanmap()* function (aiff.c) can be exploited to cause an out-of-bounds read memory access via a specially crafted AIFF file."
7991,"md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)
{
unsigned total_indent = 0;
int n_parents = 0;
int n_brothers = 0;
int n_children = 0;
MD_CONTAINER container = { 0 };
int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;
OFF off = beg;
OFF hr_killer = 0;
int ret = 0;

line->indent = md_line_indentation(ctx, total_indent, off, &off);
total_indent += line->indent;
line->beg = off;



while(n_parents < ctx->n_containers) {
MD_CONTAINER* c = &ctx->containers[n_parents];

if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&
off < ctx->size  &&  CH(off) == _T('>'))
{

off++;
total_indent++;
line->indent = md_line_indentation(ctx, total_indent, off, &off);
total_indent += line->indent;


if(line->indent > 0)
line->indent--;

line->beg = off;

} else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {

line->indent -= c->contents_indent;
} else {
break;
}

n_parents++;
}

if(off >= ctx->size  ||  ISNEWLINE(off)) {


if(n_brothers + n_children == 0) {
while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
n_parents++;
}
}

while(TRUE) {

if(pivot_line->type == MD_LINE_FENCEDCODE) {
line->beg = off;



if(line->indent < ctx->code_indent_offset) {
if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {
line->type = MD_LINE_BLANK;
ctx->last_line_has_list_loosening_effect = FALSE;
break;
}
}


if(n_parents == ctx->n_containers) {
if(line->indent > pivot_line->indent)
line->indent -= pivot_line->indent;
else
line->indent = 0;

line->type = MD_LINE_FENCEDCODE;
break;
}
}


if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {
if(n_parents < ctx->n_containers) {


ctx->html_block_type = 0;
} else {
int html_block_type;

html_block_type = md_is_html_block_end_condition(ctx, off, &off);
if(html_block_type > 0) {
MD_ASSERT(html_block_type == ctx->html_block_type);


ctx->html_block_type = 0;


if(html_block_type == 6 || html_block_type == 7) {
line->type = MD_LINE_BLANK;
line->indent = 0;
break;
}
}

line->type = MD_LINE_HTML;
n_parents = ctx->n_containers;
break;
}
}


if(off >= ctx->size  ||  ISNEWLINE(off)) {
if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {
line->type = MD_LINE_INDENTEDCODE;
if(line->indent > ctx->code_indent_offset)
line->indent -= ctx->code_indent_offset;
else
line->indent = 0;
ctx->last_line_has_list_loosening_effect = FALSE;
} else {
line->type = MD_LINE_BLANK;
ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&
n_brothers + n_children == 0  &&
ctx->containers[n_parents-1].ch != _T('>'));

#if 1











if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
ctx->n_block_bytes > (int) sizeof(MD_BLOCK))
{
MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
if(top_block->type == MD_BLOCK_LI)
ctx->last_list_item_starts_with_two_blank_lines = TRUE;
}
#endif
}
break;
} else {
#if 1




ctx->last_line_has_list_loosening_effect = FALSE;
if(ctx->last_list_item_starts_with_two_blank_lines) {
if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
ctx->n_block_bytes > (int) sizeof(MD_BLOCK))
{
MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
if(top_block->type == MD_BLOCK_LI)
n_parents--;
}

ctx->last_list_item_starts_with_two_blank_lines = FALSE;
}
#endif
}


if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT
&&  (CH(off) == _T('=') || CH(off) == _T('-'))
&&  (n_parents == ctx->n_containers))
{
unsigned level;

if(md_is_setext_underline(ctx, off, &off, &level)) {
line->type = MD_LINE_SETEXTUNDERLINE;
line->data = level;
break;
}
}


if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T(""-_*""))  &&  off >= hr_killer) {
if(md_is_hr_line(ctx, off, &off, &hr_killer)) {
line->type = MD_LINE_HR;
break;
}
}



if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {
OFF tmp;

if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&
md_is_container_compatible(&ctx->containers[n_parents], &container))
{
pivot_line = &md_dummy_blank_line;

off = tmp;

total_indent += container.contents_indent - container.mark_indent;
line->indent = md_line_indentation(ctx, total_indent, off, &off);
total_indent += line->indent;
line->beg = off;


if(off >= ctx->size || ISNEWLINE(off)) {
container.contents_indent++;
} else if(line->indent <= ctx->code_indent_offset) {
container.contents_indent += line->indent;
line->indent = 0;
} else {
container.contents_indent += 1;
line->indent--;
}

ctx->containers[n_parents].mark_indent = container.mark_indent;
ctx->containers[n_parents].contents_indent = container.contents_indent;

n_brothers++;
continue;
}
}



if(line->indent >= ctx->code_indent_offset  &&
(pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))
{
line->type = MD_LINE_INDENTEDCODE;
MD_ASSERT(line->indent >= ctx->code_indent_offset);
line->indent -= ctx->code_indent_offset;
line->data = 0;
break;
}


if(line->indent < ctx->code_indent_offset  &&
md_is_container_mark(ctx, line->indent, off, &off, &container))
{
if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
(off >= ctx->size || ISNEWLINE(off))  &&  container.ch != _T('>'))
{

} else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
(container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)
{

} else {
total_indent += container.contents_indent - container.mark_indent;
line->indent = md_line_indentation(ctx, total_indent, off, &off);
total_indent += line->indent;

line->beg = off;
line->data = container.ch;


if(off >= ctx->size || ISNEWLINE(off)) {
container.contents_indent++;
} else if(line->indent <= ctx->code_indent_offset) {
container.contents_indent += line->indent;
line->indent = 0;
} else {
container.contents_indent += 1;
line->indent--;
}

if(n_brothers + n_children == 0)
pivot_line = &md_dummy_blank_line;

if(n_children == 0)
MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));

n_children++;
MD_CHECK(md_push_container(ctx, &container));
continue;
}
}


if(pivot_line->type == MD_LINE_TABLE  &&  n_parents == ctx->n_containers) {
line->type = MD_LINE_TABLE;
break;
}


if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {
unsigned level;

if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {
line->type = MD_LINE_ATXHEADER;
line->data = level;
break;
}
}


if(CH(off) == _T('`') || CH(off) == _T('~')) {
if(md_is_opening_code_fence(ctx, off, &off)) {
line->type = MD_LINE_FENCEDCODE;
line->data = 1;
break;
}
}


if(CH(off) == _T('<')  &&  !(ctx->parser.flags & MD_FLAG_NOHTMLBLOCKS))
{
ctx->html_block_type = md_is_html_block_start_condition(ctx, off);


if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)
ctx->html_block_type = 0;

if(ctx->html_block_type > 0) {

if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {

ctx->html_block_type = 0;
}

line->type = MD_LINE_HTML;
break;
}
}


if((ctx->parser.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&
(CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':'))  &&
n_parents == ctx->n_containers)
{
unsigned col_count;

if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&
md_is_table_underline(ctx, off, &off, &col_count))
{
line->data = col_count;
line->type = MD_LINE_TABLEUNDERLINE;
break;
}
}


line->type = MD_LINE_TEXT;
if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {

n_parents = ctx->n_containers;
}


if((ctx->parser.flags & MD_FLAG_TASKLISTS)  &&  n_brothers + n_children > 0  &&
ISANYOF_(ctx->containers[ctx->n_containers-1].ch, _T(""-+*.)"")))
{
OFF tmp = off;

while(tmp < ctx->size  &&  tmp < off + 3  &&  ISBLANK(tmp))
tmp++;
if(tmp + 2 < ctx->size  &&  CH(tmp) == _T('[')  &&
ISANYOF(tmp+1, _T(""xX ""))  &&  CH(tmp+2) == _T(']')  &&
(tmp + 3 == ctx->size  ||  ISBLANK(tmp+3)  ||  ISNEWLINE(tmp+3)))
{
MD_CONTAINER* task_container = (n_children > 0 ? &ctx->containers[ctx->n_containers-1] : &container);
task_container->is_task = TRUE;
task_container->task_mark_off = tmp + 1;
off = tmp + 3;
while(ISWHITESPACE(off))
off++;
line->beg = off;
}
}

break;
}






#if defined __linux__ && !defined MD4C_USE_UTF16


if(ctx->doc_ends_with_newline  &&  off < ctx->size) {
while(TRUE) {
off += (OFF) strcspn(STR(off), ""\r\n"");



if(CH(off) == _T('\0'))
off++;
else
break;
}
} else
#endif
{

while(off + 3 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)
&&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))
off += 4;
while(off < ctx->size  &&  !ISNEWLINE(off))
off++;
}


line->end = off;


if(line->type == MD_LINE_ATXHEADER) {
OFF tmp = line->end;
while(tmp > line->beg && CH(tmp-1) == _T(' '))
tmp--;
while(tmp > line->beg && CH(tmp-1) == _T('#'))
tmp--;
if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS))
line->end = tmp;
}


if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {
while(line->end > line->beg && CH(line->end-1) == _T(' '))
line->end--;
}


if(off < ctx->size && CH(off) == _T('\r'))
off++;
if(off < ctx->size && CH(off) == _T('\n'))
off++;

*p_end = off;


if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {
MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];
if(c->ch != _T('>')) {
MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);
block->flags |= MD_BLOCK_LOOSE_LIST;
}
}


if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)
MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));


if(n_brothers > 0) {
MD_ASSERT(n_brothers == 1);
MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
ctx->containers[n_parents].task_mark_off,
(ctx->containers[n_parents].is_task ? CH(ctx->containers[n_parents].task_mark_off) : 0),
MD_BLOCK_CONTAINER_CLOSER));
MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
container.task_mark_off,
(container.is_task ? CH(container.task_mark_off) : 0),
MD_BLOCK_CONTAINER_OPENER));
ctx->containers[n_parents].is_task = container.is_task;
ctx->containers[n_parents].task_mark_off = container.task_mark_off;
}

if(n_children > 0)
MD_CHECK(md_enter_child_containers(ctx, n_children));

abort:
return ret;
}","[176, 189, 253, 294, 305, 314, 335, 336, 337]","md_analyze_line in md4c.c in md4c 0.4.7 allows attackers to trigger use of uninitialized memory, and cause a denial of service via a malformed Markdown document."
207148," void HTMLMediaElement::ProgressEventTimerFired(TimerBase*) {
    if (network_state_ != kNetworkLoading)
      return;
  
    
    
    
    
   if (MediaShouldBeOpaque())
     return;
 
    double time = WTF::CurrentTime();
    double timedelta = time - previous_progress_time_;
  
   if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress()) {
     ScheduleEvent(EventTypeNames::progress);
     previous_progress_time_ = time;
     sent_stalled_event_ = false;
     if (GetLayoutObject())
       GetLayoutObject()->UpdateFromElement();
   } else if (timedelta > 3.0 && !sent_stalled_event_) {
     ScheduleEvent(EventTypeNames::stalled);
     sent_stalled_event_ = true;
     SetShouldDelayLoadEvent(false);
   }
 }","[5, 6, 7, 8, 9, 10, 11]",Information leak in media engine in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
200938," static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)
 {
     MXFContext *mxf = arg;
     int item_num = avio_rb32(pb);
     int item_len = avio_rb32(pb);
 
     if (item_len != 18) {
          avpriv_request_sample(pb, ""Primer pack item length %d"", item_len);
          return AVERROR_PATCHWELCOME;
      }
    if (item_num > 65536) {
     if (item_num > 65536 || item_num < 0) {
          av_log(mxf->fc, AV_LOG_ERROR, ""item_num %d is too large\n"", item_num);
          return AVERROR_INVALIDDATA;
      }
     if (mxf->local_tags)
         av_log(mxf->fc, AV_LOG_VERBOSE, ""Multiple primer packs\n"");
     av_free(mxf->local_tags);
     mxf->local_tags_count = 0;
     mxf->local_tags = av_calloc(item_num, item_len);
     if (!mxf->local_tags)
         return AVERROR(ENOMEM);
     mxf->local_tags_count = item_num;
     avio_read(pb, mxf->local_tags, item_num*item_len);
     return 0;
 }","[12, 11]","In the mxf_read_primer_pack function in libavformat/mxfdec.c in FFmpeg 3.3.3, an integer signedness error might occur when a crafted file, which claims a large *item_num* field such as 0xffffffff, is provided. As a result, the variable *item_num* turns negative, bypassing the check for a large value."
199780," static int __net_init sctp_net_init(struct net *net)
 static int __net_init sctp_defaults_init(struct net *net)
  {
  	int status;
  
 	 
 	 
 	 
 	net->sctp.rto_initial			= SCTP_RTO_INITIAL;
 	 
 	net->sctp.rto_min	 		= SCTP_RTO_MIN;
 	 
 	net->sctp.rto_max 			= SCTP_RTO_MAX;
 	 
 	net->sctp.rto_alpha			= SCTP_RTO_ALPHA;
 	 
 	net->sctp.rto_beta			= SCTP_RTO_BETA;
 
 	 
 	net->sctp.valid_cookie_life		= SCTP_DEFAULT_COOKIE_LIFE;
 
 	 
 	net->sctp.cookie_preserve_enable 	= 1;
 
 	 
 #if defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5)
 	net->sctp.sctp_hmac_alg			= ""md5"";
 #elif defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1)
 	net->sctp.sctp_hmac_alg			= ""sha1"";
 #else
 	net->sctp.sctp_hmac_alg			= NULL;
 #endif
 
 	 
 	net->sctp.max_burst			= SCTP_DEFAULT_MAX_BURST;
 
 	 
 	net->sctp.max_retrans_association	= 10;
 	net->sctp.max_retrans_path		= 5;
 	net->sctp.max_retrans_init		= 8;
 
 	 
 	net->sctp.sndbuf_policy			= 0;
 
 	 
 	net->sctp.rcvbuf_policy			= 0;
 
 	 
 	net->sctp.hb_interval			= SCTP_DEFAULT_TIMEOUT_HEARTBEAT;
 
 	 
 	net->sctp.sack_timeout			= SCTP_DEFAULT_TIMEOUT_SACK;
 
 	 
 	net->sctp.addip_enable = 0;
 	net->sctp.addip_noauth = 0;
 	net->sctp.default_auto_asconf = 0;
 
 	 
 	net->sctp.prsctp_enable = 1;
 
 	 
 	net->sctp.auth_enable = 0;
 
 	 
 	net->sctp.scope_policy = SCTP_SCOPE_POLICY_ENABLE;
 
 	 
 	net->sctp.rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;
 
 	 
 	net->sctp.max_autoclose		= INT_MAX / HZ;
 
 	status = sctp_sysctl_net_register(net);
 	if (status)
 		goto err_sysctl_register;
 
 	 
 	status = init_sctp_mibs(net);
 	if (status)
 		goto err_init_mibs;
 
 	 
 	status = sctp_proc_init(net);
 	if (status)
 		goto err_init_proc;
  
  	sctp_dbg_objcnt_init(net);
  
	 
	if ((status = sctp_ctl_sock_init(net))) {
		pr_err(""Failed to initialize the SCTP control sock\n"");
		goto err_ctl_sock_init;
	}
  	 
  	INIT_LIST_HEAD(&net->sctp.local_addr_list);
  	spin_lock_init(&net->sctp.local_addr_lock);
 	sctp_get_local_addr_list(net);
 
 	 
 	INIT_LIST_HEAD(&net->sctp.addr_waitq);
 	INIT_LIST_HEAD(&net->sctp.auto_asconf_splist);
 	spin_lock_init(&net->sctp.addr_wq_lock);
 	net->sctp.addr_wq_timer.expires = 0;
 	setup_timer(&net->sctp.addr_wq_timer, sctp_addr_wq_timeout_handler,
 		    (unsigned long)net);
  
  	return 0;
  
err_ctl_sock_init:
	sctp_dbg_objcnt_exit(net);
	sctp_proc_exit(net);
  err_init_proc:
  	cleanup_sctp_mibs(net);
  err_init_mibs:
 	sctp_sysctl_net_unregister(net);
 err_sysctl_register:
  	return status;
  }","[2, 90, 91, 92, 93, 94, 110, 111, 112]","The sctp_init function in net/sctp/protocol.c in the Linux kernel before 4.2.3 has an incorrect sequence of protocol-initialization steps, which allows local users to cause a denial of service (panic or memory corruption) by creating SCTP sockets before all of the steps have finished."
197934," stringprep (char *in,
 	    size_t maxlen,
 	    Stringprep_profile_flags flags,
 	    const Stringprep_profile * profile)
 {
   int rc;
   char *utf8 = NULL;
   uint32_t *ucs4 = NULL;
   size_t ucs4len, maxucs4len, adducs4len = 50;
 
   do
     {
       uint32_t *newp;
  
        free (ucs4);
        ucs4 = stringprep_utf8_to_ucs4 (in, -1, &ucs4len);
       if (ucs4 == NULL)
 	return STRINGPREP_ICONV_ERROR;
        maxucs4len = ucs4len + adducs4len;
        newp = realloc (ucs4, maxucs4len * sizeof (uint32_t));
        if (!newp)
 	  return STRINGPREP_MALLOC_ERROR;
 	}
       ucs4 = newp;
 
       rc = stringprep_4i (ucs4, &ucs4len, maxucs4len, flags, profile);
       adducs4len += 50;
     }","[17, 18]","The stringprep_utf8_to_ucs4 function in libin before 1.31, as used in jabberd2, allows context-dependent attackers to read system memory and possibly have other unspecified impact via invalid UTF-8 characters in a string, which triggers an out-of-bounds read."
202842," krb5_init_creds_step(krb5_context context,
 		     krb5_init_creds_context ctx,
 		     krb5_data *in,
 		     krb5_data *out,
 		     krb5_krbhst_info *hostinfo,
 		     unsigned int *flags)
 {
     krb5_error_code ret;
     size_t len = 0;
     size_t size;
     AS_REQ req2;
 
     krb5_data_zero(out);
 
     if (ctx->as_req.req_body.cname == NULL) {
 	ret = init_as_req(context, ctx->flags, &ctx->cred,
 			  ctx->addrs, ctx->etypes, &ctx->as_req);
 	if (ret) {
 	    free_init_creds_ctx(context, ctx);
 	    return ret;
 	}
     }
 
 #define MAX_PA_COUNTER 10
     if (ctx->pa_counter > MAX_PA_COUNTER) {
 	krb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,
 			       N_(""Looping %d times while getting ""
 				  ""initial credentials"", """"),
 			       ctx->pa_counter);
 	return KRB5_GET_IN_TKT_LOOP;
     }
     ctx->pa_counter++;
 
     _krb5_debug(context, 5, ""krb5_get_init_creds: loop %d"", ctx->pa_counter);
 
      
     if (in && in->length) {
 	krb5_kdc_rep rep;
 
 	memset(&rep, 0, sizeof(rep));
 
 	_krb5_debug(context, 5, ""krb5_get_init_creds: processing input"");
 
 	ret = decode_AS_REP(in->data, in->length, &rep.kdc_rep, &size);
 	if (ret == 0) {
 	    unsigned eflags = EXTRACT_TICKET_AS_REQ | EXTRACT_TICKET_TIMESYNC;
 	    krb5_data data;
 
 	     
 	    ASN1_MALLOC_ENCODE(Ticket, data.data, data.length,
 			       &rep.kdc_rep.ticket, &size, ret);
 	    if (ret)
 		goto out;
 	    heim_assert(data.length == size, ""ASN.1 internal error"");
 
 	    ret = fast_unwrap_as_rep(context, ctx->nonce, &data,
 				     &ctx->fast_state, &rep.kdc_rep);
 	    krb5_data_free(&data);
 	    if (ret)
 		goto out;
 
 	     
 
 	    if (ctx->flags.canonicalize) {
 		eflags |= EXTRACT_TICKET_ALLOW_SERVER_MISMATCH;
 		eflags |= EXTRACT_TICKET_MATCH_REALM;
 	    }
 	    if (ctx->ic_flags & KRB5_INIT_CREDS_NO_C_CANON_CHECK)
 		eflags |= EXTRACT_TICKET_ALLOW_CNAME_MISMATCH;
 
 	    ret = process_pa_data_to_key(context, ctx, &ctx->cred,
 					 &ctx->as_req, &rep.kdc_rep,
 					 hostinfo, &ctx->fast_state.reply_key);
 	    if (ret) {
 		free_AS_REP(&rep.kdc_rep);
 		goto out;
 	    }
 
 	    _krb5_debug(context, 5, ""krb5_get_init_creds: extracting ticket"");
 
 	    ret = _krb5_extract_ticket(context,
 				       &rep,
 				       &ctx->cred,
 				       ctx->fast_state.reply_key,
 				       NULL,
 				       KRB5_KU_AS_REP_ENC_PART,
 				       NULL,
 				       ctx->nonce,
 				       eflags,
  				       &ctx->req_buffer,
  				       NULL,
  				       NULL);
 	    if (ret == 0 && ctx->pk_init_ctx) {
 		PA_DATA *pa_pkinit_kx;
 		int idx = 0;
 
 		pa_pkinit_kx =
 		    krb5_find_padata(rep.kdc_rep.padata->val,
 				     rep.kdc_rep.padata->len,
 				     KRB5_PADATA_PKINIT_KX,
 				     &idx);
 
 		ret = _krb5_pk_kx_confirm(context, ctx->pk_init_ctx,
 					  ctx->fast_state.reply_key,
 					  &ctx->cred.session,
 					  pa_pkinit_kx);
 		if (ret)
 		    krb5_set_error_message(context, ret,
 					   N_(""Failed to confirm PA-PKINIT-KX"", """"));
 		else if (pa_pkinit_kx != NULL)
 		    ctx->ic_flags |= KRB5_INIT_CREDS_PKINIT_KX_VALID;
 	    }
  	    if (ret == 0)
  		ret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);
  
 	    krb5_free_keyblock(context, ctx->fast_state.reply_key);
 	    ctx->fast_state.reply_key = NULL;
 	    *flags = 0;
 
 	    free_AS_REP(&rep.kdc_rep);
 	    free_EncASRepPart(&rep.enc_part);
 
 	    return ret;
 
 	} else {
 	     
 
 	    _krb5_debug(context, 5, ""krb5_get_init_creds: got an error"");
 
 	    free_KRB_ERROR(&ctx->error);
 
 	    ret = krb5_rd_error(context, in, &ctx->error);
 	    if(ret && in->length && ((char*)in->data)[0] == 4)
 		ret = KRB5KRB_AP_ERR_V4_REPLY;
 	    if (ret) {
 		_krb5_debug(context, 5, ""krb5_get_init_creds: failed to read error"");
 		goto out;
 	    }
 
 	     
 	    ret = fast_unwrap_error(context, &ctx->fast_state, &ctx->error);
 	    if (ret)
 		goto out;
 
 	     
 
 	    ret = krb5_error_from_rd_error(context, &ctx->error, &ctx->cred);
 
 	    _krb5_debug(context, 5, ""krb5_get_init_creds: KRB-ERROR %d"", ret);
 
 	     
 
 	    if (ret == KRB5KDC_ERR_PREAUTH_REQUIRED) {
 
 	        free_METHOD_DATA(&ctx->md);
 	        memset(&ctx->md, 0, sizeof(ctx->md));
 
 		if (ctx->error.e_data) {
 		    ret = decode_METHOD_DATA(ctx->error.e_data->data,
 					     ctx->error.e_data->length,
 					     &ctx->md,
 					     NULL);
 		    if (ret)
 			krb5_set_error_message(context, ret,
 					       N_(""Failed to decode METHOD-DATA"", """"));
 		} else {
 		    krb5_set_error_message(context, ret,
 					   N_(""Preauth required but no preauth ""
 					      ""options send by KDC"", """"));
 		}
 	    } else if (ret == KRB5KRB_AP_ERR_SKEW && context->kdc_sec_offset == 0) {
 		 
 		krb5_set_real_time(context, ctx->error.stime, -1);
 		if (context->kdc_sec_offset)
 		    ret = 0;
 
 		_krb5_debug(context, 10, ""init_creds: err skew updateing kdc offset to %d"",
 			    context->kdc_sec_offset);
 
 		ctx->used_pa_types = 0;
 
 	    } else if (ret == KRB5_KDC_ERR_WRONG_REALM && ctx->flags.canonicalize) {
 	         
 
 		if (ctx->error.crealm == NULL) {
 		    krb5_set_error_message(context, ret,
 					   N_(""Got a client referral, not but no realm"", """"));
 		    goto out;
 		}
 		_krb5_debug(context, 5,
 			    ""krb5_get_init_creds: got referal to realm %s"",
 			    *ctx->error.crealm);
 
 		ret = krb5_principal_set_realm(context,
 					       ctx->cred.client,
 					       *ctx->error.crealm);
 		if (ret)
 		    goto out;
 
 		if (krb5_principal_is_krbtgt(context, ctx->cred.server)) {
 		    ret = krb5_init_creds_set_service(context, ctx, NULL);
 		    if (ret)
 			goto out;
 		}
 
 		free_AS_REQ(&ctx->as_req);
 		memset(&ctx->as_req, 0, sizeof(ctx->as_req));
 
 		ctx->used_pa_types = 0;
 	    } else if (ret == KRB5KDC_ERR_KEY_EXP && ctx->runflags.change_password == 0 && ctx->prompter) {
 		char buf2[1024];
 
 		ctx->runflags.change_password = 1;
 
 		ctx->prompter(context, ctx->prompter_data, NULL, N_(""Password has expired"", """"), 0, NULL);
 
 
 		 
 		if (ctx->in_tkt_service != NULL && strcmp(ctx->in_tkt_service, ""kadmin/changepw"") == 0)
 		    goto out;
 
                  
                 if (ctx->prompter == NULL)
                     goto out;
 
 		ret = change_password(context,
 				      ctx->cred.client,
 				      ctx->password,
 				      buf2,
 				      sizeof(buf2),
 				      ctx->prompter,
 				      ctx->prompter_data,
 				      NULL);
 		if (ret)
 		    goto out;
 
 		krb5_init_creds_set_password(context, ctx, buf2);
 
  		ctx->used_pa_types = 0;
 		ret = 0;
 
  	    } else if (ret == KRB5KDC_ERR_PREAUTH_FAILED) {
  
  		if (ctx->fast_state.flags & KRB5_FAST_DISABLED)
  		    goto out;
  		if (ctx->fast_state.flags & (KRB5_FAST_REQUIRED | KRB5_FAST_EXPECTED))
  		    goto out;
  
  		_krb5_debug(context, 10, ""preauth failed with FAST, ""
 			    ""and told by KD or user, trying w/o FAST"");
  
  		ctx->fast_state.flags |= KRB5_FAST_DISABLED;
  		ctx->used_pa_types = 0;
 		ret = 0;
 	    }
 	    if (ret)
 		goto out;
 	}
     }
 
     if (ctx->as_req.req_body.cname == NULL) {
 	ret = init_as_req(context, ctx->flags, &ctx->cred,
 			  ctx->addrs, ctx->etypes, &ctx->as_req);
 	if (ret) {
 	    free_init_creds_ctx(context, ctx);
 	    return ret;
 	}
     }
 
     if (ctx->as_req.padata) {
 	free_METHOD_DATA(ctx->as_req.padata);
 	free(ctx->as_req.padata);
 	ctx->as_req.padata = NULL;
     }
 
      
     ctx->as_req.req_body.nonce = ctx->nonce;
 
      
     ret = process_pa_data_to_md(context, &ctx->cred, &ctx->as_req, ctx,
 				&ctx->md, &ctx->as_req.padata,
 				ctx->prompter, ctx->prompter_data);
     if (ret)
 	goto out;
 
      
     copy_AS_REQ(&ctx->as_req, &req2);
 
     ret = fast_wrap_req(context, &ctx->fast_state, &req2);
     if (ret) {
 	free_AS_REQ(&req2);
 	goto out;
     }
 
     krb5_data_free(&ctx->req_buffer);
 
     ASN1_MALLOC_ENCODE(AS_REQ,
 		       ctx->req_buffer.data, ctx->req_buffer.length,
 		       &req2, &len, ret);
     free_AS_REQ(&req2);
     if (ret)
 	goto out;
     if(len != ctx->req_buffer.length)
 	krb5_abortx(context, ""internal error in ASN.1 encoder"");
 
     out->data = ctx->req_buffer.data;
     out->length = ctx->req_buffer.length;
 
     *flags = KRB5_INIT_CREDS_STEP_FLAG_CONTINUE;
 
     return 0;
  out:
     return ret;
 }","[93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112]","In the client side of Heimdal before 7.6.0, failure to verify anonymous PKINIT PA-PKINIT-KX key exchange permits a man-in-the-middle attack. This issue is in krb5_init_creds_step in lib/krb5/init_creds_pw.c."
207595," int main(int argc, char **argv)
 {
 #ifdef sgi
  char tmpline[80];
 #endif
  char *p;
  int rc, alen, flen;
  int error = 0;
  int have_bg = FALSE;
  double LUT_exponent;  
  double CRT_exponent = 2.2;  
  double default_display_exponent;  
  XEvent e;
  KeySym k;
 
 
     displayname = (char *)NULL;
     filename = (char *)NULL;
 
 
   
 
 #if defined(NeXT)
     LUT_exponent = 1.0 / 2.2;
   
 #elif defined(sgi)
     LUT_exponent = 1.0 / 1.7;
   
     infile = fopen(""/etc/config/system.glGammaVal"", ""r"");
  if (infile) {
  double sgi_gamma;
 
         fgets(tmpline, 80, infile);
         fclose(infile);
         sgi_gamma = atof(tmpline);
  if (sgi_gamma > 0.0)
             LUT_exponent = 1.0 / sgi_gamma;
  }
 #elif defined(Macintosh)
     LUT_exponent = 1.8 / 2.61;
   
 #else
     LUT_exponent = 1.0;  
 #endif
 
   
     default_display_exponent = LUT_exponent * CRT_exponent;
 
 
   
 
  if ((p = getenv(""SCREEN_GAMMA"")) != NULL)
         display_exponent = atof(p);
  else
         display_exponent = default_display_exponent;
 
 
   
 
  while (*++argv && !error) {
  if (!strncmp(*argv, ""-display"", 2)) {
  if (!*++argv)
  ++error;
  else
                 displayname = *argv;
  } else if (!strncmp(*argv, ""-gamma"", 2)) {
  if (!*++argv)
  ++error;
  else {
                 display_exponent = atof(*argv);
  if (display_exponent <= 0.0)
  ++error;
  }
  } else if (!strncmp(*argv, ""-bgcolor"", 2)) {
  if (!*++argv)
  ++error;
  else {
                 bgstr = *argv;
  if (strlen(bgstr) != 7 || bgstr[0] != '#')
  ++error;
  else
                     have_bg = TRUE;
  }
  } else {
  if (**argv != '-') {
                 filename = *argv;
  if (argv[1])  
  ++error;
  } else
  ++error;  
  }
  }
 
  if (!filename)
  ++error;
 
 
   
 
  if (error) {
         fprintf(stderr, ""\n%s %s:  %s\n"", PROGNAME, VERSION, appname);
         readpng_version_info();
         fprintf(stderr, ""\n""
 
            ""Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg] file.png\n""
            ""    xdpy\tname of the target X display (e.g., ``hostname:0'')\n""
            ""    exp \ttransfer-function exponent (``gamma'') of the display\n""
          ""\t\t  system in floating-point format (e.g., ``%.1f''); equal\n""
           ""\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"",
           PROGNAME, default_display_exponent);
 
         fprintf(stderr, ""\n""
            ""\t\t  to the product of the lookup-table exponent (varies)\n""
            ""\t\t  and the CRT exponent (usually 2.2); must be positive\n""
            ""    bg  \tdesired background color in 7-character hex RGB format\n""
            ""\t\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\n""
            ""\t\t  used with transparent images\n""
            ""\nPress Q, Esc or mouse button 1 (within image window, after image\n""
          ""is displayed) to quit.\n""
          ""\n"", PROGNAME, default_display_exponent);
           ""is displayed) to quit.\n"");
          exit(1);
      }
  
 
  if (!(infile = fopen(filename, ""rb""))) {
         fprintf(stderr, PROGNAME "":  can't open PNG file [%s]\n"", filename);
  ++error;
  } else {
  if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {
  switch (rc) {
  case 1:
                     fprintf(stderr, PROGNAME
  "":  [%s] is not a PNG file: incorrect signature\n"",
                       filename);
  break;
  case 2:
                     fprintf(stderr, PROGNAME
  "":  [%s] has bad IHDR (libpng longjmp)\n"", filename);
  break;
  case 4:
                     fprintf(stderr, PROGNAME "":  insufficient memory\n"");
  break;
  default:
                     fprintf(stderr, PROGNAME
  "":  unknown readpng_init() error\n"");
  break;
  }
  ++error;
  } else {
             display = XOpenDisplay(displayname);
  if (!display) {
                 readpng_cleanup(TRUE);
                 fprintf(stderr, PROGNAME "":  can't open X display [%s]\n"",
                   displayname? displayname : ""default"");
  ++error;
  }
  }
  if (error)
             fclose(infile);
  }
 
 
  if (error) {
         fprintf(stderr, PROGNAME "":  aborting.\n"");
         exit(2);
  }
 
 
   
 
     alen = strlen(appname);
     flen = strlen(filename);
  if (alen + flen + 3 > 1023)
         sprintf(titlebar, ""%s:  ...%s"", appname, filename+(alen+flen+6-1023));
  else
         sprintf(titlebar, ""%s:  %s"", appname, filename);
 
 
   
 
  if (have_bg) {
  unsigned r, g, b;  
 
         sscanf(bgstr+1, ""%2x%2x%2x"", &r, &g, &b);
         bg_red   = (uch)r;
         bg_green = (uch)g;
         bg_blue  = (uch)b;
  } else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {
         readpng_cleanup(TRUE);
         fprintf(stderr, PROGNAME
  "":  libpng error while checking for background color\n"");
         exit(2);
  }
 
 
   
 
  if (rpng_x_create_window())
         exit(2);
 
 
   
 
  Trace((stderr, ""calling readpng_get_image()\n""))
     image_data = readpng_get_image(display_exponent, &image_channels,
  &image_rowbytes);
  Trace((stderr, ""done with readpng_get_image()\n""))
 
 
   
 
     readpng_cleanup(FALSE);
     fclose(infile);
 
  if (!image_data) {
         fprintf(stderr, PROGNAME "":  unable to decode PNG image\n"");
         exit(3);
  }
 
 
   
 
  Trace((stderr, ""calling rpng_x_display_image()\n""))
  if (rpng_x_display_image()) {
         free(image_data);
         exit(4);
  }
  Trace((stderr, ""done with rpng_x_display_image()\n""))
 
 
   
 
     printf(
  ""Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\n"");
     fflush(stdout);
 
  do
  XNextEvent(display, &e);
  while (!(e.type == ButtonPress && e.xbutton.button == Button1) &&
  !(e.type == KeyPress &&  
  ((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape) ));
 
 
   
 
  
      rpng_x_cleanup();
  
     (void)argc;  
 
      return 0;
  }","[109, 110, 111, 112, 121, 250, 251, 108, 119, 120]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
199393," static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)
 {
 	struct nlm_rqst	*req = data;
 	u32 status = ntohl(req->a_res.status);
 
 	if (RPC_ASSASSINATED(task))
 		goto die;
  
  	if (task->tk_status < 0) {
  		dprintk(""lockd: unlock failed (err = %d)\n"", -task->tk_status);
		goto retry_rebind;
 		switch (task->tk_status) {
 		case -EACCES:
 		case -EIO:
 			goto die;
 		default:
 			goto retry_rebind;
 		}
  	}
  	if (status == NLM_LCK_DENIED_GRACE_PERIOD) {
  		rpc_delay(task, NLMCLNT_GRACE_WAIT);
 		goto retry_unlock;
 	}
 	if (status != NLM_LCK_GRANTED)
 		printk(KERN_WARNING ""lockd: unexpected unlock status: %d\n"", status);
 die:
 	return;
  retry_rebind:
 	nlm_rebind_host(req->a_host);
  retry_unlock:
 	rpc_restart_call(task);
 }","[12, 13, 14, 15, 16, 17, 18, 11]",The Network Lock Manager (NLM) protocol implementation in the NFS client functionality in the Linux kernel before 3.0 allows local users to cause a denial of service (system hang) via a LOCK_UN flock system call.
205086," void RenderWidgetHostViewAura::WasHidden() {
   if (host_->is_hidden())
     return;
   host_->WasHidden();
  
    released_front_lock_ = NULL;
  
  if (ShouldReleaseFrontSurface() &&
      host_->is_accelerated_compositing_active()) {
    current_surface_ = 0;
    UpdateExternalTexture();
  }
  AdjustSurfaceProtection();
  #if defined(OS_WIN)
    aura::RootWindow* root_window = window_->GetRootWindow();
    if (root_window) {
     HWND parent = root_window->GetAcceleratedWidget();
     LPARAM lparam = reinterpret_cast<LPARAM>(this);
 
     EnumChildWindows(parent, HideWindowsCallback, lparam);
   }
 #endif
 }","[8, 9, 10, 11, 12, 13]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
206268," void Document::InitSecurityContext(const DocumentInit& initializer) {
   DCHECK(!GetSecurityOrigin());
 
   if (!initializer.HasSecurityContext()) {
     cookie_url_ = KURL(kParsedURLString, g_empty_string);
     SetSecurityOrigin(SecurityOrigin::CreateUnique());
     InitContentSecurityPolicy();
     SetFeaturePolicy(g_empty_string);
     return;
   }
 
   EnforceSandboxFlags(initializer.GetSandboxFlags());
   SetInsecureRequestPolicy(initializer.GetInsecureRequestPolicy());
   if (initializer.InsecureNavigationsToUpgrade()) {
     for (auto to_upgrade : *initializer.InsecureNavigationsToUpgrade())
        AddInsecureNavigationUpgrade(to_upgrade);
    }
  
   ContentSecurityPolicy* policy_to_inherit = nullptr;
 
    if (IsSandboxed(kSandboxOrigin)) {
      cookie_url_ = url_;
      SetSecurityOrigin(SecurityOrigin::CreateUnique());
     Document* owner = initializer.OwnerDocument();
     if (owner) {
       if (owner->GetSecurityOrigin()->IsPotentiallyTrustworthy())
          GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);
        if (owner->GetSecurityOrigin()->CanLoadLocalResources())
          GetSecurityOrigin()->GrantLoadLocalResources();
       policy_to_inherit = owner->GetContentSecurityPolicy();
      }
    } else if (Document* owner = initializer.OwnerDocument()) {
      cookie_url_ = owner->CookieURL();
      SetSecurityOrigin(owner->GetSecurityOrigin());
     policy_to_inherit = owner->GetContentSecurityPolicy();
    } else {
      cookie_url_ = url_;
      SetSecurityOrigin(SecurityOrigin::Create(url_));
   }
 
   if (initializer.IsHostedInReservedIPRange()) {
     SetAddressSpace(GetSecurityOrigin()->IsLocalhost()
                         ? kWebAddressSpaceLocal
                         : kWebAddressSpacePrivate);
   } else if (GetSecurityOrigin()->IsLocal()) {
     SetAddressSpace(kWebAddressSpaceLocal);
   } else {
     SetAddressSpace(kWebAddressSpacePublic);
   }
 
   if (ImportsController()) {
      SetContentSecurityPolicy(
          ImportsController()->Master()->GetContentSecurityPolicy());
    } else {
    InitContentSecurityPolicy();
     InitContentSecurityPolicy(nullptr, policy_to_inherit);
    }
  
    if (GetSecurityOrigin()->HasSuborigin())
     EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());
 
   if (Settings* settings = initializer.GetSettings()) {
     if (!settings->GetWebSecurityEnabled()) {
       GetSecurityOrigin()->GrantUniversalAccess();
     } else if (GetSecurityOrigin()->IsLocal()) {
       if (settings->GetAllowUniversalAccessFromFileURLs()) {
         GetSecurityOrigin()->GrantUniversalAccess();
       } else if (!settings->GetAllowFileAccessFromFileURLs()) {
         GetSecurityOrigin()->BlockLocalAccessFromLocalOrigin();
       }
     }
   }
 
   if (GetSecurityOrigin()->IsUnique() &&
       SecurityOrigin::Create(url_)->IsPotentiallyTrustworthy())
     GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);
 
   if (GetSecurityOrigin()->HasSuborigin())
     EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());
 
    SetFeaturePolicy(g_empty_string);
  }","[19, 20, 30, 35, 56, 55]","Blink in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, failed to correctly propagate CSP restrictions to javascript scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page."
